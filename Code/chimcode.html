<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chim Code - C Sequence Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&family=Courier+Prime:wght@400;700&family=Source+Code+Pro:wght@400;500;700&family=VT323&display=swap" rel="stylesheet">
    <style>
        /* --- THEME VARIABLES --- */
        :root {
            --bg-color: #111827; /* gray-900 */
            --panel-bg-color: #1f2937; /* gray-800 */
            --border-color: #374151; /* gray-700 */
            --text-color: #e5e7eb; /* gray-200 */
            --text-muted-color: #9ca3af; /* gray-400 */
            --accent-color: #22d3ee; /* cyan-400 */
            --accent-hover-color: #67e8f9; /* cyan-300 */
            --hint-color: #6ee7b7; /* emerald-300 */
            --star-color: #facc15; /* yellow-400 */
            --success-color: #059669; /* Emerald-600 */
            --error-color: #dc2626; /* Red-600 */
            --info-btn-bg: #4f46e5; /* indigo-600 */
            --info-btn-hover-bg: #6366f1; /* indigo-500 */
            --library-btn-bg: #6d28d9; /* violet-700 */
            --library-btn-hover-bg: #7c3aed; /* violet-600 */
            --price-color: #f59e0b; /* amber-500 */
            --money-price-color: #a3e635; /* lime-400 */
            --blur-amount: 3px;
            --appstore-blue: #007aff; /* iOS Blue */
            --appstore-blue-hover: #005ecb;
            /* Glassy Button Styles */
            --glass-bg-color: color-mix(in srgb, var(--panel-bg-color), transparent 70%); /* Semi-transparent background */
            --glass-border-color: color-mix(in srgb, var(--border-color), transparent 30%);
            --glass-hover-bg: color-mix(in srgb, var(--text-muted-color), transparent 80%);
            --glass-blur-amount: 8px; /* Blur intensity */
            /* Custom Theme Additions */
            --header-btn-text-color: white; /* Default for star/library buttons */
            /* Font Variable */
            --main-font-family: 'Roboto Mono', monospace; /* Default Font */
        }
        /* Example Theme 1: Matrix */
        .theme-matrix {
            --bg-color: #000000; --panel-bg-color: #0D0208; --border-color: #003B00;
            --text-color: #00FF00; --text-muted-color: #008F11; --accent-color: #00FF00;
            --accent-hover-color: #80FF80; --hint-color: #00FF00; --star-color: #39FF14;
            --success-color: #008F11; --error-color: #7F0000; --info-btn-bg: #008F11;
            --info-btn-hover-bg: #00FF00; --library-btn-bg: #006400; --library-btn-hover-bg: #008000;
            --price-color: #39FF14; --money-price-color: #80FF80;
            --appstore-blue: #00A800; --appstore-blue-hover: #007500;
            --glass-bg-color: color-mix(in srgb, var(--panel-bg-color), transparent 70%);
            --glass-border-color: color-mix(in srgb, var(--border-color), transparent 30%);
            --glass-hover-bg: color-mix(in srgb, var(--text-muted-color), transparent 80%);
            --header-btn-text-color: #00FF00;
        }
         /* Example Theme 2: Solarized Light */
        .theme-solarized {
            --bg-color: #fdf6e3; --panel-bg-color: #eee8d5; --border-color: #93a1a1;
            --text-color: #586e75; --text-muted-color: #839496; --accent-color: #268bd2;
            --accent-hover-color: #2aa198; --hint-color: #859900; --star-color: #b58900;
            --success-color: #859900; --error-color: #dc322f; --info-btn-bg: #6c71c4;
            --info-btn-hover-bg: #d33682; --library-btn-bg: #cb4b16; --library-btn-hover-bg: #dc322f;
            --price-color: #b58900; --money-price-color: #859900;
            --appstore-blue: #268bd2; --appstore-blue-hover: #1a5f90;
            --glass-bg-color: color-mix(in srgb, var(--panel-bg-color), transparent 60%); /* Adjust alpha for light theme */
            --glass-border-color: color-mix(in srgb, var(--border-color), transparent 30%);
            --glass-hover-bg: color-mix(in srgb, var(--text-muted-color), transparent 80%);
            --header-btn-text-color: #586e75;
        }

        /* Global Styles */
        body {
            font-family: var(--main-font-family); /* Use Font Variable */
            background-color: var(--bg-color);
            color: var(--text-color); overflow: hidden;
            transition: background-color 0.3s ease, color 0.3s ease, font-family 0.3s ease; /* Added font transition */
        }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--panel-bg-color); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted-color); }

        /* Code Area & Attempts Counter */
        #code-display-container { /* New wrapper */
            position: relative;
            flex-grow: 1;
            width: 100%;
            min-height: 0;
            background-color: var(--panel-bg-color); /* Match code area bg */
            border: 1px solid var(--border-color); /* Match code area border */
            border-radius: 8px; /* Match code area radius */
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.4); /* Match code area shadow */
            display: flex; /* To make area fill container */
             transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        #code-display-area {
            font-family: var(--main-font-family);
            font-size: 0.9rem; line-height: 1.6; color: var(--text-color);
            white-space: pre; overflow-y: auto;
             width: 100%; /* Fill wrapper */
            height: 100%; /* Fill wrapper */
            padding: 12px; /* Equivalent to old p-3 */
            box-sizing: border-box;
             background-color: transparent; /* Inherit from container */
             border: none; /* Remove duplicate border */
             box-shadow: none; /* Remove duplicate shadow */
             border-radius: 0; /* Not needed */
             transition: color 0.3s ease, font-family 0.3s ease; /* Keep relevant transitions */
        }
        .explanation-comment { color: var(--hint-color); font-style: italic; }
        #attempts-counter {
            position: absolute;
            bottom: 8px; /* Adjust as needed */
            right: 12px; /* Adjust as needed */
            font-size: 0.75rem; /* text-xs */
            color: var(--text-muted-color);
            pointer-events: none; /* Don't interfere with scrolling etc. */
             z-index: 10; /* Ensure it's above code */
              transition: color 0.3s ease;
        }


        /* Hint Area */
        #hint-container {
            display: flex; align-items: center; gap: 10px;
            background-color: color-mix(in srgb, var(--panel-bg-color), transparent 50%);
            border: 1px dashed var(--border-color); border-radius: 6px; padding: 8px 12px;
            min-height: 3em; margin-bottom: 10px;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        #hint-text {
            flex-grow: 1; color: var(--hint-color); font-style: italic; font-size: 0.85rem;
            line-height: 1.5; white-space: pre-wrap; transition: filter 0.3s ease, color 0.3s ease;
        }
        #hint-text.blurred { filter: blur(var(--blur-amount)); user-select: none; cursor: default; }

        /* --- Hint Button Style --- */
        #reveal-hint-btn {
            background-color: var(--appstore-blue); color: white; border: none;
            border-radius: 999px; /* Pill shape */
            padding: 5px 15px; /* Match appstore button padding */
            font-size: 0.9em; /* Match appstore button font size */
            font-weight: 600; /* Match appstore button font weight */
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, color 0.3s ease;
            line-height: 1.4; /* Match appstore button line height */
            display: inline-flex; align-items: center; justify-content: center;
            flex-shrink: 0;
            min-width: 90px; /* Match appstore button min width */
        }
        #reveal-hint-btn:hover:not(:disabled) { background-color: var(--appstore-blue-hover); }
        #reveal-hint-btn:active:not(:disabled) { transform: scale(0.96); }
        #reveal-hint-btn:disabled {
            background-color: color-mix(in srgb, var(--appstore-blue), var(--panel-bg-color) 60%);
            color: color-mix(in srgb, white, var(--panel-bg-color) 40%);
            cursor: not-allowed; opacity: 0.7;
        }
        #reveal-hint-btn .star-icon { /* Style for star inside hint button */
             color: var(--star-color); font-size: 1.2em; margin-right: 3px; line-height: 1; transition: color 0.3s ease;
        }
        #reveal-hint-btn.hidden { display: none; }
        /* --- End Hint Button Style --- */


        /* Option Buttons */
        .option-btn-wrapper { position: relative; }
        .option-btn {
            font-family: var(--main-font-family); /* Use Font Variable */
            background-color: var(--border-color); border: 1px solid var(--text-muted-color);
            color: var(--text-color); padding: 12px 10px; padding-right: 30px; border-radius: 6px;
            font-weight: 500; transition: all 0.2s ease; text-align: left; font-size: 0.85rem;
            line-height: 1.4; width: 100%; white-space: pre;
            cursor: pointer; overflow: hidden; text-overflow: ellipsis;
        }
        .option-btn:hover:not(:disabled) { background-color: var(--text-muted-color); border-color: var(--accent-color); transform: translateY(-1px); }
        .option-btn:active:not(:disabled) { transform: translateY(0px); }
        .option-btn:disabled { opacity: 0.6; cursor: not-allowed; }

        /* Info Button (on incorrect options) */
        .info-btn {
            position: absolute; right: 5px; top: 50%; transform: translateY(-50%);
            background-color: var(--info-btn-bg); color: white; border: none; border-radius: 50%;
            width: 22px; height: 22px; font-size: 14px; font-weight: bold; line-height: 22px;
            text-align: center; cursor: pointer; transition: background-color 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .info-btn:hover { background-color: var(--info-btn-hover-bg); }

        /* --- Header --- */
        #main-header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid var(--border-color); padding-bottom: 0.75rem; margin-bottom: 0.5rem;
        }
        .header-left { display: flex; align-items: baseline; gap: 0.5rem; }
        .header-right { display: flex; align-items: center; gap: 0.75rem; }

        #main-title { font-size: 1.25rem; font-weight: bold; color: var(--accent-color); transition: color 0.3s ease; }
        .language-indicator {
            font-size: 1.4em; font-weight: bold; color: var(--accent-color);
            opacity: 0.3; line-height: 1; transition: color 0.3s ease;
        }

        /* --- Glassy Header Buttons w/ Blur --- */
        .glassy-header-btn {
            background-color: var(--glass-bg-color);
            backdrop-filter: blur(var(--glass-blur-amount));
            -webkit-backdrop-filter: blur(var(--glass-blur-amount));
            border: 1px solid var(--glass-border-color);
            border-radius: 20px; padding: 6px 15px;
            display: inline-flex; align-items: center; justify-content: center;
            color: var(--header-btn-text-color); /* Use new variable */
            font-weight: 500;
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.3s ease, transform 0.1s ease;
            cursor: pointer; text-shadow: none; box-shadow: none;
        }
        @supports (backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px)) {}
        .glassy-header-btn:hover {
            background-color: var(--glass-hover-bg); border-color: var(--text-muted-color);
            color: var(--header-btn-text-color); /* Maintain text color on hover */
        }
        .glassy-header-btn:active {
            transform: scale(0.98);
            background-color: color-mix(in srgb, var(--glass-hover-bg), black 10%);
        }
        #level-display-btn { padding: 5px 10px; color: var(--accent-hover-color); font-size: 1rem; transition: color 0.3s ease; }
        #level-display-btn:hover { color: var(--accent-color); }
        #library-btn { font-size: 0.9rem; padding: 6px 12px; }
        #star-display-wrapper { min-width: 70px; }
        #star-count { margin: 0; display: flex; align-items: baseline; gap: 5px; }
        #star-count .star-icon { color: var(--star-color); font-size: 1.3em; line-height: 1; display: inline-block; vertical-align: middle; transition: color 0.3s ease;}
        #star-count .star-number { vertical-align: middle; }
        /* --- End Glassy Header Buttons --- */

        /* --- Star Animations --- */
        @keyframes star-jump { /* No changes needed */
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-8px) scale(1.1); }
        }
        .star-jump-animation { animation: star-jump 0.35s ease-in-out; }
        @keyframes star-flash-red-bg { /* Flash border/background */
            0%, 100% {
                background-color: var(--glass-bg-color); border-color: var(--glass-border-color);
            }
            50% {
                background-color: color-mix(in srgb, var(--error-color), transparent 70%);
                border-color: var(--error-color);
            }
        }
        .star-flash-red-animation { animation: star-flash-red-bg 0.4s ease-in-out; }
        /* --- End Star Styling & Animations --- */


        /* Generic Buttons (Endgame, Level Select) */
        .endgame-btn, .level-select-btn {
             background-color: var(--info-btn-bg); border: 1px solid var(--info-btn-hover-bg); color: white;
             padding: 8px 16px; border-radius: 6px; font-weight: 500;
             transition: background-color 0.2s ease; margin: 5px;
             cursor: pointer; text-align: center;
        }
         .endgame-btn:hover, .level-select-btn:hover { background-color: var(--info-btn-hover-bg); }
         .level-select-btn:disabled {
             background-color: var(--border-color); border-color: var(--text-muted-color);
             color: var(--text-muted-color); cursor: not-allowed; opacity: 0.7;
         }
         .level-select-btn { width: 100%; margin: 5px 0; }
         .level-select-btn span { display: block; font-size: 0.8em; color: var(--text-muted-color); }

        /* --- App Store Purchase Buttons --- */
        .purchase-buttons-container {
            display: flex; flex-direction: row; gap: 10px; /* Side-by-side */
            /* Default to center, specific overrides can change this */
            justify-content: center;
            align-items: center;
            min-width: 180px; /* Adjusted slightly */
        }
        /* Override for theme store items (excluding single button / buy stars) */
        #theme-store-modal .theme-item:not(.single-button-item):not(.buy-stars-item) .purchase-buttons-container {
            justify-content: flex-end;
        }
        /* Specific override for buy stars / single button items */
         .buy-stars-item .purchase-buttons-container,
         .single-button-item .purchase-buttons-container {
             justify-content: flex-end; /* Keep these right-aligned */
         }


        .appstore-purchase-btn {
            background-color: var(--appstore-blue); color: white; border: none;
            border-radius: 999px; padding: 5px 15px; font-size: 0.9em; font-weight: 600;
            cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease, color 0.3s ease;
            min-width: 90px; text-align: center; line-height: 1.4;
            display: inline-flex; align-items: center; justify-content: center;
            flex-shrink: 0; /* Prevent buttons from shrinking too much */
        }
        .appstore-purchase-btn:hover:not(:disabled) { background-color: var(--appstore-blue-hover); }
        .appstore-purchase-btn:active:not(:disabled) { transform: scale(0.96); }
        .appstore-purchase-btn:disabled {
            background-color: color-mix(in srgb, var(--appstore-blue), var(--panel-bg-color) 60%);
            color: color-mix(in srgb, white, var(--panel-bg-color) 40%);
            cursor: not-allowed; opacity: 0.7;
        }
        .appstore-purchase-btn .star-icon {
            color: var(--star-color); font-size: 1.2em; margin-right: 3px; line-height: 1; transition: color 0.3s ease;
        }
        /* Applied/Current State Text */
        .status-text-container {
             display: flex; align-items: center; justify-content: center; /* Center the status text too */
             /* Take up the space normally used by buttons */
             min-width: 180px; /* Match adjusted button container width */
        }
         /* Override for theme store items needing right alignment */
         #theme-store-modal .theme-item .status-text-container {
             justify-content: flex-end;
         }


        .status-text {
             background-color: var(--success-color); color: white;
             border-radius: 999px; padding: 5px 15px; font-size: 0.9em; font-weight: 600;
             min-width: 90px; text-align: center; line-height: 1.4;
             display: inline-block; transition: background-color 0.3s ease;
        }


        /* Modal styles */
        .modal-overlay {
            position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.7);
            display: flex; align-items: center; justify-content: center;
            z-index: 50; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease; backdrop-filter: blur(2px);
        }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content {
            background-color: var(--panel-bg-color); color: var(--text-color);
            padding: 25px; border-radius: 8px; border: 1px solid var(--border-color);
            max-width: 600px; width: 90%; position: relative;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4); transform: scale(0.95);
            transition: transform 0.3s ease, background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
            max-height: 80vh; overflow-y: auto;
        }
         .modal-overlay.visible .modal-content { transform: scale(1); }
        .modal-close-btn {
            position: absolute; top: 10px; right: 10px; background: transparent; border: none;
            color: var(--text-muted-color); font-size: 24px; line-height: 1; cursor: pointer;
        }
         .modal-close-btn:hover { color: var(--text-color); }

        /* Feedback Overlay Styles */
        .feedback-overlay {
            position: fixed; inset: 0; z-index: 100; opacity: 0; visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            pointer-events: none;
        }
        .feedback-overlay.visible { opacity: 1; visibility: visible; }
        .feedback-overlay.overlay-green { background-color: color-mix(in srgb, var(--success-color), transparent 80%); }
        .feedback-overlay.overlay-red { background-color: color-mix(in srgb, var(--error-color), transparent 80%); }

        /* Info Modal Feedback Area */
         #feedback-area { display: none; margin-top: 15px; }
         #feedback-text {
              width: 100%; background-color: var(--bg-color); color: var(--text-color);
              border: 1px solid var(--border-color); border-radius: 4px; padding: 8px;
              min-height: 60px; font-size: 0.9em; margin-bottom: 10px;
         }
         #feedback-submit-btn { /* Uses .endgame-btn style */
            background-color: var(--info-btn-bg); border: 1px solid var(--info-btn-hover-bg); color: white;
              padding: 8px 16px; border-radius: 6px; font-weight: 500;
              transition: background-color 0.2s ease; margin: 5px;
              cursor: pointer; text-align: center;
         }
          #feedback-submit-btn:hover { background-color: var(--info-btn-hover-bg); }
         #feedback-confirmation { color: var(--hint-color); font-style: italic; font-size: 0.9em; }

         /* Theme Store Specific Styles */
         .theme-item {
              border: 1px solid var(--border-color); padding: 10px 15px;
              margin-bottom: 10px; border-radius: 8px; display: flex;
              justify-content: space-between; align-items: center;
              background-color: color-mix(in srgb, var(--panel-bg-color), transparent 30%);
              min-height: 55px;
         }
         .theme-info { flex-grow: 1; margin-right: 15px; }
         .theme-name { font-weight: bold; font-size: 1.0em; color: var(--text-color); }
         /* Buy Stars Item Specific Style */
         /* .buy-stars-item .purchase-buttons-container handled globally */
         /* Single Button Item Specific Style */
         /* .single-button-item .purchase-buttons-container handled globally */


         /* Library Modal Specific Styles */
         #library-grid {
              display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); /* Wider cards for side-by-side buttons */
              gap: 15px;
         }
         .language-card {
              background-color: var(--bg-color); border: 1px solid var(--border-color);
              border-radius: 8px; padding: 15px; text-align: center;
              transition: transform 0.2s ease, box-shadow 0.2s ease;
              display: flex; flex-direction: column; justify-content: space-between;
              min-height: 100px;
         }
         .language-card:hover { transform: translateY(-3px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
         .language-name { font-weight: bold; font-size: 1.1em; margin-bottom: 10px; color: var(--accent-color); }
         .language-card.current-language { border-color: var(--accent-color); box-shadow: 0 0 10px color-mix(in srgb, var(--accent-color), transparent 70%); }
         .language-card.current-language .language-name { color: var(--accent-hover-color); }
         .language-card .purchase-buttons-container {
             margin-top: auto;
             justify-content: center; /* Explicitly center buttons in language cards */
         }
         .language-card .status-text-container {
             justify-content: center; /* Also center 'Current' text */
         }


         /* Level Select Modal Styles */
         #level-list { margin-top: 15px; max-height: 50vh; overflow-y: auto; padding-right: 10px; }
         .level-select-item { border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px; }
         .level-select-item:last-child { border-bottom: none; margin-bottom: 0; }

         /* Custom Theme Modal Styles */
         #custom-theme-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 15px;
              margin-bottom: 20px;
         }
         .color-picker-item {
              display: flex;
              align-items: center;
              gap: 10px;
              background-color: var(--bg-color); /* Match panel bg */
              padding: 8px;
              border-radius: 6px;
              border: 1px solid var(--border-color);
         }
         .color-picker-item label {
              font-size: 0.85em;
              color: var(--text-muted-color);
              flex-shrink: 0;
              width: 100px; /* Align labels */
         }
         .color-picker-item input[type="color"] {
              width: 40px; /* Adjust size */
              height: 30px;
              border: 1px solid var(--border-color);
              border-radius: 4px;
              cursor: pointer;
              padding: 0; /* Remove default padding */
              background-color: transparent; /* Ensure picker swatch is visible */
         }
         /* Style the color picker swatch itself */
         .color-picker-item input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
         .color-picker-item input[type="color"]::-webkit-color-swatch { border: none; border-radius: 3px; }
         .color-picker-item input[type="color"]::-moz-color-swatch { border: none; border-radius: 3px; }

         /* Font Selection in Custom Modal */
         #font-selection-area {
              margin-top: 20px;
              padding-top: 15px;
              border-top: 1px solid var(--border-color);
         }
         #font-selection-area label {
              display: block;
              margin-bottom: 8px;
              color: var(--text-muted-color);
              font-size: 0.9em;
              font-weight: 500;
         }
         #font-select-dropdown {
              width: 100%;
              padding: 8px 12px;
              border-radius: 6px;
              border: 1px solid var(--border-color);
              background-color: var(--bg-color);
              color: var(--text-color);
              font-family: var(--main-font-family); /* Show current font in dropdown */
              font-size: 0.9em;
              cursor: pointer;
              transition: border-color 0.2s ease, background-color 0.2s ease;
         }
         #font-select-dropdown:focus {
              outline: none;
              border-color: var(--accent-color);
         }
         #font-select-dropdown:disabled {
              opacity: 0.6;
              cursor: not-allowed;
              background-color: var(--panel-bg-color);
         }
         #font-unlock-message {
              font-size: 0.85em;
              color: var(--error-color);
              margin-top: 5px;
              text-align: center;
         }

    </style>
</head>
<body class="h-screen flex flex-col p-4 md:p-6 gap-4">

    <div id="main-header">
        <div class="header-left">
            <h1 id="main-title">Chim Code</h1>
            <span class="language-indicator">C</span>
        </div>
        <div style="flex-grow: 1;"></div> <div class="header-right">
             <button id="level-display-btn" class="glassy-header-btn" title="Select Level">
                 <span id="level-text">Level 1</span>
             </button>
             <button id="library-btn" class="glassy-header-btn" title="Open Language Library">Library</button>
             <div id="star-display-wrapper" class="glassy-header-btn" title="Open Theme Store">
                 <p id="star-count">
                     <span class="star-icon">★</span> <span class="star-number">0</span>
                 </p>
             </div>
        </div>
    </div>

    <div id="code-display-container" class="relative flex-grow w-full min-h-0">
        <div id="code-display-area" class="w-full h-full p-3">
            </div>
        <div id="attempts-counter" class="absolute bottom-2 right-3 text-xs" style="color: var(--text-muted-color); pointer-events: none;">
            Attempts: 1
        </div>
    </div>


    <div id="hint-container">
        <span id="hint-text" class="blurred"></span>
        <button id="reveal-hint-btn">Hint: <span class="star-icon">★</span> 1</button>
    </div>

    <div id="interaction-area" class="grid grid-cols-1 md:grid-cols-3 gap-3 pt-3 border-t" style="border-color: var(--border-color);">
        </div>

    <div id="info-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="modal-close" class="modal-close-btn">&times;</button>
            <h3 class="text-lg font-semibold mb-3" style="color: var(--accent-color);">Why is this incorrect?</h3>
            <p id="modal-reason" class="mb-4"></p>
            <button id="flag-feedback-btn" class="endgame-btn text-sm py-1 px-3">Disagree? Flag for Review</button>
            <div id="feedback-area">
                <textarea id="feedback-text" placeholder="Explain why you think this option might be correct (optional)..."></textarea>
                <button id="feedback-submit-btn" class="endgame-btn">Submit Feedback</button>
                <p id="feedback-confirmation" class="mt-2"></p>
            </div>
        </div>
    </div>

    <div id="theme-store-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="theme-modal-close" class="modal-close-btn">&times;</button>
            <h3 class="text-lg font-semibold mb-4" style="color: var(--accent-color);">Theme Store</h3>
            <p class="mb-4 text-sm" style="color: var(--text-muted-color);">Use stars (★) or purchase themes to customize your experience!</p>

            <div class="theme-item" data-item-identifier="default">
                <div class="theme-info"> <div class="theme-name">Default Theme</div> </div>
                <div class="purchase-buttons-container">
                    <div class="status-text-container"> <span class="status-text">Applied</span> </div>
                </div>
            </div>
            <div class="theme-item" data-item-identifier="theme-matrix" data-star-price="200" data-money-price="2.99">
                <div class="theme-info"> <div class="theme-name">Matrix Theme</div> </div>
                <div class="purchase-buttons-container">
                    </div>
                 <div class="status-text-container" style="display: none;"></div>
            </div>
            <div class="theme-item" data-item-identifier="theme-solarized" data-star-price="200" data-money-price="2.99">
                 <div class="theme-info"> <div class="theme-name">Solarized Light Theme</div> </div>
                 <div class="purchase-buttons-container">
                     </div>
                  <div class="status-text-container" style="display: none;"></div>
            </div>
            <div class="theme-item" data-item-identifier="color-orange" data-star-price="200" data-money-price="2.99">
                 <div class="theme-info"> <div class="theme-name">Accent Color: Orange</div> </div>
                 <div class="purchase-buttons-container">
                     </div>
                  <div class="status-text-container" style="display: none;"></div>
            </div>
            <div class="theme-item" data-item-identifier="custom-theme" data-star-price="1000" data-money-price="4.99">
                 <div class="theme-info"> <div class="theme-name">Custom Theme</div> </div>
                 <div class="purchase-buttons-container">
                     </div>
                  <div class="status-text-container" style="display: none;"></div>
            </div>
            <div class="theme-item single-button-item" data-item-identifier="change-font" data-star-price="20">
                <div class="theme-info"> <div class="theme-name">Change Font</div> </div>
                <div class="purchase-buttons-container">
                    </div>
                 <div class="status-text-container" style="display: none;"></div>
            </div>
            <div class="theme-item buy-stars-item" data-item-identifier="buy-stars">
                 <div class="theme-info"> <div class="theme-name">Get 1000 Stars</div> </div>
                 <div class="purchase-buttons-container">
                     <button data-action="buy-stars" data-amount="1000" data-money-price="4.99" class="appstore-purchase-btn">$4.99</button>
                 </div>
                  <div class="status-text-container" style="display: none;"></div> </div>
             <p id="store-message" class="text-center mt-4 text-sm" style="color: var(--error-color);"></p>
        </div>
    </div>

    <div id="library-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="library-modal-close" class="modal-close-btn">&times;</button>
            <h3 class="text-lg font-semibold mb-4" style="color: var(--accent-color);">Language Library</h3>
            <p class="mb-4 text-sm" style="color: var(--text-muted-color);">Select a language to start learning. Currently only 'C' is available.</p>
            <div id="library-grid">
                 </div>
            <p id="library-message" class="text-center mt-4 text-sm" style="color: var(--error-color);"></p>
        </div>
    </div>

    <div id="level-select-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="level-select-modal-close" class="modal-close-btn">&times;</button>
            <h3 class="text-lg font-semibold mb-4" style="color: var(--accent-color);">Select Level</h3>
            <div id="level-list">
                 </div>
        </div>
    </div>

    <div id="custom-theme-modal" class="modal-overlay">
        <div class="modal-content">
             <button id="custom-theme-modal-close" class="modal-close-btn">&times;</button>
             <h3 class="text-lg font-semibold mb-4" style="color: var(--accent-color);">Customize Theme</h3>
             <p class="mb-4 text-sm" style="color: var(--text-muted-color);">Select colors and font for different UI elements. Changes apply immediately.</p>

             <div id="custom-theme-grid">
                 </div>

             <div id="font-selection-area">
                 <label for="font-select-dropdown">Select Font:</label>
                 <select id="font-select-dropdown" disabled>
                     </select>
                 <p id="font-unlock-message" style="display: none;">Unlock "Change Font" in the Theme Store (★ 20) to enable selection.</p>
             </div>

             <div class="text-center mt-4">
                 <button id="apply-custom-theme-btn" class="endgame-btn">Apply & Close</button>
                 <button id="reset-custom-theme-btn" class="endgame-btn" style="background-color: var(--error-color); border-color: color-mix(in srgb, var(--error-color), black 20%);">Reset to Defaults</button>
             </div>
        </div>
    </div>


    <div id="feedback-overlay" class="feedback-overlay"></div>


    <script>
        // --- Game Data ---
        const challengesData = [ /* ... challengesData remains the same ... */
             // Level 1: Simple For Loop
             {
                 goal: "Print numbers 0 to 4 using a for loop.",
                 concepts: "Includes, main function, for loop, printf",
                 sequence: [
                     { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`stdlib.h` contains general utility functions (like memory allocation, random numbers), but `printf` requires the Standard Input/Output library, which is `stdio.h`.'}, {text: '#import <stdio.h>', reason: 'Standard C uses the `#include` preprocessor directive. `#import` is a similar concept but specific to Objective-C and not part of standard C.'}], indent: 0, explanation: "Includes the Standard Input/Output library for functions like printf." },
                     { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'The C standard (like C99, C11) specifies that `main` must return `int` to signal the program\'s exit status to the OS (0 for success). `void main()` is non-standard, though some compilers might allow it.'}, {text: 'function main() {', reason: 'The keyword `function` is used in languages like JavaScript to define functions, but in C, you define a function by specifying its return type (e.g., `int`), name, parameters, and body `{}`.'}], indent: 0, explanation: "The main function where program execution begins. It returns an integer." },
                     { correct: 'for(int i = 0; i < 5; i++) {', distractors: [{text: 'while(int i < 5) {', reason: 'A `while` loop only checks a condition. Variable declaration (`int i`) is not allowed inside the `while` condition parentheses, and initialization/increment must happen separately before/inside the loop body.'}, {text: 'if(i < 5) {', reason: 'An `if` statement executes its block only *once* if the condition is true. A `for` loop is needed to *repeat* the block multiple times based on initialization, condition, and increment steps.'}], indent: 1, explanation: "A for loop: initializes i=0, continues while i<5, increments i after each loop." },
                     { correct: 'printf("Count: %d\\n", i);', distractors: [{text: 'print("Count: %d", i);', reason: 'The standard C library function for formatted output is `printf` (print formatted). There is no standard function named `print`.'}, {text: 'console.log(i);', reason: '`console.log` is the function used for printing output in JavaScript environments (like browsers or Node.js), not in standard C.'}], indent: 2, explanation: "Prints formatted text. %d is a placeholder for an integer (i), \\n is a newline." },
                     { correct: '}', distractors: [{text: 'end for;', reason: 'C uses matching curly braces `{` and `}` to define the start and end of code blocks (like loops, functions, if-statements). Keywords like `end` are not used for this.'}, {text: 'break;', reason: 'The `break;` statement is used to exit *early* from a loop (for, while, do-while) or switch statement. It does not define the normal end of the loop block.'}], indent: 1, explanation: "Closes the for loop block." },
                     { correct: 'return 0;', distractors: [{text: 'exit(0);', reason: '`exit(0)` (from `stdlib.h`) forces immediate program termination from anywhere. `return 0;` specifically indicates the successful completion *of the `main` function* and allows normal program cleanup.'}, {text: 'return;', reason: 'The `main` function is declared as `int main()`, meaning it must return an integer value. `return;` is only valid for functions declared with a `void` return type.'}], indent: 1, explanation: "Indicates successful program execution by returning 0 from main." },
                     { correct: '}', distractors: [{text: 'end main;', reason: 'C uses curly braces `{}` to define code blocks. Keywords like `end` are not part of the C syntax for ending functions.'}, {text: '};', reason: 'A semicolon `;` is used to terminate statements in C, but it is *not* placed after the closing curly brace `}` that defines the end of a function body.'}], indent: 0, explanation: "Closes the main function block." }
                 ]
             },
             // Level 2: Simple If Statement
             {
                 goal: "Check if a variable is positive and print a message.",
                 concepts: "Variables, if statement, comparison operators",
                 sequence: [
                     { correct: '#include <stdio.h>', distractors: [{text: '#include <math.h>', reason: 'The `math.h` header provides mathematical functions (like `sqrt`, `pow`, `sin`). It is not needed for basic comparison (`>`) or printing (`printf`).'}, {text: 'using namespace std;', reason: '`using namespace std;` is a C++ directive to avoid prefixing standard library elements with `std::`. It is not used or needed in standard C.'}], indent: 0, explanation: "Include the library needed for printing output."},
                     { correct: 'int main() {', distractors: [{text: 'int start() {', reason: 'By convention and standard, the execution of a C program begins in the function named `main`. Other names like `start` won\'t be automatically recognized as the entry point.'}, {text: 'void main() {', reason: 'Standard C (like C99, C11) requires `main` to return an `int` value to indicate the program\'s exit status to the operating system. `void main()` is non-standard.'}], indent: 0, explanation: "Start the main execution block."},
                     { correct: 'int number = 10;', distractors: [{text: 'float number = 10.0;', reason: 'While `float` can store 10.0, the task involves a simple positive/non-positive check. Using `int` (integer) is more direct and common for such whole number operations.'}, {text: 'char number = \'A\';', reason: 'A `char` variable stores a character value (like \'A\'). Comparing it with `> 0` might yield unexpected results based on its ASCII value, and it doesn\'t fit the goal of checking a numerical value.'}], indent: 1, explanation: "Declare an integer variable 'number' and give it a value." },
                     { correct: 'if (number > 0) {', distractors: [{text: 'if number > 0:', reason: 'In C, the conditional expression following the `if` keyword *must* be enclosed within parentheses `()`. The colon `:` is used in languages like Python, not C.'}, {text: 'while (number > 0) {', reason: 'A `while` loop repeatedly executes the code block as long as the condition is true. An `if` statement executes the block only *once* if the condition is true, which is needed here.'}], indent: 1, explanation: "Check if the value of 'number' is greater than zero." },
                     { correct: 'printf("Number is positive.\\n");', distractors: [{text: 'printf(number);', reason: '`printf` requires a "format string" as the first argument to specify *how* to print the following arguments. To print an integer, you need `printf("%d\\n", number);`.'}, {text: 'echo "Positive";', reason: '`echo` is a command typically used in shell environments (like Bash or Command Prompt) to display text, not a function available within standard C.'}], indent: 2, explanation: "If the condition was true, print this message." },
                     { correct: '}', distractors: [{text: 'end if;', reason: 'C uses curly braces `{}` to define the beginning and end of code blocks associated with control structures like `if`. Keywords are not used to end blocks.'}, {text: 'stop;', reason: '`stop` is not a recognized keyword or command in the standard C language.'}], indent: 1, explanation: "Closes the if statement block." },
                     { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Conventionally, returning `0` from `main` indicates success, while returning a non-zero value (like `1`) signals an error or abnormal termination to the operating system.'}, {text: 'end;', reason: '`end` is not a C keyword. Use `return` followed by a value (for non-void functions) to exit a function.'}], indent: 1, explanation: "Signal that the program finished successfully."},
                     { correct: '}', distractors: [{text: 'finish', reason: '`finish` is not a C keyword used for ending code blocks or functions.'}, {text: 'end main', reason: 'C uses the closing curly brace `}` to signify the end of the `main` function\'s code block.'}], indent: 0, explanation: "Closes the main function block." }
                 ]
             },
             // Level 3: Basic Function Call
              {
                 goal: "Define and call a simple function to add two numbers.",
                 concepts: "Function declaration (prototype), function definition, function call, return value",
                 sequence: [
                     { correct: '#include <stdio.h>', distractors: [{text:'#include <functions.h>', reason:'There is no standard C header file named `functions.h`. Header files typically group related declarations (like `stdio.h` for I/O).'}, {text:'#include <iostream>', reason:'`<iostream>` is the standard input/output header file for C++, used with `cout` and `cin`. C uses `<stdio.h>` for `printf` and `scanf`.'}], indent: 0, explanation: "Include necessary library for input/output."},
                     { correct: '// Function declaration (prototype)', distractors: [{text:'// Variable declaration', reason:'This comment is misleading; the next line declares a function, not a variable.'}, {text:'// Loop setup', reason:'This comment is inaccurate; the next line is about a function, not setting up a loop.'}], indent: 0, explanation: "Add a comment explaining the next line's purpose."},
                     { correct: 'int add(int a, int b);', distractors: [{text:'void add(int a, int b);', reason:'The function is intended to calculate and *return* the sum, which is an integer. Declaring it as `void` means it wouldn\'t return any value, contradicting the goal.'}, {text:'function add(a, b);', reason:'C requires explicit type declarations. You must specify the return type (`int`) and the type of each parameter (`int a`, `int b`). The keyword `function` is not used.'}], indent: 0, explanation: "Declare the 'add' function: specify return type (int) and parameter types (int, int)."},
                     { correct: 'int main() {', distractors: [{text:'void main() {', reason:'Standard C requires `main` to return `int` to signal success (0) or failure (non-zero) to the OS.'}, {text:'program start {', reason:'C program execution starts in `int main() { ... }`. Other syntax is incorrect.'}], indent: 0, explanation: "Begin the main function."},
                     { correct: 'int result = add(5, 3);', distractors: [{text:'int result = 5 + 3;', reason:'This performs the addition directly within `main`. The goal is to demonstrate defining and *calling* a separate `add` function.'}, {text:'call add(5, 3);', reason:'In C, you call a function simply by using its name followed by arguments in parentheses `()`. The keyword `call` is not used for function invocation.'}], indent: 1, explanation: "Call the 'add' function, pass 5 and 3 as arguments, and store the returned value in 'result'."},
                     { correct: 'printf("Result: %d\\n", result);', distractors: [{text:'printf(result);', reason:'`printf` needs a format specifier (like `%d` for integers) within the format string (first argument) to know how to interpret and print the variable `result`.'}, {text:'print result;', reason:'`print` is not a standard C function. You must use `printf` for formatted output.'}], indent: 1, explanation: "Print the calculated result."},
                     { correct: 'return 0;', distractors: [{text:'return result;', reason:'The `main` function should return `0` to indicate successful execution to the operating system, not the calculated value from the `add` function.'}, {text:'exit main;', reason:'Keywords like `exit` are not used to end `main` normally; use `return 0;`.'}], indent: 1, explanation: "Exit the main function successfully."},
                     { correct: '}', distractors: [{text:'end program;', reason:'C uses the closing curly brace `}` to mark the end of the `main` function block.'}, {text:'stop;', reason:'`stop` is not a C keyword.'}], indent: 0, explanation: "Closes the main function block." },
                     { correct: '// Function definition', distractors: [{text:'// Main loop', reason:'This comment is incorrect; the following code defines the `add` function, not a loop within `main`.'}, {text:'// Variable setup', reason:'This comment is inaccurate; the following code is the implementation of the `add` function.'}], indent: 0, explanation: "Add a comment indicating the start of the function's code."},
                     { correct: 'int add(int a, int b) {', distractors: [{text:'void add(int a, int b) {', reason:'The function *definition* must match the *declaration* (prototype). Since it was declared to return `int`, the definition must also specify `int`.'}, {text:'define add(a, b) {', reason:'`#define` is a preprocessor directive for macros, not for defining functions. Function definitions require specifying return and parameter types.'}], indent: 0, explanation: "Define the 'add' function, matching the declaration."},
                     { correct: 'return a + b;', distractors: [{text:'print a + b;', reason:'The purpose of this function, as declared, is to *return* the calculated sum, not to print it directly. Printing should happen in `main` using the returned value.'}, {text:'result = a + b;', reason:'This assigns the sum to a variable named `result`, but `result` hasn\'t been declared within this function scope, and more importantly, the value isn\'t being *returned* to the caller.'}], indent: 1, explanation: "Perform the addition and return the sum."},
                     { correct: '}', distractors: [{text:'end function;', reason:'C uses the closing curly brace `}` to mark the end of the function\'s definition block.'}, {text:'end add;', reason:'C uses the closing curly brace `}` to mark the end of the function\'s definition block, not keywords.'}], indent: 0, explanation: "Closes the add function block." }
                 ]
              },
             // Add more levels here...
            // Level 4: Basic Input with scanf
    {
        goal: "Read an integer from the user and print it.",
        concepts: "scanf, printf, variables, address-of operator (&)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <input.h>', reason: 'There is no standard C header named `input.h`. Input/output functions like `scanf` and `printf` are in `stdio.h`.'}, {text: '#include <iostream>', reason: '`<iostream>` is the C++ header for input/output using `cin` and `cout`. C uses `<stdio.h>`.'}], indent: 0, explanation: "Include the standard input/output library." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return an integer (`int`) to indicate exit status.'}, {text: 'main function {', reason: 'C function definition requires a return type before the name and parentheses `()`. '}], indent: 0, explanation: "Start the main function." },
            { correct: 'int userInput;', distractors: [{text: 'var userInput;', reason: 'C is statically typed; you must declare the type explicitly (like `int`, `float`, `char`). `var` is used in languages like JavaScript.'}, {text: 'integer userInput;', reason: 'The keyword for the integer data type in C is `int`, not `integer`.'}], indent: 1, explanation: "Declare an integer variable to store the user's input." },
            { correct: 'printf("Enter an integer: ");', distractors: [{text: 'print("Enter an integer: ");', reason: 'The standard C function for formatted output is `printf`.'}, {text: 'scanf("Enter an integer: ");', reason: '`scanf` is used for *reading* formatted input, not for *printing* prompts.'}], indent: 1, explanation: "Prompt the user to enter a number." },
            { correct: 'scanf("%d", &userInput);', distractors: [{text: 'scanf("%d", userInput);', reason: '`scanf` needs the memory *address* where it should store the input. The address-of operator `&` is required before the variable name (`&userInput`).'}, {text: 'scanf(userInput);', reason: '`scanf` requires a format string (like `"%d"`) to specify the type of input expected and the address (`&variable`) to store it.'}], indent: 1, explanation: "Read an integer (%d) from input and store it at the address of 'userInput'." },
            { correct: 'printf("You entered: %d\\n", userInput);', distractors: [{text: 'printf("You entered: %d\\n", &userInput);', reason: '`printf` needs the *value* of the variable to print it. Passing the address (`&userInput`) would print the memory address, not the stored integer.'}, {text: 'printf(userInput);', reason: '`printf` requires a format string as the first argument to specify how to print the subsequent arguments.'}], indent: 1, explanation: "Print the value stored in the 'userInput' variable." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Returning 0 from `main` conventionally indicates successful execution. Non-zero often indicates an error.'}, {text: 'return userInput;', reason: '`main` should return an exit status (0 for success), not a variable\'s value unless intended as an exit code.'}], indent: 1, explanation: "Indicate successful program execution." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'C uses `}` to close function blocks.'}, {text: '};', reason: 'A semicolon `;` is used after `struct` definitions, but not after the closing brace `}` of a function.'}], indent: 0, explanation: "Close the main function block." }
        ]
    },
    // Level 5: Floating-Point Arithmetic
    {
        goal: "Calculate the area of a circle given its radius (using float).",
        concepts: "float data type, arithmetic operators, constants (#define), math.h",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason:'`stdlib.h` is for general utilities, not core I/O or math constants like M_PI.'}, {text:'#include <maths.h>', reason:'The standard math header is `<math.h>`, not `<maths.h>`.'}], indent: 0, explanation: "Include standard input/output for printing." },
            { correct: '#include <math.h>', distractors: [{text: '#include "math.h"', reason:'While sometimes permissible, standard library headers are conventionally included using angle brackets `< >`.'}, {text:'#include <float.h>', reason:'`<float.h>` defines properties of floating-point types, but not the `M_PI` constant or math functions like `pow()`.'}], indent: 0, explanation: "Include math library for constants like M_PI and functions like pow()." },
            { correct: '#define PI 3.14159f', distractors: [{text: '#define PI = 3.14159f;', reason:'`#define` is a preprocessor directive; it does not use `=` for assignment or usually end with a semicolon (the semicolon would become part of the replacement).'}, {text:'float PI = 3.14159f;', reason:'Using `#define` creates a macro replacement. Using `const float PI = 3.14159f;` would create a typed constant, which is often preferred but `#define` is common.'}], indent: 0, explanation: "Define a constant for PI (using 'f' suffix for float literal)." },
            { correct: 'int main() {', distractors: [{text:'float main() {', reason:'The C standard requires `main` to return `int`.'}, {text:'void main() {', reason:'Standard C requires `main` to return `int`. `void main` is non-standard.'}], indent: 0, explanation: "Start the main function." },
            { correct: 'float radius = 5.0f;', distractors: [{text: 'int radius = 5;', reason:'For calculations potentially involving decimals (like area with PI), using `float` or `double` provides more accurate results.'}, {text:'float radius = 5.0;', reason:'Appending `f` (e.g., `5.0f`) explicitly marks the literal as a `float`, avoiding potential implicit conversions from `double`.'}], indent: 1, explanation: "Declare a float variable 'radius' and initialize it." },
            { correct: 'float area;', distractors: [{text: 'area = 0.0f;', reason:'Declaring the variable (`float area;`) must happen before assigning a value to it.'}, {text:'float area()', reason:'This syntax resembles a function declaration, not a variable declaration.'}], indent: 1, explanation: "Declare a float variable 'area' to store the result." },
            { correct: 'area = PI * radius * radius;', distractors: [{text: 'area = PI * (radius^2);', reason:'The `^` operator in C is the bitwise XOR operator, not exponentiation. Use `radius * radius` or `pow(radius, 2.0f)` from `<math.h>`.'}, {text:'area = PI * pow(radius, 2.0f);', reason:'Using `pow()` from `<math.h>` is also correct but `radius * radius` is simpler for squaring.'}], indent: 1, explanation: "Calculate the area using the formula (PI * r^2)." },
            { correct: 'printf("Area: %.2f\\n", area);', distractors: [{text: 'printf("Area: %d\\n", area);', reason:'`%d` is the format specifier for integers. For floats, use `%f`. `%.2f` specifically formats it to 2 decimal places.'}, {text: 'printf("Area: %f.2\\n", area);', reason:'Format specifiers for precision come *before* the type character, like `%.2f`, not after.'}], indent: 1, explanation: "Print the calculated area, formatted to 2 decimal places (%.2f)." },
            { correct: 'return 0;', distractors: [{text:'return area;', reason:'`main` should return 0 for success, not the calculated area value (unless intended as a specific exit code).'}, {text:'exit(0);', reason:'`return 0;` is the standard and preferred way to indicate success from `main`, allowing normal cleanup. `exit(0)` terminates immediately.'}], indent: 1, explanation: "Indicate successful execution." },
            { correct: '}', distractors: [{text:'end;', reason:'`end` is not a C keyword.'}, {text:'});', reason:'Parentheses and semicolons mark the end of statements or expressions, not code blocks.'}], indent: 0, explanation: "Close the main function." }
        ]
    },
    // Level 6: Character Input/Output
    {
        goal: "Read a single character and print its ASCII value.",
        concepts: "char data type, getchar, printf (%c, %d)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text:'#include <char.h>', reason:'Character I/O functions like `getchar` and `printf` format specifiers are in `stdio.h`.'}, {text:'using namespace std;', reason:'This is C++ syntax for accessing the standard namespace, not used in standard C.'}], indent: 0, explanation: "Include standard input/output library." },
            { correct: 'int main() {', distractors: [{text:'int main(void) {', reason:'Both `int main()` and `int main(void)` are valid ways to declare main with no arguments in standard C.'}, {text:'char main() {', reason:'`main` must return `int`.'}], indent: 0, explanation: "Start the main function." },
            { correct: 'char inputChar;', distractors: [{text:'string inputChar;', reason:'C does not have a built-in `string` type. Use `char` for single characters.'}, {text:'character inputChar;', reason:'The keyword for the character data type in C is `char`.'}], indent: 1, explanation: "Declare a character variable." },
            { correct: 'printf("Enter a character: ");', distractors: [{text:'puts("Enter a character: ");', reason:'`puts` also prints strings but automatically adds a newline. `printf` offers more formatting control and doesn\'t add a newline unless specified (`\\n`).'}, {text:'cout << "Enter a character: ";', reason:'`cout` is the C++ standard output stream object.'}], indent: 1, explanation: "Prompt the user." },
            { correct: 'inputChar = getchar();', distractors: [{text: 'getchar(&inputChar);', reason:'`getchar()` takes no arguments; it reads a character from standard input and *returns* its value, which should be assigned.'}, {text:'scanf("%c", &inputChar);', reason:'While `scanf("%c", &inputChar)` also works, `getchar()` is specifically designed for reading just one character simply.'}], indent: 1, explanation: "Read a single character from the input stream." },
            { correct: 'printf("Character: %c\\n", inputChar);', distractors: [{text: 'printf("Character: %s\\n", &inputChar);', reason:'`%s` expects a pointer to a null-terminated string. `%c` prints the single character value held by `inputChar`.'}, {text:'printf(inputChar);', reason:'`printf` requires a format string as the first argument.'}], indent: 1, explanation: "Print the character entered using the %c format specifier." },
            { correct: 'printf("ASCII Value: %d\\n", inputChar);', distractors: [{text: 'printf("ASCII Value: %c\\n", inputChar);', reason:'Using `%c` would print the character itself again. Using `%d` treats the `char` as its underlying integer ASCII value for printing.'}, {text:'printf("ASCII Value: %u\\n", inputChar);', reason:'While ASCII values are often positive, using `%d` (signed integer) is common practice. `%u` (unsigned) would also work for standard ASCII.'}], indent: 1, explanation: "Print the integer ASCII value of the character using the %d format specifier." },
            { correct: 'return 0;', distractors: [{text:'return inputChar;', reason:'Return 0 to indicate success.'}, {text:'return (int)inputChar;', reason:'Return 0 to indicate success, not the character\'s value.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text:'};', reason:'Semicolon not used after function closing brace.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 7: If-Else Statement
    {
        goal: "Check if a number is even or odd.",
        concepts: "if-else statement, modulo operator (%)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text:'import stdio', reason:'C uses `#include <header.h>` preprocessor directive, not `import`.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: 'int number = 7;', distractors: [{text:'float number = 7.0f;', reason:'The modulo operator `%` typically works with integers. Using `int` is standard for even/odd checks.'}, {text:'int number == 7;', reason:'`==` is for comparison. Use `=` for assignment during initialization.'}], indent: 1, explanation: "Declare and initialize an integer variable." },
            { correct: 'if (number % 2 == 0) {', distractors: [{text: 'if (number % 2 = 0) {', reason:'`=` is the assignment operator. `==` is the equality comparison operator, needed here to check if the remainder is zero.'}, {text:'if (number / 2 * 2 == number) {', reason:'While this logic works for positive integers, using the modulo operator `number % 2 == 0` is the direct and standard way to check for evenness.'}], indent: 1, explanation: "Check if the remainder when divided by 2 is equal to 0." },
            { correct: 'printf("%d is even.\\n", number);', distractors: [{text:'printf("Number is even.\\n");', reason:'Including `%d` and `number` makes the output more informative, showing which number was checked.'}], indent: 2, explanation: "Print if the number is even." },
            { correct: '} else {', distractors: [{text: '} if else {', reason:'The correct syntax is simply `} else {`.'}, {text: '} else (number % 2 != 0) {', reason:'The `else` block automatically handles all cases where the preceding `if` (and any `else if`) conditions were false; no condition is needed or allowed after `else`.'}], indent: 1, explanation: "Start the block for when the 'if' condition is false." },
            { correct: 'printf("%d is odd.\\n", number);', distractors: [{text:'printf("Number is odd.\\n");', reason:'Including `%d` and `number` is more informative.'}], indent: 2, explanation: "Print if the number is odd." },
            { correct: '}', distractors: [{text:'end if;', reason:'C uses `}` to close blocks.'}, {text:'};', reason:'Semicolon not used after code block closing brace.'}], indent: 1, explanation: "Close the else block." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 8: While Loop
     {
        goal: "Print numbers from 10 down to 1 using a while loop.",
        concepts: "while loop, decrement operator (--)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: 'int counter = 10;', distractors: [{text:'int counter;', reason:'The counter needs an initial value (10) before the loop condition `counter >= 1` is checked.'}, {text:'int counter = 11;', reason:'Starting at 11 and using `--counter` inside the loop would work, but initializing directly to 10 is simpler.'}], indent: 1, explanation: "Initialize a counter variable to 10." },
            { correct: 'while (counter >= 1) {', distractors: [{text: 'while counter >= 1 {', reason:'The condition in a `while` loop must be enclosed in parentheses `()`. '}, {text:'while (counter > 0) {', reason:'Using `> 0` is equivalent to `>= 1` for integers and also correct.'}], indent: 1, explanation: "Start a loop that continues as long as 'counter' is greater than or equal to 1." },
            { correct: 'printf("%d ", counter);', distractors: [{text:'printf(counter);', reason:'`printf` requires a format string like `"%d "`.'}, {text:'printf("%d\\n", counter);', reason:'Using `\\n` prints each number on a new line. Using a space `" "` prints them on the same line as requested.'}], indent: 2, explanation: "Print the current value of the counter." },
            { correct: 'counter--;', distractors: [{text: 'counter ++;', reason:'`++` increments the counter. `--` is needed to decrement (count down).'}, {text:'--counter;', reason:'Both pre-decrement (`--counter`) and post-decrement (`counter--`) work here as standalone statements.'}], indent: 2, explanation: "Decrement the counter by 1." },
            { correct: '}', distractors: [{text:'end while;', reason:'C uses `}` to close loops.'}, {text:'break;', reason:'`break` would exit the loop prematurely after the first iteration.'}], indent: 1, explanation: "Close the while loop block." },
             { correct: 'printf("\\n"); // Print a final newline', distractors: [{text:'println();', reason:'`println` is not a standard C function.'}, {text: 'printf(\'\\n\');', reason: '`printf` expects a string literal (double quotes \" \") for the format string, not a character literal (single quotes \' \').'}], indent: 1, explanation: "Print a newline character for cleaner output after the loop." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 9: Do-While Loop
     {
        goal: "Ask the user to enter a positive number, repeat until they do.",
        concepts: "do-while loop, scanf",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: 'int number;', distractors: [{text:'int number = 0;', reason:'Initializing is fine, but the loop guarantees execution at least once, so `scanf` will assign a value before the condition `number <= 0` is checked.'}], indent: 1, explanation: "Declare an integer variable to store user input." },
            { correct: 'do {', distractors: [{text: 'while (number <= 0) {', reason:'A `while` loop checks the condition *before* the first iteration. A `do-while` loop executes the body *at least once* before checking, which is needed here to get input first.'}, {text:'for (;;) { // Infinite loop', reason:'An infinite `for` loop would require an `if` and `break` inside, making `do-while` more suitable for this condition.'}], indent: 1, explanation: "Start a do-while loop, which executes the body at least once." },
            { correct: 'printf("Enter a positive number: ");', distractors: [], indent: 2, explanation: "Prompt the user for input inside the loop." },
            { correct: 'scanf("%d", &number);', distractors: [{text:'scanf("%d", number);', reason:'`scanf` requires the address (`&`) of the variable to store the input.'}, {text:'number = getchar();', reason:'`getchar` reads a single character, not a potentially multi-digit integer. Use `scanf` with `%d`.'}], indent: 2, explanation: "Read the integer input from the user." },
            { correct: '} while (number <= 0);', distractors: [{text: '} while number <= 0;', reason:'The condition must be enclosed in parentheses `()`. '}, {text:'} while (number < 1);', reason:'This condition is equivalent to `number <= 0` for integers and also correct.'}], indent: 1, explanation: "End the loop body and check the condition. Repeat if the number is not positive (<= 0)." },
            { correct: 'printf("Thank you! You entered: %d\\n", number);', distractors: [{text:'printf("Positive number entered.\\n");', reason:'Printing the actual number entered is more informative.'}], indent: 1, explanation: "Print the valid positive number entered." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 10: Basic Function Definition and Call
     {
        goal: "Define a function to print a greeting and call it from main.",
        concepts: "Function definition, function call, void return type",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
            { correct: '// Function declaration (prototype)', distractors: [{text:'// Function definition', reason:'This is just the declaration (prototype), announcing the function\'s signature. The definition (implementation) comes later.'}], indent: 0, explanation: "Comment explaining the next line (prototype)." },
            { correct: 'void printGreeting(void);', distractors: [{text:'int printGreeting();', reason:'The function doesn\'t calculate or return a value, so `void` is the appropriate return type.'}, {text:'void printGreeting();', reason:'Specifying `(void)` for no parameters is explicit and preferred in C over empty parentheses `()` in declarations.'}], indent: 0, explanation: "Declare the function: returns nothing (void), takes no arguments (void)." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start the main function." },
            { correct: 'printGreeting();', distractors: [{text: 'call printGreeting();', reason:'Function calls in C are done using just the function name followed by parentheses `()`. `call` is not a C keyword.'}, {text:'int result = printGreeting();', reason:'A `void` function doesn\'t return a value that can be assigned to `result`.'}], indent: 1, explanation: "Call the defined function to execute its code." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate successful execution of main." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close the main function." },
            { correct: '// Function definition', distractors: [{text:'// Function call', reason:'This marks the implementation (definition) of the function.'}], indent: 0, explanation: "Comment indicating the function's implementation." },
            { correct: 'void printGreeting(void) {', distractors: [{text:'int printGreeting(void) {', reason:'The definition must match the return type (`void`) specified in the declaration.'}, {text:'void printGreeting() {', reason:'While sometimes allowed, matching the explicit `(void)` from the prototype in the definition is good practice.'}], indent: 0, explanation: "Define the function, matching the declaration." },
            { correct: 'printf("Hello from the function!\\n");', distractors: [{text:'puts("Hello from the function!");', reason:'`puts` works but adds its own newline. `printf` requires `\\n` explicitly.'}], indent: 1, explanation: "The action performed by the function: printing a message." },
            { correct: '}', distractors: [{text:'return;', reason:'Explicit `return;` is optional at the end of a `void` function; the closing brace `}` implies it.'}, {text:'};', reason:'Semicolon not needed after function closing brace.'}], indent: 0, explanation: "Close the printGreeting function block." }
        ]
    },
    // Level 11: Function with Parameters
     {
        goal: "Define a function that takes an integer and prints it.",
        concepts: "Functions with parameters, passing arguments",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
            { correct: 'void printNumber(int num);', distractors: [{text:'void printNumber(int);', reason:'While omitting the parameter name is allowed in declarations (prototypes), including it (`num`) makes it clearer what the function expects.'}, {text:'int printNumber(int num);', reason:'This function only prints, it doesn\'t calculate or return an integer value, so `void` return type is appropriate.'}], indent: 0, explanation: "Declare a function that takes one integer argument." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start the main function." },
            { correct: 'int myValue = 42;', distractors: [], indent: 1, explanation: "Declare a variable in main." },
            { correct: 'printNumber(myValue);', distractors: [{text: 'printNumber(int myValue);', reason:'When calling a function, you pass the variable (argument) directly, not its type declaration.'}, {text:'myValue.printNumber();', reason:'C uses procedural function calls `functionName(argument)`, not object-oriented method calls like `variable.method()`.'}], indent: 1, explanation: "Call the function, passing the value of 'myValue' as the argument." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." },
            { correct: 'void printNumber(int num) {', distractors: [{text:'void printNumber(value) {', reason:'The parameter declaration in the function definition requires a type (`int`) before the name (`num`).'}, {text:'void printNumber(int &num) {', reason:'This syntax `int &num` declares a reference parameter, which is a C++ feature, not standard C. C uses pointers (`int *num`) to achieve pass-by-reference behavior.'}], indent: 0, explanation: "Define the function, specifying the parameter type and name." },
            { correct: 'printf("The number passed is: %d\\n", num);', distractors: [{text:'printf("The number passed is: %d\\n", myValue);', reason:'Inside `printNumber`, the passed value is accessed using the parameter name `num`. `myValue` only exists within the scope of `main`.'}, {text:'printf("The number passed is: " + num);', reason:'String concatenation with `+` is not standard C for `printf`. Use format specifiers like `%d`.'}], indent: 1, explanation: "Print the value of the parameter 'num' received by the function." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close the printNumber function." }
        ]
    },
    // Level 12: Function Returning a Value
     {
        goal: "Define a function that squares a number and returns the result.",
        concepts: "Functions returning values, return statement",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int square(int x);', distractors: [{text:'void square(int x);', reason:'The function needs to return the calculated square (an integer), so the return type must be `int`, not `void`.'}, {text:'function int square(int x);', reason:'C does not use the `function` keyword.'}], indent: 0, explanation: "Declare a function 'square' that takes an int and returns an int." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
            { correct: 'int number = 5;', distractors: [], indent: 1, explanation: "Declare a number to be squared." },
            { correct: 'int result;', distractors: [{text:'var result;', reason:'C requires explicit type declaration like `int`.'}], indent: 1, explanation: "Declare a variable to store the function's return value." },
            { correct: 'result = square(number);', distractors: [{text: 'square(number);', reason:'The `square` function returns a value. You need to capture this returned value by assigning it to a variable (like `result = ...`) to use it.'}, {text:'result = square(&number);', reason:'The `square` function expects an integer value (`int x`), not a pointer to an integer (`int *x`). Pass `number` directly.'}], indent: 1, explanation: "Call the 'square' function and assign its return value to 'result'." },
            { correct: 'printf("%d squared is %d\\n", number, result);', distractors: [{text:'printf(result);', reason:'`printf` needs a format string.'}, {text:'printf("Square is %d\\n", result);', reason:'Including the original number makes the output clearer.'}], indent: 1, explanation: "Print the original number and the calculated result." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." },
            { correct: 'int square(int x) {', distractors: [{text:'void square(int x) {', reason:'Definition must match the declared return type (`int`).'}, {text:'int square(int& x) {', reason:'C uses pointers (`int *x`) for pass-by-reference effects, not C++ reference syntax (`int&`).'}], indent: 0, explanation: "Define the 'square' function." },
            { correct: 'int calculation = x * x;', distractors: [{text:'int calculation = pow(x, 2);', reason:'Using `pow()` requires `#include <math.h>` and is slightly less efficient for simple squaring than `x * x`.'}, {text:'calculation = x * x;', reason:'The variable `calculation` must be declared (`int calculation`) before being assigned a value.'}], indent: 1, explanation: "Calculate the square." },
            { correct: 'return calculation;', distractors: [{text: 'return;', reason:'The function is declared to return `int`, so it must return an integer value. `return;` alone is only for `void` functions.'}, {text:'printf("%d", calculation); return 0;', reason:'The function\'s primary purpose is to *return* the calculated value. Printing should ideally be done by the caller (`main`).'}], indent: 1, explanation: "Return the calculated value from the function." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close the square function." }
        ]
    },
    // Level 13: Simple Array Initialization and Access
    {
        goal: "Create an integer array, initialize it, and print the third element.",
        concepts: "Array declaration, array initialization, array indexing (0-based)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: 'int scores[5] = {88, 92, 75, 100, 95};', distractors: [{text: 'int scores = {88, 92, 75, 100, 95};', reason:'You must specify the array size (e.g., `[5]`) or use empty brackets (`[]`) to let the compiler deduce it from the initializer list.'}, {text:'int scores(5) = {88, 92, 75, 100, 95};', reason:'Array size is specified using square brackets `[]`, not parentheses `()`.'}], indent: 1, explanation: "Declare an integer array named 'scores' of size 5 and initialize it with values." },
            { correct: 'int thirdScore;', distractors: [{text:'int scores[2];', reason:'This declares another array, not a variable to hold a single score.'}], indent: 1, explanation: "Declare a variable to hold the specific score." },
            { correct: 'thirdScore = scores[2];', distractors: [{text: 'thirdScore = scores[3];', reason:'Array indexing in C is 0-based. The third element is at index 2 (0, 1, 2). Index 3 refers to the fourth element.'}, {text:'thirdScore = scores.get(2);', reason:'C arrays do not have methods like `.get()`. Access elements using square bracket notation `scores[index]`.'}], indent: 1, explanation: "Access the third element (at index 2) of the array and store it." },
            { correct: 'printf("The third score is: %d\\n", thirdScore);', distractors: [{text:'printf("The third score is: %d\\n", scores);', reason:'Passing the array name `scores` usually decays to a pointer to the first element. `printf` with `%d` expects an integer value, not an address.'}, {text:'printf(thirdScore);', reason:'`printf` requires a format string.'}], indent: 1, explanation: "Print the value retrieved from the array." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
     // Level 14: Looping Through an Array
    {
        goal: "Iterate through an array using a for loop and print all elements.",
        concepts: "Arrays, for loop, array indexing",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: 'int values[4] = {10, 20, 30, 40};', distractors: [{text:'int values[]; values = {10, 20, 30, 40};', reason:'Assignment using `{}` after declaration is not allowed for arrays.'}, {text:'int values[4] = (10, 20, 30, 40);', reason:'Array initialization uses curly braces `{}`, not parentheses `()`.'}], indent: 1, explanation: "Declare and initialize an integer array." },
            { correct: 'int i;', distractors: [{text:'i = 0;', reason:'Declare the variable `int i;` before using it.'}], indent: 1, explanation: "Declare a loop counter variable." },
             { correct: 'printf("Array elements: ");', distractors: [], indent: 1, explanation: "Print a label before the elements." },
            { correct: 'for (i = 0; i < 4; i++) {', distractors: [{text: 'for (i = 0; i <= 4; i++) {', reason:'Array indices for size 4 are 0, 1, 2, 3. Using `<=` would attempt to access `values[4]`, which is out of bounds.'}, {text:'for (i = 1; i <= 4; i++) {', reason:'Array indexing starts at 0, so the loop should start at 0 to include the first element.'}], indent: 1, explanation: "Start a for loop to iterate from index 0 up to (but not including) 4." },
            { correct: 'printf("%d ", values[i]);', distractors: [{text: 'printf("%d ", &values[i]);', reason:'`&values[i]` gives the address of the element. Pass `values[i]` directly to print the value.'}, {text:'printf(values[i]);', reason:'`printf` requires a format string like `"%d "`.'}], indent: 2, explanation: "Inside the loop, print the element at the current index 'i'." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close the for loop block." },
            { correct: 'printf("\\n");', distractors: [{text:'puts("");', reason:'`puts("")` also prints a newline and is valid here.'}, {text:'return;', reason:'Need to close the main function and return 0.'}], indent: 1, explanation: "Print a final newline for formatting." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
     // Level 15: Finding Array Size (sizeof)
    {
        goal: "Calculate the number of elements in an array using sizeof.",
        concepts: "sizeof operator, arrays, integer division",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: 'int data[] = {5, 10, 15, 20, 25, 30}; // Size inferred', distractors: [{text:'int data[6] = {5, 10, 15, 20, 25, 30};', reason:'Explicit size is fine, but letting the compiler infer size `[]` from the initializer is also common and adaptable.'}, {text:'int data[]; data = {5, 10, 15, 20, 25, 30};', reason:'Array assignment after declaration isn\'t allowed this way.'}], indent: 1, explanation: "Declare and initialize an array, letting the compiler determine its size." },
            { correct: 'int size;', distractors: [{text:'float size;', reason:'The number of elements (size) should be an integer.'}, {text:'size_t size;', reason:'`size_t` is the type technically returned by `sizeof` and is appropriate for sizes, but `int` is often used for simplicity here.'}], indent: 1, explanation: "Declare a variable to store the array size." },
            { correct: 'size = sizeof(data) / sizeof(data[0]);', distractors: [{text: 'size = sizeof(data);', reason:'`sizeof(data)` gives the total size of the array in *bytes*, not the number of elements.'}, {text:'size = sizeof(data) / sizeof(*data);', reason:'`*data` is equivalent to `data[0]` (the first element), so this is also correct, but `sizeof(data[0])` is arguably clearer.'}], indent: 1, explanation: "Calculate size: total bytes of array divided by bytes of one element." },
            { correct: 'printf("Number of elements: %d\\n", size);', distractors: [{text:'printf("Size in bytes: %d\\n", sizeof(data));', reason:'This would print the total byte size, not the element count.'}], indent: 1, explanation: "Print the calculated number of elements." },
             { correct: '// Now loop using the calculated size', distractors: [], indent: 1, explanation: "Comment indicating the next step." },
             { correct: 'for (int i = 0; i < size; i++) {', distractors: [{text:'for (int i = 0; i < 6; i++) {', reason:'Using the calculated `size` variable makes the loop automatically adapt if the array initialization changes. Hardcoding `6` is less flexible.'}, {text:'for (int i = 0; i <= size; i++) {', reason:'Loop must be `< size` as indices go from 0 to size-1.'}], indent: 1, explanation: "Use the calculated 'size' in the loop condition." },
             { correct: 'printf("%d ", data[i]);', distractors: [{text:'printf("%d ", i);', reason:'This prints the index, not the array value.'}], indent: 2, explanation: "Print each element." },
             { correct: '}', distractors: [], indent: 1, explanation: "Close the loop." },
             { correct: 'printf("\\n");', distractors: [], indent: 1, explanation: "Final newline." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 16: Pointer Basics (Revisited with NULL)
     {
        goal: "Declare a pointer, initialize it to NULL, assign an address later, and check for NULL.",
        concepts: "Pointers, NULL, address-of operator (&), dereference operator (*), if statement",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
             { correct: '#include <stdlib.h> // For NULL (though often in stdio.h too)', distractors: [{text:'#include <pointers.h>', reason:'There is no standard `<pointers.h>`. NULL is typically defined in `<stdlib.h>`, `<stdio.h>`, `<stddef.h>` and others.'}], indent: 0, explanation: "Include stdlib.h, commonly containing the NULL definition." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
            { correct: 'int number = 50;', distractors: [], indent: 1, explanation: "Declare a regular integer variable." },
            { correct: 'int *ptr = NULL;', distractors: [{text:'int *ptr;', reason:'Initializing pointers to `NULL` when declared is good practice if they aren\'t immediately assigned a valid address.'}, {text:'int *ptr = 0;', reason:'Assigning `0` is often equivalent to assigning `NULL`, but using the `NULL` macro is more explicit and standard.'}], indent: 1, explanation: "Declare an integer pointer and initialize it to NULL." },
            { correct: 'printf("Initial ptr value: %p\\n", ptr);', distractors: [], indent: 1, explanation: "Show that the pointer initially holds the NULL address (often printed as 0 or (nil))." },
             { correct: '// Assign address later', distractors: [], indent: 1, explanation: "Comment indicating address assignment." },
             { correct: 'ptr = &number;', distractors: [], indent: 1, explanation: "Assign the memory address of 'number' to the pointer 'ptr'." },
             { correct: 'printf("Ptr value after assignment: %p\\n", ptr);', distractors: [], indent: 1, explanation: "Show the non-NULL address now stored in ptr." },
            { correct: 'if (ptr != NULL) {', distractors: [{text:'if (ptr)', reason:'While checking `if (ptr)` works because NULL evaluates to false in a boolean context, explicitly comparing `ptr != NULL` is clearer.'}, {text:'if (*ptr != NULL)', reason:'`*ptr` accesses the *value* (50). We want to check if the *pointer itself* (`ptr`) is NULL before dereferencing it.'}], indent: 1, explanation: "Check if the pointer is NOT NULL before trying to use it." },
            { correct: 'printf("Value via pointer: %d\\n", *ptr);', distractors: [], indent: 2, explanation: "Safely print the value only if the pointer is not NULL." },
            { correct: '} else {', distractors: [], indent: 1, explanation: "Block for when the pointer is NULL." },
            { correct: 'printf("Pointer is NULL, cannot dereference.\\n");', distractors: [], indent: 2, explanation: "Message indicating the pointer is NULL." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close the if/else block." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
     // Level 17: Pointers and Arrays (Equivalence)
    {
        goal: "Demonstrate accessing array elements using both array[index] and *(array + index) notation.",
        concepts: "Pointers, arrays, pointer arithmetic, dereference operator (*), equivalence",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
            { correct: 'int nums[] = {11, 22, 33, 44};', distractors: [], indent: 1, explanation: "Declare and initialize an integer array." },
            { correct: 'int *ptr = nums; // Point ptr to the start of the array', distractors: [], indent: 1, explanation: "Declare a pointer and make it point to the first element of nums." },
            { correct: 'printf("Accessing elements for nums[]:\\n");', distractors: [], indent: 1, explanation: "Print a header." },
            { correct: 'printf("Element 0: nums[0]=%d, *(nums+0)=%d\\n", nums[0], *(nums + 0));', distractors: [{text:'printf("Element 0: nums[0]=%d, *nums+0=%d\\n", nums[0], *nums + 0);', reason:'`*nums + 0` dereferences `nums` first (gets 11) then adds 0. `*(nums + 0)` calculates the address first, then dereferences.'}], indent: 1, explanation: "Show accessing the first element using both notations with the array name." },
            { correct: 'printf("Element 1: nums[1]=%d, *(nums+1)=%d\\n", nums[1], *(nums + 1));', distractors: [], indent: 1, explanation: "Show accessing the second element using both notations." },
            { correct: 'printf("\\nAccessing elements via ptr:\\n");', distractors: [], indent: 1, explanation: "Print another header for pointer access." },
            { correct: 'printf("Element 0: ptr[0]=%d, *(ptr+0)=%d\\n", ptr[0], *(ptr + 0));', distractors: [{text:'printf("Element 0: ptr[0]=%d, *ptr[0]=%d\\n", ptr[0], *ptr[0]);', reason:'`*ptr[0]` is parsed as `*(ptr[0])` which is invalid here. Use `ptr[0]` or `*(ptr+0)`.'}], indent: 1, explanation: "Show accessing the first element using both notations via the pointer." },
            { correct: 'printf("Element 2: ptr[2]=%d, *(ptr+2)=%d\\n", ptr[2], *(ptr + 2));', distractors: [], indent: 1, explanation: "Show accessing the third element using both notations via the pointer." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 18: String Literal vs Char Array
    {
        goal: "Illustrate the difference between a string literal (often read-only) and a modifiable char array.",
        concepts: "String literals, char arrays, pointers, memory segments (conceptual)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
            { correct: 'char *strLiteral = "Immutable"; // Pointer to string literal', distractors: [{text:'char strLiteral[] = "Immutable";', reason:'This creates a modifiable array initialized with the string. The goal here is to show a pointer to a literal.'}], indent: 1, explanation: "Declare a pointer initialized to point to a string literal (often in read-only memory)." },
            { correct: 'char charArray[] = "Modifiable"; // Modifiable char array', distractors: [{text:'char *charArray = {"Modifiable"};', reason:'This syntax is incorrect for initializing a pointer.'}], indent: 1, explanation: "Declare a character array initialized with a string literal (creating a copy in writable memory)." },
            { correct: 'printf("String Literal: %s\\n", strLiteral);', distractors: [], indent: 1, explanation: "Print the string literal." },
            { correct: 'printf("Character Array: %s\\n", charArray);', distractors: [], indent: 1, explanation: "Print the character array." },
            { correct: '// Attempt to modify first character', distractors: [], indent: 1, explanation: "Comment explaining the next actions." },
            { correct: 'charArray[0] = \'X\'; // OK - Modifying the array', distractors: [{text:'strLiteral[0] = \'X\';', reason:'Attempting to modify a string literal through a pointer results in undefined behavior (often a crash) because the literal may be stored in read-only memory.'}], indent: 1, explanation: "Modify the first character of the character array (this is allowed)." },
            { correct: 'printf("Modified Array: %s\\n", charArray);', distractors: [], indent: 1, explanation: "Show the modification was successful." },
             { correct: '// strLiteral[0] = \'Y\'; // <-- This would likely cause a runtime error!', distractors: [{text:'strLiteral = "New"; // OK - Changing where pointer points', reason:'Assigning a new string literal changes the pointer, but doesn\'t modify the original "Immutable" literal.'}], indent: 1, explanation: "Comment illustrating the danger of modifying a string literal." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 19: Simple Struct Initialization
    {
        goal: "Initialize a struct variable using an initializer list.",
        concepts: "Structs, initialization lists",
        sequence: [
             { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
             { correct: 'struct Point { int x; int y; };', distractors: [], indent: 0, explanation: "Define a simple Point structure." },
             { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
             { correct: 'struct Point p1 = {15, 25};', distractors: [{text:'struct Point p1;', reason:'This only declares p1; the goal is to initialize during declaration.'}, {text:'struct Point p1 = (15, 25);', reason:'Struct initialization uses curly braces `{}`, not parentheses `()`.'}], indent: 1, explanation: "Declare and initialize struct variable p1 using an initializer list {value_for_x, value_for_y}." },
             { correct: 'printf("p1 coordinates: (%d, %d)\\n", p1.x, p1.y);', distractors: [], indent: 1, explanation: "Print the members of the initialized struct." },
             { correct: '// Designated initializers (C99 and later)', distractors: [], indent: 1, explanation: "Comment introducing designated initializers." },
             { correct: 'struct Point p2 = {.y = 50, .x = 30}; // Order doesn\'t matter', distractors: [{text:'struct Point p2 = {y: 50, x: 30};', reason:'Designated initializers use a dot (`.`) before the member name (`.y`, `.x`), not a colon.'}, {text:'struct Point p2 = {50, 30};', reason:'Without designated initializers, values are assigned in order (x=50, y=30). Designated initializers allow explicit assignment by name.'}], indent: 1, explanation: "Initialize p2 using designated initializers (explicitly naming members)." },
             { correct: 'printf("p2 coordinates: (%d, %d)\\n", p2.x, p2.y);', distractors: [], indent: 1, explanation: "Print the members of p2." },
             { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
             { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
     // Level 20: Passing Struct to Function (by Value)
    {
        goal: "Pass a struct to a function by value and print its members inside the function.",
        concepts: "Structs, functions, pass-by-value",
        sequence: [
             { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
             { correct: 'struct Item { int id; float price; };', distractors: [], indent: 0, explanation: "Define an Item structure." },
             { correct: 'void displayItem(struct Item it); // Function takes struct by value', distractors: [{text:'void displayItem(struct Item *it);', reason:'`struct Item *it` would mean passing a pointer (pass-by-reference effect). `struct Item it` means passing a copy (pass-by-value).'}], indent: 0, explanation: "Declare function displayItem that takes a struct Item by value (a copy)." },
             { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
             { correct: 'struct Item item1 = {101, 19.99f};', distractors: [], indent: 1, explanation: "Declare and initialize an Item struct." },
             { correct: 'displayItem(item1);', distractors: [{text:'displayItem(&item1);', reason:'The function expects a `struct Item`, not a pointer `struct Item *`. Pass `item1` directly to send a copy.'}], indent: 1, explanation: "Call displayItem, passing the item1 struct (a copy will be made)." },
              { correct: 'printf("item1 price in main after call: %.2f\\n", item1.price);', distractors: [], indent: 1, explanation: "Show that the original item1 in main is unaffected by changes inside the function (if any)." },
             { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
             { correct: '}', distractors: [], indent: 0, explanation: "Close main." },
             { correct: 'void displayItem(struct Item it) {', distractors: [], indent: 0, explanation: "Define displayItem, taking a copy of the struct named 'it'." },
             { correct: 'printf("-- Inside Function --\\n");', distractors: [], indent: 1, explanation: "Indicate output is from within the function." },
             { correct: 'printf("Item ID: %d\\n", it.id);', distractors: [], indent: 1, explanation: "Print the id member of the received struct copy 'it'." },
             { correct: 'printf("Item Price: %.2f\\n", it.price);', distractors: [], indent: 1, explanation: "Print the price member of 'it'." },
              { correct: 'it.price = 0.0f; // Modify the copy', distractors: [], indent: 1, explanation: "Modify the price of the local copy 'it' within the function." },
             { correct: 'printf("Price inside function modified to: %.2f\\n", it.price);', distractors: [], indent: 1, explanation: "Show the modified price of the copy." },
              { correct: 'printf("-- Leaving Function --\\n");', distractors: [], indent: 1, explanation: "Indicate end of function execution." },
             { correct: '}', distractors: [], indent: 0, explanation: "Close displayItem function. The copy 'it' is destroyed." }
        ]
    },
    // Level 21: Passing Struct Pointer to Function
    {
        goal: "Pass a pointer to a struct to a function to modify the original struct.",
        concepts: "Structs, pointers, functions, pass-by-reference (using pointers), arrow operator (->)",
        sequence: [
             { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
             { correct: 'struct Config { int settingA; char mode; };', distractors: [], indent: 0, explanation: "Define a Config structure." },
             { correct: 'void updateConfig(struct Config *confPtr); // Takes pointer', distractors: [{text:'void updateConfig(struct Config conf);', reason:'Passing by value (`struct Config conf`) sends a copy; modifications inside wouldn\'t affect the original.'}], indent: 0, explanation: "Declare function updateConfig taking a POINTER to a struct Config." },
             { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
             { correct: 'struct Config currentConfig = { 1, \'A\' };', distractors: [], indent: 1, explanation: "Declare and initialize a Config struct." },
             { correct: 'printf("Before call: SettingA=%d, Mode=%c\\n", currentConfig.settingA, currentConfig.mode);', distractors: [], indent: 1, explanation: "Print initial values." },
             { correct: 'updateConfig(&currentConfig);', distractors: [{text:'updateConfig(currentConfig);', reason:'The function expects a pointer (`struct Config *`). Pass the address (`&`) of `currentConfig`.'}], indent: 1, explanation: "Call updateConfig, passing the ADDRESS of currentConfig." },
             { correct: 'printf("After call: SettingA=%d, Mode=%c\\n", currentConfig.settingA, currentConfig.mode);', distractors: [], indent: 1, explanation: "Print values again to show they were modified by the function." },
             { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
             { correct: '}', distractors: [], indent: 0, explanation: "Close main." },
             { correct: 'void updateConfig(struct Config *confPtr) { // Receives pointer', distractors: [], indent: 0, explanation: "Define updateConfig, receiving a pointer named 'confPtr'." },
             { correct: 'printf("-- Inside updateConfig --\\n");', distractors: [], indent: 1, explanation: "Indicate execution within the function." },
             { correct: 'confPtr->settingA = 99;', distractors: [{text:'confPtr.settingA = 99;', reason:'`confPtr` is a pointer; use the arrow operator `->` to access members via the pointer.'}, {text:'*confPtr.settingA = 99;', reason:'Operator precedence is wrong; use `(*confPtr).settingA` or preferably `confPtr->settingA`.'}], indent: 1, explanation: "Modify the settingA member of the ORIGINAL struct via the pointer." },
             { correct: 'confPtr->mode = \'Z\';', distractors: [{text:'*confPtr->mode = \'Z\';', reason:'`confPtr->mode` already accesses the member value; no extra `*` is needed.'}], indent: 1, explanation: "Modify the mode member of the ORIGINAL struct via the pointer." },
             { correct: 'printf("Config updated inside function.\\n");', distractors: [], indent: 1, explanation: "Confirmation message." },
             { correct: '}', distractors: [], indent: 0, explanation: "Close updateConfig function." }
        ]
    },
     // Level 22: Basic File Reading (fopen, fgets, fclose)
    {
        goal: "Open an existing file ('output.txt' from Level 21), read lines from it using fgets, and print them.",
        concepts: "File I/O, FILE pointer, fopen, fgets, fclose, file modes (\"r\"), char arrays (buffers)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O for file operations and printf." },
             { correct: '// Assumes "output.txt" exists from Level 21', distractors: [], indent: 0, explanation: "Comment reminding prerequisite." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
            { correct: 'FILE *readFilePtr;', distractors: [], indent: 1, explanation: "Declare a FILE pointer for reading." },
            { correct: 'char lineBuffer[100]; // Buffer to hold one line', distractors: [{text:'char *lineBuffer;', reason:'`fgets` needs a character array (buffer) allocated in memory to store the line it reads. A simple pointer isn\'t enough.'}, {text:'char lineBuffer;', reason:'A single char cannot hold a line of text.'}], indent: 1, explanation: "Declare a character array to act as a buffer for reading lines." },
            { correct: 'readFilePtr = fopen("output.txt", "r");', distractors: [{text:'readFilePtr = fopen("output.txt", "w");', reason:'Mode "w" is for writing (and truncates the file). Mode "r" is needed for reading.'}, {text:'readFilePtr = fopen("input.txt", "r");', reason:'The previous level wrote to "output.txt". Ensure the filename matches.'}], indent: 1, explanation: "Open 'output.txt' in read mode ('r')." },
            { correct: 'if (readFilePtr == NULL) {', distractors: [], indent: 1, explanation: "Check if the file failed to open (e.g., doesn't exist)." },
            { correct: 'perror("Error opening file for reading"); return 1;', distractors: [{text:'printf("Error opening file!\\n"); return 1;', reason:'`perror` is useful as it prints the system error message corresponding to why `fopen` failed.'}], indent: 2, explanation: "Print a system error message using perror and exit if file couldn't be opened." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close error check." },
            { correct: 'printf("Contents of output.txt:\\n---\n");', distractors: [], indent: 1, explanation: "Print a header before showing file content." },
            { correct: 'while (fgets(lineBuffer, sizeof(lineBuffer), readFilePtr) != NULL) {', distractors: [{text:'while (!feof(readFilePtr)) {', reason:'Checking `feof` *before* reading can lead to issues. The standard idiom is to check the return value of the read function (`fgets` or `fscanf`) itself. `fgets` returns NULL on end-of-file or error.'}, {text:'fgets(lineBuffer, 100, readFilePtr); while(1) { ... }', reason:'`fgets` should be *inside* the loop condition to read each line and check the return value.'}], indent: 1, explanation: "Loop while fgets successfully reads a line into lineBuffer (returns non-NULL)." },
            { correct: 'printf("%s", lineBuffer); // fgets includes newline', distractors: [{text:'printf("%s\\n", lineBuffer);', reason:'`fgets` reads and stores the newline character (`\\n`) if it fits in the buffer. Adding another `\\n` in `printf` would cause double spacing.'}], indent: 2, explanation: "Print the line read by fgets. It usually includes the newline." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close the while loop." },
            { correct: 'printf("---\\nEnd of file.\\n");', distractors: [], indent: 1, explanation: "Print a footer after reading the file." },
            { correct: 'fclose(readFilePtr);', distractors: [{text:'fclose(lineBuffer);', reason:'`fclose` closes the `FILE` stream pointed to by `readFilePtr`.'}], indent: 1, explanation: "Close the file stream." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
     // Level 23: Dynamic Allocation with calloc
    {
        goal: "Allocate memory for an array of 3 integers using calloc() (initializes to zero) and print them.",
        concepts: "Dynamic memory allocation, calloc, free, sizeof, pointers, initialization to zero",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include for printf." },
            { correct: '#include <stdlib.h>', distractors: [], indent: 0, explanation: "Include stdlib.h for calloc and free." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
            { correct: 'int *zeroArray;', distractors: [], indent: 1, explanation: "Declare a pointer for the dynamically allocated array." },
            { correct: 'int count = 3;', distractors: [], indent: 1, explanation: "Define the number of elements needed." },
            { correct: 'zeroArray = (int *)calloc(count, sizeof(int));', distractors: [{text:'zeroArray = (int *)malloc(count * sizeof(int));', reason:'`malloc` allocates memory but doesn\'t initialize it (contains garbage values). `calloc` allocates *and* initializes the memory to zero.'}, {text:'zeroArray = (int *)calloc(sizeof(int), count);', reason:'The arguments for `calloc` are `(number_of_elements, size_of_each_element)`.'}], indent: 1, explanation: "Allocate memory for 'count' integers using calloc (initializes to zero) and cast." },
            { correct: 'if (zeroArray == NULL) {', distractors: [], indent: 1, explanation: "Check if calloc failed." },
            { correct: 'printf("Memory allocation failed!\\n"); return 1;', distractors: [], indent: 2, explanation: "Handle allocation failure." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close error check." },
            { correct: 'printf("Array elements after calloc (should be 0):\\n");', distractors: [], indent: 1, explanation: "Print a header." },
            { correct: 'for (int i = 0; i < count; i++) {', distractors: [], indent: 1, explanation: "Loop through the allocated elements." },
            { correct: 'printf("zeroArray[%d] = %d\\n", i, zeroArray[i]);', distractors: [], indent: 2, explanation: "Print the index and the value (should be 0)." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close the loop." },
            { correct: 'free(zeroArray);', distractors: [{text:'free(&zeroArray);', reason:'`free` needs the pointer (`zeroArray`) that holds the address returned by `calloc`.'}], indent: 1, explanation: "Free the memory allocated by calloc." },
             { correct: 'zeroArray = NULL;', distractors: [], indent: 1, explanation: "Set pointer to NULL after freeing (good practice)." },
            { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
        ]
            },
                // Level 35: Allocate Array Dynamically (malloc)
            {
                goal: "Allocate memory for an array of 5 floats dynamically, use it, and free it.",
                concepts: "Dynamic memory allocation, malloc, free, sizeof, pointers, pointer arithmetic/array notation",
                sequence: [
                    { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include for printf." },
                    { correct: '#include <stdlib.h>', distractors: [], indent: 0, explanation: "Include stdlib.h for malloc and free." },
                    { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
                    { correct: 'float *dynFloatArray;', distractors: [{text:'float dynFloatArray[5];', reason:'This declares a static array on the stack. We need a pointer for dynamically allocated memory.'}], indent: 1, explanation: "Declare a pointer to float for the dynamic array." },
                    { correct: 'int numElements = 5;', distractors: [], indent: 1, explanation: "Define the desired number of elements." },
                    { correct: 'dynFloatArray = (float *)malloc(numElements * sizeof(float));', distractors: [{text:'dynFloatArray = (float *)malloc(numElements);', reason:'`malloc` needs total *bytes*. Multiply the number of elements by the size of *each* element (`sizeof(float)`).'}, {text:'dynFloatArray = (float *)malloc(sizeof(float[numElements]));', reason:'While `sizeof(float[numElements])` might work if `numElements` is a compile-time constant, the standard way is `count * sizeof(type)`.'}], indent: 1, explanation: "Allocate memory for 'numElements' floats and cast the result to float*." },
                    { correct: 'if (dynFloatArray == NULL) {', distractors: [], indent: 1, explanation: "Check if memory allocation failed." },
                    { correct: 'printf("Memory allocation failed!\\n"); return 1;', distractors: [], indent: 2, explanation: "Handle allocation failure." },
                    { correct: '}', distractors: [], indent: 1, explanation: "Close error check." },
                    { correct: '// Initialize the dynamic array', distractors: [], indent: 1, explanation: "Comment indicating array initialization." },
                    { correct: 'for (int i = 0; i < numElements; i++) {', distractors: [], indent: 1, explanation: "Loop through the allocated elements." },
                    { correct: 'dynFloatArray[i] = (float)i * 1.1f;', distractors: [{text:'*(dynFloatArray + i) = (float)i * 1.1f;', reason:'Both array notation `dynFloatArray[i]` and pointer arithmetic `*(dynFloatArray + i)` are valid ways to access elements of the dynamically allocated block.'}], indent: 2, explanation: "Assign values using array notation (e.g., 0.0, 1.1, 2.2,...)." },
                    { correct: '}', distractors: [], indent: 1, explanation: "Close initialization loop." },
                    { correct: 'printf("Dynamic array elements: ");', distractors: [], indent: 1, explanation: "Print a label." },
                    { correct: 'for (int i = 0; i < numElements; i++) {', distractors: [], indent: 1, explanation: "Loop again to print the elements." },
                    { correct: 'printf("%.1f ", dynFloatArray[i]);', distractors: [], indent: 2, explanation: "Print each element, formatted to one decimal place." },
                    { correct: '}', distractors: [], indent: 1, explanation: "Close printing loop." },
                    { correct: 'printf("\\n");', distractors: [], indent: 1, explanation: "Final newline." },
                    { correct: 'free(dynFloatArray);', distractors: [], indent: 1, explanation: "Free the entire allocated block of memory." },
                        { correct: 'dynFloatArray = NULL;', distractors: [], indent: 1, explanation: "Set pointer to NULL after freeing." },
                    { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
                    { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
                ]
            },
    // NOTE: This adds levels 24 through 35 (12 levels).
    // Further levels would cover file reading (fscanf, fgets), more struct manipulation,
    // enums, unions, bitwise operators, preprocessor details, etc.
            // Example: Pointer Basics
            {
                goal: "Declare a pointer, assign it the address of a variable, and print the value using the pointer.",
                concepts: "Pointers, address-of operator (&), dereference operator (*)",
                sequence: [
                    { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
                    { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
                    { correct: 'int number = 99;', distractors: [], indent: 1, explanation: "Declare a regular integer variable." },
                    { correct: 'int *ptr;', distractors: [{text:'int ptr;', reason:'To declare a pointer, use the asterisk `*` before the pointer variable name.'}, {text:'int &ptr;', reason:'`&` is the address-of operator used to *get* an address, not to declare a pointer type.'}], indent: 1, explanation: "Declare a pointer 'ptr' that can point to an integer." },
                    { correct: 'ptr = &number;', distractors: [{text:'ptr = number;', reason:'A pointer stores a memory address. You need to assign the *address* of `number` (using `&`) to `ptr`, not the value of `number`.'}, {text:'*ptr = &number;', reason:'`*ptr` dereferences the pointer (accesses the value it points to). You should assign the address to `ptr` itself.'}], indent: 1, explanation: "Assign the memory address of 'number' to the pointer 'ptr'." },
                    { correct: 'printf("Value via variable: %d\\n", number);', distractors: [], indent: 1, explanation: "Print the value directly using the variable name." },
                    { correct: 'printf("Address stored in ptr: %p\\n", ptr);', distractors: [{text:'printf("Address stored in ptr: %d\\n", ptr);', reason:'`%d` is for integers. `%p` is the correct format specifier for printing pointer addresses (memory locations).'}, {text:'printf("Address stored in ptr: %p\\n", &ptr);', reason:'`&ptr` gives the address *of the pointer variable itself*, not the address *stored within* the pointer.'}], indent: 1, explanation: "Print the memory address stored in the pointer 'ptr' using %p." },
                    { correct: 'printf("Value via pointer: %d\\n", *ptr);', distractors: [{text: 'printf("Value via pointer: %d\\n", ptr);', reason:'Printing `ptr` directly shows the address it holds. The dereference operator `*` is needed to access the *value* stored at that address.'}, {text:'printf("Value via pointer: %p\\n", *ptr);', reason:'`*ptr` gives the integer value stored at the address. Use `%d` to print this integer value, not `%p`.'}], indent: 1, explanation: "Print the value pointed to by 'ptr' using the dereference operator (*)." },
                    { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
                    { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
                ]
            },
            // Example: Pointers and Arrays
            {
                goal: "Access array elements using pointer arithmetic.",
                concepts: "Pointers, arrays, pointer arithmetic",
                sequence: [
                    { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
                    { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
                    { correct: 'int nums[3] = {100, 200, 300};', distractors: [], indent: 1, explanation: "Declare and initialize an integer array." },
                    { correct: 'int *p;', distractors: [], indent: 1, explanation: "Declare an integer pointer." },
                    { correct: 'p = nums;', distractors: [{text:'p = &nums;', reason:'An array name (like `nums`) often decays into a pointer to its first element. Assigning `nums` directly to `p` is correct. `&nums` gives the address of the *entire array*, which has a different type (`int (*)[3]`).'}, {text:'p = nums[0];', reason:'`nums[0]` is the *value* of the first element (100). A pointer needs an *address*. `p = &nums[0]` would also work.'}], indent: 1, explanation: "Assign the address of the first element of 'nums' to pointer 'p'." },
                    { correct: 'printf("First element (via p): %d\\n", *p);', distractors: [{text:'printf("First element (via p): %d\\n", p);', reason:'`p` holds the address. `*p` dereferences it to get the value.'}], indent: 1, explanation: "Print the value pointed to by 'p' (the first element)." },
                    { correct: 'p++; // Move pointer to next element', distractors: [{text:'*p++;', reason:'Operator precedence: `p++` increments the pointer address first, then `*` dereferences the *new* address. This is often intended, but the comment clarifies the action.'}, {text:'p = p + sizeof(int);', reason:'Pointer arithmetic automatically scales by the size of the pointed-to type. `p++` correctly moves `p` to the next integer address.'}], indent: 1, explanation: "Increment the pointer 'p' to point to the next integer in memory." },
                    { correct: 'printf("Second element (via p): %d\\n", *p);', distractors: [], indent: 1, explanation: "Print the value at the new address pointed to by 'p' (the second element)." },
                    { correct: 'printf("Third element (via p+1): %d\\n", *(p + 1));', distractors: [{text:'printf("Third element (via p+1): %d\\n", *p + 1);', reason:'`*p + 1` dereferences `p` (getting 200) and adds 1 (resulting in 201). `*(p + 1)` calculates the address of the next element and then dereferences it.'}, {text:'printf("Third element (via p[1]): %d\\n", p[1]);', reason:'While array notation `p[1]` often works with pointers, `*(p+1)` explicitly shows pointer arithmetic.'}], indent: 1, explanation: "Access the next element using pointer arithmetic *(p + offset) without changing p." },
                    { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
                    { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
                ]
            },
            // Example: Simple String (Char Array)
            {
                goal: "Declare a string (char array), initialize it, and print it.",
                concepts: "Character arrays, string literals, null termination, printf (%s)",
                sequence: [
                    { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
                    { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
                    { correct: 'char greeting[] = "Hello";', distractors: [{text:'char greeting = "Hello";', reason:'`char` is for a single character. A string requires an array of characters `char[]`.'}, {text:'char greeting[5] = "Hello";', reason:'The string "Hello" requires 6 characters: 5 for "Hello" and 1 for the null terminator `\\0`. `char greeting[6]` or `char greeting[]` is needed.'}], indent: 1, explanation: "Declare a character array 'greeting' and initialize it with a string literal. Size is inferred (6 including null terminator)." },
                    { correct: 'printf("Greeting: %s\\n", greeting);', distractors: [{text: 'printf("Greeting: %c\\n", greeting);', reason:'`%c` is for single characters. `%s` is used to print a null-terminated string (character array).'}, {text:'for(int i=0; greeting[i] != \'\\0\'; i++) { printf("%c", greeting[i]); }', reason:'While looping and printing character by character works, `%s` in `printf` is the standard and simpler way to print strings.'}], indent: 1, explanation: "Print the entire string using the %s format specifier." },
                    { correct: 'printf("Second char: %c\\n", greeting[1]);', distractors: [{text:'printf("Second char: %c\\n", greeting[2]);', reason:'String characters are indexed like arrays (0-based). The second character (`e`) is at index 1.'}], indent: 1, explanation: "Access and print a single character from the string using array indexing." },
                    { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
                    { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
                ]
            },
            // Example: Struct Definition and Use
            {
                goal: "Define a simple struct, create an instance, and access its members.",
                concepts: "struct definition, struct variables, member access operator (.)",
                sequence: [
                    { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O." },
                    { correct: 'struct Point {', distractors: [{text:'struct {', reason:'The structure needs a tag name (like `Point`) to be easily referenced later when declaring variables of its type.'}, {text:'define struct Point {', reason:'`struct` is a keyword, not defined using `#define`.'}], indent: 0, explanation: "Start the definition of a structure named 'Point'." },
                    { correct: 'int x;', distractors: [{text:'x;', reason:'Members must have their data type specified (e.g., `int`).'}], indent: 1, explanation: "Define an integer member named 'x'." },
                    { correct: 'int y;', distractors: [], indent: 1, explanation: "Define an integer member named 'y'." },
                    { correct: '}; // Semicolon is required after struct definition', distractors: [{text: '}', reason:'The definition of a `struct` must end with a semicolon `;` after the closing brace.'}], indent: 0, explanation: "Close the struct definition (note the required semicolon)." },
                    { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
                    { correct: 'struct Point p1;', distractors: [{text:'Point p1;', reason:'In C (unlike C++), you must use the `struct` keyword when declaring a variable of a structure type (`struct Point`).'}, {text:'struct Point p1 = {0, 0};', reason:'Initialization is allowed, but this step just declares the variable.'}], indent: 1, explanation: "Declare a variable 'p1' of type 'struct Point'." },
                    { correct: 'p1.x = 10;', distractors: [{text:'p1->x = 10;', reason:'The arrow operator `->` is used to access members via a *pointer* to a struct. The dot operator `.` is used for direct access via the struct variable itself.'}, {text:'p1[x] = 10;', reason:'Members are accessed using the dot (`.`) or arrow (`->`) operator, not array-style brackets.'}], indent: 1, explanation: "Assign a value to the 'x' member of 'p1' using the dot operator." },
                    { correct: 'p1.y = 20;', distractors: [], indent: 1, explanation: "Assign a value to the 'y' member of 'p1'." },
                    { correct: 'printf("Point coordinates: (%d, %d)\\n", p1.x, p1.y);', distractors: [], indent: 1, explanation: "Print the values of the members of 'p1'." },
                    { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate success." },
                    { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
                ]
            },
            // Example: Basic File Writing (fopen, fprintf, fclose)
            {
                goal: "Open a file, write a line of text to it, and close it.",
                concepts: "File I/O, FILE pointer, fopen, fprintf, fclose, file modes (\"w\")",
                sequence: [
                    { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include standard I/O for file operations." },
                    { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
                    { correct: 'FILE *filePtr;', distractors: [{text:'File *filePtr;', reason:'The standard type for a file stream pointer is `FILE` (all uppercase), defined in `stdio.h`.'}, {text:'FILE filePtr;', reason:'You need a *pointer* to a FILE structure, so `FILE *` is required.'}], indent: 1, explanation: "Declare a pointer variable of type FILE." },
                    { correct: 'filePtr = fopen("output.txt", "w");', distractors: [{text:'filePtr = fopen("output.txt");', reason:'`fopen` requires a mode string (like `"w"` for write, `"r"` for read, `"a"` for append) as the second argument.'}, {text:'fopen("output.txt", "w", filePtr);', reason:'`fopen` *returns* the FILE pointer; you assign its return value to your pointer variable.'}], indent: 1, explanation: "Open (or create) a file named 'output.txt' in write mode ('w')." },
                    { correct: 'if (filePtr == NULL) {', distractors: [{text:'if (filePtr != NULL) {', reason:'You should check if `fopen` failed (returned NULL) to handle errors.'}, {text:'if (fopen == NULL) {', reason:'Check the *returned pointer* (`filePtr`), not the `fopen` function itself.'}], indent: 1, explanation: "Check if the file failed to open (fopen returns NULL on error)." },
                    { correct: 'printf("Error opening file!\\n"); return 1;', distractors: [{text:'printf("Error opening file!\\n");', reason:'If the file cannot be opened, the program cannot proceed. It should exit, typically returning a non-zero value to indicate an error.'}], indent: 2, explanation: "Print an error message and exit if the file couldn't be opened." },
                    { correct: '}', distractors: [], indent: 1, explanation: "Close the error-checking if block." },
                    { correct: 'fprintf(filePtr, "Hello, File! Line 1.\\n");', distractors: [{text:'printf("Hello, File! Line 1.\\n");', reason:'`printf` writes to the standard output (console). `fprintf` is used to write formatted output to a specific file stream (`filePtr`).'}, {text:'fprintf("output.txt", "Hello, File! Line 1.\\n");', reason:'`fprintf` takes the `FILE *` pointer (`filePtr`) as its first argument, not the filename string.'}], indent: 1, explanation: "Write a formatted string to the file pointed to by filePtr." },
                    { correct: 'fclose(filePtr);', distractors: [{text:'close(filePtr);', reason:'The standard C function to close a file stream opened with `fopen` is `fclose`.'}, {text:'fclose("output.txt");', reason:'`fclose` takes the `FILE *` pointer (`filePtr`) as its argument, not the filename.'}], indent: 1, explanation: "Close the file stream, flushing buffers and releasing resources." },
                    { correct: 'printf("Successfully wrote to output.txt\\n");', distractors: [], indent: 1, explanation: "Print a success message to the console." },
                    { correct: 'return 0;', distractors: [], indent: 1, explanation: "Indicate overall program success." },
                    { correct: '}', distractors: [], indent: 0, explanation: "Close main." }
                ]
            }
        ];

        const availableLanguages = [
            { id: 'c', name: 'C', priceStars: 0, priceMoney: null, available: true },
            { id: 'cpp', name: 'C++', priceStars: 1000, priceMoney: '4.99', available: false },
            { id: 'csharp', name: 'C#', priceStars: 1000, priceMoney: '4.99', available: false },
            { id: 'python', name: 'Python', priceStars: 1000, priceMoney: '4.99', available: false },
            { id: 'java', name: 'Java', priceStars: 1000, priceMoney: '4.99', available: false },
            { id: 'javascript', name: 'JavaScript', priceStars: 1000, priceMoney: '4.99', available: false },
            { id: 'html', name: 'HTML', priceStars: 1000, priceMoney: '4.99', available: false },
            { id: 'css', name: 'CSS', priceStars: 1000, priceMoney: '4.99', available: false },
            { id: 'php', name: 'PHP', priceStars: 1000, priceMoney: '4.99', available: false },
            { id: 'swift', name: 'Swift', priceStars: 1000, priceMoney: '4.99', available: false },
            { id: 'kotlin', name: 'Kotlin', priceStars: 1000, priceMoney: '4.99', available: false },
            { id: 'rust', name: 'Rust', priceStars: 1000, priceMoney: '4.99', available: false },
            { id: 'r', name: 'R', priceStars: 1000, priceMoney: '4.99', available: false },
            { id: 'ruby', name: 'Ruby', priceStars: 1000, priceMoney: '4.99', available: false },
        ];

        const availableFonts = {
            'Roboto Mono': "'Roboto Mono', monospace",
            'Source Code Pro': "'Source Code Pro', monospace",
            'Courier Prime': "'Courier Prime', monospace",
            'VT323': "'VT323', monospace" // Pixel font
        };
        const defaultFontFamily = availableFonts['Roboto Mono'];

         const customThemeProperties = {
              '--bg-color': 'Background',
              '--panel-bg-color': 'Panel Background',
              '--border-color': 'Borders',
              '--text-color': 'Primary Text',
              '--text-muted-color': 'Muted Text',
              '--accent-color': 'Accent / Logo',
              '--accent-hover-color': 'Accent Hover',
              '--hint-color': 'Hint Text',
              '--star-color': 'Star Icon',
              '--header-btn-text-color': 'Header Button Text',
              '--success-color': 'Success Messages',
              '--error-color': 'Error Messages',
              '--appstore-blue': 'Purchase Buttons'
         };
         let defaultThemeValues = {};

        // --- Game State ---
        let currentLevelIndex = 0;
        let currentStep = 0;
        let starCount = 0;
        let constructedCode = '';
        let optionsLocked = false;
        let feedbackTimeout = null;
        let incorrectChoiceData = null;
        let previousStarCountForAnimation = 0;
        let hintRevealed = false; // Still track if hint button was clicked for cost/display
        let unlockedThemes = {};
        let unlockedLanguages = {};
        let unlockedFeatures = {};
        let currentCustomColors = {};
        let currentFontFamily = defaultFontFamily;
        // --- NEW State for Star Glitch Fix & Attempts ---
        let initialStarsForLevelAttempt = 0;
        let levelAttempts = {}; // Stores attempts per level index, e.g., { 0: 1, 1: 2 }
        let levelInProgress = false; // Flag to check if refresh happened mid-level
        let levelCompletedThisSession = {}; // Track completion to prevent re-rewarding stars on simple replay without refresh {levelIndex: true}


        // --- DOM Elements ---
        const levelDisplayBtn = document.getElementById('level-display-btn');
        const levelTextSpan = document.getElementById('level-text');
        const starDisplay = document.getElementById('star-count');
        const starNumberSpan = starDisplay.querySelector('.star-number');
        const starDisplayWrapper = document.getElementById('star-display-wrapper');
        const libraryBtn = document.getElementById('library-btn');
        const codeDisplayArea = document.getElementById('code-display-area');
        const interactionArea = document.getElementById('interaction-area');
        const hintContainer = document.getElementById('hint-container');
        const hintText = document.getElementById('hint-text');
        const revealHintBtn = document.getElementById('reveal-hint-btn');
        const infoModal = document.getElementById('info-modal');
        const modalReason = document.getElementById('modal-reason');
        const modalCloseBtn = document.getElementById('modal-close');
        const themeStoreModal = document.getElementById('theme-store-modal');
        const themeStoreContent = themeStoreModal.querySelector('.modal-content');
        const themeModalCloseBtn = document.getElementById('theme-modal-close');
        const libraryModal = document.getElementById('library-modal');
        const libraryModalContent = libraryModal.querySelector('.modal-content');
        const libraryModalCloseBtn = document.getElementById('library-modal-close');
        const libraryGrid = document.getElementById('library-grid');
        const libraryMessage = document.getElementById('library-message');
        const levelSelectModal = document.getElementById('level-select-modal');
        const levelSelectModalCloseBtn = document.getElementById('level-select-modal-close');
        const levelListContainer = document.getElementById('level-list');
        const customThemeModal = document.getElementById('custom-theme-modal');
        const customThemeModalCloseBtn = document.getElementById('custom-theme-modal-close');
        const customThemeGrid = document.getElementById('custom-theme-grid');
        const applyCustomThemeBtn = document.getElementById('apply-custom-theme-btn');
        const resetCustomThemeBtn = document.getElementById('reset-custom-theme-btn');
        const feedbackOverlay = document.getElementById('feedback-overlay');
        const flagFeedbackBtn = document.getElementById('flag-feedback-btn');
        const feedbackArea = document.getElementById('feedback-area');
        const feedbackTextEl = document.getElementById('feedback-text');
        const feedbackSubmitBtn = document.getElementById('feedback-submit-btn');
        const feedbackConfirmation = document.getElementById('feedback-confirmation');
        const fontSelectionArea = document.getElementById('font-selection-area');
        const fontSelectDropdown = document.getElementById('font-select-dropdown');
        const fontUnlockMessage = document.getElementById('font-unlock-message');
        const attemptsCounter = document.getElementById('attempts-counter'); // New element


        // --- Helper Functions ---
        function shuffleArray(array) { /* ... shuffle ... */
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
         }
        function getIndent(level) { return '    '.repeat(level); } // Use 4 spaces for indent
        function getCssVariableValue(varName) {
             const cssVarName = varName.startsWith('--') ? varName : `--${varName}`;
             const value = getComputedStyle(document.documentElement).getPropertyValue(cssVarName).trim();
             return value;
        }
        // MODIFIED: updateStarDisplay no longer saves to sessionStorage
        function updateStarDisplay(animate = false, animationType = 'none') {
            starNumberSpan.textContent = starCount;
            // sessionStorage.setItem('chimCodeStars', starCount.toString()); // REMOVED - save explicitly elsewhere
            starDisplayWrapper.classList.remove('star-jump-animation', 'star-flash-red-animation');
            if (animate) {
                setTimeout(() => {
                    if (animationType === 'gain') {
                        starDisplayWrapper.classList.add('star-jump-animation');
                        setTimeout(() => starDisplayWrapper.classList.remove('star-jump-animation'), 350);
                    } else if (animationType === 'loss') {
                        starDisplayWrapper.classList.add('star-flash-red-animation');
                        setTimeout(() => starDisplayWrapper.classList.remove('star-flash-red-animation'), 400);
                    }
                }, animationType !== 'none' ? 50 : 0);
            }
            // Update buttons dependent on star count
             updateStoreButtons();
             updateLibraryButtons();
             updateHintButtonState();
        }

        // NEW: Function to explicitly save stable star count
        function saveStarCount() {
            sessionStorage.setItem('chimCodeStars', starCount.toString());
            console.log(`Saved star count: ${starCount}`);
        }

        function scrollCodeDisplay() { codeDisplayArea.scrollTop = codeDisplayArea.scrollHeight; }
        function escapeHtml(unsafe) { /* ... escapeHtml ... */
             if (typeof unsafe !== 'string') { return unsafe; }
             return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        // --- Modal Functions ---
        // (showModal, hideModal, event listeners remain mostly the same)
        function showModal(modalElement) { modalElement.classList.add('visible'); }
        function hideModal(modalElement) { modalElement.classList.remove('visible'); }
        modalCloseBtn.addEventListener('click', () => hideModal(infoModal));
        infoModal.addEventListener('click', (event) => { if (event.target === infoModal) hideModal(infoModal); });
        themeModalCloseBtn.addEventListener('click', () => hideModal(themeStoreModal));
        themeStoreModal.addEventListener('click', (event) => { if (event.target === themeStoreModal) hideModal(themeStoreModal); });
        starDisplayWrapper.addEventListener('click', () => {
            updateStoreButtons();
            document.getElementById('store-message').textContent = '';
            showModal(themeStoreModal);
        });
        libraryModalCloseBtn.addEventListener('click', () => hideModal(libraryModal));
        libraryModal.addEventListener('click', (event) => { if (event.target === libraryModal) hideModal(libraryModal); });
        libraryBtn.addEventListener('click', () => {
             populateLibraryGrid();
             updateLibraryButtons();
             libraryMessage.textContent = '';
             showModal(libraryModal);
        });
        levelSelectModalCloseBtn.addEventListener('click', () => hideModal(levelSelectModal));
        levelSelectModal.addEventListener('click', (event) => { if (event.target === levelSelectModal) hideModal(levelSelectModal); });
        levelDisplayBtn.addEventListener('click', () => {
             populateLevelList();
             showModal(levelSelectModal);
        });
        customThemeModalCloseBtn.addEventListener('click', () => {
            applyFont(sessionStorage.getItem('chimCodeFont') || defaultFontFamily);
            hideModal(customThemeModal);
        });
        customThemeModal.addEventListener('click', (event) => {
            if (event.target === customThemeModal) {
                applyFont(sessionStorage.getItem('chimCodeFont') || defaultFontFamily);
                hideModal(customThemeModal);
            }
        });
        function showInfoModal(reason, incorrectData) { /* ... showInfoModal ... */
            modalReason.textContent = reason || "No specific reason provided.";
            incorrectChoiceData = incorrectData;
            feedbackArea.style.display = 'none';
            flagFeedbackBtn.textContent = 'Disagree? Flag for Review';
            flagFeedbackBtn.disabled = false;
            feedbackTextEl.value = '';
            feedbackConfirmation.textContent = '';
            showModal(infoModal);
        }
        function showFeedbackOverlay(type) { /* ... showFeedbackOverlay ... */
            if (feedbackTimeout) { clearTimeout(feedbackTimeout); }
            feedbackOverlay.classList.remove('overlay-green', 'overlay-red', 'visible');
            void feedbackOverlay.offsetWidth; // Reflow
            feedbackOverlay.classList.add(type === 'correct' ? 'overlay-green' : 'overlay-red');
            feedbackOverlay.classList.add('visible');
            feedbackTimeout = setTimeout(() => {
                feedbackOverlay.classList.remove('visible');
                 setTimeout(() => {
                    feedbackOverlay.classList.remove('overlay-green', 'overlay-red');
                }, 200);
            }, 400);
        }

         // --- Custom Theme & Font Functions ---
         // (No changes needed in these functions)
         function populateCustomThemeModal() {
              customThemeGrid.innerHTML = '';
              const currentColors = getCurrentThemeValues();
              for (const [cssVar, label] of Object.entries(customThemeProperties)) {
                  const item = document.createElement('div');
                  item.classList.add('color-picker-item');
                  const labelEl = document.createElement('label');
                  labelEl.htmlFor = `color-picker-${cssVar}`;
                  labelEl.textContent = label;
                  const inputEl = document.createElement('input');
                  inputEl.type = 'color';
                  inputEl.id = `color-picker-${cssVar}`;
                  inputEl.dataset.cssVar = cssVar;
                  inputEl.value = currentColors[cssVar]?.startsWith('#') ? currentColors[cssVar] : '#ffffff';
                  inputEl.addEventListener('input', (event) => {
                      document.documentElement.style.setProperty(cssVar, event.target.value);
                  });
                  item.appendChild(labelEl);
                  item.appendChild(inputEl);
                  customThemeGrid.appendChild(item);
              }
              fontSelectDropdown.innerHTML = '';
              const currentSavedFont = sessionStorage.getItem('chimCodeFont') || defaultFontFamily;
              for (const [fontName, fontFamily] of Object.entries(availableFonts)) {
                  const option = document.createElement('option');
                  option.value = fontFamily;
                  option.textContent = fontName;
                  option.style.fontFamily = fontFamily;
                  if (fontFamily === currentSavedFont) {
                      option.selected = true;
                  }
                  fontSelectDropdown.appendChild(option);
              }
              const fontChangeUnlocked = unlockedFeatures['change-font'] === true;
              fontSelectDropdown.disabled = !fontChangeUnlocked;
              fontUnlockMessage.style.display = fontChangeUnlocked ? 'none' : 'block';
              showModal(customThemeModal);
         }
         function getCurrentThemeValues() {
              const currentThemeId = sessionStorage.getItem('chimCodeTheme') || 'default';
              let savedCustomColors = {};
              try {
                 savedCustomColors = JSON.parse(sessionStorage.getItem('chimCodeCustomColors') || '{}');
              } catch (e) {
                  console.error("Error parsing saved custom colors:", e);
                  sessionStorage.removeItem('chimCodeCustomColors');
              }
              if (currentThemeId === 'custom-theme' && Object.keys(savedCustomColors).length > 0) {
                  return savedCustomColors;
              }
              const computedValues = {};
              for (const cssVar in customThemeProperties) {
                  computedValues[cssVar] = getCssVariableValue(cssVar);
              }
              return computedValues;
         }
         function applyCustomColors(colorsObject) {
              for (const [cssVar, colorValue] of Object.entries(colorsObject)) {
                  if (colorValue) {
                      document.documentElement.style.setProperty(cssVar, colorValue);
                  }
              }
              currentCustomColors = colorsObject;
              sessionStorage.setItem('chimCodeCustomColors', JSON.stringify(colorsObject));
              sessionStorage.setItem('chimCodeTheme', 'custom-theme');
              updateStoreButtons();
         }
         function applyFont(fontFamily) {
             document.documentElement.style.setProperty('--main-font-family', fontFamily);
             currentFontFamily = fontFamily;
             if(fontSelectDropdown) {
                 fontSelectDropdown.style.fontFamily = fontFamily;
             }
         }
         function saveFont(fontFamily) {
             sessionStorage.setItem('chimCodeFont', fontFamily);
             applyFont(fontFamily);
         }
         fontSelectDropdown.addEventListener('change', (event) => {
             if (!event.target.disabled) {
                 applyFont(event.target.value);
             }
         });
         applyCustomThemeBtn.addEventListener('click', () => {
              const newColors = {};
              customThemeGrid.querySelectorAll('input[type="color"]').forEach(input => {
                  newColors[input.dataset.cssVar] = input.value;
              });
              applyCustomColors(newColors);
              if (!fontSelectDropdown.disabled) {
                 saveFont(fontSelectDropdown.value);
              }
              document.body.classList.remove('theme-matrix', 'theme-solarized');
              hideModal(customThemeModal);
         });
         resetCustomThemeBtn.addEventListener('click', () => {
              applyCustomColors(defaultThemeValues);
              customThemeGrid.querySelectorAll('input[type="color"]').forEach(input => {
                  const cssVar = input.dataset.cssVar;
                  input.value = defaultThemeValues[cssVar] || '#ffffff';
              });
              saveFont(defaultFontFamily);
              fontSelectDropdown.value = defaultFontFamily;
              applyFont(defaultFontFamily);
         });

        // --- Theme Functions ---
        // (No changes needed in applyTheme, applyAccentColor)
         function applyTheme(themeId) {
            document.body.classList.remove('theme-matrix', 'theme-solarized');
            if (themeId !== 'custom-theme') {
                for (const cssVar in customThemeProperties) {
                    document.documentElement.style.removeProperty(cssVar);
                }
                 sessionStorage.removeItem('chimCodeCustomColors');
                 currentCustomColors = {};
            }
            const themeClass = themeId.startsWith('theme-') ? themeId : '';
            if (themeClass) {
                 document.body.classList.add(themeClass);
            }
            sessionStorage.setItem('chimCodeTheme', themeId || 'default');
             if (themeId === 'color-orange') {
                 applyAccentColor('--accent-color', '#f97316');
                 applyAccentColor('--accent-hover-color', '#fb923c');
             } else if (themeId === 'custom-theme') {
                 let savedCustom = {};
                 try {
                     savedCustom = JSON.parse(sessionStorage.getItem('chimCodeCustomColors') || '{}');
                 } catch(e) { console.error("Error parsing custom colors on applyTheme:", e); }
                 if (Object.keys(savedCustom).length > 0) {
                     for (const [cssVar, colorValue] of Object.entries(savedCustom)) {
                         if (colorValue) document.documentElement.style.setProperty(cssVar, colorValue);
                     }
                     currentCustomColors = savedCustom;
                 } else {
                     console.warn("Custom theme selected but no colors saved. Reverting to default colors.");
                     for (const [cssVar, colorValue] of Object.entries(defaultThemeValues)) {
                         if (colorValue) document.documentElement.style.setProperty(cssVar, colorValue);
                     }
                     currentCustomColors = { ...defaultThemeValues };
                     sessionStorage.setItem('chimCodeCustomColors', JSON.stringify(currentCustomColors));
                 }
             }
             updateStoreButtons();
        }
        function applyAccentColor(colorVar, colorValue) {
             document.documentElement.style.setProperty(colorVar, colorValue);
        }


        // --- MODIFIED: loadSessionData ---
        function loadSessionData() {
            defaultThemeValues = {};
            for (const cssVar in customThemeProperties) {
                defaultThemeValues[cssVar] = getCssVariableValue(cssVar);
            }

            // --- Load Game State ---
            let stateNeedsRevert = false;
            let savedInitialStars = 0;
            let savedLevelIndex = 0;

             try {
                 // Load permanent unlocks/settings
                 unlockedThemes = JSON.parse(sessionStorage.getItem('chimCodeUnlockedThemes') || '{}');
                 unlockedLanguages = JSON.parse(sessionStorage.getItem('chimCodeUnlockedLanguages') || '{}');
                 unlockedFeatures = JSON.parse(sessionStorage.getItem('chimCodeUnlockedFeatures') || '{}');
                 currentCustomColors = JSON.parse(sessionStorage.getItem('chimCodeCustomColors') || '{}');
                 levelAttempts = JSON.parse(sessionStorage.getItem('chimCodeLevelAttempts') || '{}');
                 levelCompletedThisSession = JSON.parse(sessionStorage.getItem('chimCodeLevelCompleted') || '{}');

                 // Load potentially temporary state (related to refresh mid-level)
                 levelInProgress = JSON.parse(sessionStorage.getItem('chimCodeLevelInProgress') || 'false');
                 savedInitialStars = parseInt(sessionStorage.getItem('chimCodeInitialStars') || '0', 10);
                 savedLevelIndex = parseInt(sessionStorage.getItem('chimCodeSavedLevelIndex') || '0', 10);

                 // Load last saved star count
                 starCount = parseInt(sessionStorage.getItem('chimCodeStars') || '0', 10);
                 if (isNaN(starCount)) starCount = 0;

                 // Check if refresh happened mid-level
                 if (levelInProgress) {
                     console.warn("Level was in progress on refresh. Reverting star count.");
                     starCount = savedInitialStars; // Revert to stars before the interrupted attempt
                     currentLevelIndex = savedLevelIndex; // Ensure we restart the correct level
                     levelInProgress = false; // Reset flag as we are handling the refresh now
                      sessionStorage.setItem('chimCodeLevelInProgress', 'false'); // Update storage
                     stateNeedsRevert = true; // Flag that we reverted
                 }

             } catch (e) {
                 console.error("Error parsing saved state:", e);
                 // Reset everything on error
                 unlockedThemes = {}; unlockedLanguages = {}; unlockedFeatures = {}; currentCustomColors = {};
                 levelAttempts = {}; levelCompletedThisSession = {};
                 starCount = 0; initialStarsForLevelAttempt = 0; levelInProgress = false; currentLevelIndex = 0;
                 sessionStorage.clear(); // Clear potentially corrupted storage
             }
             // --- End Load Game State ---


             // Apply theme and font
             const savedThemeId = sessionStorage.getItem('chimCodeTheme') || 'default';
             applyTheme(savedThemeId);
             const savedFont = sessionStorage.getItem('chimCodeFont') || defaultFontFamily;
             applyFont(savedFont);

             // Return the index to start the game at (usually 0 unless refresh happened)
             return stateNeedsRevert ? savedLevelIndex : 0;
        }

        // --- Game Logic Functions ---
        function displayStep() { /* ... displayStep (no changes needed here) ... */
             if (!challengesData[currentLevelIndex]) {
                 console.error("Invalid level index:", currentLevelIndex);
                 interactionArea.innerHTML = `<p class="md:col-span-3 text-center text-red-500">Error: Level data not found.</p>`;
                 hintText.textContent = '';
                 revealHintBtn.classList.add('hidden');
                 return;
             }
             const currentChallenge = challengesData[currentLevelIndex];
             if (currentStep >= currentChallenge.sequence.length) {
                 endGame();
                 return;
             }
             optionsLocked = false;
             hintRevealed = false; // Reset hint revealed status for the new step
             const stepData = currentChallenge.sequence[currentStep];
             const hintContent = stepData.explanation ? `Hint: ${stepData.explanation}` : '';
             hintText.textContent = hintContent;
             if (hintContent) {
                 hintText.classList.add('blurred');
                 revealHintBtn.classList.remove('hidden');
                 updateHintButtonState();
             } else {
                 hintText.classList.remove('blurred');
                 revealHintBtn.classList.add('hidden');
             }
             const correctOption = { text: stepData.correct, isCorrect: true };
             const distractors = stepData.distractors || [];
             const distractorOptions = distractors.map(d => ({ ...d, isCorrect: false }));
             let allOptions = [correctOption, ...distractorOptions];
              while (allOptions.length < 3 && allOptions.length > 0) {
                  if (distractorOptions.length > 0) {
                      allOptions.push({...distractorOptions[0], isCorrect: false});
                  } else {
                      allOptions.push({text: "/* Placeholder 1 */", isCorrect: false, reason: "This is a placeholder."});
                      if (allOptions.length < 3) {
                          allOptions.push({text: "/* Placeholder 2 */", isCorrect: false, reason: "This is another placeholder."});
                      }
                  }
              }
             allOptions = shuffleArray(allOptions);
             interactionArea.innerHTML = '';
             allOptions.forEach((optionData) => {
                 const wrapper = document.createElement('div');
                 wrapper.classList.add('option-btn-wrapper');
                 const button = document.createElement('button');
                 button.classList.add('option-btn');
                 button.textContent = getIndent(stepData.indent) + optionData.text;
                 button.dataset.correct = optionData.isCorrect;
                 if (!optionData.isCorrect && optionData.reason) {
                     button.dataset.reason = optionData.reason;
                     button.dataset.incorrectText = optionData.text;
                 }
                 button.addEventListener('click', handleOptionClick);
                 wrapper.appendChild(button);
                 interactionArea.appendChild(wrapper);
             });
        }

        // --- handleOptionClick (MODIFIED) ---
        function handleOptionClick(event) {
            if (optionsLocked) return;
            optionsLocked = true;

            const button = event.target.closest('.option-btn');
            if (!button) return;

            const wrapper = button.parentElement;
            const isCorrect = button.dataset.correct === 'true';
            const reason = button.dataset.reason;
            const incorrectText = button.dataset.incorrectText;
            const currentChallenge = challengesData[currentLevelIndex];
            const stepData = currentChallenge.sequence[currentStep];

            interactionArea.querySelectorAll('.info-btn').forEach(btn => btn.remove());
            interactionArea.querySelectorAll('.option-btn').forEach(btn => btn.disabled = true);

            previousStarCountForAnimation = starCount; // Track for animation logic

            if (isCorrect) {
                // Only award stars if the level hasn't been completed in this session yet
                 if (!levelCompletedThisSession[currentLevelIndex]) {
                     starCount += 3;
                 } else {
                     console.log("Level already completed this session, no stars awarded.");
                 }
                showFeedbackOverlay('correct');
                 // Update display without saving stars yet
                updateStarDisplay(starCount > previousStarCountForAnimation, 'gain');

                // --- MODIFIED: Add explanation as comment WITHOUT "Hint: " ---
                let codeToAdd = '';
                if (stepData.explanation) {
                    // Add the explanation as a C-style comment
                    codeToAdd += getIndent(stepData.indent) + `<span class="explanation-comment">${escapeHtml("// " + stepData.explanation)}</span>\n`;
                }
                // Add the actual correct code line after the potential comment
                const escapedCorrectCode = escapeHtml(stepData.correct);
                codeToAdd += getIndent(stepData.indent) + escapedCorrectCode + '\n';
                constructedCode += codeToAdd;
                // --- END MODIFICATION ---

                codeDisplayArea.innerHTML = constructedCode; // Use innerHTML to render the span
                scrollCodeDisplay();

                setTimeout(() => {
                    currentStep++;
                    displayStep(); // Moves to next step or calls endGame
                }, 300);

            } else { // Incorrect choice
                // Only deduct stars if the level hasn't been completed in this session yet
                 if (!levelCompletedThisSession[currentLevelIndex]) {
                     starCount = Math.max(0, starCount - 2);
                 } else {
                     console.log("Level already completed this session, no stars deducted.");
                 }
                showFeedbackOverlay('incorrect');
                const didLoseStar = starCount < previousStarCountForAnimation;
                 // Update display without saving stars yet
                updateStarDisplay(didLoseStar, 'loss');

                if (reason) {
                    const infoBtn = document.createElement('button');
                    infoBtn.classList.add('info-btn');
                    infoBtn.textContent = 'ⓘ';
                    infoBtn.title = "Why is this incorrect?";
                    infoBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showInfoModal(reason, {
                            level: currentLevelIndex + 1,
                            step: currentStep + 1,
                            correct: stepData.correct,
                            incorrect: incorrectText
                        });
                    });
                    wrapper.appendChild(infoBtn);
                }

                 setTimeout(() => {
                     interactionArea.querySelectorAll('.option-btn').forEach(btn => {
                         btn.disabled = false;
                     });
                     optionsLocked = false;
                 }, 500);
            }
        }

        // --- Hint Button Logic ---
        // MODIFIED: Star deduction only if level not completed
        function updateHintButtonState() {
            const hintCost = 1;
            // Can reveal if have enough stars AND haven't revealed this step yet
            const canReveal = starCount >= hintCost && !hintRevealed;
             revealHintBtn.disabled = !canReveal;

            revealHintBtn.innerHTML = `Hint: <span class="star-icon">★</span> ${hintCost}`;
            if (starCount < hintCost && !hintRevealed) {
                 revealHintBtn.innerHTML = `Need <span class="star-icon">★</span> ${hintCost}`;
            }
             // If hint was revealed this step, keep it disabled
             if(hintRevealed) {
                revealHintBtn.disabled = true;
                 revealHintBtn.innerHTML = `Hint: <span class="star-icon">★</span> ${hintCost}`;
             }
        }

        revealHintBtn.addEventListener('click', () => {
            const hintCost = 1;
            if (starCount >= hintCost && !hintRevealed) {
                 // Only deduct stars if the level hasn't been completed in this session yet
                 let didLoseStar = false;
                 if (!levelCompletedThisSession[currentLevelIndex]) {
                    previousStarCountForAnimation = starCount;
                     starCount -= hintCost;
                     didLoseStar = true;
                 } else {
                     console.log("Level already completed this session, hint revealed for free.");
                 }

                 // Update display without saving stars yet
                 updateStarDisplay(didLoseStar, 'loss');
                hintText.classList.remove('blurred');
                hintRevealed = true; // Mark as revealed *for this step*
                updateHintButtonState(); // Update button state (will disable it)
            }
        });
        // --- End Hint Button Logic ---

        // --- MODIFIED: endGame ---
        function endGame() {
             const isLastLevel = currentLevelIndex >= challengesData.length - 1;
             hintText.textContent = '';
             revealHintBtn.classList.add('hidden');
             hintContainer.style.display = 'none';

             // Mark level as completed for this session to prevent re-earning stars
             levelCompletedThisSession[currentLevelIndex] = true;
             sessionStorage.setItem('chimCodeLevelCompleted', JSON.stringify(levelCompletedThisSession));

             // Mark level as no longer in progress
             levelInProgress = false;
             sessionStorage.setItem('chimCodeLevelInProgress', 'false');
             sessionStorage.removeItem('chimCodeInitialStars'); // Clean up
             sessionStorage.removeItem('chimCodeSavedLevelIndex'); // Clean up

             // Save the final star count now that the level is complete
             saveStarCount();

             // Display end game options
             interactionArea.innerHTML = `
                 <div class="md:col-span-3 text-center py-4">
                     <p class="font-bold text-lg mb-4" style="color: var(--success-color);">
                         Level ${currentLevelIndex + 1} Complete! Final Score: <span class="star-icon">★</span> ${starCount}
                     </p>
                     <button id="restart-btn" class="endgame-btn">Restart Level</button>
                     ${!isLastLevel ? '<button id="next-btn" class="endgame-btn">Next Level</button>' : '<p class="mt-2" style="color: var(--star-color);">All levels complete!</p>'}
                     <button id="level-select-endgame-btn" class="endgame-btn">Select Level</button>
                 </div>
             `;

             // --- MODIFIED: Restart Button Logic ---
             document.getElementById('restart-btn')?.addEventListener('click', () => {
                 // Calculate net change from the attempt that just finished
                 let starChange = starCount - initialStarsForLevelAttempt;
                 console.log(`Restarting Level ${currentLevelIndex + 1}. Initial stars for attempt: ${initialStarsForLevelAttempt}, Final stars: ${starCount}, Change: ${starChange}`);

                 // Revert the star count
                 starCount = initialStarsForLevelAttempt; // Go back to the count before this attempt
                 console.log(`Reverted star count to: ${starCount}`);

                 // Update display and save the reverted count immediately
                 updateStarDisplay();
                 saveStarCount();

                 // Re-initialize the game for the same level (will increment attempts again)
                 initializeGame(currentLevelIndex);
             });

             // --- Next Level Button Logic ---
             if (!isLastLevel) {
                 document.getElementById('next-btn')?.addEventListener('click', () => {
                     // Star count is already saved correctly by endGame
                     initializeGame(currentLevelIndex + 1);
                 });
             }

             // --- Level Select Button Logic ---
             document.getElementById('level-select-endgame-btn')?.addEventListener('click', () => {
                // Star count is already saved correctly by endGame
                 populateLevelList();
                 showModal(levelSelectModal);
             });
        }

        // --- Feedback Submission ---
        flagFeedbackBtn.addEventListener('click', () => { /* ... flagFeedbackBtn click ... */
            feedbackArea.style.display = 'block';
            flagFeedbackBtn.textContent = 'Submit Feedback';
            flagFeedbackBtn.disabled = true;
            feedbackConfirmation.textContent = '';
        });
        feedbackSubmitBtn.addEventListener('click', () => { /* ... feedbackSubmitBtn click ... */
            const feedbackContent = feedbackTextEl.value.trim();
            console.log("--- User Feedback Received ---");
            console.log("Context:", incorrectChoiceData || "N/A");
            console.log("Feedback:", feedbackContent || "(No text entered)");
            console.warn("Note: This feedback is logged to the browser console only...");
            feedbackConfirmation.textContent = 'Feedback logged to console. Thank you!';
            feedbackTextEl.value = '';
             setTimeout(() => {
                 feedbackArea.style.display = 'none';
                 feedbackConfirmation.textContent = '';
                 flagFeedbackBtn.disabled = false;
                 flagFeedbackBtn.textContent = 'Disagree? Flag for Review';
             }, 3000);
        });


        // --- Store/Library Button State Management ---
        // (MODIFIED for centered language buttons - CSS handles this now)
        function manageItemState(itemElement, isUnlocked, isApplied, isCurrent = false) {
            const btnContainer = itemElement.querySelector('.purchase-buttons-container');
            const statusContainer = itemElement.querySelector('.status-text-container');

            if (!btnContainer || !statusContainer) return;

            const itemIdentifier = itemElement.dataset.itemIdentifier;
            const isLanguageItem = itemElement.closest('#library-modal');

            // Reset visibility
            btnContainer.style.display = 'none';
            statusContainer.style.display = 'none';
            statusContainer.innerHTML = ''; // Clear old status text

            // Handle special items first
            if (itemIdentifier === 'buy-stars') {
                btnContainer.style.display = 'flex';
                 btnContainer.style.justifyContent = 'flex-end'; // Ensure right-alignment
                const buyBtn = btnContainer.querySelector('button[data-action="buy-stars"]');
                if (buyBtn) buyBtn.style.display = 'inline-flex';
                return;
            }

            // Handle regular items (Themes, Languages, Features)
            if (isApplied) { // Applied (Themes) or Current (Language)
                statusContainer.style.display = 'flex';
                 // CSS now handles alignment (center for lang, right for theme)
                const statusText = document.createElement('span');
                statusText.classList.add('status-text');
                statusText.textContent = isCurrent ? 'Current' : 'Applied';
                statusContainer.appendChild(statusText);
            } else if (isUnlocked) { // Unlocked but not applied/current
                btnContainer.style.display = 'flex';
                btnContainer.innerHTML = ''; // Clear purchase buttons
                // CSS now handles alignment (center for lang, right for theme)

                const actionBtn = document.createElement('button');
                actionBtn.classList.add('appstore-purchase-btn');

                if (isLanguageItem) { // Language item
                    actionBtn.classList.add('select-language-btn');
                    actionBtn.textContent = 'Select';
                    actionBtn.onclick = () => handleLanguageSelect(itemIdentifier.replace('lang-', ''));
                } else if (itemIdentifier === 'change-font') { // Font feature item
                     btnContainer.style.justifyContent = 'flex-end'; // Override to right-align single button
                    actionBtn.classList.add('customize-font-btn');
                    actionBtn.textContent = 'Customize';
                    actionBtn.onclick = () => {
                        hideModal(themeStoreModal); // Close store
                        populateCustomThemeModal(); // Open customizer
                    };
                } else { // Theme item
                    actionBtn.classList.add('apply-theme-btn');
                    actionBtn.textContent = 'Apply';
                    if (itemIdentifier === 'custom-theme') {
                        actionBtn.onclick = () => populateCustomThemeModal(); // Open customizer
                    } else {
                        actionBtn.onclick = () => applyTheme(itemIdentifier); // Apply directly
                    }
                }
                btnContainer.appendChild(actionBtn);
                actionBtn.style.display = 'inline-flex';
            } else { // Locked item
                btnContainer.style.display = 'flex';
                btnContainer.innerHTML = ''; // Clear potential old Apply/Select/Customize button
                 // CSS now handles alignment (center for lang, right for theme)

                let starPriceAttr = '0';
                let moneyPriceAttr = null;
                let isFeature = false;

                // --- Get prices reliably ---
                if (isLanguageItem) { // Language
                    const langId = itemIdentifier.replace('lang-', '');
                    const langData = availableLanguages.find(l => l.id === langId);
                    if (langData) {
                        starPriceAttr = langData.priceStars.toString();
                        moneyPriceAttr = langData.priceMoney; // String or null
                    }
                } else { // Theme store item (Theme or Feature)
                    starPriceAttr = itemElement.dataset.starPrice || '0'; // Read from item div
                    moneyPriceAttr = itemElement.dataset.moneyPrice || null; // Read from item div
                    isFeature = itemIdentifier === 'change-font';
                }
                // --- End Get prices ---

                // Re-create Stars button
                const newStarsBtn = document.createElement('button');
                newStarsBtn.dataset.type = 'stars';
                newStarsBtn.dataset.price = starPriceAttr;
                newStarsBtn.innerHTML = `<span class="star-icon">★</span>${starPriceAttr}`;
                newStarsBtn.classList.add('appstore-purchase-btn');
                btnContainer.appendChild(newStarsBtn);
                newStarsBtn.style.display = 'inline-flex';
                newStarsBtn.disabled = starCount < parseInt(starPriceAttr);

                // Re-create Money button only if applicable
                if (moneyPriceAttr !== null) {
                    const newMoneyBtn = document.createElement('button');
                    newMoneyBtn.dataset.type = 'money';
                    newMoneyBtn.dataset.moneyPrice = moneyPriceAttr; // Store raw value
                    newMoneyBtn.textContent = `$${moneyPriceAttr}`; // Display with $
                    newMoneyBtn.classList.add('appstore-purchase-btn');
                    btnContainer.appendChild(newMoneyBtn);
                    newMoneyBtn.style.display = 'inline-flex';
                    newMoneyBtn.disabled = false; // Assuming real money purchase always enabled
                }

                 // Ensure single button items are right aligned in themes
                if (!isLanguageItem && (isFeature || moneyPriceAttr === null)) {
                    btnContainer.style.justifyContent = 'flex-end';
                }
            }
        }


        // --- Theme Store Logic ---
        // (No major changes needed in updateStoreButtons or the event listener logic)
        function updateStoreButtons() {
             const currentThemeId = sessionStorage.getItem('chimCodeTheme') || 'default';
             themeStoreModal.querySelectorAll('.theme-item').forEach(item => {
                 const itemIdentifier = item.dataset.itemIdentifier;
                 if (!itemIdentifier) return;

                  if (itemIdentifier === 'buy-stars') {
                      const btnContainer = item.querySelector('.purchase-buttons-container');
                      const buyBtn = btnContainer?.querySelector('button[data-action="buy-stars"]');
                      if(btnContainer) btnContainer.style.justifyContent = 'flex-end'; // Ensure right-align
                      if(buyBtn) buyBtn.disabled = false;
                      return;
                  }

                 const isApplied = currentThemeId === itemIdentifier;
                 const isUnlocked = itemIdentifier === 'default' ||
                                    unlockedThemes[itemIdentifier] === true ||
                                    unlockedFeatures[itemIdentifier] === true;

                 manageItemState(item, isUnlocked, isApplied);
             });
        }
        themeStoreContent.addEventListener('click', (event) => {
            const button = event.target.closest('.appstore-purchase-btn');
            if (!button || button.disabled ||
                button.classList.contains('apply-theme-btn') ||
                button.classList.contains('select-language-btn') ||
                button.classList.contains('customize-font-btn') ||
                button.closest('[data-item-identifier="default"]')) {
                return;
            }
            const itemElement = button.closest('.theme-item');
            const itemIdentifier = itemElement.dataset.itemIdentifier;
            const storeMessage = document.getElementById('store-message');
            storeMessage.textContent = '';
            if (button.dataset.action === 'buy-stars') {
                const amount = parseInt(button.dataset.amount);
                const moneyPrice = button.dataset.moneyPrice;
                console.log(`Simulating purchase of ${amount} stars for $${moneyPrice}`);
                starCount += amount;
                 updateStarDisplay(true, 'gain'); // Update display
                 saveStarCount(); // Save explicitly after purchase
                storeMessage.textContent = `${amount} stars added!`;
                storeMessage.style.color = 'var(--hint-color)';
                setTimeout(() => { storeMessage.textContent = ''; }, 4000);
                return;
            }
            const itemName = itemElement.querySelector('.theme-name').textContent;
            const purchaseType = button.dataset.type;
            const starPrice = parseInt(button.dataset.price);
            const moneyPrice = button.dataset.moneyPrice;
            let purchased = false;
            let unlockTarget = null;
            let storageKey = null;
             if (itemIdentifier === 'change-font') {
                 unlockTarget = unlockedFeatures;
                 storageKey = 'chimCodeUnlockedFeatures';
             } else {
                 unlockTarget = unlockedThemes;
                 storageKey = 'chimCodeUnlockedThemes';
             }
             if (purchaseType === 'stars') {
                 if (starCount >= starPrice) {
                     previousStarCountForAnimation = starCount;
                     starCount -= starPrice;
                     unlockTarget[itemIdentifier] = true;
                     sessionStorage.setItem(storageKey, JSON.stringify(unlockTarget));
                     updateStarDisplay(true, 'loss'); // Update display
                     saveStarCount(); // Save explicitly after purchase
                     storeMessage.textContent = `${itemName} unlocked with stars!`;
                     storeMessage.style.color = 'var(--hint-color)';
                     purchased = true;
                 } else {
                     storeMessage.textContent = `Insufficient stars! You need ${starPrice}.`;
                     storeMessage.style.color = 'var(--error-color)';
                 }
             } else if (purchaseType === 'money') {
                 console.log(`Simulating purchase of ${itemName} for $${moneyPrice}`);
                 unlockTarget[itemIdentifier] = true;
                 sessionStorage.setItem(storageKey, JSON.stringify(unlockTarget));
                 storeMessage.textContent = `${itemName} purchased! (Simulated)`;
                 storeMessage.style.color = 'var(--hint-color)';
                 purchased = true;
             }
             if (purchased) {
                  if (itemIdentifier === 'custom-theme' || itemIdentifier === 'change-font') {
                      manageItemState(itemElement, true, false);
                  } else {
                      applyTheme(itemIdentifier);
                      manageItemState(itemElement, true, true);
                  }
                  updateStoreButtons(); // Update all buttons
             }
             setTimeout(() => { storeMessage.textContent = ''; }, 4000);
        });


        // --- Library Logic ---
        // (MODIFIED - CSS now handles alignment)
        function populateLibraryGrid() {
            libraryGrid.innerHTML = ''; // Clear previous content
            const currentLangId = 'c'; // Hardcoded

            availableLanguages.forEach(lang => {
                const langIdentifier = `lang-${lang.id}`; // Unique ID for storage
                const card = document.createElement('div');
                card.classList.add('language-card');
                card.dataset.itemIdentifier = langIdentifier;
                if (lang.id === currentLangId) {
                    card.classList.add('current-language');
                }
                const name = document.createElement('div');
                name.classList.add('language-name');
                name.textContent = lang.name;
                card.appendChild(name);
                const btnContainer = document.createElement('div');
                btnContainer.classList.add('purchase-buttons-container');
                card.appendChild(btnContainer);
                 const statusContainer = document.createElement('div');
                 statusContainer.classList.add('status-text-container');
                 statusContainer.style.display = 'none'; // Hide initially
                 card.appendChild(statusContainer);
                libraryGrid.appendChild(card);
            });
             updateLibraryButtons(); // Set initial state for all cards
        }
        function updateLibraryButtons() {
             const currentLangId = 'c'; // Hardcoded
             libraryGrid.querySelectorAll('.language-card').forEach(card => {
                 const langIdentifier = card.dataset.itemIdentifier;
                 const langId = langIdentifier.replace('lang-', '');
                 const isCurrent = langId === currentLangId;
                 const isUnlocked = unlockedLanguages[langIdentifier] === true || isCurrent; // C is always unlocked
                 manageItemState(card, isUnlocked, isCurrent, isCurrent); // Pass isCurrent flag
             });
        }
        libraryModalContent.addEventListener('click', (event) => {
             const button = event.target.closest('.appstore-purchase-btn');
             if (!button || button.disabled || button.classList.contains('select-language-btn')) return;
             const cardElement = button.closest('.language-card');
             const langIdentifier = cardElement.dataset.itemIdentifier;
             const langName = cardElement.querySelector('.language-name').textContent;
             const purchaseType = button.dataset.type;
             const starPrice = parseInt(button.dataset.price);
             const moneyPrice = button.dataset.moneyPrice;
             const libraryMessage = document.getElementById('library-message');
             libraryMessage.textContent = '';
             let purchased = false;
             if (purchaseType === 'stars') {
                 if (starCount >= starPrice) {
                     previousStarCountForAnimation = starCount;
                     starCount -= starPrice;
                     unlockedLanguages[langIdentifier] = true;
                     sessionStorage.setItem('chimCodeUnlockedLanguages', JSON.stringify(unlockedLanguages));
                     updateStarDisplay(true, 'loss'); // Update display
                     saveStarCount(); // Save explicitly
                     libraryMessage.textContent = `${langName} unlocked with stars!`;
                     libraryMessage.style.color = 'var(--hint-color)';
                     purchased = true;
                 } else {
                     libraryMessage.textContent = `Insufficient stars! You need ${starPrice}.`;
                     libraryMessage.style.color = 'var(--error-color)';
                 }
             } else if (purchaseType === 'money') {
                 console.log(`Simulating purchase of ${langName} for $${moneyPrice}`);
                 unlockedLanguages[langIdentifier] = true;
                 sessionStorage.setItem('chimCodeUnlockedLanguages', JSON.stringify(unlockedLanguages));
                 libraryMessage.textContent = `${langName} purchased! (Simulated)`;
                 libraryMessage.style.color = 'var(--hint-color)';
                 purchased = true;
             }
             if(purchased) {
                 manageItemState(cardElement, true, false, false);
                 updateLibraryButtons();
             }
             setTimeout(() => { libraryMessage.textContent = ''; }, 4000);
        });
        function handleLanguageSelect(langId) { // Called by select button's onclick
             console.log(`Switching to language: ${langId} (Not Implemented)`);
             libraryMessage.textContent = `Switching to ${langId.toUpperCase()} is not yet implemented.`;
             libraryMessage.style.color = 'var(--text-muted-color)';
             setTimeout(() => { libraryMessage.textContent = ''; }, 3000);
        }

        // --- Level Selection Logic ---
        // MODIFIED: Handle star reset when selecting the *same* level again
        function populateLevelList() {
            levelListContainer.innerHTML = ''; // Clear previous list
            challengesData.forEach((level, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('level-select-item');
                const button = document.createElement('button');
                button.classList.add('level-select-btn');
                button.dataset.levelIndex = index;
                const title = `Level ${index + 1}: ${level.goal.split('.')[0]}`;
                const concepts = level.concepts || 'Core concepts';
                button.innerHTML = `${title} <span>Concepts: ${escapeHtml(concepts)}</span>`;
                button.disabled = false; // Allow selecting any level

                button.addEventListener('click', () => {
                    const selectedLevelIndex = parseInt(button.dataset.levelIndex);
                    hideModal(levelSelectModal);

                    // Check if selecting the *same* level that was just completed or in progress
                    if (selectedLevelIndex === currentLevelIndex && !levelInProgress) {
                         // Revert stars from the last completed attempt of this level
                         let starChange = starCount - initialStarsForLevelAttempt;
                         console.log(`Re-selecting Level ${currentLevelIndex + 1}. Initial stars for last attempt: ${initialStarsForLevelAttempt}, Current stars: ${starCount}, Change: ${starChange}`);
                         starCount = initialStarsForLevelAttempt; // Revert
                         console.log(`Reverted star count to: ${starCount}`);
                         updateStarDisplay();
                         saveStarCount(); // Save reverted count
                    }
                    // If selecting a different level, the current starCount (from last save point) is fine

                    initializeGame(selectedLevelIndex); // Start the selected level
                });

                 if (index === currentLevelIndex) {
                     button.style.borderColor = 'var(--accent-color)'; // Highlight current level
                 }
                itemDiv.appendChild(button);
                levelListContainer.appendChild(itemDiv);
            });
             // Message for all levels complete remains the same
              if (currentLevelIndex >= challengesData.length && challengesData.length > 0) { // Check if current index is beyond last level
                 const allComplete = document.createElement('div');
                 allComplete.classList.add('level-select-item', 'text-center', 'font-bold');
                 allComplete.style.color = 'var(--success-color)';
                 allComplete.textContent = `All C levels complete!`;
                 levelListContainer.appendChild(allComplete);
             }
        }


        // --- MODIFIED: Initialization ---
        function initializeGame(levelIndex = 0) {
             // --- Star Revert Logic (for restart/reselect) is handled BEFORE calling initializeGame ---

             currentLevelIndex = levelIndex;
             if (!challengesData[currentLevelIndex]) {
                 console.error("Attempted to initialize invalid level:", levelIndex);
                 currentLevelIndex = 0; // Fallback to level 0
                 if (!challengesData[currentLevelIndex]) {
                     interactionArea.innerHTML = `<p class="md:col-span-3 text-center text-red-500">FATAL ERROR: No level data found.</p>`;
                     hintText.textContent = ''; revealHintBtn.classList.add('hidden'); return;
                 }
             }
             const currentChallenge = challengesData[currentLevelIndex];
             currentStep = 0;

             // --- Attempt & Star Tracking ---
             initialStarsForLevelAttempt = starCount; // Store star count BEFORE this attempt begins
             levelAttempts[currentLevelIndex] = (levelAttempts[currentLevelIndex] || 0) + 1; // Increment attempt count
             levelInProgress = true; // Mark level as in progress

             // Save initial state for potential refresh recovery
             sessionStorage.setItem('chimCodeLevelInProgress', 'true');
             sessionStorage.setItem('chimCodeInitialStars', initialStarsForLevelAttempt.toString());
             sessionStorage.setItem('chimCodeSavedLevelIndex', currentLevelIndex.toString());
             sessionStorage.setItem('chimCodeLevelAttempts', JSON.stringify(levelAttempts)); // Save attempts count
             // Do NOT save starCount itself here
             console.log(`Initializing Level ${currentLevelIndex + 1}, Attempt ${levelAttempts[currentLevelIndex]}. Initial stars: ${initialStarsForLevelAttempt}`);
             // --- End Tracking ---


             constructedCode = `// Goal: ${escapeHtml(currentChallenge.goal)}\n\n`;
             codeDisplayArea.innerHTML = constructedCode;
             levelTextSpan.textContent = `Level ${currentLevelIndex + 1}`;
             attemptsCounter.textContent = `Attempts: ${levelAttempts[currentLevelIndex]}`; // Update attempts display
             updateStarDisplay(); // Update star display (but doesn't save)
             hintContainer.style.display = 'flex';
             displayStep(); // Display first step options and hint
        }

        // --- Start the Game ---
        const startLevelIndex = loadSessionData(); // Load saved state, handles potential refresh revert
        initializeGame(startLevelIndex); // Start game at the determined level

    </script>

</body>
</html>