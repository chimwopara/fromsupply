<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Chim Farms</title>
    <link rel="icon" href="logo.jpg" type="image/jpeg" onerror="this.onerror=null; this.href='https://placehold.co/32x32/030712/FFFFFF?text=CF';">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet"/>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
      integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
      html {
        font-size: 100%;
        scroll-behavior: smooth;
      }
      body {
        font-family: 'Space Grotesk', sans-serif;
        background-color: #030712; /* gray-950 */
        overflow: hidden;
        position: relative;
        margin: 0;
        color: #E5E7EB;
      }

      /* Make top-nav completely transparent with just blur */
      .top-nav, nav.top-nav, .fixed.top-0 {
        background-color: rgba(3, 7, 18, 0.001) !important; /* Almost completely transparent */
        backdrop-filter: blur(40px) !important; /* Very strong blur */
        -webkit-backdrop-filter: blur(40px) !important; /* For Safari support */
        border-bottom: 1px solid rgba(55, 65, 81, 0.05) !important;
      }

      /* Also target any potential child containers that might have backgrounds */
      .top-nav > div, .top-nav > .mx-auto, .top-nav > .container {
        background-color: transparent !important;
      }

      #blobs-container {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        overflow: hidden; pointer-events: none; z-index: -2;
      }
      .interactive-blob {
        position: absolute; border-radius: 50%; filter: blur(120px);
        opacity: 0.20; mix-blend-mode: screen; transition: background-color 2s ease-in-out; /* Slightly less opaque */
      }

      #game-container {
        position: fixed; top: 70px; left: 0;
        width: 100vw; height: calc(100vh - 70px);
        z-index: 1; cursor: grab; /* Indicate it's interactive */
      }
      #game-container.pointer-locked {
        cursor: none; /* Hide cursor when locked */
      }
      canvas { display: block; }

      /* Hide game UI by default */
      #game-ui {
        display: none;
      }
      
      /* Hide message box by default */
      #message-box {
        display: none;
      }

      .star-button-container { position: relative; z-index: 50; }
      .star-button { /* Renamed from reserves-button for consistency, but ID is reserves-button */
        background-color: rgba(17, 24, 39, 0.7); backdrop-filter: blur(8px); border: 1px solid rgba(55, 65, 81, 0.6);
        transition: all 0.3s ease; padding: 0.5rem 1rem; border-radius: 9999px; display: flex; align-items: center; gap: 0.5rem;
        font-size: 0.875rem; color: #D1D5DB; cursor: pointer;
      }
      .star-button .fa-star { color: #FACC15; /* Tailwind yellow-400 */ margin-right: 0.25rem;}
      .star-button:hover { border-color: rgba(255, 255, 255, 0.7); background-color: rgba(17, 24, 39, 0.9); color: #ffffff; }
      .star-dropdown {
        position: absolute; top: calc(100% + 0.5rem); right: 0; background-color: rgba(31, 41, 55, 0.95); backdrop-filter: blur(12px);
        border: 1px solid rgba(75, 85, 99, 0.7); border-radius: 0.75rem; padding: 0.75rem; width: 340px; /* Slightly wider */
        z-index: 60; opacity: 0; visibility: hidden; transform: translateY(-10px) scale(0.98);
        transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s ease;
        display: flex; flex-direction: column; gap: 0.75rem; box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        max-height: 70vh; overflow-y: auto; /* Scrollable dropdown */
      }
      .star-dropdown.active { opacity: 1; visibility: visible; transform: translateY(0) scale(1); }
      .dropdown-item {
        display: flex; align-items: center; padding: 0.75rem; background-color: rgba(55, 65, 81, 0.6); border-radius: 0.5rem;
        transition: background-color 0.2s ease, transform 0.15s ease; cursor: pointer; border: 1px solid transparent;
      }
      .dropdown-item:hover { background-color: rgba(75, 85, 99, 0.8); transform: translateX(4px); border-color: rgba(107, 114, 128, 0.7); }
      .dropdown-item-icon {
        width: 40px; height: 40px; border-radius: 0.375rem; margin-right: 0.75rem;
        object-fit: cover; flex-shrink: 0; border: 1px solid rgba(75, 85, 99, 0.5);
        display: flex; align-items: center; justify-content: center; font-size: 1.5rem; /* For emoji/text placeholders */
      }
      .dropdown-item-content { flex-grow: 1; margin-right: 0.5rem; }
      .dropdown-item-title { color: #F3F4F6; font-weight: 500; font-size: 0.875rem; line-height: 1.2; margin-bottom: 2px; }
      .dropdown-item-desc { color: #9CA3AF; font-size: 0.75rem; line-height: 1.3; }
      .dropdown-item-price {
        background-color: #4B5563; color: #ffffff; font-size: 0.75rem; font-weight: 600; padding: 0.35rem 0.7rem; border-radius: 9999px;
        transition: all 0.2s ease; white-space: nowrap; border: none; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      .dropdown-item:hover .dropdown-item-price:not([disabled]) { background-color: #374151; transform: scale(1.05); }
      .dropdown-item-price[disabled] { background-color: #374151; color: #6b7280; cursor: not-allowed; opacity: 0.6; }
      .dropdown-item-price[disabled]:hover { background-color: #374151; transform: none; }

      .particle {
        position: fixed; border-radius: 50%; pointer-events: none; z-index: 5;
        opacity: 0; animation: particleFade 3s ease-out forwards;
      }
      @keyframes particleFade {
        0% { opacity: 0.7; transform: translate(0, 0) scale(1); }
        100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(0.5); }
      }
      
      .crosshair {
        position: fixed; top: 50%; left: 50%; width: 10px; height: 10px;
        border: 1px solid white; background-color: rgba(255,255,255,0.3);
        border-radius: 50%; transform: translate(-50%, -50%);
        pointer-events: none; z-index: 1000; display: none;
      }
      
      .payment-options-dropdown {
        position: absolute;
        background-color: rgba(31, 41, 55, 0.98);
        border: 1px solid rgba(75, 85, 99, 0.8);
        border-radius: 0.5rem;
        padding: 0.5rem;
        z-index: 70;
        width: 300px;
        box-shadow: 0 8px 16px rgba(0,0,0,0.4);
        display: none;
      }
      
      .payment-option {
        padding: 0.75rem;
        margin-bottom: 0.5rem;
        border-radius: 0.375rem;
        background-color: rgba(55, 65, 81, 0.7);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .payment-option:hover {
        background-color: rgba(75, 85, 99, 0.9);
        transform: translateX(4px);
      }
      
      .payment-option-label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      
      .third-party-warning {
        font-size: 0.7rem;
        color: #FCA5A5;
        padding: 0.25rem 0.5rem;
        background-color: rgba(153, 27, 27, 0.3);
        border-radius: 4px;
        margin-top: 0.25rem;
      }
      
      .shop-header-notice {
        color: #E5E7EB;
        font-size: 0.75rem;
        line-height: 1.3;
        padding: 0.75rem;
        background-color: rgba(79, 70, 229, 0.2);
        border: 1px solid rgba(79, 70, 229, 0.4);
        border-radius: 0.5rem;
        margin-bottom: 0.75rem;
      }
      
      .demo-badge {
        font-size: 0.65rem;
        padding: 0.15rem 0.4rem;
        background-color: rgba(245, 158, 11, 0.2);
        color: #FBBF24;
        border: 1px solid rgba(245, 158, 11, 0.4);
        border-radius: 9999px;
        margin-left: 0.5rem;
        vertical-align: middle;
      }
      
      .live-badge {
        font-size: 0.65rem;
        padding: 0.15rem 0.4rem;
        background-color: rgba(16, 185, 129, 0.2);
        color: #34D399;
        /* Removed border per requirement */
        border-radius: 9999px;
        margin-left: 0.5rem;
        vertical-align: middle;
        display: none;
      }
      
      .third-party-farms-section {
        display: none;
        margin-top: 0.5rem;
      }
      
      /* New aerial view styling */
      #aerial-view-container {
        position: fixed;
        top: 70px;
        left: 0;
        width: 100vw;
        height: calc(100vh - 70px);
        z-index: 2;
        display: none;
        background-color: rgba(3, 7, 18, 0.9);
      }
      
      /* Mode selection popup */
      #mode-selection-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(31, 41, 55, 0.95);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(75, 85, 99, 0.7);
        border-radius: 0.75rem;
        padding: 1.5rem;
        width: 300px;
        z-index: 75;
        box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        display: none;
      }
      
      .mode-option {
        display: flex;
        align-items: center;
        padding: 1rem;
        margin-bottom: 1rem;
        background-color: rgba(55, 65, 81, 0.6);
        border-radius: 0.5rem;
        border: 1px solid transparent;
        transition: all 0.2s ease;
        cursor: pointer;
      }
      
      .mode-option:hover {
        background-color: rgba(75, 85, 99, 0.8);
        border-color: rgba(107, 114, 128, 0.7);
        transform: translateY(-2px);
      }
      
      .mode-icon {
        font-size: 1.5rem;
        margin-right: 1rem;
      }
      
      .mode-content h3 {
        font-weight: 600;
        font-size: 1.1rem;
        margin-bottom: 0.25rem;
      }
      
      .mode-content p {
        font-size: 0.8rem;
        color: #9CA3AF;
      }
      
      /* Prast Farms popup */
      #prast-farms-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(31, 41, 55, 0.95);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(75, 85, 99, 0.7);
        border-radius: 0.75rem;
        padding: 1.5rem;
        width: 450px;
        z-index: 80;
        box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        display: none;
      }
      
      .prast-farms-header {
        font-size: 1.5rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        text-align: center;
      }
      
      .prast-farms-subheader {
        font-size: 0.85rem;
        color: #9CA3AF;
        text-align: center;
        margin-bottom: 1.5rem;
      }
      
      /* Third party farms prompt */
      .third-party-prompt {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem;
        background-color: rgba(79, 70, 229, 0.2);
        border: 1px solid rgba(79, 70, 229, 0.4);
        border-radius: 0.5rem;
        margin-top: 0.5rem;
      }
      
      /* Search functionality */
      .search-container {
        display: flex;
        margin-bottom: 1rem;
        position: relative;
      }
      
      .search-input {
        flex-grow: 1;
        background-color: rgba(55, 65, 81, 0.6);
        border: 1px solid rgba(75, 85, 99, 0.5);
        border-radius: 0.5rem;
        padding: 0.5rem 1rem;
        color: #E5E7EB;
        font-size: 0.875rem;
      }
      
      .search-input:focus {
        outline: none;
        border-color: rgba(107, 114, 128, 0.8);
        background-color: rgba(55, 65, 81, 0.8);
      }
      
      .search-button {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: #9CA3AF;
        cursor: pointer;
        padding: 0.25rem;
      }
      
      .search-button:hover {
        color: #E5E7EB;
      }
    </style>
</head>
<body class="text-gray-100 min-h-screen flex flex-col">
  <div id="blobs-container">
      <div class="interactive-blob blob-1" style="top:-10%; left:-15%; width:60vw; height:60vw;"></div>
      <div class="interactive-blob blob-2" style="bottom:-20%; right:-15%; width:55vw; height:55vw;"></div>
  </div>

  <nav class="top-nav fixed top-0 left-0 right-0 z-50">
    <div class="mx-auto h-full flex items-center justify-between px-4 sm:px-6">
      <div class="flex items-center gap-3">
        
        <span class="text-xl font-bold text-white group-hover:text-white transition-colors duration-200"> Chim Farms
          <span class="demo-badge" id="app-mode-badge">demo</span>
          <span class="live-badge" id="live-mode-badge">live</span>
        </span>
      </div>
      <div class="flex items-center gap-4">
        <a href="#" id="library-button" class="group flex items-center gap-2 bg-gray-800/60 hover:bg-gray-700/80 border border-gray-700 hover:border-gray-500 px-4 py-2 rounded-full transition-all duration-300 text-gray-300 hover:text-white text-sm">
          <span>Library</span> </a>
        <div class="star-button-container">
          <button id="reserves-button" class="star-button" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-star"></i> <span id="reserves-amount">2000</span>
          </button>
          <div id="farm-store-dropdown" class="star-dropdown" role="menu">
            <div class="search-container">
              <input type="text" class="search-input" placeholder="Search for farms or items...">
              <button class="search-button">
                <i class="fas fa-search"></i>
              </button>
            </div>
            
            
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="chicken" data-cost="500">
                <div class="dropdown-item-icon bg-yellow-700">🐔</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Chicken Farm</div>
                  <div class="dropdown-item-desc">80% annual return. Produces eggs.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-chicken-farm">Get</button>
              </div>
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="pig" data-cost="1000">
                <div class="dropdown-item-icon bg-pink-400">🐖</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Pig Farm</div>
                  <div class="dropdown-item-desc">100% annual return. Hardy animals.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-pig-farm">Get</button>
              </div>
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="cow" data-cost="2499">
                <div class="dropdown-item-icon bg-gray-400">🐄</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Cow Farm</div>
                  <div class="dropdown-item-desc">130% annual return. Milk and more.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-cow-farm">Get</button>
              </div>
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="goat" data-cost="749">
                <div class="dropdown-item-icon bg-stone-400">🐐</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Goat Farm</div>
                  <div class="dropdown-item-desc">60% annual return. Agile climbers.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-goat-farm">Get</button>
              </div>
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="fish" data-cost="99">
                <div class="dropdown-item-icon bg-sky-400">🐟</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Fish Pond</div>
                  <div class="dropdown-item-desc">60% annual return. Fresh catches.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-fish-farm">Get</button>
              </div>
              <hr class="border-gray-600 my-2">
              <div class="px-2 py-1 text-xs text-gray-400 uppercase">Plants (Max 1 Each)</div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="plantain" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-lime-600">🍌</div> <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Plantain Seeds</div>
                  <div class="dropdown-item-desc">~50% annual return. Versatile fruit.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-plantain">Get</button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="banana" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-yellow-500">🍌</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Banana Sapling</div>
                  <div class="dropdown-item-desc">~50% annual return. Sweet yield.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-banana">Get</button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="orange" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-orange-500">🍊</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Orange Tree Seedling</div>
                  <div class="dropdown-item-desc">~50% annual return. Juicy harvest.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-orange">Get</button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="sugarcane" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-green-700">🌿</div> <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Sugar Cane Stalk</div>
                  <div class="dropdown-item-desc">~50% annual return. Sweet raw material.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-sugarcane">Get</button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="coconut" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-yellow-800">🥥</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Coconut Seed</div>
                  <div class="dropdown-item-desc">~50% annual return. Tropical delight.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-coconut">Get</button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="papaya" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-orange-400">🥭</div> <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Papaya Seeds</div>
                  <div class="dropdown-item-desc">~50% annual return. Exotic fruit.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-papaya">Get</button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="carrot" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-orange-600">🥕</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Carrot Seeds</div>
                  <div class="dropdown-item-desc">~50% annual return. Root vegetable.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-carrot">Get</button>
              </div>
              <hr class="border-gray-600 my-2">
              <div class="px-2 py-1 text-xs text-gray-400 uppercase">Land & Partnerships</div>
              <div class="dropdown-item" role="menuitem" data-type="land" data-id="expansion" data-cost="2000">
                <div class="dropdown-item-icon bg-emerald-800">🏞️</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Land Expansion</div>
                  <div class="dropdown-item-desc">Expand your land by 100%. More room for farms.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-land-expansion">Get</button>
              </div>
              
              <div class="third-party-prompt">
                <div>
                  <span class="font-semibold">Want to purchase from third party farms?</span>
                  <p class="text-xs text-gray-400">Explore more farming options globally</p>
                </div>
                <button class="dropdown-item-price" data-action="show-third-party-farms">View</button>
              </div>
              
              <div class="third-party-farms-section" id="third-party-farms">
                <div class="px-2 py-1 text-xs text-amber-300">THIRD PARTY FARMS</div>
                
                <div class="search-container">
                  <input type="text" class="search-input" placeholder="Find a farm...">
                  <button class="search-button">
                    <i class="fas fa-search"></i>
                  </button>
                </div>
                
                <div class="dropdown-item" role="menuitem" data-type="third-party" data-id="sunshine-acres" data-cost="1500" data-return="85">
                  <div class="dropdown-item-icon bg-yellow-600">🌞</div>
                  <div class="dropdown-item-content">
                    <div class="dropdown-item-title">Sunshine Acres</div>
                    <div class="dropdown-item-desc">85% annual return. Organic methods.</div>
                    <div class="third-party-warning">Requires auditing fee</div>
                  </div>
                  <button class="dropdown-item-price" data-action="get-third-party-farm">Get</button>
                </div>
                
                <div class="dropdown-item" role="menuitem" data-type="third-party" data-id="azure-fields" data-cost="3500" data-return="120">
                  <div class="dropdown-item-icon bg-blue-400">🌾</div>
                  <div class="dropdown-item-content">
                    <div class="dropdown-item-title">Azure Fields</div>
                    <div class="dropdown-item-desc">120% annual return. Scale operations.</div>
                    <div class="third-party-warning">Requires auditing fee</div>
                  </div>
                  <button class="dropdown-item-price" data-action="get-third-party-farm">Get</button>
                </div>
                
                <div class="dropdown-item" role="menuitem" data-type="third-party" data-id="emerald-valleys" data-cost="7500" data-return="150">
                  <div class="dropdown-item-icon bg-emerald-500">🏞️</div>
                  <div class="dropdown-item-content">
                    <div class="dropdown-item-title">Emerald Valleys</div>
                    <div class="dropdown-item-desc">150% annual return. Premium operation.</div>
                    <div class="third-party-warning">Requires auditing fee</div>
                  </div>
                  <button class="dropdown-item-price" data-action="get-third-party-farm">Get</button>
                </div>
                
                <div class="dropdown-item" role="menuitem" data-type="third-party" data-id="mountain-vista" data-cost="5000" data-return="135">
                  <div class="dropdown-item-icon bg-indigo-500">⛰️</div>
                  <div class="dropdown-item-content">
                    <div class="dropdown-item-title">Mountain Vista</div>
                    <div class="dropdown-item-desc">135% annual return. Highland specialty crops.</div>
                    <div class="third-party-warning">Requires auditing fee</div>
                  </div>
                  <button class="dropdown-item-price" data-action="get-third-party-farm">Get</button>
                </div>
                
                <div class="dropdown-item" role="menuitem" data-type="third-party" data-id="coastal-breeze" data-cost="4200" data-return="125">
                  <div class="dropdown-item-icon bg-cyan-400">🌊</div>
                  <div class="dropdown-item-content">
                    <div class="dropdown-item-title">Coastal Breeze</div>
                    <div class="dropdown-item-desc">125% annual return. Seaside agriculture.</div>
                    <div class="third-party-warning">Requires auditing fee</div>
                  </div>
                  <button class="dropdown-item-price" data-action="get-third-party-farm">Get</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </nav>

  <div id="game-container">
  </div>
  
  <div id="aerial-view-container">
    </div>
  
  <div class="crosshair" id="crosshair"></div>

  <div id="game-ui">
    <p>Move: WASD | Look: Mouse | Jump: Space</p>
    <p>Toggle Mouse Lock: Enter | Toggle Weather: P (dev)</p>
  </div>

  <div id="message-box">tap enter to explore</div> <div id="payment-options" class="payment-options-dropdown">
    <div class="px-2 py-1 mb-2 text-xs text-gray-300 text-center font-semibold">SELECT PAYMENT METHOD</div>
    <div class="payment-option" data-payment="stars">
      <div class="payment-option-label">
        <i class="fas fa-star text-yellow-400"></i>
        <span>Pay with Stars <span class="text-xs text-gray-400">(demo)</span></span>
      </div>
      <span class="payment-price" id="stars-price">500</span>
    </div>
    <div class="payment-option" data-payment="real">
      <div class="payment-option-label">
        <i class="fas fa-dollar-sign text-green-400"></i>
        <span>Pay with $ <span class="text-xs text-green-400">(live mode)</span></span>
      </div>
      <span class="payment-price" id="dollar-price">$7.99</span>
    </div>
  </div>
  
  <div id="mode-selection-popup">
    <h2 class="text-xl font-bold mb-4 text-center">Select Mode</h2>

    <div id="library-mode-notice" class="text-xs text-gray-300 mb-4 px-1 text-center" style="line-height: 1.4;">
        Live mode partners you with real farms; You'll be charged upon approval.
    </div>
    <div class="mode-option" data-mode="demo">
        <div class="mode-icon">
            <i class="fas fa-star text-yellow-400"></i>
        </div>
        <div class="mode-content">
            <h3>Demo Mode</h3>
            <p>Try out the experience with your reserves.</p>
        </div>
    </div>

    <div class="mode-option" data-mode="live">
        <div class="mode-icon">
            <i class="fas fa-dollar-sign text-green-400"></i>
        </div>
        <div class="mode-content">
            <h3>Live Mode</h3>
            <p> Real investments with fixed audited returns.</p>
        </div>
    </div>
</div>
  
  <div id="prast-farms-popup">
    <div class="prast-farms-header">Prast Farms</div>
    <div class="prast-farms-subheader">
       Live mode partners you with real farms; You'll be charged upon approval.
    </div>
    
    <div class="prast-farms-content">
      </div>
    
    <div class="mt-4 flex justify-end">
      <button class="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-md mr-2" id="prast-farms-close">Close</button>
      <button class="bg-indigo-600 hover:bg-indigo-500 text-white px-4 py-2 rounded-md" id="prast-farms-continue">Continue</button>
    </div>
  </div>

  <script>
    // Ensure THREE is available
    if (typeof THREE === 'undefined') {
        alert("THREE.js failed to load. Game cannot start.");
        // Potentially load it dynamically or show a more graceful error
    }
     // Ensure OrbitControls is available
    if (typeof THREE.OrbitControls === 'undefined') {
        console.warn("THREE.OrbitControls failed to load. Aerial view controls might not work.");
        // You might want to load it dynamically or inform the user if it's critical
    }


    document.addEventListener('DOMContentLoaded', () => {
      const gameContainer = document.getElementById('game-container');
      const aerialViewContainer = document.getElementById('aerial-view-container');
      const reservesButton = document.getElementById('reserves-button');
      const reservesAmountSpan = document.getElementById('reserves-amount');
      const farmStoreDropdown = document.getElementById('farm-store-dropdown');
      const libraryButton = document.getElementById('library-button'); // Changed from recordsButton
      const messageBox = document.getElementById('message-box');
      const crosshair = document.getElementById('crosshair');
      const paymentOptions = document.getElementById('payment-options');
      const appModeBadge = document.getElementById('app-mode-badge');
      const liveModeBadge = document.getElementById('live-mode-badge');
      const thirdPartyFarmsSection = document.getElementById('third-party-farms');
      const modeSelectionPopup = document.getElementById('mode-selection-popup');
      const prastFarmsPopup = document.getElementById('prast-farms-popup');

      let playerReserves = 2000;
      let isLiveMode = false;
      let currentPaymentItem = null;
      let isAerialView = false;
      let aerialViewCamera, aerialViewRenderer, aerialViewControls; // For aerial view
      
      // Separate inventory for each mode
      let demoInventory = {
        chicken: 0, pig: 0, cow: 0, goat: 0, fish: 0,
        plantain: 0, banana: 0, orange: 0, sugarcane: 0, coconut: 0, papaya: 0, carrot: 0,
        expansion: 0, // Land expansion
      };
      
      let liveInventory = {
        chicken: 0, pig: 0, cow: 0, goat: 0, fish: 0,
        plantain: 0, banana: 0, orange: 0, sugarcane: 0, coconut: 0, papaya: 0, carrot: 0,
        expansion: 0, // Land expansion
      };
      
      // Use the appropriate inventory based on the current mode
      let purchasedItems = demoInventory;

      let scene, camera, renderer, player, زمین;
      let playerVelocity = new THREE.Vector3();
      let playerOnGround = false;
      const playerHeight = 1.8; // Player's eye height
      const playerCapsuleRadius = 0.4; // For potential future capsule collision
      const playerSpeed = 8.0;
      const playerJumpForce = 7.0;
      const gravity = -20.0;
      let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
      let worldObjects = []; // For farms, plants, trees, stream for potential interaction/collision
      let chickenAIMeshes = []; // Store chickens that need AI updates
      
      // Land size configuration
      let worldSize = 100; // Reduced to 1/3 of original (was 300)
      let landExpansionMultiplier = 1.0; // Will increase with land purchases

      // Weather variables
      let isRaining = false;
      let rainParticles, rainMaterial;
      let lightningActive = false;
      let lightningTimeout, nextLightningStrikeTimeout;
      let clouds = [];
      const initialFogColor = new THREE.Color(0x030712); // Changed from 0x87CEEB
      const rainFogColor = new THREE.Color(0x1A202C); // Darker fog for rain

      function initThreeJS() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x030712); // Dark background matching the header
        scene.fog = new THREE.Fog(scene.background, 20, worldSize * 0.7);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight - 70), 0.1, 1000); // Increased far plane
        camera.position.set(0, playerHeight, 0); // Camera is at player's eye level within player object

        player = new THREE.Object3D();
        player.position.set(0, playerHeight / 2, 5); // Player object center, feet on ground
        scene.add(player);
        player.add(camera);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight - 70);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        gameContainer.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Slightly brighter
        directionalLight.position.set(50, 80, 30); // Higher and more angled
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096; // Increased shadow map size
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 200; // Adjusted shadow camera far
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);
        // const helper = new THREE.CameraHelper( directionalLight.shadow.camera ); scene.add( helper );

        // Improved Ground (زمین) with Texture
        const groundTexture = createGrassTexture(512,512);
        const groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture, side: THREE.DoubleSide, roughness: 0.8, metalness: 0.2 });
        const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize, 50, 50); // Added segments for potential displacement
        زمین = new THREE.Mesh(groundGeometry, groundMaterial);
        زمین.rotation.x = -Math.PI / 2;
        زمین.receiveShadow = true;
        scene.add(زمین);
        worldObjects.push(زمین);


        createEnvironmentFeatures(); // Trees, clouds (removed stream per requirements)
        setupControls();
        animate();
        window.addEventListener('resize', onWindowResize, false);
        updateReservesDisplay();
      }
      
      // Initialize aerial view
      function initAerialView() {
        aerialViewCamera = new THREE.PerspectiveCamera(60, window.innerWidth / (window.innerHeight - 70), 0.1, 1000);
        aerialViewCamera.position.set(0, 50, 50); // Position high above
        aerialViewCamera.lookAt(0, 0, 0);
        
        aerialViewRenderer = new THREE.WebGLRenderer({ antialias: true });
        aerialViewRenderer.setSize(window.innerWidth, window.innerHeight - 70);
        aerialViewRenderer.setPixelRatio(window.devicePixelRatio);
        aerialViewRenderer.shadowMap.enabled = true;
        
        // Clear the container first
        while (aerialViewContainer.firstChild) {
          aerialViewContainer.removeChild(aerialViewContainer.firstChild);
        }
        
        aerialViewContainer.appendChild(aerialViewRenderer.domElement);
        
        // Add orbit controls for rotation
         if (typeof THREE.OrbitControls !== 'undefined') {
            aerialViewControls = new THREE.OrbitControls(aerialViewCamera, aerialViewRenderer.domElement);
            aerialViewControls.enableDamping = true;
            aerialViewControls.dampingFactor = 0.05;
            aerialViewControls.screenSpacePanning = false;
            aerialViewControls.minDistance = 20;
            aerialViewControls.maxDistance = 150;
            aerialViewControls.maxPolarAngle = Math.PI / 2.2; // Don't go below horizon
        } else {
            console.warn("OrbitControls not available for aerial view.");
        }
        
        // Start aerial view animation
        animateAerialView();
      }
      
      function animateAerialView() {
        if (!isAerialView) return;
        
        requestAnimationFrame(animateAerialView);
        
        if (aerialViewControls) aerialViewControls.update();
        aerialViewRenderer.render(scene, aerialViewCamera);
      }
      
      function toggleAerialView() {
        // Always activate aerial view on library button click, don't toggle
        isAerialView = true;
        
        // Hide game view, show aerial view
        gameContainer.style.display = 'none';
        aerialViewContainer.style.display = 'block';
        
        // Initialize aerial view if not already done
        if (!aerialViewRenderer) {
          initAerialView();
        }
        
        // Position mode selection UI in top right instead of center
        modeSelectionPopup.style.display = 'block';
        modeSelectionPopup.style.position = 'absolute'; // Changed from fixed for better context if aerial view has scroll
        modeSelectionPopup.style.top = '80px'; // Just below the header
        modeSelectionPopup.style.right = '20px';
        modeSelectionPopup.style.left = 'auto'; // Override any left positioning
        modeSelectionPopup.style.transform = 'none'; // Remove any centering transform
        
        // Make sure aerialViewControls is initialized
        if (!aerialViewControls && aerialViewRenderer && typeof THREE.OrbitControls !== 'undefined') {
          aerialViewControls = new THREE.OrbitControls(aerialViewCamera, aerialViewRenderer.domElement);
          aerialViewControls.enableDamping = true;
          aerialViewControls.dampingFactor = 0.05;
          aerialViewControls.screenSpacePanning = false;
          aerialViewControls.minDistance = 20;
          aerialViewControls.maxDistance = 150;
          aerialViewControls.maxPolarAngle = Math.PI / 2.2;
        }
        
        // Force render the aerial view immediately
        if (aerialViewRenderer) {
          aerialViewRenderer.render(scene, aerialViewCamera);
          animateAerialView(); // Start animation loop
        }
      }
      
      function exitAerialView() {
        isAerialView = false;
        gameContainer.style.display = 'block';
        aerialViewContainer.style.display = 'none';
        
        // Hide popups
        modeSelectionPopup.style.display = 'none';
        prastFarmsPopup.style.display = 'none';
      }
      
      function createGrassTexture(width, height) {
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const context = canvas.getContext('2d');

          // Base green color
          context.fillStyle = `rgb(${Math.floor(30 + Math.random()*10)}, ${Math.floor(100 + Math.random()*30)}, ${Math.floor(30 + Math.random()*10)})`;
          context.fillRect(0, 0, width, height);

          // Add some variations
          for (let i = 0; i < 20000; i++) { // More speckles for detail
              const x = Math.random() * width;
              const y = Math.random() * height;
              const r = Math.floor(20 + Math.random() * 20); // Darker greens
              const g = Math.floor(90 + Math.random() * 40);
              const b = Math.floor(20 + Math.random() * 20);
              const alpha = Math.random() * 0.5 + 0.3; // Vary opacity
              context.fillStyle = `rgba(${r},${g},${b},${alpha})`;
              context.fillRect(x, y, Math.random()*2+1, Math.random()*2+1); // Vary speckle size
          }
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(20, 20); // How many times texture repeats on ground
          return texture;
      }


      function createEnvironmentFeatures() {
        // Trees - fewer than before due to smaller land
        for (let i = 0; i < 20; i++) { // Reduced from 50
            const tree = createTree();
            tree.position.set(
                (Math.random() - 0.5) * (worldSize - 20), // Spread over ground
                0,
                (Math.random() - 0.5) * (worldSize - 20)
            );
            // Avoid placing trees too close to initial spawn or center farm area
            if (tree.position.length() > 15) { // Don't place too close to origin (0,0,0)
                 scene.add(tree);
                 worldObjects.push(tree);
            }
        }

        // Stream REMOVED per requirements

        // Clouds - fewer
        for (let i = 0; i < 8; i++) { // Reduced from 15
            const cloud = createCloud();
            cloud.position.set(
                (Math.random() - 0.5) * worldSize * 1.5,
                Math.random() * 20 + 40, // Cloud height
                (Math.random() - 0.5) * worldSize * 1.5
            );
            scene.add(cloud);
            clouds.push(cloud);
        }
      }

      function createTree() {
        const treeGroup = new THREE.Group();
        // Trunk
        const trunkHeight = Math.random() * 4 + 4; // Vary height
        const trunkRadius = Math.random() * 0.2 + 0.3;
        const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.7, trunkRadius, trunkHeight, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 }); // Brown
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.castShadow = true;
        trunk.position.y = trunkHeight / 2;
        treeGroup.add(trunk);

        // Leaves (multiple spheres for a fuller look)
        const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // ForestGreen
        const numLeafBlobs = Math.floor(Math.random() * 3) + 3;
        for(let i=0; i < numLeafBlobs; i++) {
            const leafRadius = Math.random() * 1.5 + 1.5;
            const leavesGeometry = new THREE.SphereGeometry(leafRadius, 6, 5);
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.castShadow = true;
            leaves.position.set(
                (Math.random() - 0.5) * leafRadius * 0.5, // Slight horizontal offset
                trunkHeight + (Math.random() - 0.3) * leafRadius * 0.6, // Overlap with trunk and each other
                (Math.random() - 0.5) * leafRadius * 0.5  // Slight depth offset
            );
            treeGroup.add(leaves);
        }
        return treeGroup;
      }

      // Stream creation function removed per requirements

      function createCloud() {
        const cloudGroup = new THREE.Group();
        const baseMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.85,
            flatShading: true // Gives a more cartoony, low-poly look
        });

        const numBlobs = Math.floor(Math.random() * 4) + 3; // 3 to 6 blobs per cloud
        for (let i = 0; i < numBlobs; i++) {
            const blobSize = Math.random() * 8 + 5; // Size of each blob
            const blobGeometry = new THREE.SphereGeometry(blobSize, 5, 4); // Low poly spheres
            const blobMesh = new THREE.Mesh(blobGeometry, baseMaterial);
            blobMesh.position.set(
                (Math.random() - 0.5) * blobSize * 1.5, // Overlap them
                (Math.random() - 0.5) * blobSize * 0.5,
                (Math.random() - 0.5) * blobSize * 1.0
            );
            blobMesh.castShadow = true; // Clouds can cast soft shadows
            cloudGroup.add(blobMesh);
        }
        cloudGroup.scale.y = Math.random() * 0.3 + 0.6; // Make some clouds flatter
        return cloudGroup;
      }


      function onWindowResize() {
        camera.aspect = window.innerWidth / (window.innerHeight - 70);
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight - 70);
        
        if (aerialViewRenderer) {
          aerialViewCamera.aspect = window.innerWidth / (window.innerHeight - 70);
          aerialViewCamera.updateProjectionMatrix();
          aerialViewRenderer.setSize(window.innerWidth, window.innerHeight - 70);
        }
      }

      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);
        const deltaTime = clock.getDelta();

        if (document.pointerLockElement === document.body || gameContainer.classList.contains('pointer-locked')) {
            updatePlayer(deltaTime);
        }
        
        // Stream animation removed per requirements
        
        // Animate clouds
        clouds.forEach(cloud => {
            cloud.position.x += deltaTime * (Math.random()*1+0.5); // Vary speed slightly
            if (cloud.position.x > worldSize) { // Reset cloud position if it goes too far
                cloud.position.x = -worldSize;
                cloud.position.z = (Math.random() - 0.5) * worldSize; // New Z position
            }
        });
        
        // Chicken AI
        chickenAIMeshes.forEach(chickenData => {
            chickenData.timer -= deltaTime;
            if (chickenData.timer <= 0) {
                // New random direction within pen
                const penSize = chickenData.penSize - 0.5; // keep inside fence
                chickenData.targetPosition.set(
                    (Math.random() - 0.5) * penSize,
                    chickenData.mesh.position.y, // Keep y fixed
                    (Math.random() - 0.5) * penSize
                ).add(chickenData.penCenter); // Relative to pen center

                chickenData.timer = Math.random() * 3 + 2; // Next change in 2-5 seconds
            }
            // Move towards target
            const direction = new THREE.Vector3().subVectors(chickenData.targetPosition, chickenData.mesh.position);
            if (direction.lengthSq() > 0.01) {
                direction.normalize();
                chickenData.mesh.position.addScaledVector(direction, deltaTime * 0.5); // Chicken speed
                // Make chicken look in direction of movement (simple)
                chickenData.mesh.lookAt(chickenData.targetPosition.x, chickenData.mesh.position.y , chickenData.targetPosition.z);

            }
        });

        if (isRaining) updateRain(deltaTime);

        renderer.render(scene, camera);
      }

      function setupControls() {
        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);

        document.addEventListener('pointerlockchange', () => {
          if (document.pointerLockElement === document.body) {
            crosshair.style.display = 'block';
            gameContainer.classList.add('pointer-locked');
          } else {
            crosshair.style.display = 'none';
            gameContainer.classList.remove('pointer-locked');
            moveForward = false; moveBackward = false; moveLeft = false; moveRight = false;
          }
        }, false);
      }

      function onMouseMove(event) {
        if (document.pointerLockElement === document.body) {
          const movementX = event.movementX || 0;
          const movementY = event.movementY || 0;
          player.rotation.y -= movementX * 0.002;
          camera.rotation.x -= movementY * 0.002;
          camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }
      }

      function onKeyDown(event) {
        // Changed from L key to Enter key as per requirement
        if (event.code === 'Enter') { 
            if (document.pointerLockElement === document.body) {
                document.exitPointerLock();
            } else {
                document.body.requestPointerLock().catch(err => {
                    // console.warn("Pointer lock failed. User needs to click the game screen first or browser doesn't support it well without user gesture for the element.", err);
                    // Potentially show a message to the user to click the game screen
                    if (!gameContainer.classList.contains('interacted')) {
                         showGameMessage("Click the game screen to enable mouse lock.", "info", 5000);
                    }
                });
            }
        }
        if (event.code === 'KeyP') { // Dev key to toggle weather
            toggleWeather();
        }
        if (event.code === 'Delete') { // Added Delete key to exit pointer lock
            if (document.pointerLockElement === document.body) {
                document.exitPointerLock();
            }
        }

        if (document.pointerLockElement !== document.body && !['Enter', 'KeyP', 'Escape', 'Delete'].includes(event.code)) return; // Only allow Enter, P, Delete, Esc if not locked

        switch (event.code) {
          case 'KeyW': case 'ArrowUp': moveForward = true; break;
          case 'KeyS': case 'ArrowDown': moveBackward = true; break;
          case 'KeyA': case 'ArrowLeft': moveRight = true; break; // FIXED: Left and right were swapped
          case 'KeyD': case 'ArrowRight': moveLeft = true; break; // FIXED: Left and right were swapped
          case 'Space': if (playerOnGround) playerVelocity.y = playerJumpForce; break;
          case 'Escape':
            if (document.pointerLockElement === document.body) document.exitPointerLock();
            if (farmStoreDropdown.classList.contains('active')) {
                farmStoreDropdown.classList.remove('active');
                reservesButton.setAttribute('aria-expanded', 'false');
            }
            if (paymentOptions.style.display === 'block') {
                paymentOptions.style.display = 'none';
                currentPaymentItem = null;
            }
            if (isAerialView) {
                 exitAerialView();
            }
            if (modeSelectionPopup.style.display === 'block') {
                modeSelectionPopup.style.display = 'none';
            }
            if (prastFarmsPopup.style.display === 'block') {
                prastFarmsPopup.style.display = 'none';
            }
            break;
        }
      }
        // Add a click listener to gameContainer to mark it as interacted
        if (gameContainer) {
            gameContainer.addEventListener('click', () => {
                gameContainer.classList.add('interacted');
                if (document.pointerLockElement !== document.body && !gameContainer.classList.contains('pointer-locked')) {
                    document.body.requestPointerLock().catch(err => {
                        // console.warn("Pointer lock failed on click.", err);
                    });
                }
            }, { once: false }); // { once: false } to allow repeated attempts if needed
        }


      function onKeyUp(event) {
        switch (event.code) {
          case 'KeyW': case 'ArrowUp': moveForward = false; break;
          case 'KeyS': case 'ArrowDown': moveBackward = false; break;
          case 'KeyA': case 'ArrowLeft': moveRight = false; break; // FIXED: Left and right were swapped
          case 'KeyD': case 'ArrowRight': moveLeft = false; break; // FIXED: Left and right were swapped
        }
      }

      function updatePlayer(deltaTime) {
        const moveSpeed = playerSpeed * deltaTime;
        const moveDirection = new THREE.Vector3(); // For movement calculation
        const cameraDirection = new THREE.Vector3(); // For camera orientation
        camera.getWorldDirection(cameraDirection);
        cameraDirection.y = 0;
        cameraDirection.normalize();

        const right = new THREE.Vector3().crossVectors(camera.up, cameraDirection).normalize();

        if (moveForward) moveDirection.add(cameraDirection);
        if (moveBackward) moveDirection.sub(cameraDirection);
        if (moveLeft) moveDirection.sub(right);
        if (moveRight) moveDirection.add(right);
        
        moveDirection.normalize(); // Ensure consistent speed regardless of diagonal movement
        player.position.addScaledVector(moveDirection, moveSpeed);


        playerVelocity.y += gravity * deltaTime;
        player.position.y += playerVelocity.y * deltaTime;

        if (player.position.y < playerHeight / 2) {
          player.position.y = playerHeight / 2;
          playerVelocity.y = 0;
          playerOnGround = true;
        } else {
          playerOnGround = false;
        }
        
        // Calculate world boundary based on land expansion
        const worldBoundary = (worldSize / 2) * landExpansionMultiplier;
        player.position.x = Math.max(-worldBoundary, Math.min(worldBoundary, player.position.x));
        player.position.z = Math.max(-worldBoundary, Math.min(worldBoundary, player.position.z));
      }

      function updateReservesDisplay() {
        if (reservesAmountSpan) reservesAmountSpan.textContent = playerReserves;
        const starIconHTML = '<i class="fas fa-star text-yellow-400"></i> '; // HTML for the star icon

        farmStoreDropdown.querySelectorAll('.dropdown-item').forEach(item => {
            const cost = parseInt(item.dataset.cost);
            const itemId = item.dataset.id;
            const itemType = item.dataset.type;
            const maxPurchases = item.dataset.max ? parseInt(item.dataset.max) : Infinity;
            const button = item.querySelector('.dropdown-item-price');

            if (button) {
                let alreadyMaxed = false;
                if (itemType === 'plant' && purchasedItems[itemId] >= maxPurchases) {
                    alreadyMaxed = true;
                }
                
                if (itemType === 'land' && itemId === 'expansion' && purchasedItems[itemId] >= 3) {
                    alreadyMaxed = true;
                }

                if (button.dataset.action === 'show-third-party-farms') {
                    button.disabled = false;
                } else if (itemType === 'land' && itemId === 'expansion') {
                    if (alreadyMaxed) {
                        button.textContent = "Owned"; // No icon for "Owned"
                        button.disabled = true;
                    } else {
                        button.innerHTML = starIconHTML + cost; // Star icon + cost
                        button.disabled = playerReserves < cost;
                    }
                } else if (button.dataset.action && button.dataset.action.startsWith('get-')) {
                    button.disabled = false;
                    if (alreadyMaxed) {
                        button.textContent = "Owned"; // No icon for "Owned"
                        button.disabled = true;
                    } else {
                        if (isLiveMode) {
                            button.textContent = `$${(cost / 100).toFixed(2)}`; // Dollar price, no icon
                        } else {
                            button.innerHTML = starIconHTML + cost; // Star icon + cost
                        }
                    }
                }
            }
        });
      }
      
      function setAppMode(isLive) {
        isLiveMode = isLive;
        appModeBadge.style.display = isLive ? 'none' : 'inline';
        liveModeBadge.style.display = isLive ? 'inline' : 'none';
        
        purchasedItems = isLive ? liveInventory : demoInventory;

        // Control visibility of third-party sections in the main star store
        const farmStoreDropdownElement = document.getElementById('farm-store-dropdown');
        const thirdPartyPromptEl = farmStoreDropdownElement.querySelector('.third-party-prompt');
        const thirdPartyFarmsSectionEl = farmStoreDropdownElement.querySelector('#third-party-farms');

        if (isLive) { // Live Mode
            if (thirdPartyPromptEl) thirdPartyPromptEl.style.display = 'flex'; // Or 'block' if that was its original display
            // The #third-party-farms section itself is usually display:none initially and shown by its "View" button.
            // So, we primarily ensure its prompt is visible.
        } else { // Demo Mode
            if (thirdPartyPromptEl) thirdPartyPromptEl.style.display = 'none';
            if (thirdPartyFarmsSectionEl) thirdPartyFarmsSectionEl.style.display = 'none'; // Hide the section if it was open
        }
        
        updateReservesDisplay(); // This will re-evaluate "Owned" status and button texts
      }
      
      function purchaseWithPayment(paymentType) {
        if (!currentPaymentItem) return;
        
        const {itemType, itemId, cost} = currentPaymentItem;
        const currentActiveInventory = isLiveMode ? liveInventory : demoInventory; // Ensure we use the correct inventory for "owned" checks

        if (paymentType === 'stars') {
            // Use stars (demo mode logic, but can happen in live mode if user selects it from popup)
            if (playerReserves >= cost) {
                playerReserves -= cost;
                if (isLiveMode) { // If in live mode, purchase goes to live inventory
                    liveInventory[itemId] = (liveInventory[itemId] || 0) + 1;
                } else { // Otherwise, demo inventory
                    demoInventory[itemId] = (demoInventory[itemId] || 0) + 1;
                }
                updateReservesDisplay();
                addPurchasedItemToWorld(itemType, itemId, isLiveMode ? liveInventory[itemId] : demoInventory[itemId]);
                showGameMessage(`${itemId.charAt(0).toUpperCase() + itemId.slice(1)} ${itemType === 'plant' ? 'seeds' : 'Farm'} purchased with Stars!`, 'success');
            } else {
                showGameMessage("Not enough stars!", 'error');
            }
        } else if (paymentType === 'real') {
            // Simulated real money purchase (live mode)
             if (!isLiveMode) { // If not in live mode, switch and inform
                setAppMode(true); // This switches purchasedItems to liveInventory
                showGameMessage("Switched to LIVE mode!", 'info');
            }
            liveInventory[itemId] = (liveInventory[itemId] || 0) + 1; // Increment live inventory
            updateReservesDisplay(); // Update display based on liveInventory's new state
            addPurchasedItemToWorld(itemType, itemId, liveInventory[itemId]);
            showGameMessage(`${itemId.charAt(0).toUpperCase() + itemId.slice(1)} ${itemType === 'plant' ? 'seeds' : 'Farm'} partnership initiated (LIVE)!`, 'success');
        }
        
        // Close payment dropdown
        paymentOptions.style.display = 'none';
        currentPaymentItem = null;
        
        // Check if the store should close (e.g., maxed out plants)
        const maxPurchases = farmStoreDropdown.querySelector(`.dropdown-item[data-id="${itemId}"]`)?.dataset.max;
        const currentCount = isLiveMode ? liveInventory[itemId] : demoInventory[itemId];

        if (itemType === 'plant' && currentCount >= (maxPurchases ? parseInt(maxPurchases) : Infinity)) {
            farmStoreDropdown.classList.remove('active');
            reservesButton.setAttribute('aria-expanded', 'false');
        }
         updateReservesDisplay(); // Refresh display after purchase
      }
      
      function expandLand() {
        const currentExpansionLevel = isLiveMode ? liveInventory.expansion : demoInventory.expansion;
        if (currentExpansionLevel >= 3) { // Max 3 expansions
            showGameMessage("You've reached the maximum land expansion!", 'info');
            return false; // Indicate failure
        }
        
        if (isLiveMode) {
            liveInventory.expansion++;
        } else {
            demoInventory.expansion++;
        }
        
        landExpansionMultiplier = 1.0 + (isLiveMode ? liveInventory.expansion : demoInventory.expansion) * 0.33; // Each purchase adds 33% to base

        // Update fog and other elements according to new size
        scene.fog.near = 20 * landExpansionMultiplier;
        scene.fog.far = worldSize * 0.7 * landExpansionMultiplier;
        
        // Update ground size
        if (زمین) {
            scene.remove(زمین);
            زمین.geometry.dispose();
            زمین.material.dispose();
        }
        const groundTexture = createGrassTexture(512,512);
        const groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture, side: THREE.DoubleSide, roughness: 0.8, metalness: 0.2 });
        const groundGeometry = new THREE.PlaneGeometry(worldSize * landExpansionMultiplier, worldSize * landExpansionMultiplier, 50, 50);
        زمین = new THREE.Mesh(groundGeometry, groundMaterial);
        زمین.rotation.x = -Math.PI / 2;
        زمین.receiveShadow = true;
        scene.add(زمین);
        // Make sure زمین is still at the bottom of the rendering order or correctly handled by worldObjects if it was part of it.
        // For simplicity, ensure it's re-added if it was tracked in worldObjects for collisions, though ground usually isn't for player movement.

        showGameMessage(`Land expanded! New area: ${Math.floor(worldSize * landExpansionMultiplier)}×${Math.floor(worldSize * landExpansionMultiplier)}`, 'success');
        return true; // Indicate success
      }

      function showGameMessage(message, type = 'info', timeout = 3000) {
        if (!messageBox) return;
        // Modified to handle hidden message box - don't show messages at all
      }

      if (reservesButton && farmStoreDropdown) {
          reservesButton.addEventListener('click', (event) => {
              event.stopPropagation();
              if (document.pointerLockElement === document.body) document.exitPointerLock();
              const isActive = farmStoreDropdown.classList.toggle('active');
              reservesButton.setAttribute('aria-expanded', isActive);
              if (isActive) updateReservesDisplay(); // Refresh disabled states when opening
          });
          document.addEventListener('click', (event) => {
              if (!reservesButton.contains(event.target) && !farmStoreDropdown.contains(event.target) && !paymentOptions.contains(event.target)) {
                  if (farmStoreDropdown.classList.contains('active')) {
                      farmStoreDropdown.classList.remove('active');
                      reservesButton.setAttribute('aria-expanded', 'false');
                  }
                  if (paymentOptions.style.display === 'block') {
                      paymentOptions.style.display = 'none';
                      currentPaymentItem = null;
                  }
              }
          });

          // Setup payment options
          document.querySelectorAll('.payment-option').forEach(option => {
              option.addEventListener('click', (e) => {
                  const paymentType = option.dataset.payment;
                  purchaseWithPayment(paymentType);
              });
          });
          
          // Handle third party farms view button
          const thirdPartyViewButton = document.querySelector('[data-action="show-third-party-farms"]');
          if (thirdPartyViewButton) {
            thirdPartyViewButton.addEventListener('click', (e) => {
                e.stopPropagation();
                thirdPartyFarmsSection.style.display = thirdPartyFarmsSection.style.display === 'block' ? 'none' : 'block';
            });
          }


          farmStoreDropdown.querySelectorAll('.dropdown-item').forEach(item => {
              const itemId = item.dataset.id;
              const itemType = item.dataset.type;
              const cost = parseInt(item.dataset.cost || '0');
              // maxPurchases is read inside updateReservesDisplay and purchaseWithPayment
              const purchaseButton = item.querySelector('.dropdown-item-price');

              if (purchaseButton) {
                  purchaseButton.addEventListener('click', (event) => {
                      event.stopPropagation();
                      
                      // Special cases for special actions
                      if (purchaseButton.dataset.action === 'show-third-party-farms') {
                          return; // This is handled separately
                      }
                      
                      // Land expansion direct purchase (using Stars)
                      if (itemType === 'land' && itemId === 'expansion') {
                          if (playerReserves >= cost) {
                            if (expandLand()) { // expandLand now checks max and returns true on success
                                playerReserves -= cost; // Deduct cost only if expansion was successful
                                updateReservesDisplay();
                            }
                          } else {
                              showGameMessage("Not enough stars for land expansion!", 'error');
                          }
                          return;
                      }
                      
                      // For regular items, show payment options
                      // This covers: data-action="get-chicken-farm", "get-third-party-farm" etc.
                      if (purchaseButton.dataset.action && purchaseButton.dataset.action.startsWith('get-')) {
                          // Get position for dropdown
                          const rect = purchaseButton.getBoundingClientRect();
                          paymentOptions.style.display = 'block';
                          paymentOptions.style.top = `${rect.bottom + 5}px`;
                          paymentOptions.style.left = `${rect.left - paymentOptions.offsetWidth + rect.width}px`;
                          
                          // Set the current payment item
                          currentPaymentItem = {
                              itemType: itemType,
                              itemId: itemId,
                              cost: cost // The cost from the item's data attribute
                          };
                          
                          // Update payment options display
                          document.getElementById('stars-price').textContent = cost; // Cost in stars
                          document.getElementById('dollar-price').textContent = `$${(cost / 100).toFixed(2)}`; // Example conversion for dollar price
                      }
                       // The old direct purchase logic with Stars is removed from here,
                       // as all "get-" actions now go through the payment options popup.
                       // Land expansion is handled above as a special case.
                  });
              }
          });
      }
      
      // Library button with aerial view functionality
      if (libraryButton) {
        libraryButton.addEventListener('click', (e) => {
          e.preventDefault();
          if (document.pointerLockElement === document.body) document.exitPointerLock();
          
          // Toggle aerial view
          toggleAerialView();
        });
      }
      
      // Setup mode selection popup
      document.querySelectorAll('.mode-option').forEach(option => {
        option.addEventListener('click', () => {
          const mode = option.dataset.mode;
          
          if (mode === 'demo') {
            // Show store with stars prices
            setAppMode(false); // Ensure demo mode and demo inventory is active
            farmStoreDropdown.classList.add('active');
            reservesButton.setAttribute('aria-expanded', 'true');
            updateReservesDisplay(); // Refresh store item states
          } else if (mode === 'live') {
            // Show Prast Farms popup
            prastFarmsPopup.style.display = 'block';
            const prastFarmsContent = prastFarmsPopup.querySelector('.prast-farms-content');
            prastFarmsContent.innerHTML = ''; 
            
            const searchContainerHTML = `
              <div class="search-container">
                <input type="text" class="search-input" placeholder="Search Prast Farms...">
                <button class="search-button"><i class="fas fa-search"></i></button>
              </div>`;
            prastFarmsContent.insertAdjacentHTML('beforeend', searchContainerHTML);
            
            farmStoreDropdown.querySelectorAll('.dropdown-item').forEach(originalItem => {
                if (originalItem.dataset.type !== 'land' &&
                    !originalItem.closest('#third-party-farms') &&
                    originalItem.dataset.action !== 'show-third-party-farms') {

                    const clone = originalItem.cloneNode(true);
                    const button = clone.querySelector('.dropdown-item-price');
                    const cost = parseInt(originalItem.dataset.cost || '0');

                    if (button) {
                        if (cost) { 
                            button.textContent = `$${(cost / 100).toFixed(2)}`;
                        } else {
                            button.textContent = 'Get'; 
                        }
                        button.disabled = false; 
                        button.addEventListener('click', () => {
                            if (!isLiveMode) setAppMode(true); 

                            const itemType = clone.dataset.type;
                            const itemId = clone.dataset.id;
                            
                            if (itemType === 'third-party') {
                                liveInventory[itemId] = (liveInventory[itemId] || 0) + 1;
                                showGameMessage(`Partnership with ${itemId.replace(/-/g, ' ')} initiated (LIVE)!`, 'success');
                            } else { 
                                liveInventory[itemId] = (liveInventory[itemId] || 0) + 1;
                                addPurchasedItemToWorld(itemType, itemId, liveInventory[itemId]);
                                showGameMessage(`${itemId.charAt(0).toUpperCase() + itemId.slice(1)} ${itemType === 'plant' ? 'seeds' : 'Farm'} partnership initiated (LIVE)!`, 'success');
                            }
                            
                            updateReservesDisplay(); 
                            prastFarmsPopup.style.display = 'none'; 
                        });
                    }
                    prastFarmsContent.appendChild(clone);
                }
            });

            // Add search functionality to the newly populated Prast Farms popup
            const prastSearchInput = prastFarmsContent.querySelector('.search-input');
            if (prastSearchInput) {
                prastSearchInput.addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    prastFarmsContent.querySelectorAll('.dropdown-item').forEach(item => {
                        const title = item.querySelector('.dropdown-item-title')?.textContent.toLowerCase() || '';
                        const desc = item.querySelector('.dropdown-item-desc')?.textContent.toLowerCase() || '';
                        item.style.display = (title.includes(searchTerm) || desc.includes(searchTerm)) ? 'flex' : 'none';
                    });
                });
            }
          }
          
          modeSelectionPopup.style.display = 'none'; 
        });
      });
      
      // Setup Prast Farms popup buttons
      const prastFarmsCloseButton = document.getElementById('prast-farms-close');
      if (prastFarmsCloseButton) {
        prastFarmsCloseButton.addEventListener('click', () => {
            prastFarmsPopup.style.display = 'none';
        });
      }
      
      const prastFarmsContinueButton = document.getElementById('prast-farms-continue');
      if (prastFarmsContinueButton) {
        prastFarmsContinueButton.addEventListener('click', () => {
            // This button might be redundant if items are purchased directly from the list.
            // If its purpose is just to confirm switching to live mode:
            if (!isLiveMode) {
                setAppMode(true);
                showGameMessage("Switched to LIVE mode! You can now partner with farms.", 'success');
            }
            prastFarmsPopup.style.display = 'none';
        });
      }
      
      function addPurchasedItemToWorld(itemType, itemId, count) {
        // Special handling for land expansion (already handled in its own function)
        if (itemType === 'land' && itemId === 'expansion') {
            return;
        }
        
        // Special handling for third party farms - they don't appear in the 3D world
        if (itemType === 'third-party') {
            // Message is typically shown by the purchase function.
            // This function is about adding visual representation, which third-party farms don't have.
            console.log(`Partnership established with ${itemId.replace(/-/g, ' ')}. No 3D model.`);
            return;
        }
      
        let itemGroup;
        if (itemType === 'animal') {
            itemGroup = createAnimalFarmStructure(itemId, count);
        } else if (itemType === 'plant') {
            itemGroup = createPlantPlot(itemId, count);
        } else {
            console.error("Unknown item type:", itemType);
            return;
        }

        // Position the item in the world
        const spacing = itemType === 'animal' ? 20 : 8; // Plants are smaller, closer spacing
        const itemsPerRow = itemType === 'animal' ? 5 : 10;
        
        // Filter existing world objects that are actual farm items (not trees, ground etc.)
        const existingFarmItems = worldObjects.filter(obj => obj.userData && obj.userData.itemType && (obj.userData.itemType === 'animal' || obj.userData.itemType === 'plant'));
        const itemIndex = existingFarmItems.length; // Index for new item placement

        const row = Math.floor(itemIndex / itemsPerRow);
        const col = itemIndex % itemsPerRow;

        itemGroup.position.set(
            (col - Math.floor(itemsPerRow/2) + 0.5) * spacing, // X position, +0.5 to center grid cell
            0,                                                 // Y position (on the ground)
            -30 - (row * spacing) - (itemType === 'animal' ? 0 : 20) // Z position, push plants further back or group differently
        );
        itemGroup.name = `${itemId}_${itemType}_${count}`; // Unique name for the instance
        itemGroup.userData = { itemType: itemType, itemId: itemId, instanceCount: count }; // Tag for easier filtering/identification
        scene.add(itemGroup);
        worldObjects.push(itemGroup); // Add to worldObjects for tracking or potential future interactions
      }

      function createAnimalFarmStructure(animalId, count) {
        const farmGroup = new THREE.Group();
        let baseColor, structureColor, animalColor, animalGeometry;
        const fenceHeight = 1.2, fencePostRadius = 0.1, fencePlankHeight = 0.15;
        const farmSize = (animalId === 'cow' || animalId === 'goat') ? 10 : 8; // Larger for bigger animals
        const structureSize = new THREE.Vector3(animalId === 'cow' ? 5 : 4, 2.5, animalId === 'cow' ? 4 : 3);

        // Minecraft-style blocky animals
        switch(animalId) {
            case 'chicken':
                baseColor = 0xD2B48C; structureColor = 0x8B4513; animalColor = 0xFFFFE0;
                animalGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.3); // Body
                break;
            case 'pig':
                baseColor = 0xFFC0CB; structureColor = 0xA0522D; animalColor = 0xFFA07A;
                animalGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.4); // Body
                break;
            case 'cow':
                baseColor = 0xBCB0A1; structureColor = 0x7A7061; animalColor = 0xFFFFFF; // White with black spots (texture later)
                animalGeometry = new THREE.BoxGeometry(1.5, 1.0, 0.7); // Body
                break;
            case 'goat':
                baseColor = 0xC0C0C0; structureColor = 0x505050; animalColor = 0xE0E0E0;
                animalGeometry = new THREE.BoxGeometry(1.0, 0.8, 0.5); // Body
                break;
            case 'fish': // Fish pond, no land structure like others
                return createFishPond(animalId, count); // Special handling
            default:
                baseColor = 0xCCCCCC; structureColor = 0x555555; animalColor = 0x999999;
                animalGeometry = new THREE.BoxGeometry(0.5,0.5,0.5);
        }

        const structureMaterial = new THREE.MeshStandardMaterial({ color: baseColor });
        const mainStructureMesh = new THREE.Mesh(new THREE.BoxGeometry(structureSize.x, structureSize.y, structureSize.z), structureMaterial);
        mainStructureMesh.castShadow = true; mainStructureMesh.receiveShadow = true;
        mainStructureMesh.position.y = structureSize.y / 2;
        farmGroup.add(mainStructureMesh);

        const roofMaterial = new THREE.MeshStandardMaterial({ color: structureColor });
        const roofMesh = new THREE.Mesh(new THREE.BoxGeometry(structureSize.x * 1.1, 0.3, structureSize.z * 1.1), roofMaterial);
        roofMesh.position.y = structureSize.y + 0.15;
        farmGroup.add(roofMesh);

        // Fence (similar logic as before, adapted for farmSize)
        const fenceMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown color for fence
        const postGeo = new THREE.CylinderGeometry(fencePostRadius, fencePostRadius, fenceHeight, 8);
        const plankGeoSide = new THREE.BoxGeometry(farmSize, fencePlankHeight, 0.1); // For front/back
        const plankGeoEnd = new THREE.BoxGeometry(0.1, fencePlankHeight, farmSize);   // For left/right (width becomes depth)


        // Create posts at corners
        const postPositions = [
            new THREE.Vector3(-farmSize / 2, fenceHeight / 2, -farmSize / 2),
            new THREE.Vector3(farmSize / 2, fenceHeight / 2, -farmSize / 2),
            new THREE.Vector3(-farmSize / 2, fenceHeight / 2, farmSize / 2),
            new THREE.Vector3(farmSize / 2, fenceHeight / 2, farmSize / 2)
        ];
        postPositions.forEach(pos => {
            const post = new THREE.Mesh(postGeo, fenceMaterial);
            post.position.copy(pos);
            post.castShadow = true;
            farmGroup.add(post);
        });

        // Create planks (2 levels)
        [0.3 * fenceHeight, 0.7 * fenceHeight].forEach(plankLevelY => {
            // Front plank
            const plankFront = new THREE.Mesh(plankGeoSide, fenceMaterial);
            plankFront.position.set(0, plankLevelY, farmSize / 2);
            plankFront.castShadow = true;
            farmGroup.add(plankFront);

            // Back plank
            const plankBack = new THREE.Mesh(plankGeoSide, fenceMaterial);
            plankBack.position.set(0, plankLevelY, -farmSize / 2);
            plankBack.castShadow = true;
            farmGroup.add(plankBack);
            
            // Left plank (rotated)
            const plankLeft = new THREE.Mesh(plankGeoSide, fenceMaterial); // Use same geometry, just rotate
            plankLeft.rotation.y = Math.PI / 2;
            plankLeft.position.set(-farmSize / 2, plankLevelY, 0);
            plankLeft.castShadow = true;
            farmGroup.add(plankLeft);

            // Right plank (rotated)
            const plankRight = new THREE.Mesh(plankGeoSide, fenceMaterial); // Use same geometry, just rotate
            plankRight.rotation.y = Math.PI / 2;
            plankRight.position.set(farmSize / 2, plankLevelY, 0);
            plankRight.castShadow = true;
            farmGroup.add(plankRight);
        });


        // Add blocky animals
        const animalMaterial = new THREE.MeshStandardMaterial({ color: animalColor });
        const numAnimals = (animalId === 'cow') ? 2 : (animalId === 'goat' ? 3 : 5); // Fewer cows
        const penCenterForAI = new THREE.Vector3(0,0,0); // Relative to farmGroup origin
        
        for (let i = 0; i < numAnimals; i++) {
            const animal = new THREE.Group(); // Group for body + legs if needed
            const body = new THREE.Mesh(animalGeometry, animalMaterial);
            body.castShadow = true;
            animal.add(body);

            // Simple legs for larger animals
            if (animalId === 'pig' || animalId === 'cow' || animalId === 'goat') {
                const legGeo = new THREE.BoxGeometry(0.2, 0.4, 0.2); // Adjusted leg size slightly
                const bodyParams = body.geometry.parameters;
                const legPositions = [
                    {x: bodyParams.width/2 * 0.7, z: bodyParams.depth/2 * 0.7},
                    {x: -bodyParams.width/2 * 0.7, z: bodyParams.depth/2 * 0.7},
                    {x: bodyParams.width/2 * 0.7, z: -bodyParams.depth/2 * 0.7},
                    {x: -bodyParams.width/2 * 0.7, z: -bodyParams.depth/2 * 0.7},
                ];
                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeo, animalMaterial);
                    // Position legs underneath the body
                    leg.position.set(pos.x, -bodyParams.height/2 - legGeo.parameters.height/2 + 0.1, pos.z);
                    animal.add(leg);
                });
                body.position.y = legGeo.parameters.height / 2 + 0.1; // Lift body to accommodate legs
            } else { // Chickens
                 body.position.y = animalGeometry.parameters.height / 2; // Chickens on ground
            }

            animal.position.set(
                (Math.random() - 0.5) * (farmSize - structureSize.x - 1), // Try to place outside structure
                0, // Y will be set by body/leg logic, animal group itself is at ground level
                (Math.random() - 0.5) * (farmSize - structureSize.z - 1)
            );
             // Ensure animals are somewhat clear of the main structure
            const clearance = 1.0; // Min distance from structure edge
            if (animal.position.x > -structureSize.x/2 - clearance && animal.position.x < structureSize.x/2 + clearance &&
                animal.position.z > -structureSize.z/2 - clearance && animal.position.z < structureSize.z/2 + clearance) {
                // If too close, try to push it away from structure center
                const pushDirectionX = (animal.position.x > 0 ? 1 : -1);
                const pushDirectionZ = (animal.position.z > 0 ? 1 : -1);
                animal.position.x = pushDirectionX * (structureSize.x/2 + clearance + Math.random()*0.5);
                animal.position.z = pushDirectionZ * (structureSize.z/2 + clearance + Math.random()*0.5);
            }
            // Clamp animal position to be within the fence
            const halfFarmSize = farmSize / 2 - (animalGeometry.parameters.width || 0.5); // Minus half animal width for buffer
            animal.position.x = Math.max(-halfFarmSize, Math.min(halfFarmSize, animal.position.x));
            animal.position.z = Math.max(-halfFarmSize, Math.min(halfFarmSize, animal.position.z));

            farmGroup.add(animal);

            if (animalId === 'chicken') { // Only chickens get AI for now
                 // Make sure farmGroup.position is set before this point if penCenter needs absolute coords
                 // For now, penCenter will be relative to the farmGroup's eventual position.
                 // When addPurchasedItemToWorld positions farmGroup, chickenAIMeshes.penCenter must be updated.
                chickenAIMeshes.push({
                    mesh: animal,
                    timer: Math.random() * 5,
                    targetPosition: new THREE.Vector3().copy(animal.position), // Start at current pos within farmGroup
                    penSize: farmSize, // The size of the fenced area
                    penCenter: farmGroup.position.clone().add(penCenterForAI) // Initial pen center, will be updated once farmGroup is placed
                });
            }
        }
        return farmGroup;
      }

      function createFishPond(itemId, count) {
        const pondGroup = new THREE.Group();
        const pondRadius = 4;
        const pondDepth = 1.5;

        // Water
        const waterGeo = new THREE.CylinderGeometry(pondRadius, pondRadius, pondDepth, 16);
        const waterMat = new THREE.MeshStandardMaterial({color: 0x4682B4, transparent: true, opacity: 0.6, roughness: 0.2, metalness: 0.1});
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.position.y = -pondDepth/2 + 0.1; // Slightly recessed so top is just below ground
        water.receiveShadow = true; // Water can receive shadows
        pondGroup.add(water);

        // Border
        const borderGeo = new THREE.TorusGeometry(pondRadius, 0.3, 8, 24);
        const borderMat = new THREE.MeshStandardMaterial({color: 0xAAAAAA, roughness:0.7});
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.rotation.x = Math.PI/2;
        border.position.y = 0.05; // Top of border slightly above ground
        border.castShadow = true;
        border.receiveShadow = true;
        pondGroup.add(border);

        // Fish (simple blocky fish)
        const fishGeo = new THREE.BoxGeometry(0.5, 0.2, 0.15);
        const fishMat = new THREE.MeshStandardMaterial({color: 0xFF8C00}); // Orange
        for(let i=0; i<5; i++) {
            const fish = new THREE.Mesh(fishGeo, fishMat);
            fish.position.set(
                (Math.random() - 0.5) * pondRadius * 1.5, // Spread within pond radius
                water.position.y + (pondDepth/2) - (Math.random() * (pondDepth * 0.8)) - 0.1, // Within water depth, slightly below surface
                (Math.random() - 0.5) * pondRadius * 1.5
            );
            fish.rotation.y = Math.random() * Math.PI * 2;
            fish.castShadow = true;
            pondGroup.add(fish);
        }
        return pondGroup;
      }

      function createPlantPlot(plantId, count) {
        const plotGroup = new THREE.Group();
        let plantColor1 = 0x228B22, plantColor2 = 0x006400; // Default greens
        let plantGeo1, plantGeo2;
        let scale = 1.0;

        switch(plantId) {
            case 'plantain': case 'banana':
                plantGeo1 = new THREE.CylinderGeometry(0.1, 0.2, 1.5, 6); // Stalk
                plantGeo2 = new THREE.SphereGeometry(0.6, 5, 4); // Leafy top
                plantColor1 = 0x8FBC8F; plantColor2 = 0x3CB371; scale = 1.2;
                break;
            case 'orange': case 'coconut': case 'papaya':
                plantGeo1 = new THREE.CylinderGeometry(0.15, 0.25, 1.2, 6); // Trunk
                plantGeo2 = new THREE.SphereGeometry(0.8, 6, 5); // Foliage
                plantColor1 = 0x8B4513; plantColor2 = 0x2E8B57; scale = 1.1;
                // Add fruit
                let fruitGeo, fruitMat, fruitCount = 0;
                if (plantId === 'orange') {
                    fruitGeo = new THREE.SphereGeometry(0.15, 5, 4);
                    fruitMat = new THREE.MeshStandardMaterial({color: 0xFF8C00}); // Orange
                    fruitCount = 3;
                } else if (plantId === 'coconut') {
                    fruitGeo = new THREE.SphereGeometry(0.2, 5, 4);
                    fruitMat = new THREE.MeshStandardMaterial({color: 0x8B4513}); // Brownish
                    fruitCount = 2;
                } else if (plantId === 'papaya') {
                    fruitGeo = new THREE.SphereGeometry(0.18, 5, 4); // More elliptical if possible, but sphere is fine
                    fruitMat = new THREE.MeshStandardMaterial({color: 0xFFD700}); // Yellow-Orange
                    fruitCount = 2;
                }
                if (fruitCount > 0) {
                    for(let f=0; f<fruitCount; f++) {
                        const fruit = new THREE.Mesh(fruitGeo, fruitMat);
                        fruit.castShadow = true;
                        // Position fruits within the foliage sphere (plantGeo2)
                        fruit.position.set(
                            (Math.random()-0.5) * (plantGeo2.parameters.radius * 0.8), 
                            1.2 + (plantGeo2.parameters.radius * 0.5) + (Math.random()-0.5) * (plantGeo2.parameters.radius * 0.5), 
                            (Math.random()-0.5) * (plantGeo2.parameters.radius * 0.8)
                        );
                        plotGroup.add(fruit);
                    }
                }
                break;
            case 'sugarcane':
                // Sugarcane is just stalks, no separate plantGeo2
                plantColor1 = 0x90EE90; // Light green
                scale = 1.0;
                for(let i=0; i<3; i++) { // Bundle of 3 stalks
                    const stalkHeight = 1.5 + Math.random() * 0.5;
                    const stalkGeo = new THREE.CylinderGeometry(0.05, 0.05, stalkHeight, 6);
                    const stalkMat = new THREE.MeshStandardMaterial({color: plantColor1});
                    const stalk = new THREE.Mesh(stalkGeo, stalkMat);
                    stalk.castShadow = true;
                    stalk.position.set(
                        (Math.random()-0.5)*0.3, 
                        stalkHeight/2, // Base on ground
                        (Math.random()-0.5)*0.3
                    );
                    stalk.rotation.set( // Slight random tilt
                        (Math.random()-0.5)*0.1, 0, (Math.random()-0.5)*0.1
                    );
                    plotGroup.add(stalk);
                }
                // Skip the generic part1/part2 addition for sugarcane
                plotGroup.scale.set(scale, scale, scale);
                return plotGroup; 
            case 'carrot':
                scale = 0.8;
                // Create soil patch
                const soilGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.15, 8); // Slightly thicker soil
                const soilMat = new THREE.MeshStandardMaterial({color: 0x5C4033}); // Darker brown
                const soil = new THREE.Mesh(soilGeo, soilMat);
                soil.position.y = -0.075; // Center it on ground
                soil.receiveShadow = true;
                plotGroup.add(soil);
                
                // Add multiple small carrot tops
                for(let i=0; i<5; i++) {
                    const leafClumpGeo = new THREE.SphereGeometry(0.15, 4, 3); // Small green leafy part
                    const leafClumpMat = new THREE.MeshStandardMaterial({color: 0x32CD32}); // Bright green
                    const leafClump = new THREE.Mesh(leafClumpGeo, leafClumpMat);
                    leafClump.castShadow = true;
                    
                    // Position carrots randomly within the soil patch circle
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * (0.8 - 0.15); // Within soil radius, minus leaf radius
                    leafClump.position.set(
                        Math.cos(angle) * radius,
                        0.1, // Tops just above soil line
                        Math.sin(angle) * radius
                    );
                    plotGroup.add(leafClump);
                    
                    // Add a small carrot cone sticking out (optional, mostly buried)
                    if (Math.random() > 0.5) { // Some carrots might show a bit
                        const carrotTopGeo = new THREE.ConeGeometry(0.05, 0.1, 4);
                        const carrotTopMat = new THREE.MeshStandardMaterial({color: 0xFF8C00}); // Orange
                        const carrotTop = new THREE.Mesh(carrotTopGeo, carrotTopMat);
                        carrotTop.castShadow = true;
                        carrotTop.position.copy(leafClump.position);
                        carrotTop.position.y = 0.02; // Tip slightly visible
                        // carrotTop.rotation.x = Math.PI; // Pointing down, already default for cone base
                        plotGroup.add(carrotTop);
                    }
                }
                plotGroup.scale.set(scale, scale, scale);
                return plotGroup; // Skip generic part1/part2 for carrot
            default:
                plantGeo1 = new THREE.BoxGeometry(0.3, 0.8, 0.3); // Fallback generic plant
                break;
        }

        // For standard plant types that use the trunk/foliage pattern
        if (plantGeo1) {
            const mat1 = new THREE.MeshStandardMaterial({color: plantColor1});
            const part1 = new THREE.Mesh(plantGeo1, mat1);
            part1.castShadow = true;
            part1.position.y = (plantGeo1.parameters.height || 0.8) / 2; // Base on ground
            plotGroup.add(part1);

            if (plantGeo2) {
                const mat2 = new THREE.MeshStandardMaterial({color: plantColor2});
                const part2 = new THREE.Mesh(plantGeo2, mat2);
                part2.castShadow = true;
                // Position foliage on top of the trunk
                part2.position.y = (plantGeo1.parameters.height || 0.8) -0.1 + (plantGeo2.parameters.radius || 0.3) * 0.5; 
                plotGroup.add(part2);
            }
        }

        plotGroup.scale.set(scale, scale, scale);
        return plotGroup;
      }
        // Add search functionality to the main store dropdown
        const mainStoreSearchInput = farmStoreDropdown.querySelector('.search-input');
        if (mainStoreSearchInput) {
            mainStoreSearchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                farmStoreDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                    // Ensure not to hide special sections like "THIRD PARTY FARMS" header or prompts unless they are part of item filtering
                    if (item.classList.contains('third-party-prompt') || item.textContent.toUpperCase() === 'THIRD PARTY FARMS' || item.querySelector('.shop-header-notice') || item.matches('hr') || item.classList.contains('px-2')) {
                        // Keep these structural elements visible unless explicitly part of search logic for them
                        return;
                    }
                    const title = item.querySelector('.dropdown-item-title')?.textContent.toLowerCase() || '';
                    const desc = item.querySelector('.dropdown-item-desc')?.textContent.toLowerCase() || '';
                    item.style.display = (title.includes(searchTerm) || desc.includes(searchTerm)) ? 'flex' : 'none';
                });
            });
        }

        // Add search functionality to the third-party farms section (if it's separate)
        const thirdPartySearchInput = thirdPartyFarmsSection.querySelector('.search-input');
        if (thirdPartySearchInput) {
            thirdPartySearchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                thirdPartyFarmsSection.querySelectorAll('.dropdown-item').forEach(item => {
                    const title = item.querySelector('.dropdown-item-title')?.textContent.toLowerCase() || '';
                    const desc = item.querySelector('.dropdown-item-desc')?.textContent.toLowerCase() || '';
                    item.style.display = (title.includes(searchTerm) || desc.includes(searchTerm)) ? 'flex' : 'none';
                });
            });
        }
      initThreeJS();
      updateReservesDisplay();
      // showGameMessage("Tap ENTER to begin.", "info"); // Message box is hidden

    });
  </script>
</body>
</html>