<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Prast Farms</title>
    <link rel="icon" href="logo.jpg" type="image/jpeg" onerror="this.onerror=null; this.href='https://placehold.co/32x32/030712/FFFFFF?text=PF';">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet"/>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
      integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      html {
        font-size: 100%;
        scroll-behavior: smooth;
      }
      body {
        font-family: 'Space Grotesk', sans-serif;
        background-color: #030712; /* gray-950 */
        overflow: hidden;
        position: relative;
        margin: 0;
        color: #E5E7EB;
      }

      .top-nav {
        background-color: rgba(3, 7, 18, 0.8);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(55, 65, 81, 0.5);
        height: 70px;
      }

      #blobs-container {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        overflow: hidden; pointer-events: none; z-index: -2;
      }
      .interactive-blob {
        position: absolute; border-radius: 50%; filter: blur(120px);
        opacity: 0.20; mix-blend-mode: screen; transition: background-color 2s ease-in-out; /* Slightly less opaque */
      }

      #game-container {
        position: fixed; top: 70px; left: 0;
        width: 100vw; height: calc(100vh - 70px);
        z-index: 1; cursor: grab; /* Indicate it's interactive */
      }
      #game-container.pointer-locked {
        cursor: none; /* Hide cursor when locked */
      }
      canvas { display: block; }

      #game-ui {
        position: fixed; top: 80px; left: 10px; z-index: 10;
        color: white; background-color: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; font-size: 0.9rem;
      }
      #message-box {
        position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
        background-color: rgba(23, 37, 84, 0.9); color: white; padding: 15px 25px;
        border-radius: 8px; z-index: 100; opacity: 0;
        transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
        border: 1px solid rgba(79, 70, 229, 0.7); box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        text-align: center; max-width: 80%;
      }
      #message-box.visible { opacity: 1; transform: translateX(-50%) translateY(-20px); }

      .star-button-container { position: relative; z-index: 50; }
      .star-button { /* Renamed from reserves-button for consistency, but ID is reserves-button */
        background-color: rgba(17, 24, 39, 0.7); backdrop-filter: blur(8px); border: 1px solid rgba(55, 65, 81, 0.6);
        transition: all 0.3s ease; padding: 0.5rem 1rem; border-radius: 9999px; display: flex; align-items: center; gap: 0.5rem;
        font-size: 0.875rem; color: #D1D5DB; cursor: pointer;
      }
      .star-button .fa-star { color: #FACC15; /* Tailwind yellow-400 */ margin-right: 0.25rem;}
      .star-button:hover { border-color: rgba(255, 255, 255, 0.7); background-color: rgba(17, 24, 39, 0.9); color: #ffffff; }
      .star-dropdown {
        position: absolute; top: calc(100% + 0.5rem); right: 0; background-color: rgba(31, 41, 55, 0.95); backdrop-filter: blur(12px);
        border: 1px solid rgba(75, 85, 99, 0.7); border-radius: 0.75rem; padding: 0.75rem; width: 340px; /* Slightly wider */
        z-index: 60; opacity: 0; visibility: hidden; transform: translateY(-10px) scale(0.98);
        transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s ease;
        display: flex; flex-direction: column; gap: 0.75rem; box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        max-height: 70vh; overflow-y: auto; /* Scrollable dropdown */
      }
      .star-dropdown.active { opacity: 1; visibility: visible; transform: translateY(0) scale(1); }
      .dropdown-item {
        display: flex; align-items: center; padding: 0.75rem; background-color: rgba(55, 65, 81, 0.6); border-radius: 0.5rem;
        transition: background-color 0.2s ease, transform 0.15s ease; cursor: pointer; border: 1px solid transparent;
      }
      .dropdown-item:hover { background-color: rgba(75, 85, 99, 0.8); transform: translateX(4px); border-color: rgba(107, 114, 128, 0.7); }
      .dropdown-item-icon {
        width: 40px; height: 40px; border-radius: 0.375rem; margin-right: 0.75rem;
        object-fit: cover; flex-shrink: 0; border: 1px solid rgba(75, 85, 99, 0.5);
        display: flex; align-items: center; justify-content: center; font-size: 1.5rem; /* For emoji/text placeholders */
      }
      .dropdown-item-content { flex-grow: 1; margin-right: 0.5rem; }
      .dropdown-item-title { color: #F3F4F6; font-weight: 500; font-size: 0.875rem; line-height: 1.2; margin-bottom: 2px; }
      .dropdown-item-desc { color: #9CA3AF; font-size: 0.75rem; line-height: 1.3; }
      .dropdown-item-price {
        background-color: #4B5563; color: #ffffff; font-size: 0.75rem; font-weight: 600; padding: 0.35rem 0.7rem; border-radius: 9999px;
        transition: all 0.2s ease; white-space: nowrap; border: none; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      .dropdown-item:hover .dropdown-item-price:not([disabled]) { background-color: #374151; transform: scale(1.05); }
      .dropdown-item-price[disabled] { background-color: #374151; color: #6b7280; cursor: not-allowed; opacity: 0.6; }
      .dropdown-item-price[disabled]:hover { background-color: #374151; transform: none; }

      .particle {
        position: fixed; border-radius: 50%; pointer-events: none; z-index: 5;
        opacity: 0; animation: particleFade 3s ease-out forwards;
      }
      @keyframes particleFade {
        0% { opacity: 0.7; transform: translate(0, 0) scale(1); }
        100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(0.5); }
      }

      .game-footer {
          position: fixed; bottom: 0; left: 0; width: 100%;
          background-color: rgba(3, 7, 18, 0.7); backdrop-filter: blur(5px);
          padding: 0.5rem 1rem; text-align: center; font-size: 0.75rem; color: #9CA3AF;
          z-index: 50; border-top: 1px solid rgba(55, 65, 81, 0.3);
      }
      .crosshair {
        position: fixed; top: 50%; left: 50%; width: 10px; height: 10px;
        border: 1px solid white; background-color: rgba(255,255,255,0.3);
        border-radius: 50%; transform: translate(-50%, -50%);
        pointer-events: none; z-index: 1000; display: none;
      }
    </style>
</head>
<body class="text-gray-100 min-h-screen flex flex-col">
  <div id="blobs-container">
      <div class="interactive-blob blob-1" style="top:-10%; left:-15%; width:60vw; height:60vw;"></div>
      <div class="interactive-blob blob-2" style="bottom:-20%; right:-15%; width:55vw; height:55vw;"></div>
  </div>

  <nav class="top-nav fixed top-0 left-0 right-0 z-50">
    <div class="mx-auto h-full flex items-center justify-between px-4 sm:px-6">
      <div class="flex items-center gap-3">
        <i class="fa-solid fa-tractor text-amber-400 text-2xl"></i>
        <span class="text-xl font-bold text-amber-400 group-hover:text-white transition-colors duration-200">Prast Farms</span>
      </div>
      <div class="flex items-center gap-4">
        <a href="#" id="records-button" class="group flex items-center gap-2 bg-gray-800/60 hover:bg-gray-700/80 border border-gray-700 hover:border-gray-500 px-4 py-2 rounded-full transition-all duration-300 text-gray-300 hover:text-white text-sm">
          <i class="fa-solid fa-book text-sm"></i>
          <span class="hidden sm:inline">Records</span>
        </a>
        <div class="star-button-container">
          <button id="reserves-button" class="star-button" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-star"></i> <span id="reserves-amount">2000</span>
          </button>
          <div id="farm-store-dropdown" class="star-dropdown" role="menu">
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="chicken" data-cost="500">
               <div class="dropdown-item-icon bg-yellow-700">üêî</div>
               <div class="dropdown-item-content">
                 <div class="dropdown-item-title">Chicken Farm</div>
                 <div class="dropdown-item-desc">80% annual return. Produces eggs.</div>
               </div>
               <button class="dropdown-item-price" data-action="buy-chicken-farm">$500</button>
             </div>
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="pig" data-cost="1000">
               <div class="dropdown-item-icon bg-pink-400">üêñ</div>
               <div class="dropdown-item-content">
                 <div class="dropdown-item-title">Pig Farm</div>
                 <div class="dropdown-item-desc">100% annual return. Hardy animals.</div>
               </div>
               <button class="dropdown-item-price" data-action="buy-pig-farm">$1000</button>
             </div>
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="cow" data-cost="2499">
                <div class="dropdown-item-icon bg-gray-400">üêÑ</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Cow Farm</div>
                  <div class="dropdown-item-desc">130% annual return. Milk and more.</div>
                </div>
                <button class="dropdown-item-price" data-action="buy-cow-farm">$2499</button>
              </div>
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="goat" data-cost="749">
                <div class="dropdown-item-icon bg-stone-400">üêê</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Goat Farm</div>
                  <div class="dropdown-item-desc">60% annual return. Agile climbers.</div>
                </div>
                <button class="dropdown-item-price" data-action="buy-goat-farm">$749</button>
              </div>
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="fish" data-cost="99">
                <div class="dropdown-item-icon bg-sky-400">üêü</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Fish Pond</div>
                  <div class="dropdown-item-desc">60% annual return. Fresh catches.</div>
                </div>
                <button class="dropdown-item-price" data-action="buy-fish-farm">$99</button>
              </div>
              <hr class="border-gray-600 my-2">
              <div class="px-2 py-1 text-xs text-gray-400 uppercase">Plants (Max 1 Each)</div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="plantain" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-lime-600">üçå</div> <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Plantain Seeds</div>
                  <div class="dropdown-item-desc">~50% annual return. Versatile fruit.</div>
                </div>
                <button class="dropdown-item-price" data-action="buy-plantain">$50</button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="banana" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-yellow-500">üçå</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Banana Sapling</div>
                  <div class="dropdown-item-desc">~50% annual return. Sweet yield.</div>
                </div>
                <button class="dropdown-item-price" data-action="buy-banana">$50</button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="orange" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-orange-500">üçä</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Orange Tree Seedling</div>
                  <div class="dropdown-item-desc">~50% annual return. Juicy harvest.</div>
                </div>
                <button class="dropdown-item-price" data-action="buy-orange">$50</button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="sugarcane" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-green-700">üåø</div> <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Sugar Cane Stalk</div>
                  <div class="dropdown-item-desc">~50% annual return. Sweet raw material.</div>
                </div>
                <button class="dropdown-item-price" data-action="buy-sugarcane">$50</button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="coconut" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-yellow-800">ü••</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Coconut Seed</div>
                  <div class="dropdown-item-desc">~50% annual return. Tropical delight.</div>
                </div>
                <button class="dropdown-item-price" data-action="buy-coconut">$50</button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="papaya" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-orange-400">ü•≠</div> <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Papaya Seeds</div>
                  <div class="dropdown-item-desc">~50% annual return. Exotic fruit.</div>
                </div>
                <button class="dropdown-item-price" data-action="buy-papaya">$50</button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="carrot" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-orange-600">ü•ï</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Carrot Seeds</div>
                  <div class="dropdown-item-desc">~50% annual return. Root vegetable.</div>
                </div>
                <button class="dropdown-item-price" data-action="buy-carrot">$50</button>
              </div>
            </div>
        </div>
      </div>
    </div>
  </nav>

  <div id="game-container">
    </div>
  <div class="crosshair" id="crosshair"></div>

  <div id="game-ui">
    <p>Move: WASD | Look: Mouse | Jump: Space</p>
    <p>Toggle Mouse Lock: L | Toggle Weather: P (dev)</p>
  </div>

  <div id="message-box">Sample Message</div>

  <footer class="game-footer">
    ¬© 2025 Prast Farms. All rights reserved. (Enhanced 3D Experience)
  </footer>

  <script>
    // Ensure THREE is available
    if (typeof THREE === 'undefined') {
        alert("THREE.js failed to load. Game cannot start.");
        // Potentially load it dynamically or show a more graceful error
    }

    document.addEventListener('DOMContentLoaded', () => {
      const gameContainer = document.getElementById('game-container');
      const reservesButton = document.getElementById('reserves-button');
      const reservesAmountSpan = document.getElementById('reserves-amount');
      const farmStoreDropdown = document.getElementById('farm-store-dropdown');
      const recordsButton = document.getElementById('records-button');
      const messageBox = document.getElementById('message-box');
      const crosshair = document.getElementById('crosshair');

      let playerReserves = 2000;
      // Stores counts for animals, and a flag (1 if purchased) for plants
      let purchasedItems = {
        chicken: 0, pig: 0, cow: 0, goat: 0, fish: 0,
        plantain: 0, banana: 0, orange: 0, sugarcane: 0, coconut: 0, papaya: 0, carrot: 0
      };

      let scene, camera, renderer, player, ÿ≤ŸÖ€åŸÜ;
      let playerVelocity = new THREE.Vector3();
      let playerOnGround = false;
      const playerHeight = 1.8; // Player's eye height
      const playerCapsuleRadius = 0.4; // For potential future capsule collision
      const playerSpeed = 8.0;
      const playerJumpForce = 7.0;
      const gravity = -20.0;
      let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
      let worldObjects = []; // For farms, plants, trees, stream for potential interaction/collision
      let chickenAIMeshes = []; // Store chickens that need AI updates

      // Weather variables
      let isRaining = false;
      let rainParticles, rainMaterial;
      let lightningActive = false;
      let lightningTimeout, nextLightningStrikeTimeout;
      let clouds = [];
      const initialFogColor = new THREE.Color(0x87CEEB);
      const rainFogColor = new THREE.Color(0x5A6A7B); // Darker, grayish blue

      function initThreeJS() {
        scene = new THREE.Scene();
        scene.background = initialFogColor.clone();
        scene.fog = new THREE.Fog(scene.background, 50, 200); // Adjusted fog start

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight - 70), 0.1, 1000); // Increased far plane
        camera.position.set(0, playerHeight, 0); // Camera is at player's eye level within player object

        player = new THREE.Object3D();
        player.position.set(0, playerHeight / 2, 5); // Player object center, feet on ground
        scene.add(player);
        player.add(camera);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight - 70);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        gameContainer.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Slightly brighter
        directionalLight.position.set(50, 80, 30); // Higher and more angled
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096; // Increased shadow map size
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 200; // Adjusted shadow camera far
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);
        // const helper = new THREE.CameraHelper( directionalLight.shadow.camera ); scene.add( helper );

        // Improved Ground (ÿ≤ŸÖ€åŸÜ) with Texture
        const groundTexture = createGrassTexture(512,512);
        const groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture, side: THREE.DoubleSide, roughness: 0.8, metalness: 0.2 });
        const groundGeometry = new THREE.PlaneGeometry(300, 300, 50, 50); // Added segments for potential displacement
        ÿ≤ŸÖ€åŸÜ = new THREE.Mesh(groundGeometry, groundMaterial);
        ÿ≤ŸÖ€åŸÜ.rotation.x = -Math.PI / 2;
        ÿ≤ŸÖ€åŸÜ.receiveShadow = true;
        scene.add(ÿ≤ŸÖ€åŸÜ);
        worldObjects.push(ÿ≤ŸÖ€åŸÜ);


        createEnvironmentFeatures(); // Trees, stream, clouds
        setupControls();
        animate();
        window.addEventListener('resize', onWindowResize, false);
        updateReservesDisplay();
      }
      
      function createGrassTexture(width, height) {
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const context = canvas.getContext('2d');

          // Base green color
          context.fillStyle = `rgb(${Math.floor(30 + Math.random()*10)}, ${Math.floor(100 + Math.random()*30)}, ${Math.floor(30 + Math.random()*10)})`;
          context.fillRect(0, 0, width, height);

          // Add some variations
          for (let i = 0; i < 20000; i++) { // More speckles for detail
              const x = Math.random() * width;
              const y = Math.random() * height;
              const r = Math.floor(20 + Math.random() * 20); // Darker greens
              const g = Math.floor(90 + Math.random() * 40);
              const b = Math.floor(20 + Math.random() * 20);
              const alpha = Math.random() * 0.5 + 0.3; // Vary opacity
              context.fillStyle = `rgba(${r},${g},${b},${alpha})`;
              context.fillRect(x, y, Math.random()*2+1, Math.random()*2+1); // Vary speckle size
          }
          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(20, 20); // How many times texture repeats on ground
          return texture;
      }


      function createEnvironmentFeatures() {
        // Trees
        for (let i = 0; i < 50; i++) { // More trees
            const tree = createTree();
            tree.position.set(
                (Math.random() - 0.5) * 280, // Spread over ground
                0,
                (Math.random() - 0.5) * 280
            );
            // Avoid placing trees too close to initial spawn or center farm area
            if (tree.position.length() > 30) { // Don't place too close to origin (0,0,0)
                 scene.add(tree);
                 worldObjects.push(tree);
            }
        }

        // Stream
        const stream = createStream();
        stream.position.set(0, 0.05, -50); // Position it in the world
        scene.add(stream);
        worldObjects.push(stream);

        // Clouds
        for (let i = 0; i < 15; i++) {
            const cloud = createCloud();
            cloud.position.set(
                (Math.random() - 0.5) * 300,
                Math.random() * 20 + 60, // Cloud height
                (Math.random() - 0.5) * 300
            );
            scene.add(cloud);
            clouds.push(cloud);
        }
      }

      function createTree() {
        const treeGroup = new THREE.Group();
        // Trunk
        const trunkHeight = Math.random() * 4 + 4; // Vary height
        const trunkRadius = Math.random() * 0.2 + 0.3;
        const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.7, trunkRadius, trunkHeight, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 }); // Brown
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.castShadow = true;
        trunk.position.y = trunkHeight / 2;
        treeGroup.add(trunk);

        // Leaves (multiple spheres for a fuller look)
        const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // ForestGreen
        const numLeafBlobs = Math.floor(Math.random() * 3) + 3;
        for(let i=0; i < numLeafBlobs; i++) {
            const leafRadius = Math.random() * 1.5 + 1.5;
            const leavesGeometry = new THREE.SphereGeometry(leafRadius, 6, 5);
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.castShadow = true;
            leaves.position.set(
                (Math.random() - 0.5) * leafRadius * 0.5, // Slight horizontal offset
                trunkHeight + (Math.random() - 0.3) * leafRadius * 0.6, // Overlap with trunk and each other
                (Math.random() - 0.5) * leafRadius * 0.5  // Slight depth offset
            );
            treeGroup.add(leaves);
        }
        return treeGroup;
      }

      function createStream() {
        const streamGroup = new THREE.Group();
        const streamWidth = 4;
        const streamLength = 200;
        const streamDepth = 0.2;

        // Water Surface
        const waterGeometry = new THREE.PlaneGeometry(streamWidth, streamLength, 10, 50); // Segments for animation
        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x3399FF,
            transparent: true,
            opacity: 0.7,
            roughness: 0.2,
            metalness: 0.1,
        });
        const waterSurface = new THREE.Mesh(waterGeometry, waterMaterial);
        waterSurface.rotation.x = -Math.PI / 2;
        waterSurface.position.y = -streamDepth / 2 + 0.01; // Slightly above bed
        streamGroup.add(waterSurface);

        // Stream Bed
        const bedMaterial = new THREE.MeshStandardMaterial({ color: 0x967969 }); // Muddy brown
        const bedGeometry = new THREE.BoxGeometry(streamWidth + 1, streamDepth, streamLength);
        const streamBed = new THREE.Mesh(bedGeometry, bedMaterial);
        streamBed.position.y = -streamDepth; // Below surface
        streamBed.receiveShadow = true;
        streamGroup.add(streamBed);
        
        // Store for animation
        streamGroup.userData.waterSurface = waterSurface;
        streamGroup.userData.time = 0;

        return streamGroup;
      }
      
      function createCloud() {
        const cloudGroup = new THREE.Group();
        const baseMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.85,
            flatShading: true // Gives a more cartoony, low-poly look
        });

        const numBlobs = Math.floor(Math.random() * 4) + 3; // 3 to 6 blobs per cloud
        for (let i = 0; i < numBlobs; i++) {
            const blobSize = Math.random() * 8 + 5; // Size of each blob
            const blobGeometry = new THREE.SphereGeometry(blobSize, 5, 4); // Low poly spheres
            const blobMesh = new THREE.Mesh(blobGeometry, baseMaterial);
            blobMesh.position.set(
                (Math.random() - 0.5) * blobSize * 1.5, // Overlap them
                (Math.random() - 0.5) * blobSize * 0.5,
                (Math.random() - 0.5) * blobSize * 1.0
            );
            blobMesh.castShadow = true; // Clouds can cast soft shadows
            cloudGroup.add(blobMesh);
        }
        cloudGroup.scale.y = Math.random() * 0.3 + 0.6; // Make some clouds flatter
        return cloudGroup;
      }


      function onWindowResize() {
        camera.aspect = window.innerWidth / (window.innerHeight - 70);
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight - 70);
      }

      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);
        const deltaTime = clock.getDelta();

        if (document.pointerLockElement === document.body || gameContainer.classList.contains('pointer-locked')) {
            updatePlayer(deltaTime);
        }
        
        // Animate stream water
        worldObjects.forEach(obj => {
            if (obj.userData.waterSurface) {
                obj.userData.time += deltaTime * 0.5;
                const vertices = obj.userData.waterSurface.geometry.attributes.position;
                for (let i = 0; i < vertices.count; i++) {
                    const y = vertices.getY(i); // Get original Y (which is Z in world space for plane)
                    vertices.setZ(i, Math.sin(y * 0.5 + obj.userData.time) * 0.1); // Animate Z (which is Y in world space)
                }
                vertices.needsUpdate = true;
            }
        });

        // Animate clouds
        clouds.forEach(cloud => {
            cloud.position.x += deltaTime * (Math.random()*1+0.5); // Vary speed slightly
            if (cloud.position.x > 200) { // Reset cloud position if it goes too far
                cloud.position.x = -200;
                cloud.position.z = (Math.random() - 0.5) * 300; // New Z position
            }
        });
        
        // Chicken AI
        chickenAIMeshes.forEach(chickenData => {
            chickenData.timer -= deltaTime;
            if (chickenData.timer <= 0) {
                // New random direction within pen
                const penSize = chickenData.penSize - 0.5; // keep inside fence
                chickenData.targetPosition.set(
                    (Math.random() - 0.5) * penSize,
                    chickenData.mesh.position.y, // Keep y fixed
                    (Math.random() - 0.5) * penSize
                ).add(chickenData.penCenter); // Relative to pen center

                chickenData.timer = Math.random() * 3 + 2; // Next change in 2-5 seconds
            }
            // Move towards target
            const direction = new THREE.Vector3().subVectors(chickenData.targetPosition, chickenData.mesh.position);
            if (direction.lengthSq() > 0.01) {
                direction.normalize();
                chickenData.mesh.position.addScaledVector(direction, deltaTime * 0.5); // Chicken speed
                // Make chicken look in direction of movement (simple)
                chickenData.mesh.lookAt(chickenData.targetPosition.x, chickenData.mesh.position.y , chickenData.targetPosition.z);

            }
        });

        if (isRaining) updateRain(deltaTime);

        renderer.render(scene, camera);
      }

      function setupControls() {
        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);

        // Pointer Lock toggle instead of automatic
        // gameContainer.addEventListener('click', () => {
        //   if (!document.pointerLockElement) document.body.requestPointerLock();
        // });

        document.addEventListener('pointerlockchange', () => {
          if (document.pointerLockElement === document.body) {
            crosshair.style.display = 'block';
            gameContainer.classList.add('pointer-locked');
          } else {
            crosshair.style.display = 'none';
            gameContainer.classList.remove('pointer-locked');
            moveForward = false; moveBackward = false; moveLeft = false; moveRight = false;
          }
        }, false);
      }

      function onMouseMove(event) {
        if (document.pointerLockElement === document.body) {
          const movementX = event.movementX || 0;
          const movementY = event.movementY || 0;
          player.rotation.y -= movementX * 0.002;
          camera.rotation.x -= movementY * 0.002;
          camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }
      }

      function onKeyDown(event) {
        if (event.code === 'KeyL') { // Toggle pointer lock with 'L'
            if (document.pointerLockElement === document.body) {
                document.exitPointerLock();
            } else {
                document.body.requestPointerLock();
            }
        }
        if (event.code === 'KeyP') { // Dev key to toggle weather
            toggleWeather();
        }

        if (document.pointerLockElement !== document.body && !['KeyL', 'KeyP', 'Escape'].includes(event.code) ) return; // Only allow L, P, Esc if not locked

        switch (event.code) {
          case 'KeyW': case 'ArrowUp': moveForward = true; break;
          case 'KeyS': case 'ArrowDown': moveBackward = true; break;
          case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
          case 'KeyD': case 'ArrowRight': moveRight = true; break;
          case 'Space': if (playerOnGround) playerVelocity.y = playerJumpForce; break;
          case 'Escape':
            if (document.pointerLockElement === document.body) document.exitPointerLock();
            if (farmStoreDropdown.classList.contains('active')) {
                farmStoreDropdown.classList.remove('active');
                reservesButton.setAttribute('aria-expanded', 'false');
            }
            break;
        }
      }

      function onKeyUp(event) {
        switch (event.code) {
          case 'KeyW': case 'ArrowUp': moveForward = false; break;
          case 'KeyS': case 'ArrowDown': moveBackward = false; break;
          case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
          case 'KeyD': case 'ArrowRight': moveRight = false; break;
        }
      }

      function updatePlayer(deltaTime) {
        const moveSpeed = playerSpeed * deltaTime;
        const moveDirection = new THREE.Vector3(); // For movement calculation
        const cameraDirection = new THREE.Vector3(); // For camera orientation
        camera.getWorldDirection(cameraDirection);
        cameraDirection.y = 0;
        cameraDirection.normalize();

        const right = new THREE.Vector3().crossVectors(camera.up, cameraDirection).normalize();

        if (moveForward) moveDirection.add(cameraDirection);
        if (moveBackward) moveDirection.sub(cameraDirection);
        if (moveLeft) moveDirection.sub(right);
        if (moveRight) moveDirection.add(right);
        
        moveDirection.normalize(); // Ensure consistent speed regardless of diagonal movement
        player.position.addScaledVector(moveDirection, moveSpeed);


        playerVelocity.y += gravity * deltaTime;
        player.position.y += playerVelocity.y * deltaTime;

        if (player.position.y < playerHeight / 2) {
          player.position.y = playerHeight / 2;
          playerVelocity.y = 0;
          playerOnGround = true;
        } else {
          playerOnGround = false;
        }
        
        const worldBoundary = 145;
        player.position.x = Math.max(-worldBoundary, Math.min(worldBoundary, player.position.x));
        player.position.z = Math.max(-worldBoundary, Math.min(worldBoundary, player.position.z));
      }

      function updateReservesDisplay() {
        if (reservesAmountSpan) reservesAmountSpan.textContent = playerReserves;
        farmStoreDropdown.querySelectorAll('.dropdown-item').forEach(item => {
            const cost = parseInt(item.dataset.cost);
            const itemId = item.dataset.id;
            const itemType = item.dataset.type;
            const maxPurchases = item.dataset.max ? parseInt(item.dataset.max) : Infinity;
            const button = item.querySelector('.dropdown-item-price');

            if (button) {
                let alreadyMaxed = false;
                if (itemType === 'plant' && purchasedItems[itemId] >= maxPurchases) {
                    alreadyMaxed = true;
                }
                button.disabled = playerReserves < cost || alreadyMaxed;
                if (alreadyMaxed) {
                    button.textContent = "Owned";
                } else {
                    button.textContent = `$${cost}`;
                }
            }
        });
      }

      if (reservesButton && farmStoreDropdown) {
          reservesButton.addEventListener('click', (event) => {
              event.stopPropagation();
              if (document.pointerLockElement === document.body) document.exitPointerLock();
              const isActive = farmStoreDropdown.classList.toggle('active');
              reservesButton.setAttribute('aria-expanded', isActive);
              if (isActive) updateReservesDisplay(); // Refresh disabled states when opening
          });
          document.addEventListener('click', (event) => {
              if (!reservesButton.contains(event.target) && !farmStoreDropdown.contains(event.target)) {
                  if (farmStoreDropdown.classList.contains('active')) {
                      farmStoreDropdown.classList.remove('active');
                      reservesButton.setAttribute('aria-expanded', 'false');
                  }
              }
          });

          farmStoreDropdown.querySelectorAll('.dropdown-item').forEach(item => {
              const itemId = item.dataset.id;
              const itemType = item.dataset.type;
              const cost = parseInt(item.dataset.cost);
              const maxPurchases = item.dataset.max ? parseInt(item.dataset.max) : Infinity;
              const purchaseButton = item.querySelector('.dropdown-item-price');

              if (purchaseButton) {
                  purchaseButton.addEventListener('click', (event) => {
                      event.stopPropagation();
                      if (playerReserves >= cost && purchasedItems[itemId] < maxPurchases) {
                          playerReserves -= cost;
                          purchasedItems[itemId]++;
                          updateReservesDisplay();
                          addPurchasedItemToWorld(itemType, itemId, purchasedItems[itemId]);
                          showGameMessage(`${itemId.charAt(0).toUpperCase() + itemId.slice(1)} ${itemType === 'plant' ? 'seeds' : 'Farm'} purchased!`, 'success');
                          if (purchasedItems[itemId] >= maxPurchases || itemType === 'plant') { // Auto-close if maxed or it's a single plant
                              farmStoreDropdown.classList.remove('active');
                              reservesButton.setAttribute('aria-expanded', 'false');
                          }
                      } else if (purchasedItems[itemId] >= maxPurchases) {
                          showGameMessage(`You already own the maximum number of ${itemId}s.`, 'info');
                      } else {
                          showGameMessage("Not enough reserves!", 'error');
                      }
                  });
              }
          });
      }
      
      function showGameMessage(message, type = 'info') {
        if (!messageBox) return;
        messageBox.textContent = message;
        messageBox.className = 'message-box visible'; // Add visible directly
        if (type === 'success') {
            messageBox.style.backgroundColor = 'rgba(22, 163, 74, 0.9)'; messageBox.style.borderColor = 'rgba(22, 101, 52, 0.7)';
        } else if (type === 'error') {
            messageBox.style.backgroundColor = 'rgba(220, 38, 38, 0.9)'; messageBox.style.borderColor = 'rgba(153, 27, 27, 0.7)';
        } else {
            messageBox.style.backgroundColor = 'rgba(23, 37, 84, 0.9)'; messageBox.style.borderColor = 'rgba(79, 70, 229, 0.7)';
        }
        setTimeout(() => { messageBox.classList.remove('visible'); }, 3000);
      }

      function addPurchasedItemToWorld(itemType, itemId, count) {
        let itemGroup;
        if (itemType === 'animal') {
            itemGroup = createAnimalFarmStructure(itemId, count);
        } else if (itemType === 'plant') {
            itemGroup = createPlantPlot(itemId, count);
        } else {
            console.error("Unknown item type:", itemType);
            return;
        }

        // Position the item in the world
        const spacing = itemType === 'animal' ? 20 : 8; // Plants are smaller, closer spacing
        const itemsPerRow = itemType === 'animal' ? 5 : 10;
        const itemIndex = worldObjects.filter(obj => obj.userData.itemType === itemType).length; // Count existing items of this type for placement
        
        const row = Math.floor(itemIndex / itemsPerRow);
        const col = itemIndex % itemsPerRow;

        itemGroup.position.set(
            (col - Math.floor(itemsPerRow/2) + 0.5) * spacing, // X position, +0.5 to center grid cell
            0,                                             // Y position (on the ground)
            -30 - (row * spacing) - (itemType === 'animal' ? 0 : 20) // Z position, push plants further back or group differently
        );
        itemGroup.name = `${itemId}_${itemType}_${count}`;
        itemGroup.userData.itemType = itemType; // Tag for easier filtering
        scene.add(itemGroup);
        worldObjects.push(itemGroup);
      }

      function createAnimalFarmStructure(animalId, count) {
        const farmGroup = new THREE.Group();
        let baseColor, structureColor, animalColor, animalGeometry;
        const fenceHeight = 1.2, fencePostRadius = 0.1, fencePlankHeight = 0.15;
        const farmSize = (animalId === 'cow' || animalId === 'goat') ? 10 : 8; // Larger for bigger animals
        const structureSize = new THREE.Vector3(animalId === 'cow' ? 5 : 4, 2.5, animalId === 'cow' ? 4 : 3);

        // Minecraft-style blocky animals
        switch(animalId) {
            case 'chicken':
                baseColor = 0xD2B48C; structureColor = 0x8B4513; animalColor = 0xFFFFE0;
                animalGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.3); // Body
                // Add simple beak and comb later if desired
                break;
            case 'pig':
                baseColor = 0xFFC0CB; structureColor = 0xA0522D; animalColor = 0xFFA07A;
                animalGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.4); // Body
                break;
            case 'cow':
                baseColor = 0xBCB0A1; structureColor = 0x7A7061; animalColor = 0xFFFFFF; // White with black spots (texture later)
                animalGeometry = new THREE.BoxGeometry(1.5, 1.0, 0.7); // Body
                break;
            case 'goat':
                baseColor = 0xC0C0C0; structureColor = 0x505050; animalColor = 0xE0E0E0;
                animalGeometry = new THREE.BoxGeometry(1.0, 0.8, 0.5); // Body
                break;
            case 'fish': // Fish pond, no land structure like others
                return createFishPond(animalId, count); // Special handling
            default:
                baseColor = 0xCCCCCC; structureColor = 0x555555; animalColor = 0x999999;
                animalGeometry = new THREE.BoxGeometry(0.5,0.5,0.5);
        }

        const structureMaterial = new THREE.MeshStandardMaterial({ color: baseColor });
        const mainStructureMesh = new THREE.Mesh(new THREE.BoxGeometry(structureSize.x, structureSize.y, structureSize.z), structureMaterial);
        mainStructureMesh.castShadow = true; mainStructureMesh.receiveShadow = true;
        mainStructureMesh.position.y = structureSize.y / 2;
        farmGroup.add(mainStructureMesh);

        const roofMaterial = new THREE.MeshStandardMaterial({ color: structureColor });
        const roofMesh = new THREE.Mesh(new THREE.BoxGeometry(structureSize.x * 1.1, 0.3, structureSize.z * 1.1), roofMaterial);
        roofMesh.position.y = structureSize.y + 0.15;
        farmGroup.add(roofMesh);

        // Fence (similar logic as before, adapted for farmSize)
        const fenceMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const postGeo = new THREE.CylinderGeometry(fencePostRadius, fencePostRadius, fenceHeight, 8);
        const plankGeo = new THREE.BoxGeometry(farmSize, fencePlankHeight, 0.1);

        for (let i = 0; i < 4; i++) {
            const p1 = new THREE.Mesh(plankGeo, fenceMaterial); p1.castShadow = true;
            const p2 = new THREE.Mesh(plankGeo, fenceMaterial); p2.castShadow = true;
            const postA = new THREE.Mesh(postGeo, fenceMaterial); postA.castShadow = true; postA.position.y = fenceHeight/2;
            const postB = new THREE.Mesh(postGeo, fenceMaterial); postB.castShadow = true; postB.position.y = fenceHeight/2;

            if (i === 0) { // Front
                p1.position.set(0, fenceHeight * 0.3, farmSize / 2); p2.position.set(0, fenceHeight * 0.7, farmSize / 2);
                postA.position.set(-farmSize/2, fenceHeight/2, farmSize/2); postB.position.set(farmSize/2, fenceHeight/2, farmSize/2);
            } else if (i === 1) { // Back
                p1.position.set(0, fenceHeight * 0.3, -farmSize / 2); p2.position.set(0, fenceHeight * 0.7, -farmSize / 2);
                postA.position.set(-farmSize/2, fenceHeight/2, -farmSize/2); postB.position.set(farmSize/2, fenceHeight/2, -farmSize/2);
            } else if (i === 2) { // Left
                p1.rotation.y = p2.rotation.y = Math.PI / 2;
                p1.position.set(-farmSize / 2, fenceHeight * 0.3, 0); p2.position.set(-farmSize / 2, fenceHeight * 0.7, 0);
            } else { // Right
                p1.rotation.y = p2.rotation.y = Math.PI / 2;
                p1.position.set(farmSize / 2, fenceHeight * 0.3, 0); p2.position.set(farmSize / 2, fenceHeight * 0.7, 0);
            }
            farmGroup.add(p1); farmGroup.add(p2);
            if (i < 2) { farmGroup.add(postA.clone()); farmGroup.add(postB.clone());}
        }

        // Add blocky animals
        const animalMaterial = new THREE.MeshStandardMaterial({ color: animalColor });
        const numAnimals = (animalId === 'cow') ? 2 : (animalId === 'goat' ? 3 : 5); // Fewer cows
        const penCenterForAI = new THREE.Vector3(0,0,0); // Relative to farmGroup origin
        
        for (let i = 0; i < numAnimals; i++) {
            const animal = new THREE.Group(); // Group for body + legs if needed
            const body = new THREE.Mesh(animalGeometry, animalMaterial);
            body.castShadow = true;
            animal.add(body);

            // Simple legs for larger animals
            if (animalId === 'pig' || animalId === 'cow' || animalId === 'goat') {
                const legGeo = new THREE.BoxGeometry(0.2, 0.4, 0.2);
                const legPositions = [
                    {x: body.geometry.parameters.width/2 * 0.7, z: body.geometry.parameters.depth/2 * 0.7},
                    {x: -body.geometry.parameters.width/2 * 0.7, z: body.geometry.parameters.depth/2 * 0.7},
                    {x: body.geometry.parameters.width/2 * 0.7, z: -body.geometry.parameters.depth/2 * 0.7},
                    {x: -body.geometry.parameters.width/2 * 0.7, z: -body.geometry.parameters.depth/2 * 0.7},
                ];
                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeo, animalMaterial);
                    leg.position.set(pos.x, -body.geometry.parameters.height/2 - legGeo.parameters.height/2 + 0.1, pos.z);
                    animal.add(leg);
                });
                body.position.y = legGeo.parameters.height/2 + 0.1; // Lift body for legs
            } else {
                 body.position.y = animalGeometry.parameters.height / 2; // Chickens on ground
            }


            animal.position.set(
                (Math.random() - 0.5) * (farmSize - structureSize.x - 1),
                 0, // Y will be set by body/leg logic
                (Math.random() - 0.5) * (farmSize - structureSize.z - 1)
            );
             // Ensure animals are somewhat clear of the main structure
            if (animal.position.x > -structureSize.x/2 && animal.position.x < structureSize.x/2 &&
                animal.position.z > -structureSize.z/2 && animal.position.z < structureSize.z/2) {
                animal.position.x += (animal.position.x > 0 ? 1 : -1) * (structureSize.x/2 + 0.5);
            }
            farmGroup.add(animal);

            if (animalId === 'chicken') { // Only chickens get AI for now
                 chickenAIMeshes.push({
                    mesh: animal,
                    timer: Math.random() * 5,
                    targetPosition: new THREE.Vector3().copy(animal.position), // Start at current pos
                    penSize: farmSize,
                    penCenter: farmGroup.position.clone().add(penCenterForAI) // Absolute world coords of pen center
                });
            }
        }
        return farmGroup;
      }

      function createFishPond(itemId, count) {
        const pondGroup = new THREE.Group();
        const pondRadius = 4;
        const pondDepth = 1.5;

        // Water
        const waterGeo = new THREE.CylinderGeometry(pondRadius, pondRadius, pondDepth, 16);
        const waterMat = new THREE.MeshStandardMaterial({color: 0x4682B4, transparent: true, opacity: 0.6});
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.position.y = -pondDepth/2 + 0.1; // Slightly recessed
        pondGroup.add(water);

        // Border
        const borderGeo = new THREE.TorusGeometry(pondRadius, 0.3, 8, 24);
        const borderMat = new THREE.MeshStandardMaterial({color: 0xAAAAAA});
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.rotation.x = Math.PI/2;
        border.position.y = 0.15; // Top of border at ground level
        pondGroup.add(border);

        // Fish (simple blocky fish)
        const fishGeo = new THREE.BoxGeometry(0.5, 0.2, 0.15);
        const fishMat = new THREE.MeshStandardMaterial({color: 0xFF8C00}); // Orange
        for(let i=0; i<5; i++) {
            const fish = new THREE.Mesh(fishGeo, fishMat);
            fish.position.set(
                (Math.random() - 0.5) * pondRadius * 1.5,
                water.position.y + (Math.random() - 0.5) * (pondDepth * 0.7), // Within water depth
                (Math.random() - 0.5) * pondRadius * 1.5
            );
            fish.rotation.y = Math.random() * Math.PI * 2;
            pondGroup.add(fish);
        }
        return pondGroup;
      }

      function createPlantPlot(plantId, count) {
        const plotGroup = new THREE.Group();
        let plantColor1 = 0x228B22, plantColor2 = 0x006400; // Default greens
        let plantGeo1, plantGeo2;
        let scale = 1.0;

        switch(plantId) {
            case 'plantain': case 'banana':
                plantGeo1 = new THREE.CylinderGeometry(0.1, 0.2, 1.5, 6); // Stalk
                plantGeo2 = new THREE.SphereGeometry(0.6, 5, 4); // Leafy top
                plantColor1 = 0x8FBC8F; plantColor2 = 0x3CB371; scale = 1.2;
                break;
            case 'orange': case 'coconut': case 'papaya':
                plantGeo1 = new THREE.CylinderGeometry(0.15, 0.25, 1.2, 6); // Trunk
                plantGeo2 = new THREE.SphereGeometry(0.8, 6, 5); // Foliage
                plantColor1 = 0x8B4513; plantColor2 = 0x2E8B57; scale = 1.1;
                 // Add fruit if coconut/orange
                if (plantId === 'orange') {
                    const fruitGeo = new THREE.SphereGeometry(0.15, 5,4);
                    const fruitMat = new THREE.MeshStandardMaterial({color:0xFF8C00});
                    for(let f=0; f<3; f++) {
                        const fruit = new THREE.Mesh(fruitGeo, fruitMat);
                        fruit.position.set((Math.random()-0.5)*0.5, 1.2+(Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5);
                        plotGroup.add(fruit);
                    }
                }
                break;
            case 'sugarcane':
                plantGeo1 = new THREE.CylinderGeometry(0.05, 0.05, 2.0, 6); // Tall stalk
                plantColor1 = 0x90EE90;
                break;
            case 'carrot':
                plantGeo1 = new THREE.ConeGeometry(0.2, 0.5, 6); // Carrot root (mostly underground)
                plantGeo2 = new THREE.SphereGeometry(0.3, 5, 3); // Leafy top
                plantColor1 = 0xFF8C00; plantColor2 = 0x32CD32;
                break;
            default: plantGeo1 = new THREE.BoxGeometry(0.3,0.8,0.3);
        }

        const mat1 = new THREE.MeshStandardMaterial({color: plantColor1});
        const part1 = new THREE.Mesh(plantGeo1, mat1);
        part1.castShadow = true;
        part1.position.y = (plantId==='carrot' ? 0.1 : (plantGeo1.parameters.height || 0.8) /2 );
        plotGroup.add(part1);

        if (plantGeo2) {
            const mat2 = new THREE.MeshStandardMaterial({color: plantColor2});
            const part2 = new THREE.Mesh(plantGeo2, mat2);
            part2.castShadow = true;
            part2.position.y = (plantId==='carrot' ? 0.4 : (plantGeo1.parameters.height || 0.8) -0.1 + (plantGeo2.parameters.radius || 0.3)/2);
            plotGroup.add(part2);
        }
        plotGroup.scale.set(scale,scale,scale);
        return plotGroup;
      }


      // --- Weather System ---
      function toggleWeather() {
        isRaining = !isRaining;
        if (isRaining) {
            startRain();
            showGameMessage("It started raining...", "info");
            scheduleLightning();
            scene.fog.color.set(rainFogColor);
            scene.background.set(rainFogColor);
        } else {
            stopRain();
            showGameMessage("The rain stopped.", "info");
            clearTimeout(lightningTimeout);
            clearTimeout(nextLightningStrikeTimeout);
            lightningActive = false;
            const lightningFlash = scene.getObjectByName("lightningFlash");
            if(lightningFlash) scene.remove(lightningFlash);
            scene.fog.color.set(initialFogColor);
            scene.background.set(initialFogColor);
        }
      }
      window.toggleWeather = toggleWeather; // Make it callable from console for dev

      function startRain() {
        const particleCount = 10000;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3); // For y-velocity

        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 200; // x
            positions[i * 3 + 1] = Math.random() * 100 + 20;  // y (start high)
            positions[i * 3 + 2] = (Math.random() - 0.5) * 200; // z
            velocities[i*3+1] = -(Math.random() * 15 + 10); // downward velocity
        }
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3)); // Store velocities

        rainMaterial = new THREE.PointsMaterial({ color: 0xaaaaee, size: 0.2, transparent: true, opacity: 0.6 });
        rainParticles = new THREE.Points(particles, rainMaterial);
        rainParticles.name = "rainEffect";
        scene.add(rainParticles);
      }

      function updateRain(deltaTime) {
        if (rainParticles) {
            const positions = rainParticles.geometry.attributes.position;
            const velocities = rainParticles.geometry.attributes.velocity;
            for (let i = 0; i < positions.count; i++) {
                positions.array[i * 3 + 1] += velocities.array[i*3+1] * deltaTime; // Update y position
                if (positions.array[i * 3 + 1] < 0) { // Reset if hit ground
                    positions.array[i * 3 + 1] = Math.random() * 50 + 50; // Reset high
                    positions.array[i * 3] = player.position.x + (Math.random() - 0.5) * 100; // Reset around player
                    positions.array[i * 3 + 2] = player.position.z + (Math.random() - 0.5) * 100;
                }
            }
            positions.needsUpdate = true;
        }
      }

      function stopRain() {
        const rainEffect = scene.getObjectByName("rainEffect");
        if (rainEffect) {
            scene.remove(rainEffect);
            rainEffect.geometry.dispose();
            rainEffect.material.dispose();
        }
        rainParticles = null;
      }

      function scheduleLightning() {
        if (!isRaining) return;
        const strikeDelay = Math.random() * 15000 + 10000; // 10-25 seconds
        nextLightningStrikeTimeout = setTimeout(() => {
            if (isRaining) triggerLightning();
            scheduleLightning(); // Schedule next one
        }, strikeDelay);
      }

      function triggerLightning() {
        if (lightningActive) return;
        lightningActive = true;

        const lightningFlash = new THREE.DirectionalLight(0xffffff, 2.5); // Intense white flash
        lightningFlash.position.set((Math.random()-0.5)*100, 100, (Math.random()-0.5)*100);
        lightningFlash.name = "lightningFlash";
        scene.add(lightningFlash);
        
        // Darken sky more
        const originalFogColor = scene.fog.color.clone();
        scene.fog.color.set(0x101020);
        scene.background.set(0x101020);


        // Flash effect
        setTimeout(() => {
            if(scene.getObjectByName("lightningFlash")) scene.remove(lightningFlash);
        }, 100); // Short flash
        setTimeout(() => {
            if(scene.getObjectByName("lightningFlash")) scene.remove(lightningFlash); // Ensure removal
        }, 250); // Second flash (softer)
         setTimeout(() => {
            if(scene.getObjectByName("lightningFlash")) scene.remove(lightningFlash);
             if (isRaining) { // Restore rain fog color if still raining
                scene.fog.color.set(rainFogColor);
                scene.background.set(rainFogColor);
             } else { // Else restore initial fog
                scene.fog.color.set(initialFogColor);
                scene.background.set(initialFogColor);
             }
            lightningActive = false;
        }, 400);
      }


      // --- Placeholder for Records ---
      if (recordsButton) {
        recordsButton.addEventListener('click', (e) => {
          e.preventDefault();
          if (document.pointerLockElement === document.body) document.exitPointerLock();
          let recordMsg = "Current Holdings:\n";
          for (const item in purchasedItems) {
              if (purchasedItems[item] > 0) {
                  recordMsg += `${item.charAt(0).toUpperCase() + item.slice(1)}: ${purchasedItems[item]}\n`;
              }
          }
          if (recordMsg === "Current Holdings:\n") recordMsg = "No items purchased yet.";
          showGameMessage(recordMsg, 'info');
        });
      }

      const blobsContainer = document.getElementById('blobs-container');
      const htmlBlobs = blobsContainer ? blobsContainer.querySelectorAll('.interactive-blob') : [];
      let blobHues = [270, 220];
      function animateBackgroundBlobs() {
         if (blobsContainer && htmlBlobs.length > 0) {
             htmlBlobs.forEach((blob, index) => {
                 blobHues[index] = (blobHues[index] + 0.05) % 360;
                 blob.style.backgroundColor = `hsl(${blobHues[index]}, 70%, 60%)`;
             });
         }
         requestAnimationFrame(animateBackgroundBlobs);
      }
      if (blobsContainer && htmlBlobs.length > 0) animateBackgroundBlobs();

      document.addEventListener('mousemove', (e) => {
        if (Math.random() > 0.99) createParticle(e.clientX, e.clientY); // Even less frequent
      });
      function createParticle(x, y) { /* ... (same as before, shortened for brevity) ... */ }

      document.querySelectorAll('img').forEach(img => { /* ... (same as before) ... */ });
      function handleImageError(img) { /* ... (same as before, ensure it handles new emoji/text placeholders) ... */ }
      
      initThreeJS();
      updateReservesDisplay();
      showGameMessage("Welcome to Prast Farms! Press L to toggle mouse lock for controls.", "info");

    });
  </script>
</body>
</html>
