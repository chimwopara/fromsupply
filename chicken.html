<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Chicken</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background-color: #f0f0f0; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; }
        #info {
            position: absolute;
            top: 10px;
            width: 90%; 
            max-width: 780px; 
            text-align: center;
            color: #333;
            font-size: 16px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10; 
        }
        #canvas-container {
            margin-top: 80px; /* Increased margin to prevent overlap with potentially larger info bar */
            width: 90%;
            max-width: 800px;
            height: 70vh;
            max-height: 600px;
            border-radius: 12px;
            overflow: hidden; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        canvas { display: block; width: 100% !important; height: 100% !important; border-radius: 12px; }
    </style>
</head>
<body>
    <script>
        // Helper function to display errors if scripts fail to load
        function handleScriptError(scriptName, scriptUrl) {
            console.error(`Error loading ${scriptName} from ${scriptUrl}. Please check the CDN link, your network connection, and ensure no browser extensions are blocking it. Check the browser's Network tab (F12) for more details on the loading failure (e.g., HTTP status code).`);
            window.CRITICAL_SCRIPT_LOAD_FAILURE = true; // Set flag
            const infoDiv = document.getElementById('info');
            if (infoDiv) {
                infoDiv.innerHTML = `<b>Critical Error:</b> Failed to load a required 3D library (<code>${scriptName}</code>).
                <br>The 3D model cannot be displayed.
                <br><br><b>URL that failed:</b> <code>${scriptUrl}</code>
                <br><br><b>Please try the following:</b>
                <br>1. Check your internet connection.
                <br>2. Try refreshing the page (Ctrl+R or Cmd+R).
                <br>3. Open your browser's Developer Tools (usually F12), go to the "Network" tab, and reload the page. Look for the script URL above to see why it failed (e.g., status 404, 0, or 'blocked').
                <br>4. If you use browser extensions (like ad blockers, privacy tools, or firewalls), try temporarily disabling them for this page.
                <br>5. Try opening this page in a different web browser or an incognito/private window.`;
                infoDiv.style.color = "black"; 
                infoDiv.style.backgroundColor = "#ffebee"; 
                infoDiv.style.border = "2px solid red";
                infoDiv.style.padding = "15px";
                infoDiv.style.textAlign = "left";
                infoDiv.style.fontSize = "14px"; // Slightly smaller for more text
            } else {
                alert(`Critical Error: Failed to load ${scriptName}. The 3D model cannot be displayed. Please check console and try troubleshooting steps like checking network/extensions.`);
            }
        }
    </script>

    <div id="info">
        A 3D Chicken Model. Drag to rotate, scroll to zoom.
    </div>
    <div id="canvas-container">
        <canvas id="chickenCanvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.129.0/three.min.js" 
            onerror="handleScriptError('Three.js main library (three.min.js)', this.src)"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.129.0/examples/js/controls/OrbitControls.js" 
            onerror="handleScriptError('OrbitControls library (OrbitControls.js)', this.src)"></script>

    <script defer>
        // Global variables
        let scene, camera, renderer, chickenGroup, controls;
        let animationLoopStarted = false; 

        // Colors
        const BODY_COLOR = 0xFFFFFF; 
        const BEAK_LEGS_COLOR = 0xFFD700; 
        const COMB_WATTLE_COLOR = 0xDC143C; 
        const EYE_COLOR = 0x000000; 

        function init() {
            console.log("init() called");

            // Check if a critical script load failure already occurred
            if (window.CRITICAL_SCRIPT_LOAD_FAILURE) {
                console.warn("init() aborted: CRITICAL_SCRIPT_LOAD_FAILURE flag is set.");
                return;
            }

            if (typeof THREE === 'undefined') {
                console.error("CRITICAL in init(): THREE object is not defined. This means three.min.js did not load or execute correctly.");
                // Call handleScriptError again if it wasn't already (though it should have been by onerror)
                if (!window.CRITICAL_SCRIPT_LOAD_FAILURE) { // Avoid redundant calls if onerror already handled it
                   handleScriptError('Three.js main library (three.min.js)', 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.129.0/three.min.js');
                }
                return; 
            }
            if (typeof THREE.OrbitControls === 'undefined') {
                 console.error("CRITICAL in init(): THREE.OrbitControls is not defined. This means OrbitControls.js did not load/execute correctly or THREE was not available when it ran.");
                 if (!window.CRITICAL_SCRIPT_LOAD_FAILURE) {
                    handleScriptError('OrbitControls library (OrbitControls.js)', 'https://cdn.jsdelivr.net/npm/three@0.129.0/examples/js/controls/OrbitControls.js');
                 }
                return;
            }

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 

            // Camera setup
            const canvasContainer = document.getElementById('canvas-container');
            if (!canvasContainer) {
                console.error("Canvas container not found!");
                return;
            }
            console.log("Initial container dimensions (W x H):", canvasContainer.clientWidth, "x", canvasContainer.clientHeight);

            let aspect = 16/9; 
            if (canvasContainer.clientHeight > 0 && canvasContainer.clientWidth > 0) {
                aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            } else {
                console.warn("Initial canvas container width or height is 0. Using default aspect 16/9.");
            }
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 1.5, 5);

            // Renderer setup
            const canvas = document.getElementById('chickenCanvas');
            if (!canvas) {
                console.error("Canvas element not found!");
                return;
            }
            try {
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            } catch (e) {
                console.error("Error creating WebGLRenderer:", e);
                const infoDiv = document.getElementById('info');
                if (infoDiv && !window.CRITICAL_SCRIPT_LOAD_FAILURE) { // Avoid overwriting primary script load error
                    infoDiv.innerHTML = "Error: Could not initialize WebGL. Your browser or device may not support it, or it might be disabled. Please check your browser settings. More details in console.";
                    infoDiv.style.color = "red";
                    infoDiv.style.backgroundColor = "pink";
                }
                return;
            }

            const initialWidth = canvasContainer.clientWidth || 300; 
            const initialHeight = canvasContainer.clientHeight || 200; 
            if (canvasContainer.clientWidth === 0 || canvasContainer.clientHeight === 0) {
                console.warn("Renderer initial size was 0 (or container was 0), using fallback:", initialWidth, initialHeight);
            }
            renderer.setSize(initialWidth, initialHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;

            // Lighting, Ground, Chicken Model... (rest of the setup code)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);

            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x90EE90, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -1;
            ground.receiveShadow = true;
            scene.add(ground);
            
            chickenGroup = new THREE.Group();
            createChicken(); 
            scene.add(chickenGroup);
            chickenGroup.position.y = -0.1; 

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 2;
            controls.maxDistance = 20;
            controls.target.set(0, 0.5, 0); 

            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); 

            console.log("init() finished successfully.");
            const infoDiv = document.getElementById('info');
            if (infoDiv && infoDiv.innerHTML.includes("A 3D Chicken Model")) { // Only reset if not showing an error
                 infoDiv.innerHTML = "A 3D Chicken Model. Drag to rotate, scroll to zoom."; // Reset to original if all good
            }
            animate();
        }

        function createChicken() {
            const standardMaterialProps = { roughness: 0.7, metalness: 0.1 };
            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.8, 1.2, 4, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: BODY_COLOR, ...standardMaterialProps });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.z = Math.PI / 2; 
            body.rotation.y = Math.PI / 12; 
            body.castShadow = true;
            chickenGroup.add(body);
            // Head
            const headGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const headMaterial = new THREE.MeshStandardMaterial({ color: BODY_COLOR, ...standardMaterialProps });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(1.0, 0.6, 0); 
            head.castShadow = true;
            chickenGroup.add(head);
            // Beak
            const beakGeometry = new THREE.ConeGeometry(0.15, 0.4, 32);
            const beakMaterial = new THREE.MeshStandardMaterial({ color: BEAK_LEGS_COLOR, ...standardMaterialProps });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.position.set(1.4, 0.6, 0); 
            beak.rotation.z = -Math.PI / 2;
            beak.castShadow = true;
            chickenGroup.add(beak);
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: EYE_COLOR, ...standardMaterialProps });
            const eyeLeft = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eyeLeft.position.set(1.2, 0.8, 0.25);
            eyeLeft.castShadow = true;
            chickenGroup.add(eyeLeft);
            const eyeRight = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eyeRight.position.set(1.2, 0.8, -0.25);
            eyeRight.castShadow = true;
            chickenGroup.add(eyeRight);
            // Comb
            const combMaterial = new THREE.MeshStandardMaterial({ color: COMB_WATTLE_COLOR, ...standardMaterialProps });
            const baseCombPartGeometry = new THREE.SphereGeometry(0.12, 16, 16);
            const comb1 = new THREE.Mesh(baseCombPartGeometry.clone().scale(1, 1.5, 0.5), combMaterial);
            comb1.position.set(1.0, 1.1, 0);
            comb1.castShadow = true;
            chickenGroup.add(comb1);
            const comb2 = new THREE.Mesh(baseCombPartGeometry.clone().scale(0.8 * 1, 0.8 * 1.5, 0.8 * 0.5), combMaterial);
            comb2.position.set(0.85, 1.05, 0);
            comb2.castShadow = true;
            chickenGroup.add(comb2);
            const comb3 = new THREE.Mesh(baseCombPartGeometry.clone().scale(0.8 * 1, 0.8 * 1.5, 0.8 * 0.5), combMaterial);
            comb3.position.set(1.15, 1.05, 0);
            comb3.castShadow = true;
            chickenGroup.add(comb3);
            // Wattle
            const wattleGeometry = new THREE.CapsuleGeometry(0.08, 0.2, 4, 8);
            const wattleMaterial = new THREE.MeshStandardMaterial({ color: COMB_WATTLE_COLOR, ...standardMaterialProps });
            const wattleLeft = new THREE.Mesh(wattleGeometry, wattleMaterial);
            wattleLeft.position.set(1.25, 0.35, 0.05);
            wattleLeft.rotation.z = Math.PI / 8;
            wattleLeft.castShadow = true;
            chickenGroup.add(wattleLeft);
            const wattleRight = new THREE.Mesh(wattleGeometry, wattleMaterial);
            wattleRight.position.set(1.25, 0.35, -0.05);
            wattleRight.rotation.z = -Math.PI / 8;
            wattleRight.castShadow = true;
            chickenGroup.add(wattleRight);
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 16);
            const legMaterial = new THREE.MeshStandardMaterial({ color: BEAK_LEGS_COLOR, ...standardMaterialProps });
            const legLeft = new THREE.Mesh(legGeometry, legMaterial);
            legLeft.position.set(0, -0.5, 0.3);
            legLeft.castShadow = true;
            chickenGroup.add(legLeft);
            const legRight = new THREE.Mesh(legGeometry, legMaterial);
            legRight.position.set(0, -0.5, -0.3);
            legRight.castShadow = true;
            chickenGroup.add(legRight);
            // Feet
            const footPartGeometry = new THREE.BoxGeometry(0.15, 0.05, 0.3);
            const footMaterial = new THREE.MeshStandardMaterial({ color: BEAK_LEGS_COLOR, ...standardMaterialProps });
            const footLeft = new THREE.Mesh(footPartGeometry, footMaterial);
            footLeft.position.set(0, -0.9, 0.3); 
            footLeft.castShadow = true;
            chickenGroup.add(footLeft);
            const footRight = new THREE.Mesh(footPartGeometry, footMaterial);
            footRight.position.set(0, -0.9, -0.3); 
            footRight.castShadow = true;
            chickenGroup.add(footRight);
            // Wings
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);
            wingShape.absellipse(0, 0, 0.7, 1, 0, Math.PI * 2, false); 
            const wingExtrudeSettings = { depth: 0.1, bevelEnabled: true, bevelSegments: 2, steps: 1, bevelSize: 0.05, bevelThickness: 0.05 };
            const wingGeometry = new THREE.ExtrudeGeometry(wingShape, wingExtrudeSettings);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: BODY_COLOR, ...standardMaterialProps, side: THREE.DoubleSide });
            const wingLeft = new THREE.Mesh(wingGeometry, wingMaterial);
            wingLeft.position.set(0.1, 0.3, 0.7); 
            wingLeft.rotation.y = Math.PI / 2;
            wingLeft.rotation.x = -Math.PI / 8; 
            wingLeft.scale.set(0.8, 0.8, 0.8);
            wingLeft.castShadow = true;
            chickenGroup.add(wingLeft);
            const wingRight = new THREE.Mesh(wingGeometry, wingMaterial);
            wingRight.position.set(0.1, 0.3, -0.7); 
            wingRight.rotation.y = -Math.PI / 2;
            wingRight.rotation.x = -Math.PI / 8; 
            wingRight.scale.set(0.8, 0.8, 0.8);
            wingRight.castShadow = true;
            chickenGroup.add(wingRight);
            // Tail
            const tailFeatherGeometry = new THREE.BoxGeometry(0.2, 1, 0.05); 
            const tailMaterial = new THREE.MeshStandardMaterial({ color: BODY_COLOR, ...standardMaterialProps, side: THREE.DoubleSide });
            const tailFeather1 = new THREE.Mesh(tailFeatherGeometry, tailMaterial);
            tailFeather1.position.set(-1.3, 0.5, 0);
            tailFeather1.rotation.z = Math.PI / 4; 
            tailFeather1.castShadow = true;
            chickenGroup.add(tailFeather1);
            const tailFeather2 = new THREE.Mesh(tailFeatherGeometry, tailMaterial);
            tailFeather2.position.set(-1.2, 0.45, 0.15);
            tailFeather2.rotation.z = Math.PI / 4;
            tailFeather2.rotation.y = Math.PI / 8;
            tailFeather2.scale.set(0.8, 0.9, 0.8);
            tailFeather2.castShadow = true;
            chickenGroup.add(tailFeather2);
            const tailFeather3 = new THREE.Mesh(tailFeatherGeometry, tailMaterial);
            tailFeather3.position.set(-1.2, 0.45, -0.15);
            tailFeather3.rotation.z = Math.PI / 4;
            tailFeather3.rotation.y = -Math.PI / 8;
            tailFeather3.scale.set(0.8, 0.9, 0.8);
            tailFeather3.castShadow = true;
            chickenGroup.add(tailFeather3);
            console.log("createChicken() finished.");
        }

        function onWindowResize() {
            if (window.CRITICAL_SCRIPT_LOAD_FAILURE) return; // Don't run if libs failed
            const canvasContainer = document.getElementById('canvas-container');
            if (camera && renderer && canvasContainer) {
                const width = canvasContainer.clientWidth;
                const height = canvasContainer.clientHeight;
                if (height === 0 || width === 0) { 
                    console.warn("Canvas container height or width is 0 during resize. Renderer/camera not updated.");
                    if (renderer.domElement.width === 0 || renderer.domElement.height === 0) {
                         renderer.setSize(300,200); 
                    }
                    return; 
                }
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
        }

        function animate() {
            if (window.CRITICAL_SCRIPT_LOAD_FAILURE) return; // Don't run if libs failed
            requestAnimationFrame(animate);
            if (!animationLoopStarted) {
                console.log("Animation loop started.");
                animationLoopStarted = true;
            }
            if (controls) controls.update(); 
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOMContentLoaded fired.");
            if (window.CRITICAL_SCRIPT_LOAD_FAILURE) {
                console.warn("DOMContentLoaded: Aborting init call because CRITICAL_SCRIPT_LOAD_FAILURE flag is set.");
                return;
            }
            console.log("Attempting to initialize application.");
            init();
        });
    </script>
</body>
</html>
