const challengesData = [
    // Level 1: Simple For Loop
    {
        goal: "Print numbers 0 to 4 using a for loop.",
        concepts: "Includes, main function, for loop, printf",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`stdlib.h` contains general utility functions (like memory allocation, random numbers), but `printf` requires the Standard Input/Output library, which is `stdio.h`.'}, {text: '#import <stdio.h>', reason: 'Standard C uses the `#include` preprocessor directive. `#import` is a similar concept but specific to Objective-C and not part of standard C.'}], indent: 0, explanation: "Includes the Standard Input/Output library for functions like printf." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'The C standard (like C99, C11) specifies that `main` must return `int` to signal the program\'s exit status to the OS (0 for success). `void main()` is non-standard, though some compilers might allow it.'}, {text: 'function main() {', reason: 'The keyword `function` is used in languages like JavaScript to define functions, but in C, you define a function by specifying its return type (e.g., `int`), name, parameters, and body `{}`.'}], indent: 0, explanation: "The main function where program execution begins. It returns an integer." },
            { correct: 'for(int i = 0; i < 5; i++) {', distractors: [{text: 'while(int i < 5) {', reason: 'A `while` loop only checks a condition. Variable declaration (`int i`) is not allowed inside the `while` condition parentheses, and initialization/increment must happen separately before/inside the loop body.'}, {text: 'if(i < 5) {', reason: 'An `if` statement executes its block only *once* if the condition is true. A `for` loop is needed to *repeat* the block multiple times based on initialization, condition, and increment steps.'}], indent: 1, explanation: "A for loop: initializes i=0, continues while i<5, increments i after each loop." },
            { correct: 'printf("Count: %d\\n", i);', distractors: [{text: 'print("Count: %d", i);', reason: 'The standard C library function for formatted output is `printf` (print formatted). There is no standard function named `print`.'}, {text: 'console.log(i);', reason: '`console.log` is the function used for printing output in JavaScript environments (like browsers or Node.js), not in standard C.'}], indent: 2, explanation: "Prints formatted text. %d is a placeholder for an integer (i), \\n is a newline." },
            { correct: '}', distractors: [{text: 'end for;', reason: 'C uses matching curly braces `{` and `}` to define the start and end of code blocks (like loops, functions, if-statements). Keywords like `end` are not used for this.'}, {text: 'break;', reason: 'The `break;` statement is used to exit *early* from a loop (for, while, do-while) or switch statement. It does not define the normal end of the loop block.'}], indent: 1, explanation: "Closes the for loop block." },
            { correct: 'return 0;', distractors: [{text: 'exit(0);', reason: '`exit(0)` (from `stdlib.h`) forces immediate program termination from anywhere. `return 0;` specifically indicates the successful completion *of the `main` function* and allows normal program cleanup.'}, {text: 'return;', reason: 'The `main` function is declared as `int main()`, meaning it must return an integer value. `return;` is only valid for functions declared with a `void` return type.'}], indent: 1, explanation: "Indicates successful program execution by returning 0 from main." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'C uses curly braces `{}` to define code blocks. Keywords like `end` are not part of the C syntax for ending functions.'}, {text: '};', reason: 'A semicolon `;` is used to terminate statements in C, but it is *not* placed after the closing curly brace `}` that defines the end of a function body.'}], indent: 0, explanation: "Closes the main function block." }
        ]
    },
    // Level 2: Simple If Statement
    {
        goal: "Check if a variable is positive and print a message.",
        concepts: "Variables, if statement, comparison operators",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <math.h>', reason: 'The `math.h` header provides mathematical functions (like `sqrt`, `pow`, `sin`). It is not needed for basic comparison (`>`) or printing (`printf`).'}, {text: 'using namespace std;', reason: '`using namespace std;` is a C++ directive to avoid prefixing standard library elements with `std::`. It is not used or needed in standard C.'}], indent: 0, explanation: "Include the library needed for printing output."},
            { correct: 'int main() {', distractors: [{text: 'int start() {', reason: 'By convention and standard, the execution of a C program begins in the function named `main`. Other names like `start` won\'t be automatically recognized as the entry point.'}, {text: 'void main() {', reason: 'Standard C (like C99, C11) requires `main` to return an `int` value to indicate the program\'s exit status to the operating system. `void main()` is non-standard.'}], indent: 0, explanation: "Start the main execution block."},
            { correct: 'int number = 10;', distractors: [{text: 'float number = 10.0;', reason: 'While `float` can store 10.0, the task involves a simple positive/non-positive check. Using `int` (integer) is more direct and common for such whole number operations.'}, {text: 'char number = \'A\';', reason: 'A `char` variable stores a character value (like \'A\'). Comparing it with `> 0` might yield unexpected results based on its ASCII value, and it doesn\'t fit the goal of checking a numerical value.'}], indent: 1, explanation: "Declare an integer variable 'number' and give it a value." },
            { correct: 'if (number > 0) {', distractors: [{text: 'if number > 0:', reason: 'In C, the conditional expression following the `if` keyword *must* be enclosed within parentheses `()`. The colon `:` is used in languages like Python, not C.'}, {text: 'while (number > 0) {', reason: 'A `while` loop repeatedly executes the code block as long as the condition is true. An `if` statement executes the block only *once* if the condition is true, which is needed here.'}], indent: 1, explanation: "Check if the value of 'number' is greater than zero." },
            { correct: 'printf("Number is positive.\\n");', distractors: [{text: 'printf(number);', reason: '`printf` requires a "format string" as the first argument to specify *how* to print the following arguments. To print an integer, you need `printf("%d\\n", number);`.'}, {text: 'echo "Positive";', reason: '`echo` is a command typically used in shell environments (like Bash or Command Prompt) to display text, not a function available within standard C.'}], indent: 2, explanation: "If the condition was true, print this message." },
            { correct: '}', distractors: [{text: 'end if;', reason: 'C uses curly braces `{}` to define the beginning and end of code blocks associated with control structures like `if`. Keywords are not used to end blocks.'}, {text: 'stop;', reason: '`stop` is not a recognized keyword or command in the standard C language.'}], indent: 1, explanation: "Closes the if statement block." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Conventionally, returning `0` from `main` indicates success, while returning a non-zero value (like `1`) signals an error or abnormal termination to the operating system.'}, {text: 'end;', reason: '`end` is not a C keyword. Use `return` followed by a value (for non-void functions) to exit a function.'}], indent: 1, explanation: "Signal that the program finished successfully."},
            { correct: '}', distractors: [{text: 'finish', reason: '`finish` is not a C keyword used for ending code blocks or functions.'}, {text: 'end main', reason: 'C uses the closing curly brace `}` to signify the end of the `main` function\'s code block.'}], indent: 0, explanation: "Closes the main function block." }
        ]
    },
    // Level 3: Basic Function Call
    {
        goal: "Define and call a simple function to add two numbers.",
        concepts: "Function declaration (prototype), function definition, function call, return value",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text:'#include <functions.h>', reason:'There is no standard C header file named `functions.h`. Header files typically group related declarations (like `stdio.h` for I/O).'}, {text:'#include <iostream>', reason:'`<iostream>` is the standard input/output header file for C++, used with `cout` and `cin`. C uses `<stdio.h>` for `printf` and `scanf`.'}], indent: 0, explanation: "Include necessary library for input/output."},
            { correct: '// Function declaration (prototype)', distractors: [{text:'// Variable declaration', reason:'This comment is misleading; the next line declares a function, not a variable.'}, {text:'// Loop setup', reason:'This comment is inaccurate; the next line is about a function, not setting up a loop.'}], indent: 0, explanation: "Add a comment explaining the next line's purpose."},
            { correct: 'int add(int a, int b);', distractors: [{text:'void add(int a, int b);', reason:'The function is intended to calculate and *return* the sum, which is an integer. Declaring it as `void` means it wouldn\'t return any value, contradicting the goal.'}, {text:'function add(a, b);', reason:'C requires explicit type declarations. You must specify the return type (`int`) and the type of each parameter (`int a`, `int b`). The keyword `function` is not used.'}], indent: 0, explanation: "Declare the 'add' function: specify return type (int) and parameter types (int, int)."},
            { correct: 'int main() {', distractors: [{text:'void main() {', reason:'Standard C requires `main` to return `int` to signal success (0) or failure (non-zero) to the OS.'}, {text:'program start {', reason:'C program execution starts in `int main() { ... }`. Other syntax is incorrect.'}], indent: 0, explanation: "Begin the main function."},
            { correct: 'int result = add(5, 3);', distractors: [{text:'int result = 5 + 3;', reason:'This performs the addition directly within `main`. The goal is to demonstrate defining and *calling* a separate `add` function.'}, {text:'call add(5, 3);', reason:'In C, you call a function simply by using its name followed by arguments in parentheses `()`. The keyword `call` is not used for function invocation.'}], indent: 1, explanation: "Call the 'add' function, pass 5 and 3 as arguments, and store the returned value in 'result'."},
            { correct: 'printf("Result: %d\\n", result);', distractors: [{text:'printf(result);', reason:'`printf` needs a format specifier (like `%d` for integers) within the format string (first argument) to know how to interpret and print the variable `result`.'}, {text:'print result;', reason:'`print` is not a standard C function. You must use `printf` for formatted output.'}], indent: 1, explanation: "Print the calculated result."},
            { correct: 'return 0;', distractors: [{text:'return result;', reason:'The `main` function should return `0` to indicate successful execution to the operating system, not the calculated value from the `add` function.'}, {text:'exit main;', reason:'Keywords like `exit` are not used to end `main` normally; use `return 0;`.'}], indent: 1, explanation: "Exit the main function successfully."},
            { correct: '}', distractors: [{text:'end program;', reason:'C uses the closing curly brace `}` to mark the end of the `main` function block.'}, {text:'stop;', reason:'`stop` is not a C keyword.'}], indent: 0, explanation: "Closes the main function block." },
            { correct: '// Function definition', distractors: [{text:'// Main loop', reason:'This comment is incorrect; the following code defines the `add` function, not a loop within `main`.'}, {text:'// Variable setup', reason:'This comment is inaccurate; the following code is the implementation of the `add` function.'}], indent: 0, explanation: "Add a comment indicating the start of the function's code."},
            { correct: 'int add(int a, int b) {', distractors: [{text:'void add(int a, int b) {', reason:'The function *definition* must match the *declaration* (prototype). Since it was declared to return `int`, the definition must also specify `int`.'}, {text:'define add(a, b) {', reason:'`#define` is a preprocessor directive for macros, not for defining functions. Function definitions require specifying return and parameter types.'}], indent: 0, explanation: "Define the 'add' function, matching the declaration."},
            { correct: 'return a + b;', distractors: [{text:'print a + b;', reason:'The purpose of this function, as declared, is to *return* the calculated sum, not to print it directly. Printing should happen in `main` using the returned value.'}, {text:'result = a + b;', reason:'This assigns the sum to a variable named `result`, but `result` hasn\'t been declared within this function scope, and more importantly, the value isn\'t being *returned* to the caller.'}], indent: 1, explanation: "Perform the addition and return the sum."},
            { correct: '}', distractors: [{text:'end function;', reason:'C uses the closing curly brace `}` to mark the end of the function\'s definition block.'}, {text:'end add;', reason:'C uses the closing curly brace `}` to mark the end of the function\'s definition block, not keywords.'}], indent: 0, explanation: "Closes the add function block." }
        ]
    },
    // Level 4: Basic Input with scanf
    {
        goal: "Read an integer from the user and print it.",
        concepts: "scanf, printf, variables, address-of operator (&)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <input.h>', reason: 'There is no standard C header named `input.h`. Input/output functions like `scanf` and `printf` are in `stdio.h`.'}, {text: '#include <iostream>', reason: '`<iostream>` is the C++ header for input/output using `cin` and `cout`. C uses `<stdio.h>`.'}], indent: 0, explanation: "Include the standard input/output library." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return an integer (`int`) to indicate exit status.'}, {text: 'main function {', reason: 'C function definition requires a return type before the name and parentheses `()`. '}], indent: 0, explanation: "Start the main function." },
            { correct: 'int userInput;', distractors: [{text: 'var userInput;', reason: 'C is statically typed; you must declare the type explicitly (like `int`, `float`, `char`). `var` is used in languages like JavaScript.'}, {text: 'integer userInput;', reason: 'The keyword for the integer data type in C is `int`, not `integer`.'}], indent: 1, explanation: "Declare an integer variable to store the user's input." },
            { correct: 'printf("Enter an integer: ");', distractors: [{text: 'print("Enter an integer: ");', reason: 'The standard C function for formatted output is `printf`.'}, {text: 'scanf("Enter an integer: ");', reason: '`scanf` is used for *reading* formatted input, not for *printing* prompts.'}], indent: 1, explanation: "Prompt the user to enter a number." },
            { correct: 'scanf("%d", &userInput);', distractors: [{text: 'scanf("%d", userInput);', reason: '`scanf` needs the memory *address* where it should store the input. The address-of operator `&` is required before the variable name (`&userInput`).'}, {text: 'scanf(userInput);', reason: '`scanf` requires a format string (like `"%d"`) to specify the type of input expected and the address (`&variable`) to store it.'}], indent: 1, explanation: "Read an integer (%d) from input and store it at the address of 'userInput'." },
            { correct: 'printf("You entered: %d\\n", userInput);', distractors: [{text: 'printf("You entered: %d\\n", &userInput);', reason: '`printf` needs the *value* of the variable to print it. Passing the address (`&userInput`) would print the memory address, not the stored integer.'}, {text: 'printf(userInput);', reason: '`printf` requires a format string as the first argument to specify how to print the subsequent arguments.'}], indent: 1, explanation: "Print the value stored in the 'userInput' variable." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Returning 0 from `main` conventionally indicates successful execution. Non-zero often indicates an error.'}, {text: 'return userInput;', reason: '`main` should return an exit status (0 for success), not a variable\'s value unless intended as an exit code.'}], indent: 1, explanation: "Indicate successful program execution." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'C uses `}` to close function blocks.'}, {text: '};', reason: 'A semicolon `;` is used after `struct` definitions, but not after the closing brace `}` of a function.'}], indent: 0, explanation: "Close the main function block." }
        ]
    },
    // Level 5: Floating-Point Arithmetic
    {
        goal: "Calculate the area of a circle given its radius (using float).",
        concepts: "float data type, arithmetic operators, constants (#define), math.h",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason:'`stdlib.h` is for general utilities, not core I/O or math constants like M_PI.'}, {text:'#include <maths.h>', reason:'The standard math header is `<math.h>`, not `<maths.h>`.'}], indent: 0, explanation: "Include standard input/output for printing." },
            { correct: '#include <math.h>', distractors: [{text: '#include "math.h"', reason:'While sometimes permissible, standard library headers are conventionally included using angle brackets `< >`.'}, {text:'#include <float.h>', reason:'`<float.h>` defines properties of floating-point types, but not the `M_PI` constant or math functions like `pow()`.'}], indent: 0, explanation: "Include math library for constants like M_PI and functions like pow()." },
            { correct: '#define PI 3.14159f', distractors: [{text: '#define PI = 3.14159f;', reason:'`#define` is a preprocessor directive; it does not use `=` for assignment or usually end with a semicolon (the semicolon would become part of the replacement).'}, {text:'const float PI = 3.14159f;', reason:'Using `const float` is a more type-safe way to define constants in modern C, but `#define` is also common and widely used, especially in older codebases.'}], indent: 0, explanation: "Define a constant for PI (using 'f' suffix for float literal)." },
            { correct: 'int main() {', distractors: [{text:'float main() {', reason:'The C standard requires `main` to return `int`.'}, {text:'void main() {', reason:'Standard C requires `main` to return `int`. `void main` is non-standard.'}], indent: 0, explanation: "Start the main function." },
            { correct: 'float radius = 5.0f;', distractors: [{text: 'int radius = 5;', reason:'For calculations potentially involving decimals (like area with PI), using `float` or `double` provides more accurate results.'}, {text:'float radius = 5.0;', reason:'Appending `f` (e.g., `5.0f`) explicitly marks the literal as a `float`, avoiding potential implicit conversions from `double` if `5.0` were treated as `double` by default.'}], indent: 1, explanation: "Declare a float variable 'radius' and initialize it." },
            { correct: 'float area;', distractors: [{text: 'area = 0.0f;', reason:'Declaring the variable (`float area;`) must happen before assigning a value to it.'}, {text:'float area()', reason:'This syntax resembles a function declaration (`float area() { ... }`), not a variable declaration.'}], indent: 1, explanation: "Declare a float variable 'area' to store the result." },
            { correct: 'area = PI * radius * radius;', distractors: [{text: 'area = PI * (radius^2);', reason:'The `^` operator in C is the bitwise XOR operator, not exponentiation. Use `radius * radius` or `pow(radius, 2.0f)` from `<math.h>`.'}, {text:'area = PI * pow(radius, 2);', reason:'Using `pow()` from `<math.h>` is also correct (though `pow` typically takes `double` arguments, `radius` would be promoted). `radius * radius` is simpler for squaring.'}], indent: 1, explanation: "Calculate the area using the formula (PI * r^2)." },
            { correct: 'printf("Area: %.2f\\n", area);', distractors: [{text: 'printf("Area: %d\\n", area);', reason:'`%d` is the format specifier for integers. For floats, use `%f`. `%.2f` specifically formats it to 2 decimal places.'}, {text: 'printf("Area: %f.2\\n", area);', reason:'Format specifiers for precision come *before* the type character, like `%.2f`, not after (`%f.2`).'}], indent: 1, explanation: "Print the calculated area, formatted to 2 decimal places (%.2f)." },
            { correct: 'return 0;', distractors: [{text:'return area;', reason:'`main` should return 0 for success, not the calculated area value (unless intended as a specific exit code).'}, {text:'exit(0);', reason:'`return 0;` is the standard and preferred way to indicate success from `main`, allowing normal cleanup. `exit(0)` terminates immediately.'}], indent: 1, explanation: "Indicate successful execution." },
            { correct: '}', distractors: [{text:'end;', reason:'`end` is not a C keyword.'}, {text:'});', reason:'Parentheses and semicolons mark the end of statements or expressions, not code blocks.'}], indent: 0, explanation: "Close the main function." }
        ]
    },
    // Level 6: Character ASCII Value Even/Odd Check
    {
        goal: "Read a single character, get its integer ASCII value, and determine if that value is even or odd.",
        concepts: "char data type, getchar, printf, if-else statement, modulo operator (%)",
        sequence: [
            { correct: "#include <stdio.h>", distractors: [{text:"#include <stdlib.h>", reason:"`stdlib.h` is for general utilities. The functions for input/output like `printf` and `getchar` are in `stdio.h`."}, {text:"import stdio", reason:"`import` is not used in C; use `#include`."}], indent: 0, explanation: "Include the Standard Input/Output library for functions like `printf` and `getchar`." },
            { correct: "int main() {", distractors: [{text:"void main() {", reason:"Standard C requires `main` to return `int` to signal the program's exit status. `void main()` is non-standard."}, {text:"main() {", reason:"Missing return type for `main`. Should be `int main()`."}], indent: 0, explanation: "The main function where program execution begins." },
            { correct: "char inputChar;", distractors: [{text:"int inputChar;", reason:"While an `int` can store a character, using the `char` type is more idiomatic and clearly expresses the intent to store a character value."}, {text:"string inputChar;", reason:"`string` is not a built-in type in C."}], indent: 1, explanation: "Declare a variable of type `char` to store the user's input." },
            { correct: "printf(\"Enter a character: \");", distractors: [{text:"puts(\"Enter a character: \");", reason:"`puts` adds a newline automatically; `printf` provides better control."}, {text:"cout << \"Enter a character: \";", reason:"`cout` is a C++ feature, not C."}], indent: 1, explanation: "Prompt the user for input." },
            { correct: "inputChar = getchar();", distractors: [{text:"getchar(&inputChar);", reason:"`getchar()` returns a character; it doesn’t take a pointer argument."}, {text:"scanf(\"%c\", &inputChar);", reason:"`scanf(\"%c\", &inputChar)` works, but `getchar()` is simpler for reading a single character."}], indent: 1, explanation: "Read a single character from standard input." },
            { correct: "printf(\"Character: '%c'\\n\", inputChar);", distractors: [{text:"printf(\"Character: %s\\n\", &inputChar);", reason:"`%s` expects a null-terminated string; `%c` is for single characters."}, {text:"printf(inputChar);", reason:"`printf` requires a format string as the first argument to prevent security vulnerabilities."}], indent: 1, explanation: "Print the character that was entered." },
            { correct: "printf(\"ASCII Value: %d\\n\", inputChar);", distractors: [{text:"printf(\"ASCII Value: %c\\n\", inputChar);", reason:"`%c` would print the character itself again, not its numeric ASCII value. `%d` promotes the char to an int for printing."}, {text:"printf(\"ASCII Value: %u\\n\", inputChar);", reason:"`%d` is the standard choice for printing signed ASCII values, though `%u` would also work for standard characters."}], indent: 1, "explanation": "Display the numeric ASCII value of the character." },
            { correct: "if (inputChar % 2 == 0) {", distractors: [{text:"if (inputChar % 2 = 0) {", reason:"The `=` operator is for assignment. The `==` operator is for comparison."}, {text:"if (inputChar / 2 * 2 == inputChar) {", reason:"While this logic is correct for positive integers, using the modulo operator `%` is the direct and idiomatic way to check for evenness."}], indent: 1, explanation: "Check if the ASCII value is an even number." },
            { correct: "printf(\"The ASCII value %d is EVEN.\\n\", inputChar);", distractors: [{text:"printf(\"Character is even.\\n\");", reason:"It's more informative to use `%d` to explicitly show the user which numeric value was checked."}, {text:"printf(\"%f is even.\\n\", inputChar);", reason:"`%f` is for floating-point numbers. A `char` is an integer type, so `%d` must be used."}], indent: 2, explanation: "Display that the ASCII value is even." },
            { correct: "} else {", distractors: [{text:"} if else {", reason:"The `else` keyword does not take a condition directly after it. Use `else if (condition)` or just `else`."}, {text:"} else (inputChar % 2 != 0) {", reason:"An `else` block does not take a condition in parentheses. It automatically handles all cases where the preceding `if` was false."}], indent: 1, "explanation": "If the number was not even, this block executes." },
            { correct: "printf(\"The ASCII value %d is ODD.\\n\", inputChar);", distractors: [{text:"printf(\"Character is odd.\\n\");", reason:"It is better practice to print the actual numeric value with `%d` to provide full context."}, {text:"printf(\"It's odd!\\n\");", reason:"This is correct, but less informative than showing the value."}], indent: 2, "explanation": "Display that the ASCII value is odd." },
            { correct: "}", distractors: [{text:"end if;", reason:"C uses curly braces `{}` to define code blocks, not keywords like `end`."}, {text:"};", reason:"A semicolon is not placed after the closing brace of a code block."}], indent: 1, "explanation": "Close the else block." },
            { correct: "return 0;", distractors: [{text:"return inputChar;", reason:"Standard practice is to `return 0;` from `main` to indicate successful execution."}, {text:"end;", reason:"`end` is not a valid keyword in C."}], indent: 1, "explanation": "Exit the program successfully." },
            { correct: "}", distractors: [{text:"finish;", reason:"`finish` is not a keyword in C."}, {text:"end main;", reason:"C uses a closing curly brace `}` to end a function block, not keywords."}], indent: 0, "explanation": "Close the main function." }
        ]
    },
    // Level 7: Countdown with While Loop
    {
        goal: "Print numbers from 10 down to 1 using a while loop.",
        concepts: "while loop, decrement operator (--)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`stdlib.h` is for general utilities, not the `printf` function, which is in `stdio.h`.'}, {text: '#include "stdio.h"', reason: 'Using angle brackets `<>` is the convention for standard library headers, telling the compiler to look in standard system directories.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return `int`.'}, {text: 'int main(void) {', reason: 'This is also a correct way to declare main with no arguments, but `int main()` is more common.'}], indent: 0, explanation: "Start main function." },
            { correct: 'int counter = 10;', distractors: [{text:'int counter;', reason:'The counter needs an initial value (10) before the loop condition `counter >= 1` is checked.'}, {text:'int counter = 11;', reason:'Starting at 11 and using `--counter` inside the loop would work, but initializing directly to 10 is simpler.'}], indent: 1, explanation: "Initialize a counter variable to 10." },
            { correct: 'while (counter >= 1) {', distractors: [{text: 'while counter >= 1 {', reason:'The condition in a `while` loop must be enclosed in parentheses `()`. '}, {text:'while (counter > 0) {', reason:'Using `> 0` is equivalent to `>= 1` for integers and also correct.'}], indent: 1, explanation: "Start a loop that continues as long as 'counter' is greater than or equal to 1." },
            { correct: 'printf("%d ", counter);', distractors: [{text:'printf(counter);', reason:'`printf` requires a format string like `"%d "`.'}, {text:'printf("%d\\n", counter);', reason:'Using `\\n` prints each number on a new line. Using a space `" "` prints them on the same line as requested.'}], indent: 2, explanation: "Print the current value of the counter." },
            { correct: 'counter--;', distractors: [{text: 'counter ++;', reason:'`++` increments the counter. `--` is needed to decrement (count down).'}, {text:'--counter;', reason:'Both pre-decrement (`--counter`) and post-decrement (`counter--`) work here as standalone statements.'}], indent: 2, explanation: "Decrement the counter by 1." },
            { correct: '}', distractors: [{text:'end while;', reason:'C uses `}` to close loops.'}, {text:'break;', reason:'`break` would exit the loop prematurely after the first iteration.'}], indent: 1, explanation: "Close the while loop block." },
            { correct: 'printf("\\n"); // Print a final newline', distractors: [{text:'println();', reason:'`println` is not a standard C function.'}, {text: 'printf(\'\\n\');', reason: '`printf` expects a string literal (double quotes \" \") for the format string, not a character literal (single quotes \' \').'}], indent: 1, explanation: "Print a newline character for cleaner output after the loop." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to signal success. Non-zero values typically indicate an error.'}, {text: 'exit(0);', reason: '`exit(0)` is a valid way to terminate, but `return 0;` is the standard way to exit the `main` function.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: '`end` is not a C keyword.'}, {text: '};', reason: 'A semicolon is not placed after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 8: Input Validation with Do-While
    {
        goal: "Ask the user to enter a positive number, repeat until they do.",
        concepts: "do-while loop, scanf",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: 'include <stdio.h>;', reason: 'The preprocessor directive must start with `#` and should not end with a semicolon.'}, {text: '#include <iostream>', reason: '`<iostream>` is the C++ header for I/O. For `printf` and `scanf`, use `<stdio.h>`.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'The `main` function must be declared to return `int` in standard C.'}, {text: 'function main() {', reason: 'C does not use the `function` keyword. A function is defined by its return type, name, and parameters.'}], indent: 0, explanation: "Start main function." },
            { correct: 'int number;', distractors: [{text:'int number = 0;', reason:'Initializing is fine, but the loop guarantees execution at least once, so `scanf` will assign a value before the condition `number <= 0` is checked.'}, {text: 'let number;', reason: '`let` is not a C keyword for variable declaration. Use a type like `int`.'}], indent: 1, explanation: "Declare an integer variable to store user input." },
            { correct: 'do {', distractors: [{text: 'while (number <= 0) {', reason:'A `while` loop checks the condition *before* the first iteration. A `do-while` loop executes the body *at least once* before checking, which is needed here to get input first.'}, {text:'for (;;) { // Infinite loop', reason:'An infinite `for` loop would require an `if` and `break` inside, making `do-while` more suitable for this condition.'}], indent: 1, explanation: "Start a do-while loop, which executes the body at least once." },
            { correct: 'printf("Enter a positive number: ");', distractors: [{text: 'print("Enter a positive number: ");', reason: '`print` is not a standard C function; the correct function name is `printf`.'}, {text: 'scanf("Enter a positive number: ");', reason: '`scanf` is used for reading input from the user, not for displaying a message.'}], indent: 2, explanation: "Prompt the user for input inside the loop." },
            { correct: 'scanf("%d", &number);', distractors: [{text:'scanf("%d", number);', reason:'`scanf` requires the address (`&`) of the variable to store the input.'}, {text:'number = getchar();', reason:'`getchar` reads a single character, not a potentially multi-digit integer. Use `scanf` with `%d`.'}], indent: 2, explanation: "Read the integer input from the user." },
            { correct: '} while (number <= 0);', distractors: [{text: '} while number <= 0;', reason:'The condition must be enclosed in parentheses `()`. '}, {text:'} while (number < 1);', reason:'This condition is equivalent to `number <= 0` for integers and also correct.'}], indent: 1, explanation: "End the loop body and check the condition. Repeat if the number is not positive (<= 0)." },
            { correct: 'printf("Thank you! You entered: %d\\n", number);', distractors: [{text:'printf("Positive number entered.\\n");', reason:'Printing the actual number entered is more informative.'}, {text: 'printf("Thank you! You entered: %d", &number);', reason: '`printf` needs the variable\'s value, not its memory address (`&number`).'}], indent: 1, explanation: "Print the valid positive number entered." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Returning 1 indicates an error. The program completed successfully, so return 0.'}, {text: 'return number;', reason: '`main` should return an exit code, not the user\'s input.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'C uses `}` to close blocks, not the `end` keyword.'}, {text: '};', reason: 'Do not place a semicolon after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 9: Void Function
    {
        goal: "Define a function to print a greeting and call it from main.",
        concepts: "Function definition, function call, void return type",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: 'include <stdio.h>', reason: 'Preprocessor directives must begin with a `#` symbol.'}, {text: '#include <stdlib.h>', reason: '`printf` is in the standard I/O library (`stdio.h`), not the standard library (`stdlib.h`).'}], indent: 0, explanation: "Include standard I/O." },
            { correct: '// Function declaration (prototype)', distractors: [{text:'// Function definition', reason:'This is just the declaration (prototype), announcing the function\'s signature. The definition (implementation) comes later.'}, {text: '// Main function start', reason: 'This comment is inaccurate. The line below it declares a custom function, not `main`.'}], indent: 0, explanation: "Comment explaining the next line (prototype)." },
            { correct: 'void printGreeting(void);', distractors: [{text:'int printGreeting();', reason:'The function doesn\'t calculate or return a value, so `void` is the appropriate return type.'}, {text:'void printGreeting();', reason:'Specifying `(void)` for no parameters is explicit and preferred in C over empty parentheses `()` in declarations.'}], indent: 0, explanation: "Declare the function: returns nothing (void), takes no arguments (void)." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return an `int`.'}, {text: 'main function {', reason: 'This is not valid C syntax for a function definition.'}], indent: 0, explanation: "Start the main function." },
            { correct: 'printGreeting();', distractors: [{text: 'call printGreeting();', reason:'Function calls in C are done using just the function name followed by parentheses `()`. `call` is not a C keyword.'}, {text:'int result = printGreeting();', reason:'A `void` function doesn\'t return a value that can be assigned to `result`.'}], indent: 1, explanation: "Call the defined function to execute its code." },
            { correct: 'return 0;', distractors: [{text: 'return;', reason: 'The `main` function is defined to return `int`, so it must return an integer value.'}, {text: 'return "success";', reason: '`main` must return an integer exit code, not a string.'}], indent: 1, explanation: "Indicate successful execution of main." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'C uses `}` to close a function block, not keywords.'}, {text: 'stop;', reason: '`stop` is not a C keyword.'}], indent: 0, explanation: "Close the main function." },
            { correct: '// Function definition', distractors: [{text:'// Function call', reason:'This marks the implementation (definition) of the function.'}, {text: '// Comment block', reason: 'This is a comment, but "Function definition" is more specific and accurate for the code that follows.'}], indent: 0, explanation: "Comment indicating the function's implementation." },
            { correct: 'void printGreeting(void) {', distractors: [{text:'int printGreeting(void) {', reason:'The definition must match the return type (`void`) specified in the declaration.'}, {text:'void printGreeting() {', reason:'While sometimes allowed, matching the explicit `(void)` from the prototype in the definition is good practice.'}], indent: 0, explanation: "Define the function, matching the declaration." },
            { correct: 'printf("Hello from the function!\\n");', distractors: [{text:'puts("Hello from the function!");', reason:'`puts` works but adds its own newline. `printf` requires `\\n` explicitly.'}, {text: 'printf("Hello from the function!");', reason: 'Forgetting the `\\n` means the output might not have a line break, which can mess up terminal formatting.'}], indent: 1, explanation: "The action performed by the function: printing a message." },
            { correct: '}', distractors: [{text:'return;', reason:'Explicit `return;` is optional at the end of a `void` function; the closing brace `}` implies it.'}, {text:'};', reason:'Semicolon not needed after function closing brace.'}], indent: 0, explanation: "Close the printGreeting function block." }
        ]
    },
    // Level 10: Function Returning Value
    {
        goal: "Demonstrate the three fundamental types of functions: void (no parameters), with parameters, and returning a value.",
        concepts: "Function prototypes, function definitions, void functions, function parameters, return statement",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <functions.h>', reason: 'There is no standard C header for general functions; they are a core part of the language.'}], indent: 0, explanation: "Include the standard I/O library for printing." },
            { correct: '// --- Function Prototypes ---', distractors: [{text: '/* Function Declarations */', reason: 'This is also a valid multi-line comment style.'}], indent: 0, explanation: "Declaring all functions before `main` allows us to call them from anywhere." },
            { correct: 'void print_intro_message(void);', distractors: [{text: 'int print_intro_message(void);', reason: 'Since this function only prints a message and does not calculate or return any data, its return type should be `void`.'}], indent: 0, explanation: "Prototype 1: A `void` function that takes no arguments." },
            { correct: 'int add_two_numbers(int a, int b);', distractors: [{text: 'void add_two_numbers(int a, int b);', reason: 'This function needs to return the calculated sum (an integer), so its return type must be `int`.'}], indent: 0, explanation: "Prototype 2: A function that takes two integers and returns an integer result." },
            { correct: 'void print_final_result(int result);', distractors: [{text: 'void print_final_result(int);', reason: 'While omitting the parameter name is allowed in prototypes, including it (`result`) makes the function\'s purpose clearer.'}], indent: 0, explanation: "Prototype 3: A `void` function that accepts an integer argument to print." },
            { correct: '// --- Main Function ---', distractors: [], indent: 0, explanation: "The main entry point where we will orchestrate our function calls." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return an integer to indicate its exit status to the operating system.'}], indent: 0, explanation: "Start the main function." },
            { correct: 'print_intro_message();', distractors: [{text: 'call print_intro_message();', reason: 'C does not use a `call` keyword. A function is called simply by using its name followed by parentheses.'}], indent: 1, explanation: "Call the first function to print a welcome message." },
            { correct: 'int num1 = 20;', distractors: [], indent: 1, explanation: "Declare and initialize the first number." },
            { correct: 'int num2 = 22;', distractors: [], indent: 1, explanation: "Declare and initialize the second number." },
            { correct: 'int sum;', distractors: [], indent: 1, explanation: "Declare a variable to hold the result of our calculation." },
            { correct: 'sum = add_two_numbers(num1, num2);', distractors: [{text: 'add_two_numbers(num1, num2);', reason: 'The `add_two_numbers` function returns a value. You must capture it by assigning it to a variable to use it later.'}], indent: 1, explanation: "Call the addition function, passing `num1` and `num2` as arguments, and store the return value in `sum`." },
            { correct: 'print_final_result(sum);', distractors: [{text: 'print_final_result(int sum);', reason: 'When calling a function, you pass the variable (the argument) directly, without its type declaration.'}], indent: 1, explanation: "Call the final function, passing the calculated `sum` as its argument." },
            { correct: 'return 0;', distractors: [{text: 'return sum;', reason: '`main` should return 0 to signal success, not the result of the calculation.'}], indent: 1, explanation: "Indicate that the program finished successfully." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close the main function." },
            { correct: '// --- Function Definitions ---', distractors: [], indent: 0, explanation: "Now we provide the implementation for each of our declared functions." },
            { correct: 'void print_intro_message(void) {', distractors: [{text: 'int print_intro_message(void) {', reason: 'The function definition must match the prototype. Since it was declared to return `void`, the definition must also be `void`.'}], indent: 0, explanation: "Implement the intro message function." },
            { correct: '  printf("--- Function Demo: Starting calculation... ---\\n");', distractors: [], indent: 1, explanation: "The body of the function simply prints a line of text." },
            { correct: '}', distractors: [{text: 'return;', reason: 'An explicit `return;` is valid but optional at the end of a `void` function; the closing brace `}` is sufficient.'}], indent: 0, explanation: "Close the function block." },
            { correct: 'int add_two_numbers(int a, int b) {', distractors: [{text: 'void add_two_numbers(int a, int b) {', reason: 'The definition\'s return type (`int`) must match the prototype\'s return type.'}], indent: 0, explanation: "Implement the addition function." },
            { correct: '  int result = a + b;', distractors: [], indent: 1, explanation: "Perform the addition and store it in a local variable." },
            { correct: '  return result;', distractors: [{text: 'printf("Sum is %d", result);', reason: 'This function\'s job, as declared, is to *return* the calculated value, not to print it. The printing is handled by another function.'}], indent: 1, explanation: "Use the `return` keyword to send the calculated value back to the caller." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close the function block." },
            { correct: 'void print_final_result(int result) {', distractors: [{text: 'void print_final_result(value) {', reason: 'Function parameters in C require an explicit type declaration (e.g., `int result`).'}], indent: 0, explanation: "Implement the function that prints the final result." },
            { correct: '  printf("--- The final result is: %d ---\\n\", result);', distractors: [{text: 'printf(\"Result is %d\", sum);', reason: 'Inside this function, the passed value is known by the parameter name `result`. The variable `sum` only exists within the `main` function\'s scope.'}], indent: 1, explanation: "Print the integer value that was passed into the function." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close the final function block." }
        ]
    },
    // Level 11: Array Basics
    {
        goal: "Create an integer array, initialize it, and print the third element.",
        concepts: "Array declaration, array initialization, array indexing (0-based)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <arrays.h>', reason: 'There is no standard C header `<arrays.h>`. Basic array functionality is built into the language.'}, {text: '#include <iostream>', reason: '`<iostream>` is the C++ header for I/O. Use `<stdio.h>` for `printf` in C.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires that `main` returns an `int`.'}, {text: 'int main(void) {', reason: 'This is also a correct signature for `main`, but `int main()` is more common and sufficient here.'}], indent: 0, explanation: "Start main function." },
            { correct: 'int scores[5] = {88, 92, 75, 100, 95};', distractors: [{text: 'int scores = {88, 92, 75, 100, 95};', reason:'You must specify the array size (e.g., `[5]`) or use empty brackets (`[]`) to let the compiler deduce it from the initializer list.'}, {text:'int scores(5) = {88, 92, 75, 100, 95};', reason:'Array size is specified using square brackets `[]`, not parentheses `()`.'}], indent: 1, explanation: "Declare an integer array named 'scores' of size 5 and initialize it with values." },
            { correct: 'int thirdScore;', distractors: [{text:'int scores[2];', reason:'This declares another array, not a variable to hold a single score.'}, {text: 'var thirdScore;', reason: 'C is a statically typed language and does not use the `var` keyword. You must specify the type, like `int`.'}], indent: 1, explanation: "Declare a variable to hold the specific score." },
            { correct: 'thirdScore = scores[2];', distractors: [{text: 'thirdScore = scores[3];', reason:'Array indexing in C is 0-based. The third element is at index 2 (0, 1, 2). Index 3 refers to the fourth element.'}, {text:'thirdScore = scores.get(2);', reason:'C arrays do not have methods like `.get()`. Access elements using square bracket notation `scores[index]`.'}], indent: 1, explanation: "Access the third element (at index 2) of the array and store it." },
            { correct: 'printf("The third score is: %d\\n", thirdScore);', distractors: [{text:'printf("The third score is: %d\\n", scores);', reason:'Passing the array name `scores` usually decays to a pointer to the first element. `printf` with `%d` expects an integer value, not an address.'}, {text:'printf(thirdScore);', reason:'`printf` requires a format string.'}], indent: 1, explanation: "Print the value retrieved from the array." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 for success. A non-zero return value from `main` conventionally indicates an error.'}, {text: 'exit(0);', reason: '`exit(0)` is another way to terminate, but `return 0;` is the standard way to exit from `main`.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: '`end` is not a C keyword. A closing brace `}` is used.'}, {text: '};', reason: 'A semicolon should not be placed after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 12: Array Iteration
    {
        goal: "Iterate through an array using a for loop and print all elements.",
        concepts: "Arrays, for loop, array indexing",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`printf` is in `<stdio.h>`, not `<stdlib.h>`.'}, {text: '#include "stdio.h"', reason: 'Angle brackets `<>` are the standard convention for including system library headers.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must be declared to return `int` in standard C.'}, {text: 'function main() {', reason: 'C does not use the `function` keyword.'}], indent: 0, explanation: "Start main function." },
            { correct: 'int values[4] = {10, 20, 30, 40};', distractors: [{text:'int values[]; values = {10, 20, 30, 40};', reason:'Assignment using `{}` after declaration is not allowed for arrays.'}, {text:'int values[4] = (10, 20, 30, 40);', reason:'Array initialization uses curly braces `{}`, not parentheses `()`.'}], indent: 1, explanation: "Declare and initialize an integer array." },
            { correct: 'int i;', distractors: [{text:'i = 0;', reason:'Declare the variable `int i;` before using it.'}, {text: 'var i;', reason: 'C requires an explicit type like `int`, not the `var` keyword.'}], indent: 1, explanation: "Declare a loop counter variable." },
            { correct: 'printf("Array elements: ");', distractors: [{text: 'puts("Array elements: ");', reason: '`puts` also prints the string, but automatically adds a newline. `printf` is used here to keep all numbers on one line.'}, {text: 'printf(Array elements: );', reason: 'The string argument to `printf` must be enclosed in double quotes.'}], indent: 1, explanation: "Print a label before the elements." },
            { correct: 'for (i = 0; i < 4; i++) {', distractors: [{text: 'for (i = 0; i <= 4; i++) {', reason:'Array indices for size 4 are 0, 1, 2, 3. Using `<=` would attempt to access `values[4]`, which is out of bounds.'}, {text:'for (i = 1; i <= 4; i++) {', reason:'Array indexing starts at 0, so the loop should start at 0 to include the first element.'}], indent: 1, explanation: "Start a for loop to iterate from index 0 up to (but not including) 4." },
            { correct: 'printf("%d ", values[i]);', distractors: [{text: 'printf("%d ", &values[i]);', reason:'`&values[i]` gives the address of the element. Pass `values[i]` directly to print the value.'}, {text:'printf(values[i]);', reason:'`printf` requires a format string like `"%d "`.'}], indent: 2, explanation: "Inside the loop, print the element at the current index 'i'." },
            { correct: '}', distractors: [{text: 'end for;', reason: 'C uses `}` to close loop blocks, not keywords.'}, {text: 'continue;', reason: '`continue` would skip to the next iteration of the loop, not end the loop block definition.'}], indent: 1, explanation: "Close the for loop block." },
            { correct: 'printf("\\n");', distractors: [{text:'puts("");', reason:'`puts("")` also prints a newline and is valid here.'}, {text:'return 1; // Error', reason:'This implies an error. The goal is just to print a newline for formatting before a successful exit.'}], indent: 1, explanation: "Print a final newline for formatting." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to signal success.'}, {text: 'end;', reason: '`end` is not a C keyword.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'C uses `}` to end function blocks.'}, {text: '};', reason: 'A semicolon is not used after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 13: Array Size with sizeof
    {
        goal: "Calculate the number of elements in an array using sizeof.",
        concepts: "sizeof operator, arrays, integer division",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: 'import <stdio.h>', reason: 'Use `#include` in C, not `import`.'}, {text: '#include <stdlib.h>', reason: '`printf` and `sizeof` do not require `stdlib.h`.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}, {text: 'main() {', reason: 'Explicitly defining the return type `int` for main is standard practice.'}], indent: 0, explanation: "Start main function." },
            { correct: 'int data[] = {5, 10, 15, 20, 25, 30}; // Size inferred', distractors: [{text:'int data[6] = {5, 10, 15, 20, 25, 30};', reason:'Explicit size is fine, but letting the compiler infer size `[]` from the initializer is also common and adaptable.'}, {text:'int data[]; data = {5, 10, 15, 20, 25, 30};', reason:'Array assignment after declaration isn\'t allowed this way.'}], indent: 1, explanation: "Declare and initialize an array, letting the compiler determine its size." },
            { correct: 'int size;', distractors: [{text:'float size;', reason:'The number of elements (size) should be an integer.'}, {text:'size_t size;', reason:'`size_t` is the type technically returned by `sizeof` and is appropriate for sizes, but `int` is often used for simplicity here.'}], indent: 1, explanation: "Declare a variable to store the array size." },
            { correct: 'size = sizeof(data) / sizeof(data[0]);', distractors: [{text: 'size = sizeof(data);', reason:'`sizeof(data)` gives the total size of the array in *bytes*, not the number of elements.'}, {text:'size = sizeof(data) / sizeof(int*);', reason:'`sizeof(int*)` gives the size of a pointer to an integer, not the size of an integer element itself. Use `sizeof(data[0])` or `sizeof(int)`.'}], indent: 1, explanation: "Calculate size: total bytes of array divided by bytes of one element." },
            { correct: 'printf("Number of elements: %d\\n", size);', distractors: [{text:'printf("Size in bytes: %d\\n", sizeof(data));', reason:'This would print the total byte size, not the element count.'}, {text: 'printf("Number of elements: %s\\n", size);', reason: '`%s` is the format specifier for strings. To print an integer like `size`, you must use `%d`.'}], indent: 1, explanation: "Print the calculated number of elements." },
            { correct: '// Now loop using the calculated size', distractors: [{text: '// This is a comment', reason: 'While true, a more descriptive comment explaining the intent of the next code block is better.'}, {text: '/* Loop time */', reason: 'Both `//` and `/**/` are valid comment styles, but this comment is less descriptive.'}], indent: 1, explanation: "Comment indicating the next step." },
            { correct: 'for (int i = 0; i < size; i++) {', distractors: [{text:'for (int i = 0; i < 6; i++) {', reason:'Using the calculated `size` variable makes the loop automatically adapt if the array initialization changes. Hardcoding `6` is less flexible.'}, {text:'for (int i = 0; i <= size; i++) {', reason:'Loop must be `< size` as indices go from 0 to size-1.'}], indent: 1, explanation: "Use the calculated 'size' in the loop condition." },
            { correct: 'printf("%d ", data[i]);', distractors: [{text:'printf("%d ", i);', reason:'This prints the index, not the array value.'}, {text: 'printf(data[i]);', reason: '`printf` requires a format string (like `"%d "`) as its first argument.'}], indent: 2, explanation: "Print each element." },
            { correct: '}', distractors: [{text: 'end loop;', reason: 'C uses `}` to close blocks.'}, {text: 'continue;', reason: '`continue` skips to the next iteration; it does not close the loop definition.'}], indent: 1, explanation: "Close the loop." },
            { correct: 'printf("\\n");', distractors: [{text: 'puts("");', reason: '`puts` also prints a newline and is valid, but `printf("\\n");` is also very common.'}, {text: 'printf("/n");', reason: 'The backslash `\\` is the correct escape character for a newline, not the forward slash `/`.'}], indent: 1, explanation: "Final newline." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate a successful run.'}, {text: 'return size;', reason: '`main` should return an exit code, not the size of the array.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Use `}` to close the `main` function.'}, {text: '};', reason: 'Semicolons are not used after a function\'s closing brace.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 14: Pointer Basics
    {
        goal: "Declare a pointer, initialize it to NULL, assign an address later, and check for NULL.",
        concepts: "Pointers, NULL, address-of operator (&), dereference operator (*), if statement",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <string.h>', reason: '`<string.h>` is for string functions. `printf` is in `<stdio.h>`.'}, {text: '#include <pointers.h>', reason: 'There is no standard C header `<pointers.h>`.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: '#include <stdlib.h> // For NULL (though often in stdio.h too)', distractors: [{text:'#include <pointers.h>', reason:'There is no standard `<pointers.h>`. NULL is typically defined in `<stdlib.h>`, `<stdio.h>`, `<stddef.h>` and others.'}, {text: '#define NULL 0', reason: 'While `NULL` is often defined as `0` or `(void*)0`, you should include a standard header like `<stdlib.h>` rather than defining it yourself.'}], indent: 0, explanation: "Include stdlib.h, commonly containing the NULL definition." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int` in standard C.'}, {text: 'int main(void) {', reason: 'This is also correct, but `int main()` is more common.'}], indent: 0, explanation: "Start main." },
            { correct: 'int number = 50;', distractors: [{text: 'int number == 50;', reason: 'Use `=` for assignment, `==` for comparison.'}, {text: 'const int number = 50;', reason: 'Using `const` would make the variable read-only, which is fine here but not necessary for the goal.'}], indent: 1, explanation: "Declare a regular integer variable." },
            { correct: 'int *ptr = NULL;', distractors: [{text:'int *ptr;', reason:'Initializing pointers to `NULL` when declared is good practice if they aren\'t immediately assigned a valid address.'}, {text:'int *ptr = 0;', reason:'Assigning `0` is often equivalent to assigning `NULL`, but using the `NULL` macro is more explicit and standard.'}], indent: 1, explanation: "Declare an integer pointer and initialize it to NULL." },
            { correct: 'printf("Initial ptr value: %p\\n", ptr);', distractors: [{text: 'printf("Initial ptr value: %d\\n", ptr);', reason: 'The `%p` format specifier is specifically for printing pointer addresses in a standard, implementation-defined way.'}, {text: 'printf("Initial ptr value: %p\\n", *ptr);', reason: 'This would attempt to dereference a `NULL` pointer, leading to a crash or undefined behavior. We want to print the pointer\'s value itself.'}], indent: 1, explanation: "Show that the pointer initially holds the NULL address (often printed as 0 or (nil))." },
            { correct: '// Assign address later', distractors: [{text: '/* Assign address later */', reason: 'Both comment styles are valid in C.'}, {text: '// Pointer assignment follows', reason: 'This is also a perfectly good comment.'}], indent: 1, explanation: "Comment indicating address assignment." },
            { correct: 'ptr = &number;', distractors: [{text: 'ptr = number;', reason: '`ptr` is a pointer and needs a memory address. `number` is an integer value (50). The address-of operator `&` is needed.'}, {text: '*ptr = &number;', reason: 'This is incorrect. It tries to assign an address to the location `ptr` points to (which is NULL), a guaranteed error.'}], indent: 1, explanation: "Assign the memory address of 'number' to the pointer 'ptr'." },
            { correct: 'printf("Ptr value after assignment: %p\\n", ptr);', distractors: [{text: 'printf("Number address: %d\\n", ptr);', reason: 'Use `%p` to print pointer addresses.'}, {text: 'printf("Number value: %d\\n", *ptr);', reason: 'This is valid and would print 50, but the goal here is to show the address the pointer now holds.'}], indent: 1, explanation: "Show the non-NULL address now stored in ptr." },
            { correct: 'if (ptr != NULL) {', distractors: [{text:'if (ptr)', reason:'While checking `if (ptr)` works because NULL evaluates to false in a boolean context, explicitly comparing `ptr != NULL` is clearer.'}, {text:'if (*ptr != NULL)', reason:'`*ptr` accesses the *value* (50). We want to check if the *pointer itself* (`ptr`) is NULL before dereferencing it.'}], indent: 1, explanation: "Check if the pointer is NOT NULL before trying to use it." },
            { correct: 'printf("Value via pointer: %d\\n", *ptr);', distractors: [{text: 'printf("Value via pointer: %d\\n", ptr);', reason: '`ptr` holds the address. The dereference operator `*` is needed to get the value (50) stored at that address.'}, {text: 'printf("Value via pointer: %p\\n", *ptr);', reason: '`%p` is for printing pointers/addresses. `%d` is for printing the integer value that `*ptr` resolves to.'}], indent: 2, explanation: "Safely print the value only if the pointer is not NULL." },
            { correct: '} else {', distractors: [{text: '} else if (ptr == NULL) {', reason: 'An `else` block does not take a condition; it executes if the preceding `if` condition was false.'}, {text: '} otherwise {', reason: 'C uses the keyword `else`, not `otherwise`.'}], indent: 1, explanation: "Block for when the pointer is NULL." },
            { correct: 'printf("Pointer is NULL, cannot dereference.\\n");', distractors: [{text: 'printf("Error!");', reason: 'This is too generic. The message should be specific about why the `else` block was entered.'}, {text: 'return 1;', reason: 'While you could exit, the goal here is just to print a message, not terminate the program.'}], indent: 2, explanation: "Message indicating the pointer is NULL." },
            { correct: '}', distractors: [{text: 'end if;', reason: 'C uses `}` to close blocks.'}, {text: '};', reason: 'A semicolon is not used here.'}], indent: 1, explanation: "Close the if/else block." },
            { correct: 'return 0;', distractors: [{text: 'return NULL;', reason: '`main` should return an integer exit code. `NULL` might work if it\'s defined as 0, but `return 0;` is explicit and correct.'}, {text: 'return (0);', reason: 'Parentheses are not required and this is just a stylistic difference.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Use `}` to close the function block.'}, {text: '});', reason: 'This syntax is incorrect for closing a block.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 15: Pointers and Arrays
    {
        goal: "Demonstrate accessing array elements using both array[index] and *(array + index) notation.",
        concepts: "Pointers, arrays, pointer arithmetic, dereference operator (*), equivalence",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: 'The `printf` function is declared in `stdio.h`.'}, {text: '#include "stdio.h"', reason: 'Angle brackets `<>` are preferred for standard library headers.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}, {text: 'int main(void) {', reason: 'This is also correct.'}], indent: 0, explanation: "Start main." },
            { correct: 'int nums[] = {11, 22, 33, 44};', distractors: [{text: 'int nums[4] = (11, 22, 33, 44);', reason: 'Array initialization lists must use curly braces `{}`.'}, {text: 'int nums[]; nums = {11, 22, 33, 44};', reason: 'You cannot assign to an array using an initializer list after it has been declared.'}], indent: 1, explanation: "Declare and initialize an integer array." },
            { correct: 'int *ptr = nums; // Point ptr to the start of the array', distractors: [{text: 'int *ptr = &nums;', reason: '`nums` by itself decays into a pointer to its first element. `&nums` is a pointer to the entire array, a different type (`int (*)[4]`).'}, {text: 'int ptr = nums;', reason: 'The pointer variable `ptr` must be declared with an asterisk `*` to indicate it is a pointer.'}], indent: 1, explanation: "Declare a pointer and make it point to the first element of nums." },
            { correct: 'printf("Accessing elements for nums[]:\\n");', distractors: [{text: 'puts("Accessing elements for nums[]:\\n");', reason: '`puts` is also valid here, as it prints a string and a newline.'}, {text: 'printf("Accessing elements for nums[]:");', reason: 'Adding the `\\n` newline character makes the output cleaner.'}], indent: 1, explanation: "Print a header." },
            { correct: 'printf("Element 0: nums[0]=%d, *(nums+0)=%d\\n", nums[0], *(nums + 0));', distractors: [{text:'printf("Element 0: nums[0]=%d, *nums+0=%d\\n", nums[0], *nums + 0);', reason:'Operator precedence matters. `*nums + 0` dereferences `nums` first (gets 11) then adds 0. `*(nums + 0)` calculates the address first, then dereferences.'}, {text: 'printf("Element 0: %d, %d\\n", nums[0], *nums);', reason: '`*nums` is equivalent to `*(nums + 0)`, so this is also correct, but the goal is to explicitly show the `+ 0` arithmetic.'}], indent: 1, explanation: "Show accessing the first element using both notations with the array name." },
            { correct: 'printf("Element 1: nums[1]=%d, *(nums+1)=%d\\n", nums[1], *(nums + 1));', distractors: [{text: 'printf("Element 1: %d\\n", nums[1]);', reason: 'This is correct but only shows one access method. The goal is to show both `[]` and `*()` notations are equivalent.'}, {text: 'printf("Element 1: %d, %d\\n", nums[1], *nums + 1);', reason: '`*nums + 1` would evaluate to `11 + 1 = 12`. `*(nums + 1)` correctly gets the second element, `22`.'}], indent: 1, explanation: "Show accessing the second element using both notations." },
            { correct: 'printf("\\nAccessing elements via ptr:\\n");', distractors: [{text: 'printf("Accessing elements via ptr:\\n");', reason: 'Adding the leading `\\n` creates a blank line, which helps separate the output sections for clarity.'}, {text: 'puts("\\nAccessing elements via ptr:");', reason: '`puts` would print two newlines (one from `\\n`, one from `puts` itself), creating too much space.'}], indent: 1, explanation: "Print another header for pointer access." },
            { correct: 'printf("Element 0: ptr[0]=%d, *(ptr+0)=%d\\n", ptr[0], *(ptr + 0));', distractors: [{text:'printf("Element 0: ptr[0]=%d, *ptr[0]=%d\\n", ptr[0], *ptr[0]);', reason:'`*ptr[0]` is parsed as `*(ptr[0])` which is invalid here. Use `ptr[0]` or `*(ptr+0)`.'}, {text: 'printf("Element 0: %d, %d\\n", *ptr, *(ptr));', reason: 'This is also correct, but the goal is to show the explicit equivalence of `ptr[0]` and `*(ptr + 0)`.'}], indent: 1, explanation: "Show accessing the first element using both notations via the pointer." },
            { correct: 'printf("Element 2: ptr[2]=%d, *(ptr+2)=%d\\n", ptr[2], *(ptr + 2));', distractors: [{text: 'printf("Element 2: %d, %d\\n", ptr[2], *ptr + 2);', reason: '`*ptr + 2` would evaluate to `11 + 2 = 13`. The correct pointer arithmetic is `*(ptr + 2)` to get the value `33`.'}, {text: 'printf("Element 2: %d, %d\\n", *(ptr+2), *(ptr+2));', reason: 'This is correct but doesn\'t show the `ptr[2]` notation, which is part of the goal.'}], indent: 1, explanation: "Show accessing the third element using both notations via the pointer." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate success.'}, {text: 'end;', reason: '`end` is not a C keyword.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'Use `}` to close function blocks.'}, {text: '};', reason: 'Semicolons are not used after a function closing brace.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 16: String Literal vs Char Array
    {
        goal: "Illustrate the difference between a string literal (often read-only) and a modifiable char array.",
        concepts: "String literals, char arrays, pointers, memory segments (conceptual)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <string.h>', reason: '`printf` is in `<stdio.h>`. `<string.h>` is needed for functions like `strcpy`, which are not used here.'}, {text: '#include <stdlib.h>', reason: 'This header is not needed for this program.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` should return `int`.'}, {text: 'program main() {', reason: 'This is not valid C syntax.'}], indent: 0, explanation: "Start main." },
            { correct: 'char *strLiteral = "Immutable"; // Pointer to string literal', distractors: [{text:'char strLiteral[] = "Immutable";', reason:'This creates a modifiable array initialized with the string. The goal here is to show a pointer to a literal.'}, {text: 'string strLiteral = "Immutable";', reason: 'C does not have a native `string` type. Use `char*` for string literals or `char[]` for string variables.'}], indent: 1, explanation: "Declare a pointer initialized to point to a string literal (often in read-only memory)." },
            { correct: 'char charArray[] = "Modifiable"; // Modifiable char array', distractors: [{text:'char *charArray = {"Modifiable"};', reason:'This syntax is incorrect for initializing a pointer to a character array content. You would need `char *charArray = "Modifiable";` for a pointer to a literal, or `char charArray[]` for a modifiable array.'}, {text: 'char charArray[10]; charArray = "Modifiable";', reason: 'You cannot assign a string literal to a char array after its declaration. You must use `strcpy` or initialize it at declaration.'}], indent: 1, explanation: "Declare a character array initialized with a string literal (creating a copy in writable memory)." },
            { correct: 'printf("String Literal: %s\\n", strLiteral);', distractors: [{text: 'printf("String Literal: %c\\n", *strLiteral);', reason: '`%c` prints a single character. `*strLiteral` would print just the first character, \'I\'. `%s` is needed to print the whole string.'}, {text: 'puts(strLiteral);', reason: '`puts` would work, but it adds its own newline. The goal is likely to practice with `printf`.'}], indent: 1, explanation: "Print the string literal." },
            { correct: 'printf("Character Array: %s\\n", charArray);', distractors: [{text: 'printf("Character Array: %s\\n", &charArray);', reason: '`printf` with `%s` expects a `char*`. The array name `charArray` already decays to a pointer to its first element, so `&charArray` is not correct here (it has type `char (*)[size]`).'}, {text: 'for(int i=0; charArray[i]!=\'\\0\'; i++){ putchar(charArray[i]); }', reason: 'This is a valid way to print a string, but using `printf` with `%s` is much simpler and more common.'}], indent: 1, explanation: "Print the character array." },
            { correct: '// Attempt to modify first character', distractors: [{text: '/* Modify char */', reason: 'This is also a valid comment.'}, {text: '# Modify first char', reason: '`#` is not the C syntax for single-line comments. Use `//`.'}], indent: 1, explanation: "Comment explaining the next actions." },
            { correct: 'charArray[0] = \'X\'; // OK - Modifying the array', distractors: [{text:'strLiteral[0] = \'X\';', reason:'Attempting to modify a string literal through a pointer results in undefined behavior (often a crash) because the literal may be stored in read-only memory.'}, {text: 'charArray[0] = "X";', reason: 'Single quotes `\'X\'` are for a single `char` literal. Double quotes `"X"` are for a string literal (which includes a null terminator `\\0`), which cannot be assigned to a single char.'}], indent: 1, explanation: "Modify the first character of the character array (this is allowed)." },
            { correct: 'printf("Modified Array: %s\\n", charArray);', distractors: [{text: 'printf("Modified Array: %c\\n", charArray[0]);', reason: 'This would print only the first character \'X\'. `%s` is needed to see the whole modified string "Xodifiable".'}, {text: 'puts(charArray);', reason: '`puts` would also work correctly here.'}], indent: 1, explanation: "Show the modification was successful." },
            { correct: '// strLiteral[0] = \'Y\'; // <-- This would likely cause a runtime error!', distractors: [{text:'strLiteral = "New"; // OK - Changing where pointer points', reason:'Assigning a new string literal changes the pointer, but doesn\'t modify the original "Immutable" literal.'}, {text: '// strcpy(strLiteral, "New"); // Also an error!', reason: 'This would also cause a runtime error, as `strcpy` would attempt to write to the read-only memory where "Immutable" is stored.'}], indent: 1, explanation: "Comment illustrating the danger of modifying a string literal." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate success.'}, {text: 'exit(0);', reason: '`return 0;` is the standard way to exit `main`.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Use `}` to close the block.'}, {text: '};', reason: 'Semicolons are not used after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 17: Struct Initialization
    {
        goal: "Initialize a struct variable using an initializer list.",
        concepts: "Structs, initialization lists",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <structs.h>', reason: 'There is no standard `<structs.h>`. The `struct` keyword is built into the C language.'}, {text: '#include <string.h>', reason: 'This header is not needed for basic struct operations or `printf`.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'struct Point { int x; int y; };', distractors: [{text: 'struct Point ( int x, int y );', reason: 'The members of a struct must be defined within curly braces `{}`.'}, {text: 'class Point { int x; int y; };', reason: '`class` is the keyword for defining classes in C++, not for structs in C.'}], indent: 0, explanation: "Define a simple Point structure." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return `int`.'}, {text: 'int main(void) {', reason: 'This is also a correct way to define `main`.'}], indent: 0, explanation: "Start main." },
            { correct: 'struct Point p1 = {15, 25};', distractors: [{text:'struct Point p1;', reason:'This only declares p1; the goal is to initialize during declaration.'}, {text:'struct Point p1 = (15, 25);', reason:'Struct initialization uses curly braces `{}`, not parentheses `()`.'}], indent: 1, explanation: "Declare and initialize struct variable p1 using an initializer list {value_for_x, value_for_y}." },
            { correct: 'printf("p1 coordinates: (%d, %d)\\n", p1.x, p1.y);', distractors: [{text: 'printf("p1 x: %d\\n", p1.x); printf("p1 y: %d\\n", p1.y);', reason: 'This also works, but the goal is to print both coordinates in a single formatted line.'}, {text: 'printf("p1 coordinates: %d, %d\\n", p1);', reason: 'You cannot pass an entire struct to `printf` and expect it to print the members. You must pass each member individually.'}], indent: 1, explanation: "Print the members of the initialized struct." },
            { correct: '// Designated initializers (C99 and later)', distractors: [{text: '// C99 feature', reason: 'This is true, but the current comment is more descriptive of what the feature is.'}, {text: '/* Named initializers */', reason: 'This is also a valid comment and descriptive name.'}], indent: 1, explanation: "Comment introducing designated initializers." },
            { correct: 'struct Point p2 = {.y = 50, .x = 30}; // Order doesn\'t matter', distractors: [{text:'struct Point p2 = {y: 50, x: 30};', reason:'Designated initializers use a dot (`.`) before the member name (`.y`, `.x`), not a colon.'}, {text:'struct Point p2 = {50, 30};', reason:'Without designated initializers, values are assigned in order (x=50, y=30). Designated initializers allow explicit assignment by name.'}], indent: 1, explanation: "Initialize p2 using designated initializers (explicitly naming members)." },
            { correct: 'printf("p2 coordinates: (%d, %d)\\n", p2.x, p2.y);', distractors: [{text: 'printf("p2 coordinates: (%d, %d)\\n", p2.y, p2.x);', reason: 'This would print "(50, 30)". The format string expects the x-coordinate first, so `p2.x` should be the first argument.'}, {text: 'printf(p2.x, p2.y);', reason: '`printf` always requires a format string as its first argument.'}], indent: 1, explanation: "Print the members of p2." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate success.'}, {text: 'end;', reason: '`end` is not a C keyword.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'Use `}` to close the function.'}, {text: '};', reason: 'A semicolon is not placed after the brace closing a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 18: Pass Struct by Value
    {
        goal: "Pass a struct to a function by value and print its members inside the function.",
        concepts: "Structs, functions, pass-by-value",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: 'This header is not needed for this program.'}, {text: '#include <string.h>', reason: 'This header is not needed for this program.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'struct Item { int id; float price; };', distractors: [{text: 'struct Item[int id, float price];', reason: 'Struct members are defined within curly braces `{}`.'}, {text: 'typedef struct { int id; float price; } Item;', reason: 'Using `typedef` is a common and excellent practice, but this level focuses on the basic `struct` keyword syntax.'}], indent: 0, explanation: "Define an Item structure." },
            { correct: 'void displayItem(struct Item it); // Function takes struct by value', distractors: [{text:'void displayItem(struct Item *it);', reason:'`struct Item *it` would mean passing a pointer (pass-by-reference effect). `struct Item it` means passing a copy (pass-by-value).'}, {text: 'int displayItem(struct Item it);', reason: 'The function only prints information, it does not calculate or return a value, so `void` is the correct return type.'}], indent: 0, explanation: "Declare function displayItem that takes a struct Item by value (a copy)." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}, {text: 'int main(void) {', reason: 'This is also correct.'}], indent: 0, explanation: "Start main." },
            { correct: 'struct Item item1 = {101, 19.99f};', distractors: [{text: 'struct Item item1 = {19.99f, 101};', reason: 'Without designated initializers, the values must be in the same order as the members are declared in the struct (`id` then `price`).'}, {text: 'struct Item item1; item1 = {101, 19.99f};', reason: 'In modern C (C99+), you can assign to a struct with a compound literal after declaration, but initialization is more direct.'}], indent: 1, explanation: "Declare and initialize an Item struct." },
            { correct: 'displayItem(item1);', distractors: [{text:'displayItem(&item1);', reason:'The function expects a `struct Item`, not a pointer `struct Item *`. Pass `item1` directly to send a copy.'}, {text: 'displayItem({101, 19.99f});', reason: 'Passing a compound literal like this is also valid C, but the goal is to pass the variable `item1`.'}], indent: 1, explanation: "Call displayItem, passing the item1 struct (a copy will be made)." },
            { correct: 'printf("item1 price in main after call: %.2f\\n", item1.price);', distractors: [{text: 'printf("item1 price in main: %.2f\\n", it.price);', reason: 'The variable `it` only exists inside the `displayItem` function. In `main`, you must use `item1`.'}, {text: 'printf("item1 price: %f\\n", item1.price);', reason: '`%.2f` is better for currency as it formats the float to two decimal places.'}], indent: 1, explanation: "Show that the original item1 in main is unaffected by changes inside the function (if any)." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 for success.'}, {text: 'exit(0);', reason: '`return 0;` is the standard way to exit `main`.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'Use `}` to close the function.'}, {text: '};', reason: 'Semicolons are not placed after function braces.'}], indent: 0, explanation: "Close main." },
            { correct: 'void displayItem(struct Item it) {', distractors: [{text: 'void displayItem(struct Item item1) {', reason: 'It is good practice to use a different parameter name (`it`) to make it clear you are working with a copy, not the original `item1` from `main`.'}, {text: 'void displayItem(Item it) {', reason: 'In C, you must use the `struct` keyword before the struct name in a parameter list (unless you use `typedef`).'}], indent: 0, explanation: "Define displayItem, taking a copy of the struct named 'it'." },
            { correct: 'printf("-- Inside Function --\\n");', distractors: [{text: 'puts("-- Inside Function --");', reason: '`puts` also works and is slightly more efficient for printing a simple string with a newline.'}, {text: 'printf("-- Inside Function --");', reason: 'Adding `\\n` ensures the output moves to the next line, which is cleaner.'}], indent: 1, explanation: "Indicate output is from within the function." },
            { correct: 'printf("Item ID: %d\\n", it.id);', distractors: [{text: 'printf("Item ID: %d\\n", it->id);', reason: 'The arrow operator `->` is used to access members via a pointer to a struct. Since `it` is a struct variable itself (a copy), you use the dot operator `.`.'}, {text: 'printf("Item ID: %d\\n", &it.id);', reason: 'Passing `&it.id` would print the memory address of the `id` member, not its value.'}], indent: 1, explanation: "Print the id member of the received struct copy 'it'." },
            { correct: 'printf("Item Price: %.2f\\n", it.price);', distractors: [{text: 'printf("Item Price: %d\\n", it.price);', reason: '`%d` is for integers. The `price` member is a `float`, so you must use `%f` (or `%.2f` for formatting).'}, {text: 'printf("Item Price: %.2f\\n", it . price);', reason: 'There should not be a space between the variable name and the dot operator.'}], indent: 1, explanation: "Print the price member of 'it'." },
            { correct: 'it.price = 0.0f; // Modify the copy', distractors: [{text: 'item1.price = 0.0f;', reason: 'The original `item1` from `main` is not in scope here. You can only modify the local copy, `it`.'}, {text: 'it.id = 0;', reason: 'This modifies the `id`, but the goal is to show how modifying the price of the copy does not affect the original.'}], indent: 1, explanation: "Modify the price of the local copy 'it' within the function." },
            { correct: 'printf("Price inside function modified to: %.2f\\n", it.price);', distractors: [{text: 'printf("Price is now 0.00\\n");', reason: 'While true, printing the variable itself (`it.price`) confirms the assignment worked.'}, {text: 'printf("Original price was: %.2f\\n", item1.price);', reason: '`item1` is not accessible from within this function.'}], indent: 1, explanation: "Show the modified price of the copy." },
            { correct: 'printf("-- Leaving Function --\\n");', distractors: [{text: 'puts("-- Leaving Function --");', reason: '`puts` is also a valid and good choice here.'}, {text: '// End of function', reason: 'A print statement is better here to explicitly show the flow of control in the program\'s output.'}], indent: 1, explanation: "Indicate end of function execution." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Use `}` to close the function block.'}, {text: 'return;', reason: 'An explicit `return;` is optional at the end of a `void` function. The closing `}` is sufficient.'}], indent: 0, explanation: "Close displayItem function. The copy 'it' is destroyed." }
        ]
    },
    // Level 19: Pass Struct by Pointer
    {
        goal: "Pass a pointer to a struct to a function to modify the original struct.",
        concepts: "Structs, pointers, functions, pass-by-reference (using pointers), arrow operator (->)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: 'This header is not needed for this program\'s functionality.'}, {text: '#include <string.h>', reason: 'This header is for string manipulation and is not needed here.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'struct Config { int settingA; char mode; };', distractors: [{text: 'struct Config { int settingA, char mode };', reason: 'Members in a struct definition must be separated by semicolons, not commas.'}, {text: 'typedef struct { int settingA; char mode; };', reason: 'This is not a valid `typedef`. It should be `typedef struct { ... } Config;`.'}], indent: 0, explanation: "Define a Config structure." },
            { correct: 'void updateConfig(struct Config *confPtr); // Takes pointer', distractors: [{text:'void updateConfig(struct Config conf);', reason:'Passing by value (`struct Config conf`) sends a copy; modifications inside wouldn\'t affect the original.'}, {text: 'void updateConfig(struct Config &confPtr);', reason: 'Reference parameters using `&` are a C++ feature. To modify the original in C, you must pass a pointer (`*`).'}], indent: 0, explanation: "Declare function updateConfig taking a POINTER to a struct Config." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return an integer.'}, {text: 'int main(void) {', reason: 'This is also a correct way to declare `main`.'}], indent: 0, explanation: "Start main." },
            { correct: 'struct Config currentConfig = { 1, \'A\' };', distractors: [{text: 'struct Config currentConfig = { .settingA = 1, .mode = \'A\'};', reason: 'Using designated initializers is also correct and often clearer, but this level uses the simpler positional initialization.'}, {text: 'struct Config currentConfig;', reason: 'This just declares the struct variable but does not initialize its members, which would contain garbage values.'}], indent: 1, explanation: "Declare and initialize a Config struct." },
            { correct: 'printf("Before call: SettingA=%d, Mode=%c\\n", currentConfig.settingA, currentConfig.mode);', distractors: [{text: 'printf("Before: %d, %c\\n", currentConfig);', reason: 'You cannot pass an entire struct to `printf` this way. You must specify each member you want to print.'}, {text: 'puts("Config is initialized.");', reason: 'This is too vague. Printing the actual values is necessary to see the change later.'}], indent: 1, explanation: "Print initial values." },
            { correct: 'updateConfig(&currentConfig);', distractors: [{text:'updateConfig(currentConfig);', reason:'The function expects a pointer (`struct Config *`). Pass the address (`&`) of `currentConfig`.'}, {text: 'updateConfig(*currentConfig);', reason: 'This is invalid. `*` is the dereference operator, and you cannot dereference a non-pointer variable like `currentConfig`.'}], indent: 1, explanation: "Call updateConfig, passing the ADDRESS of currentConfig." },
            { correct: 'printf("After call: SettingA=%d, Mode=%c\\n", currentConfig.settingA, currentConfig.mode);', distractors: [{text: 'printf("After call: SettingA=%d, Mode=%c\\n", confPtr->settingA, confPtr->mode);', reason: 'The pointer `confPtr` only exists within the `updateConfig` function. In `main`, you must use the original variable `currentConfig`.'}, {text: 'puts("Config was updated.");', reason: 'Again, printing the actual values is the only way to prove the function worked as intended.'}], indent: 1, explanation: "Print values again to show they were modified by the function." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to signal that the program completed without errors.'}, {text: 'end;', reason: '`end` is not a keyword in C.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'Use `}` to close the function block.'}, {text: '};', reason: 'Do not put a semicolon after the function\'s closing brace.'}], indent: 0, explanation: "Close main." },
            { correct: 'void updateConfig(struct Config *confPtr) { // Receives pointer', distractors: [{text: 'void updateConfig(struct Config confPtr) {', reason: 'The function was declared to take a pointer (`struct Config *`), so the definition must match.'}, {text: 'void updateConfig(struct Config *config) {', reason: 'Using a different parameter name like `config` is perfectly fine and does not change the logic.'}], indent: 0, explanation: "Define updateConfig, receiving a pointer named 'confPtr'." },
            { correct: 'printf("-- Inside updateConfig --\\n");', distractors: [{text: 'puts("-- Inside updateConfig --");', reason: 'This is also a correct and efficient way to print this line.'}, {text: '// Now modifying the struct', reason: 'A comment is good, but a `printf` shows the program flow at runtime.'}], indent: 1, explanation: "Indicate execution within the function." },
            { correct: 'confPtr->settingA = 99;', distractors: [{text:'confPtr.settingA = 99;', reason:'`confPtr` is a pointer; use the arrow operator `->` to access members via the pointer.'}, {text:'*confPtr.settingA = 99;', reason:'Operator precedence is wrong; use `(*confPtr).settingA` or preferably `confPtr->settingA`.'}], indent: 1, explanation: "Modify the settingA member of the ORIGINAL struct via the pointer." },
            { correct: 'confPtr->mode = \'Z\';', distractors: [{text:'*confPtr->mode = \'Z\';', reason:'`confPtr->mode` already accesses the member value; no extra `*` is needed.'}, {text: '(*confPtr).mode = \'Z\';', reason: 'This syntax is also correct and equivalent to the arrow operator, but the arrow operator `->` is generally preferred for its readability with pointers.'}], indent: 1, explanation: "Modify the mode member of the ORIGINAL struct via the pointer." },
            { correct: 'printf("Config updated inside function.\\n");', distractors: [{text: 'printf("Updated to %d and %c\\n", confPtr->settingA, confPtr->mode);', reason: 'This is also a great option to be more explicit about what happened inside the function.'}, {text: 'return;', reason: 'A `return` is not necessary here; the goal is to print a confirmation.'}], indent: 1, explanation: "Confirmation message." },
            { correct: '}', distractors: [{text: 'end function;', reason: 'C uses `}` to close blocks.'}, {text: 'return;', reason: 'A `return;` is implied at the end of a `void` function by the closing brace.'}], indent: 0, explanation: "Close updateConfig function." }
        ]
    },
    // Level 20: File Read with fgets
    {
        goal: "Open an existing file ('output.txt'), read lines from it using fgets, and print them.",
        concepts: "File I/O, FILE pointer, fopen, fgets, fclose, file modes (\"r\"), char arrays (buffers)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: 'File operations are part of the standard I/O library, `<stdio.h>`.'}, {text: '#include <files.h>', reason: 'There is no standard C header named `<files.h>`.'}], indent: 0, explanation: "Include standard I/O for file operations and printf." },
            { correct: '// Assumes "output.txt" exists (e.g., from a previous write operation)', distractors: [{text: '/* File must exist */', reason: 'This is also a valid comment achieving the same goal.'}, {text: '// Create "output.txt"', reason: 'This comment is misleading. The code does not create the file; it assumes it\'s already there.'}], indent: 0, explanation: "Comment reminding prerequisite." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}, {text: 'int main(void) {', reason: 'This is also correct.'}], indent: 0, explanation: "Start main." },
            { correct: 'FILE *readFilePtr;', distractors: [{text: 'File *readFilePtr;', reason: 'The type for a file stream is `FILE`, in all capital letters.'}, {text: 'int *readFilePtr;', reason: 'A file stream requires a special `FILE` pointer, not a standard integer pointer.'}], indent: 1, explanation: "Declare a FILE pointer for reading." },
            { correct: 'char lineBuffer[100]; // Buffer to hold one line', distractors: [{text:'char *lineBuffer;', reason:'`fgets` needs a character array (buffer) allocated in memory to store the line it reads. A simple pointer isn\'t enough.'}, {text:'char lineBuffer;', reason:'A single char cannot hold a line of text.'}], indent: 1, explanation: "Declare a character array to act as a buffer for reading lines." },
            { correct: 'readFilePtr = fopen("output.txt", "r");', distractors: [{text:'readFilePtr = fopen("output.txt", "w");', reason:'Mode "w" is for writing (and truncates the file). Mode "r" is needed for reading.'}, {text:'readFilePtr = open("output.txt", "r");', reason:'`open` is a different, lower-level I/O function (from `<fcntl.h>`). The standard C library function is `fopen`.'}], indent: 1, explanation: "Open 'output.txt' in read mode ('r')." },
            { correct: 'if (readFilePtr == NULL) {', distractors: [{text: 'if (!readFilePtr) {', reason: 'This is also a correct and common way to check for a NULL pointer.'}, {text: 'if (readFilePtr == 0) {', reason: '`NULL` is the standard macro for a null pointer constant. While it may be defined as 0, using `NULL` is more explicit and portable.'}], indent: 1, explanation: "Check if the file failed to open (e.g., doesn't exist)." },
            { correct: 'perror("Error opening file for reading"); return 1;', distractors: [{text:'printf("Error opening file!\\n"); return 1;', reason:'`perror` is useful as it prints the system error message corresponding to why `fopen` failed.'}, {text: 'return 1;', reason: 'Exiting is correct, but you should always print an error message so the user knows what went wrong.'}], indent: 2, explanation: "Print a system error message using perror and exit if file couldn't be opened." },
            { correct: '}', distractors: [{text: 'end if;', reason: 'Use `}` to close a block.'}], indent: 1, explanation: "Close error check." },
            { correct: 'printf("Contents of output.txt:\\n---\n");', distractors: [{text: 'puts("Contents of output.txt:\\n---");', reason: '`puts` is fine, but it will add an extra newline at the end.'}], indent: 1, explanation: "Print a header before showing file content." },
            { correct: 'while (fgets(lineBuffer, sizeof(lineBuffer), readFilePtr) != NULL) {', distractors: [{text:'while (!feof(readFilePtr)) {', reason:'Checking `feof` *before* reading can lead to issues. The standard idiom is to check the return value of the read function (`fgets` or `fscanf`) itself. `fgets` returns NULL on end-of-file or error.'}, {text:'fgets(lineBuffer, 100, readFilePtr); while(1) { ... }', reason:'`fgets` should be *inside* the loop condition to read each line and check the return value.'}], indent: 1, explanation: "Loop while fgets successfully reads a line into lineBuffer (returns non-NULL)." },
            { correct: 'printf("%s", lineBuffer); // fgets includes newline', distractors: [{text:'printf("%s\\n", lineBuffer);', reason:'`fgets` reads and stores the newline character (`\\n`) if it fits in the buffer. Adding another `\\n` in `printf` would cause double spacing.'}, {text: 'puts(lineBuffer);', reason: '`puts` also prints the string but adds its own newline, which would also result in double spacing because `fgets` already captured one.'}], indent: 2, explanation: "Print the line read by fgets. It usually includes the newline." },
            { correct: '}', distractors: [{text: 'end while;', reason: 'Use `}` to close the loop block.'}], indent: 1, explanation: "Close the while loop." },
            { correct: 'printf("---\\nEnd of file.\\n");', distractors: [{text: 'puts("---\\nEnd of file.");', reason: 'This is also a perfectly valid way to print this.'}], indent: 1, explanation: "Print a footer after reading the file." },
            { correct: 'fclose(readFilePtr);', distractors: [{text:'fclose(lineBuffer);', reason:'`fclose` closes the `FILE` stream pointed to by `readFilePtr`.'}, {text: 'close(readFilePtr);', reason: '`close` is the corresponding function for `open`, not for `fopen`.'}], indent: 1, explanation: "Close the file stream." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate the program ran successfully.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Use `}` to close the main function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 21: Dynamic Memory with calloc
    {
        goal: "Allocate memory for an array of 3 integers using calloc() (initializes to zero) and print them.",
        concepts: "Dynamic memory allocation, calloc, free, sizeof, pointers, initialization to zero",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <string.h>', reason: 'This header is not needed.'}], indent: 0, explanation: "Include for printf." },
            { correct: '#include <stdlib.h>', distractors: [{text: '#include <memory.h>', reason: 'Dynamic memory functions like `calloc` and `free` are in the standard library header, `<stdlib.h>`.'}], indent: 0, explanation: "Include stdlib.h for calloc and free." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}], indent: 0, explanation: "Start main." },
            { correct: 'int *zeroArray;', distractors: [{text: 'int zeroArray[];', reason: 'This declares a static array of unknown size, which is not allowed. For dynamic memory, you need a pointer to hold the address.'}, {text: 'int *zeroArray = NULL;', reason: 'Initializing to NULL is excellent practice and also correct.'}], indent: 1, explanation: "Declare a pointer for the dynamically allocated array." },
            { correct: 'int count = 3;', distractors: [{text: 'const int count = 3;', reason: 'Using `const` is good practice for a value that won\'t change and is also correct here.'}, {text: '#define count 3', reason: 'Using a `#define` macro is another way to create a constant, but an `int` variable is often preferred in modern C.'}], indent: 1, explanation: "Define the number of elements needed." },
            { correct: 'zeroArray = (int *)calloc(count, sizeof(int));', distractors: [{text:'zeroArray = (int *)malloc(count * sizeof(int));', reason:'`malloc` allocates memory but doesn\'t initialize it (contains garbage values). `calloc` allocates *and* initializes the memory to zero.'}, {text:'zeroArray = (int *)calloc(sizeof(int), count);', reason:'The arguments for `calloc` are `(number_of_elements, size_of_each_element)`.'}], indent: 1, explanation: "Allocate memory for 'count' integers using calloc (initializes to zero) and cast." },
            { correct: 'if (zeroArray == NULL) {', distractors: [{text: 'if (!zeroArray) {', reason: 'This is another correct and common way to check for a NULL pointer.'}, {text: 'if (zeroArray != NULL) {', reason: 'This checks for a successful allocation. The block immediately following should handle the *failure* case.'}], indent: 1, explanation: "Check if calloc failed." },
            { correct: 'printf("Memory allocation failed!\\n"); return 1;', distractors: [{text: 'return 1;', reason: 'You should always print an error message to inform the user why the program is terminating.'}, {text: 'exit(1);', reason: '`exit(1)` from `<stdlib.h>` is also a valid way to terminate the program upon error.'}], indent: 2, explanation: "Handle allocation failure." },
            { correct: '}', distractors: [{text: 'end if;', reason: 'Use `}` to close the block.'}], indent: 1, explanation: "Close error check." },
            { correct: 'printf("Array elements after calloc (should be 0):\\n");', distractors: [{text: 'puts("Array elements are zero:");', reason: 'This also works, but the current message is slightly more descriptive about why they should be zero.'}], indent: 1, explanation: "Print a header." },
            { correct: 'for (int i = 0; i < count; i++) {', distractors: [{text: 'for (int i = 0; i <= count; i++) {', reason: 'This would cause a buffer overflow by trying to access `zeroArray[3]`, which is one element past the allocated memory.'}], indent: 1, explanation: "Loop through the allocated elements." },
            { correct: 'printf("zeroArray[%d] = %d\\n", i, zeroArray[i]);', distractors: [{text: 'printf("%d\\n", zeroArray[i]);', reason: 'Including the index `i` in the printout makes the output clearer and easier to verify.'}, {text: 'printf("Value is %d\\n", *(zeroArray + i));', reason: 'This is also a correct way to access and print the element using pointer arithmetic notation.'}], indent: 2, explanation: "Print the index and the value (should be 0)." },
            { correct: '}', distractors: [{text: 'end loop;', reason: 'Use `}` to close the loop.'}], indent: 1, explanation: "Close the loop." },
            { correct: 'free(zeroArray);', distractors: [{text:'free(&zeroArray);', reason:'`free` needs the pointer (`zeroArray`) that holds the address returned by `calloc`.'}, {text: 'delete(zeroArray);', reason: '`delete` is the C++ operator for freeing memory allocated with `new`. In C, you must use `free`.'}], indent: 1, explanation: "Free the memory allocated by calloc." },
            { correct: 'zeroArray = NULL;', distractors: [{text: '// Memory is now free', reason: 'This is a good comment, but setting the pointer to NULL is an important safety step to prevent dangling pointers.'}, {text: 'free(zeroArray); // Free again to be sure', reason: 'Freeing the same memory twice (a "double free") leads to undefined behavior and can crash your program.'}], indent: 1, explanation: "Set pointer to NULL after freeing (good practice)." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate success.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Use `}` to close `main`.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 22: Dynamic Memory with malloc
    {
        goal: "Allocate memory for an array of 5 floats dynamically using malloc, use it, and free it.",
        concepts: "Dynamic memory allocation, malloc, free, sizeof, pointers, pointer arithmetic/array notation",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: 'While `stdlib.h` is needed for this program, the `printf` function specifically requires `<stdio.h>`.'}, {text: 'import <stdio.h>', reason: 'C uses the `#include` preprocessor directive, not `import`.'}], indent: 0, explanation: "Include for printf." },
            { correct: '#include <stdlib.h>', distractors: [{text: '#include <memory.h>', reason: 'The standard C header for memory allocation functions like `malloc` and `free` is `<stdlib.h>`.'}, {text: '#include <string.h>', reason: 'The `<string.h>` header contains string manipulation functions, not memory allocation functions.'}], indent: 0, explanation: "Include stdlib.h for malloc and free." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'In standard C, the `main` function must be declared to return an `int` to signal its exit status.'}, {text: 'function main() {', reason: 'C does not use the `function` keyword; a function is defined by its return type, name, and parameters.'}], indent: 0, explanation: "Start main." },
            { correct: 'float *dynFloatArray;', distractors: [{text:'float dynFloatArray[5];', reason:'This declares a static array on the stack. We need a pointer for dynamically allocated memory from the heap.'}, {text: 'float *dynFloatArray = NULL;', reason: 'Initializing the pointer to NULL is excellent practice and is also a correct way to start.'}], indent: 1, explanation: "Declare a pointer to float for the dynamic array." },
            { correct: 'int numElements = 5;', distractors: [{text: '#define numElements 5', reason: 'Using a preprocessor macro is another valid way to define a constant like the size.'}, {text: 'const int numElements = 5;', reason: 'Using a `const` variable is also a great, type-safe way to define the size.'}], indent: 1, explanation: "Define the desired number of elements." },
            { correct: 'dynFloatArray = (float *)malloc(numElements * sizeof(float));', distractors: [{text:'dynFloatArray = (float *)malloc(numElements);', reason:'`malloc` needs the total number of *bytes*. You must multiply the number of elements by the size of *each* element (`sizeof(float)`).'}, {text:'dynFloatArray = (float *)malloc(sizeof(float[numElements]));', reason:'While this might work if `numElements` is a compile-time constant, the standard and most flexible way is `count * sizeof(type)`.'}], indent: 1, explanation: "Allocate memory for 'numElements' floats and cast the result to float*." },
            { correct: 'if (dynFloatArray == NULL) {', distractors: [{text: 'if (!dynFloatArray) {', reason: 'This is an equivalent and common way to check if a pointer is NULL, as NULL evaluates to false.'}, {text: 'if (dynFloatArray != NULL) {', reason: 'This checks for success. The `if` block here is intended to handle the *failure* case.'}], indent: 1, explanation: "Check if memory allocation failed." },
            { correct: 'printf("Memory allocation failed!\\n"); return 1;', distractors: [{text: 'return 1;', reason: 'It is crucial to print an error message to let the user know what went wrong before exiting.'}, {text: 'exit(1);', reason: '`exit(1)` from `<stdlib.h>` is also a valid and common way to terminate the program upon error.'}], indent: 2, explanation: "Handle allocation failure." },
            { correct: '}', distractors: [{text: 'end if;', reason: 'C uses a closing curly brace `}` to end a block, not keywords.'}], indent: 1, explanation: "Close error check." },
            { correct: '// Initialize the dynamic array', distractors: [{text: '/* Initialize array */', reason: 'This is another valid comment style in C.'}], indent: 1, explanation: "Comment indicating array initialization." },
            { correct: 'for (int i = 0; i < numElements; i++) {', distractors: [{text: 'for (int i=0; i < 5; i++) {', reason: 'Using the `numElements` variable is better practice than hard-coding the number 5, making the code easier to change.'}], indent: 1, explanation: "Loop through the allocated elements." },
            { correct: 'dynFloatArray[i] = (float)i * 1.1f;', distractors: [{text:'*(dynFloatArray + i) = (float)i * 1.1f;', reason:'Both array notation `dynFloatArray[i]` and pointer arithmetic `*(dynFloatArray + i)` are valid ways to access elements.'}, {text: 'dynFloatArray[i] = i * 1.1;', reason: 'Appending `f` (as in `1.1f`) makes the number a `float` literal, which is good practice for type consistency.'}], indent: 2, explanation: "Assign values using array notation (e.g., 0.0, 1.1, 2.2,...)." },
            { correct: '}', distractors: [{text: 'end for;', reason: 'C uses `}` to end loop blocks.'}], indent: 1, explanation: "Close initialization loop." },
            { correct: 'printf("Dynamic array elements: ");', distractors: [{text: 'puts("Dynamic array elements: ");', reason: '`puts` automatically adds a newline, which would cause the numbers to print on the next line, not after the label.'}], indent: 1, explanation: "Print a label." },
            { correct: 'for (int i = 0; i < numElements; i++) {', distractors: [{text: 'for (int i = 0; i <= numElements; i++) {', reason: 'Using `<=` would try to access an element at index 5, which is out of bounds for an array of 5 elements (indices 0-4).'}], indent: 1, explanation: "Loop again to print the elements." },
            { correct: 'printf("%.1f ", dynFloatArray[i]);', distractors: [{text: 'printf("%f ", dynFloatArray[i]);', reason: 'Using `%.1f` formats the output to one decimal place, which looks cleaner here.'}, {text: 'printf("%d ", dynFloatArray[i]);', reason: '`%d` is for printing integers. You must use `%f` for printing float values.'}], indent: 2, explanation: "Print each element, formatted to one decimal place." },
            { correct: '}', distractors: [{text: 'continue;', reason: '`continue` would just skip to the next loop iteration; it does not define the end of the loop\'s code block.'}], indent: 1, explanation: "Close printing loop." },
            { correct: 'printf("\\n");', distractors: [{text: 'puts("");', reason: 'This is another valid and common way to print just a newline character.'}], indent: 1, explanation: "Final newline." },
            { correct: 'free(dynFloatArray);', distractors: [{text: 'delete dynFloatArray;', reason: '`delete` is a C++ keyword for freeing memory. The C equivalent is `free`.'}, {text: 'free(dynFloatArray[0]);', reason: 'You must `free` the pointer to the start of the memory block that `malloc` returned, not a pointer to a single element.'}], indent: 1, explanation: "Free the entire allocated block of memory." },
            { correct: 'dynFloatArray = NULL;', distractors: [{text: '// Pointer is now invalid', reason: 'This comment is true, but actively setting the pointer to `NULL` is a crucial safety step to create a null pointer, not a dangling one.'}], indent: 1, explanation: "Set pointer to NULL after freeing." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Returning `1` (or any non-zero value) from `main` conventionally indicates that an error occurred.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: '`end` is not a C keyword. A closing brace `}` is used to end a function block.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 23: String Copy with strcpy
    {
        goal: "Copy one string to another using strcpy.",
        concepts: "strcpy, string.h, char arrays, null termination, buffer safety (conceptual)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: 'The header for `printf` is `<stdio.h>`.'}, {text: '#include "stdio.h"', reason: 'Using angle brackets `<>` is the standard convention for including system library headers.'}], indent: 0, explanation: "Include for printf." },
            { correct: '#include <string.h>', distractors: [{text: '#include <strings.h>', reason:'The standard C header for string manipulation is `<string.h>`, not `<strings.h>` (a non-standard POSIX header).'}, {text: '#include <stdlib.h>', reason: 'The `strcpy` function is declared in `<string.h>`, not `<stdlib.h>`.'}], indent: 0, explanation: "Include string.h for strcpy." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires that `main` returns an `int`.'}, {text: 'int main(void) {', reason: 'This is also a correct way to declare `main` with no arguments.'}], indent: 0, explanation: "Start main." },
            { correct: 'char source[] = "Hello C!";', distractors: [{text:'char *source = "Hello C!";', reason:'This creates a pointer to a string literal, which may be read-only. For demonstrating `strcpy`, using a mutable array is safe.'}, {text: 'char source[] = {\'H\',\'e\',\'l\',\'l\',\'o\',\' \',\'C\',\'!\'};', reason: 'This array is missing the required null terminator (`\\0`). `strcpy` would read past the end of it.'}], indent: 1, explanation: "Declare and initialize the source string." },
            { correct: 'char destination[20];', distractors: [{text:'char destination[];', reason:'When declaring an array that will be a destination, its size must be specified and be large enough to hold the source string.'}, {text:'char *destination;', reason:'This declares an uninitialized pointer. `strcpy` needs a valid memory location (like an array) to copy data into.'}], indent: 1, explanation: "Declare the destination string buffer (must be large enough)." },
            { correct: 'strcpy(destination, source);', distractors: [{text:'strcpy(source, destination);', reason:'The first argument to `strcpy` is the destination, and the second is the source. This would be a dangerous buffer overflow.'}, {text:'destination = source;', reason:'You cannot assign one array to another using the `=` operator in C. You must use a function like `strcpy` to copy the content.'}], indent: 1, explanation: "Copy the source string to the destination string." },
            { correct: 'printf("Source: %s\\n", source);', distractors: [{text: 'printf(source);', reason: 'This is insecure and considered bad practice (a format string vulnerability). Always use a format specifier like `%s`.'}, {text: 'puts(source);', reason: '`puts` is also a correct way to print the string, and it automatically adds a newline.'}], indent: 1, explanation: "Print the source string." },
            { correct: 'printf("Destination: %s\\n", destination);', distractors: [{text: 'puts(destination);', reason: '`puts` would also work correctly here.'}, {text: 'printf("Destination: %s\\n", &destination);', reason: 'The array name `destination` already decays to a pointer. `&destination` is a pointer to the whole array, which is the wrong type for `%s`.'}], indent: 1, explanation: "Print the copied string in destination." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate a successful run.'}, {text: 'return destination;', reason: '`main` must return an `int` exit code, not a pointer to a string.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: '`end` is not a C keyword. Use `}`.'}, {text: '};', reason: 'A semicolon is not used after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 24: String Concatenation with strcat
    {
        goal: "Concatenate two strings using strcat.",
        concepts: "strcat, string.h, char arrays, buffer overflow risk (conceptual)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`printf` is in `<stdio.h>`.'}, {text: '#include "stdio.h"', reason: 'Use angle brackets `<>` for standard library headers.'}], indent: 0, explanation: "Include for printf." },
            { correct: '#include <string.h>', distractors: [{text: '#include <stdlib.h>', reason: 'String functions like `strcat` are declared in `<string.h>`.'}, {text: '#include <str.h>', reason: 'There is no standard C header named `<str.h>`. The correct header is `<string.h>`.'}], indent: 0, explanation: "Include string.h for strcat." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return type `int`.'}, {text: 'int main(void) {', reason: 'This is also correct.'}], indent: 0, explanation: "Start main." },
            { correct: 'char str1[50] = "Hello, ";', distractors: [{text:'char str1[] = "Hello, ";', reason:'While this initialization is valid, the destination array for `strcat` must be explicitly sized large enough to hold the final concatenated string.'}, {text: 'char *str1 = "Hello, ";', reason: 'You cannot use `strcat` to modify a string literal, as they are typically stored in read-only memory.'}], indent: 1, explanation: "Declare first string with enough space for concatenation." },
            { correct: 'char str2[] = "World!";', distractors: [{text: 'const char str2[] = "World!";', reason: 'Marking the source string `const` is good practice since `strcat` does not modify it. This would also work.'}, {text: 'char str2[6] = "World!";', reason: 'This is too small. It does not leave room for the null terminator `\\0`.'}], indent: 1, explanation: "Declare the second string to append." },
            { correct: 'strcat(str1, str2);', distractors: [{text:'strcat(str2, str1);', reason:'`strcat` appends the second string to the first. `str2` does not have enough space to hold the result, leading to a buffer overflow.'}, {text:'str1 = str1 + str2;', reason:'String concatenation with the `+` operator is not a feature of C char arrays; you must use a function like `strcat`.'}], indent: 1, explanation: "Append str2 to the end of str1." },
            { correct: 'printf("Concatenated string: %s\\n", str1);', distractors: [{text: 'printf(str1);', reason: 'This is insecure and can lead to a format string vulnerability. Always use `%s`.'}, {text: 'puts(str1);', reason: '`puts` is also a correct and safe way to print the final string.'}], indent: 1, explanation: "Print the resulting string in str1." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 for success.'}, {text: 'return strlen(str1);', reason: '`main` should return an exit code (0 for success), not a calculated value like the string length.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'Use `}` to close a function block.'}, {text: '};', reason: 'Do not place a semicolon after a function\'s closing brace.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 25: String Length with strlen
    {
        goal: "Find the length of a string using strlen.",
        concepts: "strlen, string.h, null termination (excluding)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`printf` is in `<stdio.h>`.'}, {text: 'import <stdio.h>', reason: 'C uses `#include`.'}], indent: 0, explanation: "Include for printf." },
            { correct: '#include <string.h>', distractors: [{text: '#include <stdlib.h>', reason: '`strlen` is declared in `<string.h>`.'}, {text: '#include <strings.h>', reason: 'The standard header is `<string.h>`. `<strings.h>` is a different, non-standard header.'}], indent: 0, explanation: "Include string.h for strlen." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}, {text: 'int main[] {', reason: 'Functions use parentheses `()` for their signature, not square brackets `[]`.'}], indent: 0, explanation: "Start main." },
            { correct: 'char myString[] = "Test"; // Length is 4', distractors: [{text: 'char *myString = "Test";', reason: 'This also works, as `strlen` correctly handles pointers to string literals.'}, {text: 'char myString[] = {\'T\', \'e\', \'s\', \'t\'};', reason: 'This array is NOT null-terminated. `strlen` would read past the end of the allocated memory, causing undefined behavior.'}], indent: 1, explanation: "Declare and initialize a string." },
            { correct: 'int length;', distractors: [{text:'size_t length;', reason:'`strlen` actually returns type `size_t`. Using `int` is common for simplicity, but `size_t` is the most correct type.'}, {text: 'int length = 0;', reason: 'Initializing to zero is fine and good practice, though it will be immediately overwritten by the `strlen` call.'}], indent: 1, explanation: "Declare a variable to store the length." },
            { correct: 'length = strlen(myString);', distractors: [{text:'length = sizeof(myString);', reason:'`sizeof(myString)` gives the size of the array in memory (5 bytes: 4 chars + 1 null terminator). `strlen` counts only the characters *before* the null terminator (4).'}, {text:'length = strlen(&myString);', reason:'`strlen` expects a `char*`. The array name `myString` decays to this type. `&myString` is a pointer to the whole array, which is the wrong type.'}], indent: 1, explanation: "Calculate the length of the string." },
            { correct: 'printf("The length of \\"%s\\" is %d.\\n", myString, length);', distractors: [{text: 'printf("Length is %d\\n", length);', reason: 'This works, but including the original string `myString` in the output makes it much more descriptive.'}, {text: 'printf("Length of %s is %f\\n", myString, length);', reason: '`%f` is the format specifier for floats. You must use `%d` to print an integer like `length`.'}], indent: 1, explanation: "Print the string and its calculated length." },
            { correct: 'return 0;', distractors: [{text: 'return length;', reason: '`main` should return the exit code `0` for success, not the calculated length of the string.'}, {text: 'exit(0);', reason: '`exit(0)` is another way to terminate successfully, but `return 0;` is the standard way to exit the `main` function.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'C uses `}` to close function blocks.'}, {text: '};', reason: 'A semicolon is not placed after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 26: String Comparison with strcmp
    {
        goal: "Compare two strings using strcmp.",
        concepts: "strcmp, string.h, return values (0, <0, >0)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`printf` is in `<stdio.h>`.'}, {text: '#include <string.h>', reason: 'This is also needed, but this line is for `printf`.'}], indent: 0, explanation: "Include for printf." },
            { correct: '#include <string.h>', distractors: [{text: '#include <stdio.h>', reason: 'This is already included. This line is for `strcmp` which is in `<string.h>`.'}, {text: '#include <compare.h>', reason: 'There is no standard C header `<compare.h>`. String comparison is in `<string.h>`.'}], indent: 0, explanation: "Include string.h for strcmp." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}, {text: 'int main(void) {', reason: 'This is also correct.'}], indent: 0, explanation: "Start main." },
            { correct: 'char s1[] = "apple";', distractors: [{text: 'char s1 = "apple";', reason: 'You cannot assign a multi-character string literal to a single `char` variable.'}, {text: 'char s1[] = {\'a\',\'p\',\'p\',\'l\',\'e\'};', reason: 'This array is missing the essential null terminator (`\\0`), which would cause `strcmp` to read out of bounds.'}], indent: 1, explanation: "Declare first string." },
            { correct: 'char s2[] = "apply";', distractors: [{text: 'char s2[5] = "apply";', reason: 'This array is not large enough. It needs to be size 6 to hold the 5 characters plus the null terminator.'}, {text: 'char *s2 = "apply";', reason: 'This is also a valid way to create a string for comparison.'}], indent: 1, explanation: "Declare second string (different)." },
            { correct: 'char s3[] = "apple";', distractors: [{text: 'char s3[] = s1;', reason: 'You cannot initialize an array with another array in this manner.'}, {text: 'char *s3 = s1;', reason: 'This makes `s3` a pointer to `s1`. `strcmp(s1, s3)` would work, but the goal is to compare two separate but identical strings.'}], indent: 1, explanation: "Declare third string (same as s1)." },
            { correct: 'int result12 = strcmp(s1, s2);', distractors: [{text:'int result12 = s1 == s2;', reason:'Comparing char arrays with `==` compares their memory addresses, not their content. Use `strcmp` for content comparison.'}, {text: 'int result12 = str_cmp(s1, s2);', reason: 'The standard C library function is named `strcmp`, not `str_cmp`.'}], indent: 1, explanation: "Compare s1 and s2." },
            { correct: 'int result13 = strcmp(s1, s3);', distractors: [{text: 'int result13 = (s1 == s3);', reason: 'The `==` operator compares memory addresses. Since `s1` and `s3` are two different arrays, their addresses are different, and this would incorrectly result in 0 (false).'}], indent: 1, explanation: "Compare s1 and s3." },
            { correct: 'if (result12 < 0) { printf("%s comes before %s\\n", s1, s2); }', distractors: [{text:'if (result12 == 0) { printf("s1 and s2 are equal.\\n"); }', reason:'`strcmp` returns 0 only if strings are equal. "apple" and "apply" are not equal.'}, {text: 'if (result12 > 0) { printf("%s comes after %s\\n", s1, s2); }', reason: '`strcmp` returns a negative value because the first differing character, \'e\', comes before \'y\' alphabetically.'}], indent: 1, explanation: "Check if s1 is lexicographically less than s2." },
            { correct: 'if (result13 == 0) { printf("%s and %s are equal\\n", s1, s3); }', distractors: [{text:'if (result13 != 0) { printf("s1 and s3 are different.\\n"); }', reason:'`strcmp` returns 0 when strings *are* identical, so this condition is the opposite of what we want to check.'}, {text: 'if (result13) { printf("s1 and s3 are different.\\n"); }', reason: 'A return value of 0 is treated as `false` in a C `if` statement. This block would only execute if the strings were different.'}], indent: 1, explanation: "Check if s1 and s3 are equal." },
            { correct: 'return 0;', distractors: [{text: 'return result12;', reason: 'This would return a non-zero exit code to the OS, signaling an error, which is not the program\'s intent.'}, {text: 'return;', reason: '`main` is declared to return an `int`, so a value must be provided (`0` for success).'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Not a C keyword. Use `}`.'}, {text: 'end if;', reason: 'Incorrect syntax. Use `}` to close the `main` function block.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 27: Function Pointer
    {
        goal: "Declare and use a simple function pointer.",
        concepts: "Function pointers (declaration, assignment, call)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <functions.h>', reason: 'There is no standard C header `<functions.h>`. Functionality is built-in.'}, {text: 'import <stdio.h>', reason: 'C uses `#include`.'}], indent: 0, explanation: "Include for printf." },
            { correct: 'void sayHello() { printf("Hello!\\n"); }', distractors: [{text: 'int sayHello() { printf("Hello!\\n"); return 0; }', reason: 'This is a valid function, but a `void` return type is simpler for this first example.'}], indent: 0, explanation: "Define a simple function." },
            { correct: 'int add(int a, int b) { return a + b; }', distractors: [{text: 'void add(int a, int b) { printf("%d", a + b); }', reason: 'This function prints but does not *return* an integer value, so it would not match the function pointer we will declare.'}], indent: 0, explanation: "Define another function with parameters and return type." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return `int`.'}, {text: 'main() {', reason: 'Omitting the return type for functions is deprecated and bad practice. Always be explicit.'}], indent: 0, explanation: "Start main." },
            { correct: 'void (*helloPtr)();', distractors: [{text:'void *helloPtr();', reason:'This declares a function named `helloPtr` that returns a `void*` pointer. The parentheses `(*helloPtr)` are essential to declare a pointer to a function.'}, {text:'void helloPtr();', reason:'This declares a regular function named `helloPtr`, not a pointer to one.'}], indent: 1, explanation: "Declare a function pointer 'helloPtr' that can point to a void function with no arguments." },
            { correct: 'helloPtr = sayHello;', distractors: [{text:'helloPtr = sayHello();', reason:'Assign the function name directly. Adding `()` would *call* the function and try to assign its `void` result, which is invalid.'}, {text:'helloPtr = &sayHello;', reason:'Using the address-of operator `&` is also a valid and more explicit way to assign the function\'s address.'}], indent: 1, explanation: "Assign the address of 'sayHello' to 'helloPtr'." },
            { correct: 'helloPtr(); // Call function via pointer', distractors: [{text:'(*helloPtr)();', reason:'This is also a valid, older syntax for calling a function through a pointer. The simpler `helloPtr()` is more common today.'}, {text: 'sayHello();', reason: 'This calls the original function directly, not through the pointer, which defeats the purpose of this exercise.'}], indent: 1, explanation: "Call the function using the function pointer." },
            { correct: 'int (*mathOp)(int, int);', distractors: [{text:'int *mathOp(int, int);', reason:'This declares a function `mathOp` that returns a pointer-to-int. The parentheses `(*mathOp)` are required to specify a pointer-to-function.'}, {text: 'int mathOp(int, int);', reason: 'This declares a regular function, not a pointer.'}], indent: 1, explanation: "Declare a function pointer 'mathOp' for a function taking two ints and returning an int." },
            { correct: 'mathOp = add;', distractors: [{text: 'mathOp = add(5, 3);', reason: 'This would call the `add` function and try to assign its integer result (8) to the pointer, which is a type mismatch.'}, {text: '*mathOp = add;', reason: 'Assignment is done to the pointer variable `mathOp` itself, not by dereferencing it.'}], indent: 1, explanation: "Assign the address of 'add' to 'mathOp'." },
            { correct: 'printf("Sum: %d\\n", mathOp(5, 3));', distractors: [{text:'printf("Sum: %d\\n", (*mathOp)(5, 3));', reason:'This older syntax with the explicit dereference is also a valid way to call the function through the pointer.'}, {text: 'printf("Sum: %d\\n", add(5, 3));', reason: 'This calls the function directly, bypassing the function pointer.'}], indent: 1, explanation: "Call 'add' via 'mathOp' and print the result." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to signal success.'}, {text: 'return NULL;', reason: 'While `NULL` might be defined as 0, returning `0` explicitly is the standard and clearest way to signal success from `main`.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'Use `}` to close a block.'}, {text: '};', reason: 'Semicolons are not used after a function\'s closing brace.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 28: Enum Usage
    {
        goal: "Define an enum for days of the week and use it.",
        concepts: "enum keyword, enum values, using enum variables",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <enum.h>', reason: 'There is no standard `<enum.h>`. The `enum` keyword is a built-in part of the C language.'}, {text: '#include <stdlib.h>', reason: 'This header is not needed for this program.'}], indent: 0, explanation: "Include for printf." },
            { correct: 'enum Weekday { SUN, MON, TUE, WED, THU, FRI, SAT };', distractors: [{text:'enum Weekday [ SUN, MON, TUE ];', reason:'Enum members are listed inside curly braces `{}` and separated by commas, not square brackets.'}, {text:'struct Weekday { int SUN, MON, TUE; };', reason:'`struct` is used to group variables, not to define a set of named integer constants like `enum` does.'}], indent: 0, explanation: "Define an enumeration for days of the week (SUN=0, MON=1, etc.)." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return `int`.'}, {text: 'int main(void) {', reason: 'This is also a correct way to declare `main`.'}], indent: 0, explanation: "Start main." },
            { correct: 'enum Weekday today;', distractors: [{text:'Weekday today;', reason:'In C (unlike C++), you must use the `enum` keyword when declaring a variable of an enum type, e.g., `enum Weekday`.'}, {text: 'int today;', reason: 'While an enum is compatible with `int`, declaring it as `enum Weekday` is more type-safe and clearly expresses your intent.'}], indent: 1, explanation: "Declare a variable 'today' of type 'enum Weekday'." },
            { correct: 'today = WED;', distractors: [{text:'today = "WED";', reason:'Enum values are named integer constants, not strings. You must use the enumerator `WED` directly, without quotes.'}, {text:'today = 3;', reason:'While `WED` is equal to 3 in this case, using the name `WED` is far more readable and self-documenting.'}], indent: 1, explanation: "Assign an enum value to 'today'." },
            { correct: 'if (today == WED) {', distractors: [{text:'if (today == "WED") {', reason:'You must compare enum variables with enum constants (`WED`), not with string literals (`"WED"`).'}, {text: 'if (strcmp(today, "WED") == 0)', reason: '`strcmp` is for comparing strings, not for comparing an enum value which acts like an integer.'}], indent: 1, explanation: "Check the value of the enum variable." },
            { correct: 'printf("Today is Wednesday!\\n");', distractors: [{text: 'printf("Today is %d\\n", today);', reason: 'This would print "Today is 3", which is not the goal. We want to print a specific message based on the `if` check.'}, {text: 'puts("Today is Wednesday!");', reason: 'This is also a perfectly correct way to print the desired output.'}], indent: 2, explanation: "Print a message based on the enum value." },
            { correct: '}', distractors: [{text: 'end if;', reason: 'C uses a closing brace `}` to end a block.'}, {text: 'break;', reason: '`break` is used to exit from a loop or a switch case, not an `if` statement.'}], indent: 1, explanation: "Close if block." },
            { correct: 'printf("Value of FRI: %d\\n", FRI);', distractors: [{text:'printf("Value of FRI: %s\\n", FRI);', reason:'Enum values are fundamentally integers. You must use the `%d` format specifier to print their numeric value, not `%s` for strings.'}, {text: 'printf("Value of FRI: %d\\n", "FRI");', reason: 'This passes a string literal to `printf` where it expects an integer, leading to incorrect output.'}], indent: 1, explanation: "Print the integer value of an enumerator." },
            { correct: 'return 0;', distractors: [{text: 'return today;', reason: '`main` should return a `0` for success, not the integer value of an enum variable.'}, {text: 'return 1;', reason: 'Returning `1` would signal that the program failed, which is not the case.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: '`end` is not a C keyword. Use `}`.'}, {text: '};', reason: 'A semicolon is not used after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
  // Level 29: 2D Arrays and Functions
  {
    goal: "Declare a 2D array, pass it to a function to calculate row sums, and print the results.",
    concepts: "2D arrays, nested loops, passing multidimensional arrays to functions, function prototypes",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "That’s a C++ header, not valid C." }, { text: "#import <stdio.h>", reason: "`#import` isn’t a standard directive in C." }], indent: 0, explanation: "Include standard I/O for printf." },
      { correct: "#define ROWS 3", distractors: [{ text: "#define ROWS = 3;", reason: "Macros don’t use `=` or semicolons." }, { text: "enum { ROWS = 3 };", reason: "Using an enum works but deviates from the `#define` convention here." }], indent: 0, explanation: "Define a constant for the number of rows." },
      { correct: "#define COLS 4", distractors: [{ text: "const int COLS = 4;", reason: "Also valid, but this level uses `#define` for dimensions." }, { text: "#define COLS = 4", reason: "Macros don’t use `=` sign." }], indent: 0, explanation: "Define a constant for the number of columns." },
      { correct: "// Prototype for the function that will process the array", distractors: [{ text: "/* Prototype to sum columns */", reason: "Mislabels the function’s purpose." }, { text: "// Declare sumCols prototype", reason: "Wrong function name/comment mismatch." }], indent: 0, explanation: "A comment explaining the function declaration." },
      { correct: "void sumRows(int arr[][COLS]);", distractors: [{ text: "void sumRows(int arr[][]);", reason: "Must specify all but the first dimension." }, { text: "void sumRows(int** arr);", reason: "A 2D array isn’t the same as an `int**` pointer." }], indent: 0, explanation: "Declare a function that accepts a 2D array, specifying all but the first dimension." },
      { correct: "int main(void) {", distractors: [{ text: "void main() {", reason: "Standard C requires `main` to return `int`." }, { text: "int main()", reason: "Missing parameter list—less explicit than `main(void)`." }], indent: 0, explanation: "Start the main function." },
      { correct: "// Initialize the 2D array", distractors: [{ text: "// Declare matrix size", reason: "Wrong comment for initialization." }, { text: "// Setup headers", reason: "Irrelevant comment." }], indent: 1, explanation: "Comment on array initialization." },
      { correct: "int matrix[ROWS][COLS] = {", distractors: [{ text: "int matrix[ROWS, COLS] = {", reason: "Dimensions must be in separate brackets." }, { text: "int matrix[3,4] = {", reason: "Comma operator yields a single dimension." }], indent: 1, explanation: "Begin declaring and initializing the 2D array." },
      { correct: "  { 10, 20, 30, 40 },", distractors: [{ text: "  (10, 20, 30, 40),", reason: "Parentheses aren’t valid for initializer lists." }, { text: "  {10,20,30}", reason: "Wrong number of elements." }], indent: 2, explanation: "Initialize the first row." },
      { correct: "  { 5, 15, 25, 35 },", distractors: [{ text: "  { 5, 15, 25, 35 }", reason: "Missing comma after row initializer." }, { text: "  {5 15 25 35},", reason: "Missing commas between values." }], indent: 2, explanation: "Initialize the second row." },
      { correct: "  { 11, 22, 33, 44 }", distractors: [{ text: "  { 11, 22, 33, 44, }", reason: "Trailing comma allowed but usually omitted here." }, { text: "  { 11; 22; 33; 44 }", reason: "Semicolons invalid in initializer lists." }], indent: 2, explanation: "Initialize the third row." },
      { correct: "};", distractors: [{ text: "}", reason: "Missing semicolon to end declaration." }, { text: "];", reason: "Wrong closing bracket." }], indent: 1, explanation: "Close the array initializer and the declaration statement." },
      { correct: "printf(\"Calculating row sums...\\n\");", distractors: [{ text: "puts(\"Calculating row sums...\");", reason: "`puts` adds a newline but differs from `printf` usage." }, { text: "print(\"Calculating row sums...\\n\");", reason: "`print` isn’t a C standard function." }], indent: 1, explanation: "Print an informational message." },
      { correct: "sumRows(matrix);", distractors: [{ text: "sumRows(matrix[ROWS][COLS]);", reason: "Passes a single element, not the array." }, { text: "sumRows(&matrix);", reason: "`&matrix` has the wrong pointer type." }], indent: 1, explanation: "Call the function, passing the 2D array." },
      { correct: "return 0;", distractors: [{ text: "return;", reason: "Missing return value for `main`." }, { text: "exit(0);", reason: "`exit` bypasses `main` return." }], indent: 1, explanation: "Indicate successful execution." },
      { correct: "}", distractors: [{ text: "end;", reason: "`end` is not C syntax." }, { text: "};", reason: "Extra semicolon is invalid." }], indent: 0, explanation: "Close the main function." },
      { correct: "void sumRows(int arr[][COLS]) {", distractors: [{ text: "void sumRows(int arr[ROWS][COLS]) {", reason: "Specifying both dims is valid but less flexible." }, { text: "void sumRows(int *arr) {", reason: "Loses 2D structure needed for `arr[r][c]`." }], indent: 0, explanation: "Define the function, matching the prototype's parameter type." },
      { correct: "for (int r = 0; r < ROWS; r++) {", distractors: [{ text: "for (r = 0; r < ROWS; r++) {", reason: "`r` must be declared." }, { text: "for (int r = 1; r <= ROWS; r++) {", reason: "Off-by-one and wrong bounds." }], indent: 1, explanation: "Start a loop to iterate through each row." },
      { correct: "int current_sum = 0;", distractors: [{ text: "int current_sum;", reason: "Uninitialized variable is undefined." }, { text: "int current_sum = arr[r][0];", reason: "Incorrect accumulation start." }], indent: 2, explanation: "Initialize a variable to hold the sum for the current row." },
      { correct: "for (int c = 0; c < COLS; c++) {", distractors: [{ text: "for (int c = 1; c < COLS; c++) {", reason: "Skips the first column." }, { text: "for (int c = 0; c <= COLS; c++) {", reason: "Off-by-one: iterates out of bounds." }], indent: 2, explanation: "Start a nested loop to iterate through each column in the current row." },
      { correct: "current_sum += arr[r][c];", distractors: [{ text: "current_sum = arr[r][c];", reason: "Overwrites the sum each time." }, { text: "current_sum += *(arr + r + c);", reason: "Pointer arithmetic is incorrect for 2D arrays." }], indent: 3, explanation: "Add the value of the current element to the row's sum." },
      { correct: "}", distractors: [{ text: ")", reason: "Loops close with `}`, not `)`." }, { text: "];", reason: "Invalid block closure." }], indent: 2, explanation: "Close the inner (column) loop." },
      { correct: "printf(\"Sum of row %d = %d\\n\", r, current_sum);", distractors: [{ text: "printf(\"Sum = %d\\n\", current_sum);", reason: "Doesn't show which row." }, { text: "printf(\"Row %d sum: %d\\n\");", reason: "Missing arguments for placeholders." }], indent: 2, explanation: "Print the calculated sum for the completed row." },
      { correct: "}", distractors: [{ text: ")", reason: "Loops close with `}`." }, { text: "];", reason: "Invalid block closure." }], indent: 1, explanation: "Close the outer (row) loop." },
      { correct: "}", distractors: [{ text: "];", reason: "Functions close with `}`." }, { text: "}}", reason: "Extra brace is a syntax error." }], indent: 0, explanation: "Close the function definition." }
    ]
  },

  // Level 30: Pointers to Pointers & Dynamic 2D Array
  {
    goal: "Dynamically allocate, fill, and free a 2D array using a pointer-to-a-pointer (int **).",
    concepts: "Pointers to pointers, dynamic memory allocation, malloc, free, loops",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "That’s C++ code, not C." }, { text: "#import <stdio.h>", reason: "`#import` isn’t used in C." }], indent: 0, explanation: "Include for standard I/O." },
      { correct: "#include <stdlib.h>", distractors: [{ text: "#include <malloc.h>", reason: "Non-standard header on some platforms." }, { text: "#include <string.h>", reason: "Not needed for malloc/free." }], indent: 0, explanation: "Include for malloc and free." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "`main` must return `int` in standard C." }, { text: "main() {", reason: "Missing return type altogether." }], indent: 0, explanation: "Start the main function." },
      { correct: "int rows = 3;", distractors: [{ text: "rows = 3;", reason: "Missing type declaration." }, { text: "const int rows;", reason: "Uninitialized constant—invalid." }], indent: 1, explanation: "Define the number of rows." },
      { correct: "int cols = 4;", distractors: [{ text: "cols = 4;", reason: "Missing type declaration." }, { text: "const cols = 4;", reason: "Missing type—invalid syntax." }], indent: 1, explanation: "Define the number of columns." },
      { correct: "int **dynamic_matrix;", distractors: [{ text: "int *dynamic_matrix;", reason: "A single pointer doesn’t represent a 2D array." }, { text: "int dynamic_matrix[rows][cols];", reason: "Declares a VLA on the stack, not heap memory." }], indent: 1, explanation: "Declare a pointer-to-a-pointer to manage the dynamic 2D array." },
      { correct: "// Allocate the array of row pointers", distractors: [{ text: "// Allocate the matrix", reason: "Too generic—needs separate pointer array step." }, { text: "// Setup rows", reason: "Doesn’t mention malloc." }], indent: 1, explanation: "Comment on the first allocation step." },
      { correct: "dynamic_matrix = (int **)malloc(rows * sizeof(int *));", distractors: [{ text: "dynamic_matrix = malloc(rows * sizeof(int));", reason: "Allocates space for ints, not pointers." }, { text: "dynamic_matrix = (int *)malloc(rows * sizeof(int *));", reason: "Wrong cast type." }], indent: 1, explanation: "Allocate memory for an array of pointers, one for each row." },
      { correct: "if (dynamic_matrix == NULL) { return 1; }", distractors: [{ text: "if (!dynamic_matrix) exit(1);", reason: "Exit abrupt but works; less explicit return." }, { text: "if (dynamic_matrix == 0) { return; }", reason: "Missing return value for `main`." }], indent: 1, explanation: "Always check if memory allocation was successful." },
      { correct: "// Allocate memory for each row", distractors: [{ text: "// Allocate heap memory", reason: "Too generic." }, { text: "// Setup columns", reason: "Doesn’t mention malloc." }], indent: 1, explanation: "Comment on the second allocation step." },
      { correct: "for (int i = 0; i < rows; i++) {", distractors: [{ text: "for (i = 0; i < rows; i++) {", reason: "`i` must be declared." }, { text: "for (int i = 1; i <= rows; i++) {", reason: "Off-by-one and wrong bounds." }], indent: 1, explanation: "Loop through each row to allocate its columns." },
      { correct: "dynamic_matrix[i] = (int *)malloc(cols * sizeof(int));", distractors: [{ text: "dynamic_matrix[i] = malloc(cols * sizeof(int *));", reason: "Allocates pointer-size chunks, not ints." }, { text: "dynamic_matrix[i] = (int **)malloc(cols * sizeof(int));", reason: "Wrong cast/pointer type." }], indent: 2, explanation: "For each row pointer, allocate enough memory for all the columns in that row." },
      { correct: "if (dynamic_matrix[i] == NULL) { return 1; }", distractors: [{ text: "if (!dynamic_matrix[i]) exit(1);", reason: "Works but less explicit." }, { text: "if (dynamic_matrix[i] == 0) return;", reason: "Missing return value." }], indent: 2, explanation: "Also check if each individual row allocation was successful." },
      { correct: "}", distractors: [{ text: "};", reason: "Extra semicolon." }, { text: ")", reason: "Wrong closing bracket." }], indent: 1, explanation: "Close the row allocation loop." },
      { correct: "// Fill and print the matrix", distractors: [{ text: "// Initialize matrix values", reason: "Too generic." }, { text: "// Display matrix", reason: "Misses filling step." }], indent: 1, explanation: "Comment explaining the next section." },
      { correct: "for (int i = 0; i < rows; i++) {", distractors: [{ text: "for (i = 0; i < rows; i++) {", reason: "`i` must be declared." }, { text: "while (i < rows) {", reason: "Wrong loop construct." }], indent: 1, explanation: "Start a loop to iterate through the rows." },
      { correct: "for (int j = 0; j < cols; j++) {", distractors: [{ text: "for (j = 0; j < cols; j++) {", reason: "`j` must be declared." }, { text: "for (int j = 1; j <= cols; j++) {", reason: "Off-by-one." }], indent: 2, explanation: "Start a nested loop for the columns." },
      { correct: "dynamic_matrix[i][j] = i * 10 + j;", distractors: [{ text: "*(*(dynamic_matrix + i) + j) = i*10+j;", reason: "Valid but not the syntax taught here." }, { text: "dynamic_matrix[j][i] = i+j;", reason: "Swaps indices—wrong mapping." }], indent: 3, explanation: "Assign a value to each element in the matrix." },
      { correct: "printf(\"%3d\", dynamic_matrix[i][j]);", distractors: [{ text: "printf(\"%d\", dynamic_matrix[i][j]);", reason: "No field width—less aligned." }, { text: "printf(\"%3d\\n\", dynamic_matrix[i][j]);", reason: "Prints newline after every element instead of row." }], indent: 3, explanation: "Print the newly assigned value." },
      { correct: "}", distractors: [{ text: ")", reason: "Wrong bracket." }, { text: "];", reason: "Invalid block closure." }], indent: 2, explanation: "Close the column loop." },
      { correct: "printf(\"\\n\");", distractors: [{ text: "printf(\"\\n\\n\");", reason: "Prints extra blank line." }, { text: "putchar('\\n');", reason: "Works but differs from `printf` usage." }], indent: 2, explanation: "Print a newline after each row." },
      { correct: "}", distractors: [{ text: "};", reason: "Extra semicolon." }, { text: ")", reason: "Wrong bracket." }], indent: 1, explanation: "Close the row loop." },
      { correct: "// Free the allocated memory in reverse order of allocation", distractors: [{ text: "// Deallocate matrix", reason: "Too generic." }, { text: "// Clean up rows", reason: "Misses pointer-array step." }], indent: 1, explanation: "A crucial comment on freeing memory." },
      { correct: "for (int i = 0; i < rows; i++) {", distractors: [{ text: "for (i = 0; i < rows; i++) {", reason: "`i` must be declared." }, { text: "while (i < rows) {", reason: "Wrong loop type." }], indent: 1, explanation: "First, loop through to free each individual row." },
      { correct: "free(dynamic_matrix[i]);", distractors: [{ text: "free(dynamic_matrix);", reason: "Frees pointer array too soon." }, { text: "dynamic_matrix[i] = NULL;", reason: "Does not actually free memory." }], indent: 2, explanation: "Free the memory allocated for each row's columns." },
      { correct: "}", distractors: [{ text: "};", reason: "Extra semicolon." }, { text: ")", reason: "Wrong bracket." }], indent: 1, explanation: "Close the row-freeing loop." },
      { correct: "free(dynamic_matrix);", distractors: [{ text: "dynamic_matrix = NULL;", reason: "Does not free memory." }, { text: "delete[] dynamic_matrix;", reason: "C++ syntax, not C." }], indent: 1, explanation: "Finally, free the memory that held the array of row pointers." },
      { correct: "return 0;", distractors: [{ text: "return;", reason: "Missing return value." }, { text: "exit(0);", reason: "Bypasses `main` return." }], indent: 1, explanation: "Indicate successful execution." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the main function." }
    ]
  },

  // Level 31: Creating a Simple Linked List
  {
    goal: "Create a simple 3-node linked list, traverse it, print the data, and free the memory.",
    concepts: "structs, pointers, dynamic memory allocation (malloc), linked lists, NULL",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "That’s C++ code." }, { text: "#import <stdio.h>", reason: "`#import` isn’t a C directive." }], indent: 0, explanation: "Include for printf." },
      { correct: "#include <stdlib.h>", distractors: [{ text: "#include <malloc.h>", reason: "Non-standard header." }, { text: "#include <string.h>", reason: "Not needed here." }], indent: 0, explanation: "Include for malloc and free." },
      { correct: "// Define the structure for a node in the list", distractors: [{ text: "/* Node struct declaration */", reason: "Generic comment missing clarity." }, { text: "// Structure: Node", reason: "Too vague." }], indent: 0, explanation: "Comment on the purpose of the struct." },
      { correct: "struct Node {", distractors: [{ text: "struct Node();", reason: "Syntax for function, not struct." }, { text: "class Node {", reason: "C++ keyword, not C." }], indent: 0, explanation: "Begin defining the Node struct." },
      { correct: "int data;", distractors: [{ text: "int *data;", reason: "Pointer instead of value." }, { text: "float data;", reason: "Wrong type." }], indent: 1, explanation: "Each node will hold an integer data value." },
      { correct: "struct Node *next;", distractors: [{ text: "struct Node next;", reason: "Embeds a struct instead of a pointer." }, { text: "Node *next;", reason: "`Node` isn’t typedef’d yet." }], indent: 1, explanation: "A pointer to the next node in the sequence." },
      { correct: "};", distractors: [{ text: "};;", reason: "Extra semicolon." }, { text: "}", reason: "Missing semicolon after struct." }], indent: 0, explanation: "End the struct definition." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "Standard C requires `int` return." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start main function." },
      { correct: "// Declare pointers for the head and other nodes", distractors: [{ text: "// Pointers", reason: "Too generic." }, { text: "// Node variables", reason: "Misses that they’re pointers." }], indent: 1, explanation: "Comment on pointer declarations." },
      { correct: "struct Node *head;", distractors: [{ text: "Node *head;", reason: "C requires `struct` keyword here." }, { text: "int *head;", reason: "Wrong type." }], indent: 1, explanation: "Declare the head pointer, which will point to the start of the list." },
      { correct: "struct Node *second;", distractors: [{ text: "struct Node second;", reason: "Declares a struct, not pointer." }, { text: "Node *second;", reason: "Missing `struct` keyword." }], indent: 1, explanation: "Declare a pointer for the second node." },
      { correct: "struct Node *third;", distractors: [{ text: "struct Node third;", reason: "Declares a struct instance, not pointer." }, { text: "Node third;", reason: "Missing pointer notation." }], indent: 1, explanation: "Declare a pointer for the third node." },
      { correct: "// Allocate memory for the three nodes on the heap", distractors: [{ text: "// New nodes", reason: "Doesn’t mention malloc." }, { text: "// Setup nodes", reason: "Too vague." }], indent: 1, explanation: "Comment on memory allocation." },
      { correct: "head = (struct Node*)malloc(sizeof(struct Node));", distractors: [{ text: "head = malloc(sizeof(int));", reason: "Allocates too little memory." }, { text: "head = &someNode;", reason: "Uses address of local, not heap." }], indent: 1, explanation: "Allocate memory for the first node." },
      { correct: "second = (struct Node*)malloc(sizeof(struct Node));", distractors: [{ text: "second = malloc(sizeof(Node));", reason: "Missing `struct` keyword in sizeof." }, { text: "second = NULL;", reason: "Doesn’t allocate memory." }], indent: 1, explanation: "Allocate memory for the second node." },
      { correct: "third = (struct Node*)malloc(sizeof(struct Node));", distractors: [{ text: "third = malloc(sizeof(*third));", reason: "Works but less explicit." }, { text: "third = second;", reason: "Points to the wrong node." }], indent: 1, explanation: "Allocate memory for the third node." },
      { correct: "// Assign data and link the head node", distractors: [{ text: "// Set head data", reason: "Missing link step." }, { text: "// Link nodes", reason: "Too generic." }], indent: 1, explanation: "Comment on setting up the first node." },
      { correct: "head->data = 10;", distractors: [{ text: "head.data = 10;", reason: "Must use `->` on a pointer." }, { text: "(*head).data = 10;", reason: "Valid but not the shorthand taught." }], indent: 1, explanation: "Set the data for the head node." },
      { correct: "head->next = second;", distractors: [{ text: "head->next = &second;", reason: "`second` is already a pointer." }, { text: "head->next = NULL;", reason: "Wrong link—terminates list too early." }], indent: 1, explanation: "Link the head node to the second node." },
      { correct: "// Assign data and link the second node", distractors: [{ text: "// Second node data", reason: "Misses linking." }, { text: "// Link head to third", reason: "Skips second node." }], indent: 1, explanation: "Comment on setting up the second node." },
      { correct: "second->data = 20;", distractors: [{ text: "second.data = 20;", reason: "Must use `->` on pointer." }, { text: "(*second).data = 20;", reason: "Valid but not taught shorthand." }], indent: 1, explanation: "Set the data for the second node." },
      { correct: "second->next = third;", distractors: [{ text: "second->next = head;", reason: "Creates a loop." }, { text: "second->next = NULL;", reason: "Terminates list too soon." }], indent: 1, explanation: "Link the second node to the third node." },
      { correct: "// Assign data and terminate the list at the third node", distractors: [{ text: "// Third node data", reason: "Misses termination." }, { text: "// End list", reason: "Too generic." }], indent: 1, explanation: "Comment on setting up the final node." },
      { correct: "third->data = 30;", distractors: [{ text: "third.data = 30;", reason: "Must use `->` on a pointer." }, { text: "(*third).data = 30;", reason: "Valid but not taught shorthand." }], indent: 1, explanation: "Set the data for the third node." },
      { correct: "third->next = NULL;", distractors: [{ text: "third->next = 0;", reason: "`NULL` is clearer than literal `0`." }, { text: "// third->next uninitialized", reason: "Unsafe and wrong." }], indent: 1, explanation: "Set the `next` pointer of the last node to NULL to signify the end of the list." },
      { correct: "// Traverse and print the list", distractors: [{ text: "// Print list", reason: "Misses traversal comment." }, { text: "// Walk nodes", reason: "Too vague." }], indent: 1, explanation: "Comment on list traversal." },
      { correct: "struct Node *current = head;", distractors: [{ text: "Node *current = head;", reason: "Missing `struct` keyword." }, { text: "struct Node current = head;", reason: "Wrong type—declares a struct, not pointer." }], indent: 1, explanation: "Create a temporary pointer to traverse the list, starting at the head." },
      { correct: "while (current != NULL) {", distractors: [{ text: "while (current)", reason: "Works but less explicit." }, { text: "for (; current; ) {", reason: "Different loop form, not taught here." }], indent: 2, explanation: "Loop as long as we have not reached the end of the list (the NULL pointer)." },
      { correct: "printf(\"%d -> \", current->data);", distractors: [{ text: "printf(\"%d\", current->data);", reason: "Missing arrow and separator." }, { text: "puts(current->data);", reason: "`puts` expects a string, not an int." }], indent: 3, explanation: "Print the data of the current node." },
      { correct: "current = current->next;", distractors: [{ text: "current = head;", reason: "Resets pointer—infinite loop." }, { text: "current->next = current;", reason: "Creates a self-loop." }], indent: 3, explanation: "Move the `current` pointer to the next node in the list." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not valid C syntax." }, { text: "];", reason: "Invalid block closure." }], indent: 2, explanation: "Close the traversal loop." },
      { correct: "printf(\"NULL\\n\");", distractors: [{ text: "puts(\"NULL\");", reason: "No newline escape." }, { text: "printf(\"%s\\n\", \"NULL\");", reason: "Valid but not the format shown." }], indent: 1, explanation: "Print NULL to show the end of the list visually." },
      { correct: "// Free the allocated memory to prevent memory leaks", distractors: [{ text: "// Delete nodes", reason: "C++ keyword, not C." }, { text: "// Clear nodes", reason: "Too generic." }], indent: 1, explanation: "Comment on freeing memory." },
      { correct: "free(head);", distractors: [{ text: "free(current);", reason: "`current` is NULL here." }, { text: "head = NULL;", reason: "Doesn’t free memory." }], indent: 1, explanation: "Free the first node." },
      { correct: "free(second);", distractors: [{ text: "free(head);", reason: "Duplicates previous free—incorrect order." }, { text: "second = NULL;", reason: "Doesn’t free memory." }], indent: 1, explanation: "Free the second node." },
      { correct: "free(third);", distractors: [{ text: "free(second);", reason: "Duplicates previous free." }, { text: "third = NULL;", reason: "Doesn’t free memory." }], indent: 1, explanation: "Free the third node." },
      { correct: "return 0;", distractors: [{ text: "return head;", reason: "Wrong return type." }, { text: "exit(0);", reason: "Bypasses `main` return." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not valid C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close main function." }
    ]
  },

  // Level 32: Advanced Linked List - Insertion Function
  {
    goal: "Create a function that inserts a new node at the head of a linked list using a pointer-to-a-pointer.",
    concepts: "Linked lists, pointers to pointers, functions modifying pointers, dynamic memory",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for standard I/O." },
      { correct: "#include <stdlib.h>", distractors: [{ text: "#include <malloc.h>", reason: "Non-standard." }, { text: "#include <string.h>", reason: "Not required here." }], indent: 0, explanation: "Include for malloc/free." },
      { correct: "typedef struct Node {", distractors: [{ text: "struct Node {", reason: "Missing typedef—requires `typedef` keyword." }, { text: "class Node {", reason: "C++ keyword." }], indent: 0, explanation: "Begin defining the Node struct using a typedef for convenience." },
      { correct: "  int data;", distractors: [{ text: "  int *data;", reason: "Pointer to int, not int." }, { text: "  float data;", reason: "Wrong type." }], indent: 1, explanation: "The data held by the node." },
      { correct: "  struct Node *next;", distractors: [{ text: "  Node *next;", reason: "`Node` alias not active until after typedef ends." }, { text: "  struct Node next;", reason: "Embeds node, not pointer." }], indent: 1, explanation: "A pointer to the next node." },
      { correct: "} Node;", distractors: [{ text: "} Node", reason: "Missing semicolon after typedef." }, { text: "} node_t;", reason: "Alias name differs from `Node`." }], indent: 0, explanation: "Create the alias `Node` for `struct Node`." },
      { correct: "// Function prototype to insert a node at the beginning", distractors: [{ text: "// Prototype: insert function", reason: "Too generic." }, { text: "// Insertion helper", reason: "Misses pointer-to-pointer detail." }], indent: 0, explanation: "Comment on the function prototype." },
      { correct: "void insertAtHead(Node **head_ref, int new_data);", distractors: [{ text: "void insertAtHead(Node *head, int new_data);", reason: "Passes head by value—can’t modify original." }, { text: "Node* insertAtHead(Node *head, int new_data);", reason: "Returns new head instead of modifying in place." }], indent: 0, explanation: "Declare a function that takes a pointer to the head pointer." },
      { correct: "void printList(Node *node);", distractors: [{ text: "void printList(Node **node);", reason: "Unnecessary double pointer." }, { text: "void print(Node *n);", reason: "Different name—less clear." }], indent: 0, explanation: "Prototype for a helper function to print the list." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "`main` must return `int`." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start main function." },
      { correct: "Node *head = NULL;", distractors: [{ text: "Node head = NULL;", reason: "Wrong type—should be pointer." }, { text: "Node *head;", reason: "Uninitialized pointer—undefined behavior." }], indent: 1, explanation: "Initialize the head of the list to NULL, indicating it's empty." },
      { correct: "printf(\"Inserting 30...\\n\");", distractors: [{ text: "puts(\"Inserting 30...\");", reason: "Valid but differs from `printf`." }, { text: "print(\"Inserting 30...\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Informational print." },
      { correct: "insertAtHead(&head, 30);", distractors: [{ text: "insertAtHead(head, 30);", reason: "Needs address-of for double pointer." }, { text: "insertAtHead(*head, 30);", reason: "Dereferences NULL—crash." }], indent: 1, explanation: "Call the insertion function, passing the address of the head pointer." },
      { correct: "printList(head);", distractors: [{ text: "printList(&head);", reason: "Wrong pointer type." }, { text: "printList(*head);", reason: "Dereferences head—wrong type." }], indent: 1, explanation: "Print the list to verify the insertion." },
      { correct: "printf(\"Inserting 20...\\n\");", distractors: [{ text: "puts(\"Inserting 20...\");", reason: "Valid but differs." }, { text: "print(\"Inserting 20...\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Informational print." },
      { correct: "insertAtHead(&head, 20);", distractors: [{ text: "insertAtHead(head, 20);", reason: "Wrong pointer level." }, { text: "insertAtHead(NULL, 20);", reason: "Passes NULL—no effect." }], indent: 1, explanation: "Insert another node. It should become the new head." },
      { correct: "printList(head);", distractors: [{ text: "printList(&head);", reason: "Wrong pointer type." }, { text: "printList(*head);", reason: "Dereferences head—wrong type." }], indent: 1, explanation: "Print the list again." },
      { correct: "printf(\"Inserting 10...\\n\");", distractors: [{ text: "puts(\"Inserting 10...\");", reason: "Valid but differs." }, { text: "print(\"Inserting 10...\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Informational print." },
      { correct: "insertAtHead(&head, 10);", distractors: [{ text: "insertAtHead(head, 10);", reason: "Wrong pointer level." }, { text: "insertAtHead(NULL, 10);", reason: "Passes NULL—no effect." }], indent: 1, explanation: "Insert a third node." },
      { correct: "printList(head);", distractors: [{ text: "printList(&head);", reason: "Wrong pointer type." }, { text: "printList(*head);", reason: "Dereferences head—wrong type." }], indent: 1, explanation: "Print the final list." },
      { correct: "return 0;", distractors: [{ text: "return head;", reason: "Wrong return type." }, { text: "exit(0);", reason: "Bypasses `main` return." }], indent: 1, explanation: "Indicate success. (Note: memory is not freed in this example to keep it focused on insertion)." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the main function." },
      { correct: "void insertAtHead(Node **head_ref, int new_data) {", distractors: [{ text: "void insertAtHead(Node *head, int new_data) {", reason: "Wrong pointer level." }, { text: "void insertAtHead(Node head_ref, int new_data) {", reason: "Passes struct by value." }], indent: 0, explanation: "Define the insertion function, accepting a double pointer." },
      { correct: "// 1. Allocate memory for the new node", distractors: [{ text: "// Create new node", reason: "Too generic—misses malloc detail." }, { text: "// Step 1: data", reason: "Wrong focus." }], indent: 1, explanation: "Step 1 of insertion." },
      { correct: "Node *new_node = (Node*)malloc(sizeof(Node));", distractors: [{ text: "Node *new_node = malloc(sizeof(Node));", reason: "Missing cast (though works in C, not explicit)." }, { text: "Node new_node = malloc(sizeof(Node));", reason: "Wrong type—declares struct, not pointer." }], indent: 1, explanation: "Create the new node on the heap." },
      { correct: "// 2. Put data in the new node", distractors: [{ text: "// Assign data", reason: "Too generic." }, { text: "// new_node->data", reason: "Missing assignment." }], indent: 1, explanation: "Step 2 of insertion." },
      { correct: "new_node->data = new_data;", distractors: [{ text: "new_node.data = new_data;", reason: "Must use `->` on pointer." }, { text: "(*new_node).data = new_data;", reason: "Valid but not taught shorthand." }], indent: 1, explanation: "Assign the provided data." },
      { correct: "// 3. Make the new node point to the old head", distractors: [{ text: "// Link new node", reason: "Too generic." }, { text: "// Set next", reason: "Missing pointer dereference detail." }], indent: 1, explanation: "Step 3 of insertion." },
      { correct: "new_node->next = (*head_ref);", distractors: [{ text: "new_node->next = head_ref;", reason: "`head_ref` is a double pointer." }, { text: "new_node->next = NULL;", reason: "Wrong link—terminates list early." }], indent: 1, explanation: "The new node's `next` should be the current start of the list." },
      { correct: "// 4. Move the head to point to the new node", distractors: [{ text: "// Update head", reason: "Too generic." }, { text: "// head_ref = new_node", reason: "Modifies pointer copy." }], indent: 1, explanation: "Step 4 of insertion." },
      { correct: "(*head_ref) = new_node;", distractors: [{ text: "head_ref = new_node;", reason: "Modifies local pointer, not original." }, { text: "head = new_node;", reason: "Doesn’t use `head_ref`—no effect." }], indent: 1, explanation: "Change the original head pointer in main to now point at our new node." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the insertion function." },
      { correct: "void printList(Node *node) {", distractors: [{ text: "void printList(Node **node) {", reason: "Wrong pointer level." }, { text: "void print(Node *node) {", reason: "Different name." }], indent: 0, explanation: "Define the list printing utility function." },
      { correct: "while (node != NULL) {", distractors: [{ text: "while (node) {", reason: "Works but less explicit." }, { text: "for (; node; ) {", reason: "Different form—not shown here." }], indent: 1, explanation: "Loop until the end of the list." },
      { correct: "printf(\" %d ->\", node->data);", distractors: [{ text: "puts(node->data);", reason: "`puts` expects a string." }, { text: "printf(\"%d->\", node->data);", reason: "Missing leading space." }], indent: 2, explanation: "Print the data for the current node." },
      { correct: "node = node->next;", distractors: [{ text: "node->next = node;", reason: "Creates a cycle." }, { text: "node = head;", reason: "Resets pointer—infinite loop." }], indent: 2, explanation: "Move to the next node." },
      { correct: "}", distractors: [{ text: "];", reason: "Wrong bracket." }, { text: "end;", reason: "Not C syntax." }], indent: 1, explanation: "Close the loop." },
      { correct: "printf(\" NULL\\n\");", distractors: [{ text: "puts(\"NULL\");", reason: "No leading space." }, { text: "printf(\"%s\\n\", \"NULL\");", reason: "Valid but not taught format." }], indent: 1, explanation: "Print NULL at the end for clarity." },
      { correct: "}", distractors: [{ text: "};", reason: "Extra semicolon." }, { text: "end;", reason: "Not C syntax." }], indent: 0, explanation: "Close the print function." }
    ]
  },

  // Level 33: Bitwise Operations for Flags
  {
    goal: "Manage a set of boolean options using a single integer and bitwise operations.",
    concepts: "Bitwise operators (&, |, ~, <<), enums, hexadecimal literals, masks",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for printf." },
      { correct: "// Define flags as distinct powers of 2", distractors: [{ text: "/* Flags definition */", reason: "Too generic." }, { text: "// Bit masks", reason: "Less descriptive." }], indent: 0, explanation: "Comment on flag definition." },
      { correct: "enum Options {", distractors: [{ text: "enum Flags {", reason: "Different name—less clear." }, { text: "typedef enum Options {", reason: "Extra `typedef` not used here." }], indent: 0, explanation: "Use an enum to give names to our bit flags." },
      { correct: "  OPTION_A = 1 << 0, // 00000001 (1)", distractors: [{ text: "  OPTION_A = 0x01,", reason: "Hex literal is valid but not the taught shift form." }, { text: "  OPTION_A = 1,", reason: "Valid but doesn’t show bit-shift intent." }], indent: 1, explanation: "Flag for option A is the 0th bit." },
      { correct: "  OPTION_B = 1 << 1, // 00000010 (2)", distractors: [{ text: "  OPTION_B = 2,", reason: "Valid but loses shift clarity." }, { text: "  OPTION_B = 1 << 0,", reason: "Duplicates OPTION_A value." }], indent: 1, explanation: "Flag for option B is the 1st bit." },
      { correct: "  OPTION_C = 1 << 2, // 00000100 (4)", distractors: [{ text: "  OPTION_C = 4,", reason: "Valid but no shift." }, { text: "  OPTION_C = 1 << 1,", reason: "Duplicates OPTION_B value." }], indent: 1, explanation: "Flag for option C is the 2nd bit." },
      { correct: "  OPTION_D = 1 << 3  // 00001000 (8)", distractors: [{ text: "  OPTION_D = 8,", reason: "Valid but less illustrative." }, { text: "  OPTION_D = 1 << 2,", reason: "Duplicates OPTION_C value." }], indent: 1, explanation: "Flag for option D is the 3rd bit." },
      { correct: "};", distractors: [{ text: "}", reason: "Missing semicolon." }, { text: "];", reason: "Wrong bracket." }], indent: 0, explanation: "Close the enum definition." },
      { correct: "void print_options(unsigned char settings);", distractors: [{ text: "void print_options(int settings);", reason: "Wrong type—should be `unsigned char`." }, { text: "print_options(unsigned char settings);", reason: "Missing return type." }], indent: 0, explanation: "Prototype for a function to display the current settings." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "Wrong return type." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start main function." },
      { correct: "unsigned char my_settings = 0;", distractors: [{ text: "int my_settings = 0;", reason: "Wrong type size." }, { text: "unsigned my_settings = 0;", reason: "Missing `char` qualifier." }], indent: 1, explanation: "Declare the variable to hold our flags, initialized to all off." },
      { correct: "printf(\"Initial settings:\\n\");", distractors: [{ text: "puts(\"Initial settings:\");", reason: "No newline escape." }, { text: "print(\"Initial settings:\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Print header." },
      { correct: "print_options(my_settings);", distractors: [{ text: "print_options(&my_settings);", reason: "Wrong pointer type." }, { text: "print(my_settings);", reason: "`print` not C." }], indent: 1, explanation: "Show initial state." },
      { correct: "// Turn ON option A and C", distractors: [{ text: "/* Enable bits */", reason: "Too generic." }, { text: "// Set flags", reason: "Less specific." }], indent: 1, explanation: "Comment on setting flags." },
      { correct: "my_settings = my_settings | OPTION_A | OPTION_C;", distractors: [{ text: "my_settings |= OPTION_A + OPTION_C;", reason: "Uses addition inside OR—confusing." }, { text: "my_settings = OPTION_A & OPTION_C;", reason: "AND clears bits, not sets." }], indent: 1, explanation: "Use the bitwise OR operator to set bits for options A and C." },
      { correct: "printf(\"\\nSettings after turning ON A and C:\\n\");", distractors: [{ text: "puts(\"Settings after turning ON A and C:\");", reason: "No newline escape." }, { text: "print(\"Settings after turning ON A and C:\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Print header." },
      { correct: "print_options(my_settings);", distractors: [{ text: "print_options(&my_settings);", reason: "Wrong pointer type." }, { text: "printf(\"%d\\n\", my_settings);", reason: "Prints raw number, not formatted flags." }], indent: 1, explanation: "Show new state." },
      { correct: "// Turn OFF option C", distractors: [{ text: "/* Clear bit C */", reason: "Less clear syntax." }, { text: "// Disable C", reason: "Too generic." }], indent: 1, explanation: "Comment on clearing a flag." },
      { correct: "my_settings = my_settings & ~OPTION_C;", distractors: [{ text: "my_settings -= OPTION_C;", reason: "Subtraction works only if bit set once." }, { text: "my_settings ^= OPTION_C;", reason: "XOR toggles bit, not guaranteed clear." }], indent: 1, explanation: "Use bitwise AND with the bitwise NOT of the flag to clear the bit." },
      { correct: "printf(\"\\nSettings after turning OFF C:\\n\");", distractors: [{ text: "puts(\"Settings after OFF C:\");", reason: "No newline escape." }, { text: "print(\"Settings after turning OFF C:\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Print header." },
      { correct: "print_options(my_settings);", distractors: [{ text: "print_options(&my_settings);", reason: "Wrong pointer type." }, { text: "printf(\"%d\\n\", my_settings);", reason: "Raw number only." }], indent: 1, explanation: "Show final state." },
      { correct: "return 0;", distractors: [{ text: "exit(0);", reason: "Bypasses `main` return." }, { text: "return;", reason: "Missing return value." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close main." },
      { correct: "void print_options(unsigned char settings) {", distractors: [{ text: "print_options(unsigned char settings) {", reason: "Missing return type." }, { text: "void print_options(char settings) {", reason: "Wrong type size." }], indent: 0, explanation: "Define the display function." },
      { correct: "printf(\"Binary: \");", distractors: [{ text: "puts(\"Binary: \");", reason: "No newline escape." }, { text: "print(\"Binary: \");", reason: "`print` isn’t C." }], indent: 1, explanation: "Print binary label." },
      { correct: "for (int i = 7; i >= 0; i--) {", distractors: [{ text: "for (i = 7; i >= 0; i--) {", reason: "`i` must be declared." }, { text: "while (i >= 0) {", reason: "Wrong loop type." }], indent: 1, explanation: "Loop to print each bit of the 8-bit char." },
      { correct: "putchar((settings >> i) & 1 ? '1' : '0');", distractors: [{ text: "printf(\"%d\", (settings >> i) & 1);", reason: "Prints 0/1, not '0'/'1'." }, { text: "putchar(settings & (1 << i));", reason: "Passes integer, not character." }], indent: 2, explanation: "Right-shift the bit to the 0th position, mask with 1, and print '1' or '0'." },
      { correct: "}", distractors: [{ text: ")", reason: "Wrong bracket." }, { text: "];", reason: "Invalid block closure." }], indent: 1, explanation: "Close bit-printing loop." },
      { correct: "printf(\"\\n\");", distractors: [{ text: "putchar('\\n');", reason: "Works but differs from `printf`." }, { text: "puts(\"\\n\");", reason: "Double newline." }], indent: 1, explanation: "Newline for formatting." },
      { correct: "// Check if a specific option is ON", distractors: [{ text: "// Test flags", reason: "Too generic." }, { text: "// Query bit", reason: "Less clear." }], indent: 1, explanation: "Comment on checking a flag." },
      { correct: "if ((settings & OPTION_A) != 0) {", distractors: [{ text: "if (settings == OPTION_A) {", reason: "Fails when multiple bits set." }, { text: "if (settings & ~OPTION_A) {", reason: "Checks opposite bit." }], indent: 1, explanation: "Use bitwise AND to check if the bit for Option A is set." },
      { correct: "printf(\"- Option A is ON\\n\");", distractors: [{ text: "puts(\"Option A ON\");", reason: "Missing dash and space." }, { text: "print(\"- Option A is ON\\n\");", reason: "`print` isn’t C." }], indent: 2, explanation: "Print status if on." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "];", reason: "Wrong bracket." }], indent: 1, explanation: "Close check for A." },
      { correct: "if (settings & OPTION_B) { printf(\"- Option B is ON\\n\"); }", distractors: [{ text: "if ((settings & OPTION_B) == OPTION_B) {", reason: "Also valid but verbose." }, { text: "if (settings | OPTION_B) {", reason: "Bitwise OR always true when bit set." }], indent: 1, explanation: "A more concise way to check Option B." },
      { correct: "if (settings & OPTION_C) { printf(\"- Option C is ON\\n\"); }", distractors: [{ text: "if (settings ^ OPTION_C) {", reason: "XOR toggles, not checks." }, { text: "if (settings == OPTION_C) {", reason: "Fails if other bits set." }], indent: 1, explanation: "Check Option C." },
      { correct: "if (settings & OPTION_D) { printf(\"- Option D is ON\\n\"); }", distractors: [{ text: "if (~settings & OPTION_D) {", reason: "Checks the opposite bit." }, { text: "if (settings & ~OPTION_D) {", reason: "Checks other bits." }], indent: 1, explanation: "Check Option D." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "];", reason: "Wrong closure." }], indent: 0, explanation: "Close the display function." }
    ]
  },

  // Level 34: Function Pointers as Callbacks
  {
    goal: "Create a generic array processing function that accepts a function pointer (callback) to perform an operation on each element.",
    concepts: "Function pointers, callbacks, typedef, generic programming",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for printf." },
      { correct: "#include <math.h>", distractors: [{ text: "#include <cmath>", reason: "C++ header." }, { text: "#include <stdlib.h>", reason: "Not needed for `pow`." }], indent: 0, explanation: "Include for pow() function." },
      { correct: "// Define a type for our function pointer for readability", distractors: [{ text: "/* Function pointer alias */", reason: "Less descriptive." }, { text: "// Typedef callback", reason: "Too generic." }], indent: 0, explanation: "Comment on using typedef." },
      { correct: "typedef void (*IntOperation)(int);", distractors: [{ text: "void (*IntOperation)(int);", reason: "Declares a variable, not a type." }, { text: "typedef void IntOperation(int);", reason: "Missing `*` in typedef syntax." }], indent: 0, explanation: "Create a type alias `IntOperation` for a pointer to a function that takes an int and returns void." },
      { correct: "// Callback function 1: Square a number", distractors: [{ text: "/* square callback */", reason: "Less descriptive." }, { text: "// First operation", reason: "Too generic." }], indent: 0, explanation: "Comment for first callback." },
      { correct: "void square(int num) {", distractors: [{ text: "int square(int num) {", reason: "Wrong return type." }, { text: "void square();", reason: "Missing parameter list." }], indent: 0, explanation: "Define the square function." },
      { correct: "printf(\"Square of %d is %d\\n\", num, num * num);", distractors: [{ text: "printf(\"%d^2 = %d\\n\", num, num*num);", reason: "Different format string." }, { text: "puts(\"Square computed\");", reason: "Doesn’t print the value." }], indent: 1, explanation: "Print the square." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close square function." },
      { correct: "// Callback function 2: Cube a number", distractors: [{ text: "/* cube callback */", reason: "Less descriptive." }, { text: "// Second operation", reason: "Too generic." }], indent: 0, explanation: "Comment for second callback." },
      { correct: "void cube(int num) {", distractors: [{ text: "int cube(int num) {", reason: "Wrong return type." }, { text: "void cube();", reason: "Missing parameter list." }], indent: 0, explanation: "Define the cube function." },
      { correct: "printf(\"Cube of %d is %.0f\\n\", num, pow(num, 3));", distractors: [{ text: "printf(\"%d^3=%.0f\\n\", num, pow(num,3));", reason: "Different format string." }, { text: "puts(\"Cube done\");", reason: "Doesn’t print the result." }], indent: 1, explanation: "Print the cube using the pow() function." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close cube function." },
      { correct: "// The generic processing function", distractors: [{ text: "/* Processor */", reason: "Less descriptive." }, { text: "// Generic callback", reason: "Too generic." }], indent: 0, explanation: "Comment for the main processing function." },
      { correct: "void processArray(int arr[], int size, IntOperation op) {", distractors: [{ text: "void processArray(int *arr, int size, IntOperation op) {", reason: "Works but less clear that it’s an array." }, { text: "void processArray(int arr[], size_t size, IntOperation op) {", reason: "Uses `size_t`, not taught here." }], indent: 0, explanation: "Define a function that takes an array, its size, and our function pointer type." },
      { correct: "for (int i = 0; i < size; i++) {", distractors: [{ text: "for (i = 0; i < size; i++) {", reason: "`i` must be declared." }, { text: "while (i < size) {", reason: "Wrong loop type." }], indent: 1, explanation: "Loop through each element of the array." },
      { correct: "op(arr[i]);", distractors: [{ text: "(*op)(arr[i]);", reason: "Valid but older syntax." }, { text: "arr[i] = op(arr[i]);", reason: "Assumes return value—wrong signature." }], indent: 2, explanation: "Call the provided callback function, passing the current array element." },
      { correct: "}", distractors: [{ text: ")", reason: "Wrong bracket." }, { text: "];", reason: "Invalid closure." }], indent: 1, explanation: "Close the loop." },
      { correct: "}", distractors: [{ text: "};", reason: "Extra semicolon." }, { text: "end;", reason: "Not C syntax." }], indent: 0, explanation: "Close the processing function." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "Wrong return type." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start the main function." },
      { correct: "int numbers[] = {1, 2, 3, 4, 5};", distractors: [{ text: "int numbers[5] = {1,2,3,4,5};", reason: "Valid but no spaces—less readable." }, { text: "int numbers[] = {1 2 3 4 5};", reason: "Missing commas." }], indent: 1, explanation: "Create an array of numbers to process." },
      { correct: "int size = sizeof(numbers) / sizeof(numbers[0]);", distractors: [{ text: "int size = sizeof(numbers);", reason: "Gives byte count, not element count." }, { text: "int size = 5;", reason: "Hard-codes length—less generic." }], indent: 1, explanation: "Calculate the number of elements in the array." },
      { correct: "printf(\"--- Processing with square() ---\\n\");", distractors: [{ text: "puts(\"--- Processing with square() ---\");", reason: "No newline escape." }, { text: "print(\"--- Processing with square() ---\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Print a header for the first operation." },
      { correct: "processArray(numbers, size, square);", distractors: [{ text: "processArray(&numbers, size, square);", reason: "Wrong pointer level." }, { text: "processArray(numbers, size, square());", reason: "Calls function instead of passing pointer." }], indent: 1, explanation: "Call the processor, passing the `square` function as the callback." },
      { correct: "printf(\"\\n--- Processing with cube() ---\\n\");", distractors: [{ text: "puts(\"--- Processing with cube() ---\");", reason: "No newline escape." }, { text: "print(\"--- Processing with cube() ---\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Print a header for the second operation." },
      { correct: "processArray(numbers, size, cube);", distractors: [{ text: "processArray(numbers, size, &cube);", reason: "Explicit `&` is redundant." }, { text: "processArray(numbers, size, cube());", reason: "Calls function, not pass pointer." }], indent: 1, explanation: "Call the processor again, this time passing the `cube` function." },
      { correct: "return 0;", distractors: [{ text: "exit(0);", reason: "Bypasses `main` return." }, { text: "return;", reason: "Missing return value." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the main function." }
    ]
  },

  // Level 35: Binary File I/O with Structs
  {
    goal: "Write an array of structs to a binary file using fwrite, then read it back with fread and verify the data.",
    concepts: "struct, binary file I/O, fopen, fwrite, fread, fclose, sizeof",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <fstream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for file I/O and printf." },
      { correct: "#include <stdlib.h>", distractors: [{ text: "#include <unistd.h>", reason: "POSIX, not needed here." }, { text: "#include <string.h>", reason: "Not required." }], indent: 0, explanation: "Include for exit()." },
      { correct: "typedef struct {", distractors: [{ text: "struct Player {", reason: "Missing `typedef` alias." }, { text: "typedef struct Player {", reason: "Alias name duplicated incorrectly." }], indent: 0, explanation: "Define a `Player` struct using typedef." },
      { correct: "  int id;", distractors: [{ text: "  char id;", reason: "Wrong type." }, { text: "  unsigned id;", reason: "Misses type width." }], indent: 1, explanation: "Player's unique ID." },
      { correct: "  char name[50];", distractors: [{ text: "  char *name;", reason: "Pointer requires allocation." }, { text: "  std::string name;", reason: "C++ type." }], indent: 1, explanation: "Player's name." },
      { correct: "  float score;", distractors: [{ text: "  double score;", reason: "Different precision." }, { text: "  int score;", reason: "Wrong type." }], indent: 1, explanation: "Player's score." },
      { correct: "} Player;", distractors: [{ text: "} player_t;", reason: "Alias name differs." }, { text: "} Player;", reason: "Duplicate correct alias (redundant)." }], indent: 0, explanation: "Create the alias `Player`." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "Wrong return type." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start main function." },
      { correct: "Player players_out[2] = {", distractors: [{ text: "Player players_out[] = {", reason: "Missing size—VLA not standard here." }, { text: "Player players_out[3] = {", reason: "Wrong array length." }], indent: 1, explanation: "Create an array of Player structs to write to the file." },
      { correct: "  {1, \"Alice\", 99.5f},", distractors: [{ text: "  {1, Alice, 99.5f},", reason: "String must be in quotes." }, { text: "  {1; \"Alice\"; 99.5f},", reason: "Semicolons invalid." }], indent: 2, explanation: "Initialize the first player." },
      { correct: "  {2, \"Bob\", 88.0f}", distractors: [{ text: "  {2, Bob, 88.0f}", reason: "Missing quotes around string." }, { text: "  {2, \"Bob\", 88.0}", reason: "Missing `f` suffix." }], indent: 2, explanation: "Initialize the second player." },
      { correct: "};", distractors: [{ text: "}", reason: "Missing semicolon." }, { text: "];", reason: "Wrong bracket." }], indent: 1, explanation: "Close the initializer list." },
      { correct: "FILE *file_ptr;", distractors: [{ text: "fstream file_ptr;", reason: "C++ type." }, { text: "FILE file_ptr;", reason: "Must be pointer." }], indent: 1, explanation: "Declare a file pointer." },
      { correct: "// --- WRITE TO FILE ---", distractors: [{ text: "/* WRITE */", reason: "Too generic." }, { text: "// Open for write", reason: "Misses binary mode detail." }], indent: 1, explanation: "Comment for the writing section." },
      { correct: "file_ptr = fopen(\"players.bin\", \"wb\");", distractors: [{ text: "file_ptr = fopen(\"players.bin\", \"w\");", reason: "Text mode corrupts binary data." }, { text: "file_ptr = fopen(\"players.txt\", \"wb\");", reason: "Wrong filename extension." }], indent: 1, explanation: "Open a file in binary write mode ('wb')." },
      { correct: "if (file_ptr == NULL) { perror(\"Error opening for write\"); exit(1); }", distractors: [{ text: "if (!file_ptr) return 1;", reason: "Works but less explicit." }, { text: "if (file_ptr == 0) exit(EXIT_FAILURE);", reason: "Uses macro differently." }], indent: 1, explanation: "Check for file open error." },
      { correct: "fwrite(players_out, sizeof(Player), 2, file_ptr);", distractors: [{ text: "fwrite(players_out, sizeof(Player), 1, file_ptr);", reason: "Writes only one element." }, { text: "fwrite(&players_out, sizeof(Player), 2, file_ptr);", reason: "Passes pointer-to-array, not element pointer." }], indent: 1, explanation: "Write the entire array of 2 players to the file." },
      { correct: "fclose(file_ptr);", distractors: [{ text: "close(file_ptr);", reason: "POSIX `close` on file descriptor, not `FILE*`." }, { text: "fclose(\"players.bin\");", reason: "Wrong argument type." }], indent: 1, explanation: "Always close the file after writing." },
      { correct: "printf(\"Data written to players.bin\\n\\n\");", distractors: [{ text: "puts(\"Data written!\");", reason: "Less informative." }, { text: "print(\"Data written to players.bin\\n\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Confirmation message." },
      { correct: "// --- READ FROM FILE ---", distractors: [{ text: "/* READ */", reason: "Too generic." }, { text: "// Reopen file", reason: "Misses binary mode detail." }], indent: 1, explanation: "Comment for the reading section." },
      { correct: "Player players_in[2];", distractors: [{ text: "Player players_in[];", reason: "Missing size." }, { text: "Player players_in[3];", reason: "Wrong size." }], indent: 1, explanation: "Create a new array to hold the data read from the file." },
      { correct: "file_ptr = fopen(\"players.bin\", \"rb\");", distractors: [{ text: "fopen(\"players.bin\",\"r\");", reason: "Text mode wrong." }, { text: "fopen(\"players.txt\",\"rb\");", reason: "Wrong extension." }], indent: 1, explanation: "Re-open the file in binary read mode ('rb')." },
      { correct: "if (file_ptr == NULL) { perror(\"Error opening for read\"); exit(1); }", distractors: [{ text: "if (!file_ptr) return 1;", reason: "Less explicit." }, { text: "if (file_ptr == 0) exit(EXIT_FAILURE);", reason: "Uses macro differently." }], indent: 1, explanation: "Check for file open error again." },
      { correct: "fread(players_in, sizeof(Player), 2, file_ptr);", distractors: [{ text: "fread(players_in, sizeof(Player*), 2, file_ptr);", reason: "Wrong size argument." }, { text: "fread(&players_in, sizeof(Player), 2, file_ptr);", reason: "Passes pointer-to-array." }], indent: 1, explanation: "Read exactly 2 Player-sized chunks of data from the file into the new array." },
      { correct: "fclose(file_ptr);", distractors: [{ text: "close(file_ptr);", reason: "POSIX call, not `FILE*`." }, { text: "fclose(\"players.bin\");", reason: "Wrong argument type." }], indent: 1, explanation: "Close the file after reading." },
      { correct: "printf(\"Verifying data read from file:\\n\");", distractors: [{ text: "puts(\"Verifying...\");", reason: "Less detailed." }, { text: "print(\"Verifying data read from file:\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Header for verification." },
      { correct: "for (int i = 0; i < 2; i++) {", distractors: [{ text: "for (i = 0; i < 2; i++) {", reason: "`i` must be declared." }, { text: "while (i < 2) {", reason: "Wrong loop type." }], indent: 1, explanation: "Loop through the read-in data." },
      { correct: "printf(\"Player %d: ID=%d, Name=%s, Score=%.1f\\n\",", distractors: [{ text: "printf(\"Player %d: %d %s %.1f\\n\",", reason: "Wrong format fields." }, { text: "printf(\"%d %d %s %f\\n\",", reason: "Wrong format and missing labels." }], indent: 2, explanation: "Print the data for each player read from the file." },
      { correct: "  i + 1, players_in[i].id, players_in[i].name, players_in[i].score);", distractors: [{ text: "i, players_in[i].id, players_in[i].name, players_in[i].score);", reason: "Off-by-one index." }, { text: "i+1, &players_in[i].id, players_in[i].name, players_in[i].score);", reason: "Passing address of id, not value." }], indent: 3, explanation: "Access the members of the struct to print them." },
      { correct: "}", distractors: [{ text: "};", reason: "Extra semicolon." }, { text: "end;", reason: "Not C syntax." }], indent: 1, explanation: "Close the verification loop." },
      { correct: "return 0;", distractors: [{ text: "return 1;", reason: "Signals failure." }, { text: "exit(EXIT_SUCCESS);", reason: "Bypasses normal return." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the main function." }
    ]
  },

  // Level 36: `typedef` for Readability
  {
    goal: "Refactor complex type declarations using `typedef` to improve code readability.",
    concepts: "typedef, structs, function pointers, complex declarations",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for standard I/O." },
      { correct: "#include <string.h>", distractors: [{ text: "#include <cstring>", reason: "C++ header." }, { text: "#include <stdlib.h>", reason: "Not needed for strcpy." }], indent: 0, explanation: "Include for strcpy." },
      { correct: "// --- Without Typedef (Complex) ---", distractors: [{ text: "/* Complex types */", reason: "Less explicit." }, { text: "// No typedef section", reason: "Less structured." }], indent: 0, explanation: "Section demonstrating complex C types." },
      { correct: "struct user_profile {", distractors: [{ text: "struct user_profile();", reason: "Function, not struct." }, { text: "class user_profile {", reason: "C++ keyword." }], indent: 0, explanation: "Define a struct the long way." },
      { correct: "  unsigned long id;", distractors: [{ text: "  ulong id;", reason: "`ulong` not defined yet." }, { text: "  unsigned id;", reason: "Missing type width." }], indent: 1, explanation: "A member with a long type name." },
      { correct: "  char name[50];", distractors: [{ text: "  char *name;", reason: "Requires separate allocation." }, { text: "  std::string name;", reason: "C++ type." }], indent: 1, explanation: "A name member." },
      { correct: "};", distractors: [{ text: "}", reason: "Missing semicolon." }, { text: "};;", reason: "Extra semicolon." }], indent: 0, explanation: "End the struct definition." },
      { correct: "void print_user(struct user_profile u) {", distractors: [{ text: "void print_user(user_profile u) {", reason: "Missing `struct` keyword." }, { text: "int print_user(struct user_profile u) {", reason: "Wrong return type." }], indent: 0, explanation: "A function taking the struct, requiring the `struct` keyword." },
      { correct: "printf(\"ID: %lu, Name: %s\\n\", u.id, u.name);", distractors: [{ text: "printf(\"ID: %d, Name: %s\\n\", u.id, u.name);", reason: "Wrong format for `unsigned long`." }, { text: "puts(u.name);", reason: "Only prints name, not id." }], indent: 1, explanation: "Print user info. `%lu` is for `unsigned long`." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the print function." },
      { correct: "// --- With Typedef (Readable) ---", distractors: [{ text: "/* Typedef section */", reason: "Less explicit." }, { text: "// Readable types", reason: "Too generic." }], indent: 0, explanation: "Section demonstrating how typedef improves readability." },
      { correct: "typedef unsigned long ulong;", distractors: [{ text: "typedef ulong unsigned long;", reason: "Alias and type swapped." }, { text: "using ulong = unsigned long;", reason: "C++ syntax, not C." }], indent: 0, explanation: "Create a simple alias `ulong` for `unsigned long`." },
      { correct: "typedef struct {", distractors: [{ text: "typedef struct user_profile {", reason: "Naming conflicts." }, { text: "struct {", reason: "Missing typedef keyword." }], indent: 0, explanation: "Begin an anonymous struct definition for use in a typedef." },
      { correct: "  ulong id;", distractors: [{ text: "  unsigned long id;", reason: "Reverts to full type—misses benefit." }, { text: "  ulong id[50];", reason: "Wrong type shape." }], indent: 1, explanation: "Use the new `ulong` type for the ID." },
      { correct: "  char name[50];", distractors: [{ text: "  char *name;", reason: "Requires allocation." }, { text: "  string name;", reason: "C++ type." }], indent: 1, explanation: "The name member." },
      { correct: "} UserProfile;", distractors: [{ text: "} Profile;", reason: "Alias name differs." }, { text: "} UserProfile", reason: "Missing semicolon." }], indent: 0, explanation: "Complete the typedef, creating the alias `UserProfile` for the entire struct." },
      { correct: "typedef int (*MathFunc)(int, int);", distractors: [{ text: "typedef int MathFunc(int, int);", reason: "Defines a function type, not a pointer." }, { text: "int (*MathFunc)(int, int);", reason: "Declares variable, not typedef." }], indent: 0, explanation: "Create a `typedef` for a function pointer that takes two ints and returns an int." },
      { correct: "int add(int a, int b) { return a + b; }", distractors: [{ text: "int add(int a, int b) { return a - b; }", reason: "Implements subtract, not add." }, { text: "void add(int a, int b) { return a + b; }", reason: "Wrong return type." }], indent: 0, explanation: "Define a function that matches the `MathFunc` signature." },
      { correct: "int subtract(int a, int b) { return a - b; }", distractors: [{ text: "int subtract(int a, int b) { return a + b; }", reason: "Implements add, not subtract." }, { text: "void subtract(int a, int b) { return a - b; }", reason: "Wrong return type." }], indent: 0, explanation: "Define another function that matches." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "Wrong return type." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start the main function." },
      { correct: "// Using the cleaner, typedef'd versions", distractors: [{ text: "/* Using typedefs */", reason: "Less explicit." }, { text: "// Cleaner types", reason: "Too generic." }], indent: 1, explanation: "Comment on using the new types." },
      { correct: "UserProfile user1;", distractors: [{ text: "struct UserProfile user1;", reason: "Requires `typedef` to avoid `struct` keyword." }, { text: "UserProfile user1[1];", reason: "Declares an array, not variable." }], indent: 1, explanation: "Declare a `UserProfile` variable easily." },
      { correct: "user1.id = 12345UL;", distractors: [{ text: "user1.id = 12345;", reason: "Missing `UL` suffix—different type." }, { text: "user1.id = 0x3039;", reason: "Hex literal valid but less clear." }], indent: 1, explanation: "Assign an ID. `UL` suffix denotes an unsigned long." },
      { correct: "strcpy(user1.name, \"Charlie\");", distractors: [{ text: "strncpy(user1.name, \"Charlie\", 50);", reason: "Safe but not taught." }, { text: "user1.name = \"Charlie\";", reason: "Invalid assignment to array." }], indent: 1, explanation: "Assign a name using strcpy." },
      { correct: "print_user(user1); // Note: print_user was not typedef'd", distractors: [{ text: "UserProfile u = user1; print_user(u);", reason: "Unnecessary copy." }, { text: "print_user(&user1);", reason: "Wrong argument type." }], indent: 1, explanation: "Call the original print function (it's compatible)." },
      { correct: "MathFunc operation;", distractors: [{ text: "int (*operation)(int,int);", reason: "More verbose original syntax." }, { text: "MathFunc *operation;", reason: "Pointer-to-function-pointer—wrong." }], indent: 1, explanation: "Declare a function pointer variable using our new `MathFunc` type." },
      { correct: "operation = add;", distractors: [{ text: "operation = &add;", reason: "Explicit `&` redundant." }, { text: "operation = subtract;", reason: "Points to wrong function initially." }], indent: 1, explanation: "Point the `operation` pointer to the `add` function." },
      { correct: "printf(\"Result of add: %d\\n\", operation(10, 5));", distractors: [{ text: "printf(\"%d\\n\", operation(10,5));", reason: "Missing label." }, { text: "puts(\"Result of add computed\");", reason: "Doesn’t print value." }], indent: 1, explanation: "Use the function pointer." },
      { correct: "operation = subtract;", distractors: [{ text: "operation = add;", reason: "Remains pointing to add." }, { text: "operation = &subtract;", reason: "Redundant `&`." }], indent: 1, explanation: "Point the same pointer to the `subtract` function." },
      { correct: "printf(\"Result of subtract: %d\\n\", operation(10, 5));", distractors: [{ text: "printf(\"%d\\n\", operation(10,5));", reason: "Missing label." }, { text: "puts(\"Subtraction done\");", reason: "Doesn’t print result." }], indent: 1, explanation: "Use the function pointer again." },
      { correct: "return 0;", distractors: [{ text: "exit(0);", reason: "Bypasses `main` return." }, { text: "return;", reason: "Missing return value." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the main function." }
    ]
  },

  // Level 37: Command-Line Argument Parsing
  {
    goal: "Write a program that parses and uses command-line arguments `argc` and `argv`.",
    concepts: "main function arguments, argc, argv, string comparison, atoi",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for standard I/O." },
      { correct: "#include <stdlib.h>", distractors: [{ text: "#include <cstdlib>", reason: "C++ header." }, { text: "#include <string.h>", reason: "Not needed for `atoi`." }], indent: 0, explanation: "Include for `atoi` (convert string to integer)." },
      { correct: "#include <string.h>", distractors: [{ text: "#include <cstring>", reason: "C++ header." }, { text: "#include <strings.h>", reason: "POSIX header, not standard C." }], indent: 0, explanation: "Include for `strcmp` (string comparison)." },
      { correct: "// The main function signature for accepting command-line args", distractors: [{ text: "/* main signature */", reason: "Too generic." }, { text: "// Signature: int main()", reason: "Missing `argv` in comment." }], indent: 0, explanation: "Comment on main's signature." },
      { correct: "int main(int argc, char *argv[]) {", distractors: [{ text: "int main() {", reason: "Signature lacks arguments." }, { text: "int main(int argv, char *argc[]) {", reason: "Names swapped—wrong semantics." }], indent: 0, explanation: "Define `main` to accept argument count (`argc`) and argument vector (`argv`)." },
      { correct: "// argc is the number of strings in argv", distractors: [{ text: "/* argc count */", reason: "Less descriptive." }, { text: "// argv length", reason: "Confuses argc/argv roles." }], indent: 1, explanation: "Explain argc." },
      { correct: "// argv is an array of strings (char pointers)", distractors: [{ text: "// argv list", reason: "Less precise." }, { text: "/* argv pointers */", reason: "Generic comment." }], indent: 1, explanation: "Explain argv." },
      { correct: "// argv[0] is always the program's name", distractors: [{ text: "// argv[1] is first arg", reason: "Wrong index explanation." }, { text: "// argv[0] is first param", reason: "Imprecise wording." }], indent: 1, explanation: "Explain argv[0]." },
      { correct: "printf(\"Program name: %s\\n\", argv[0]);", distractors: [{ text: "puts(argv[0]);", reason: "No label or newline control." }, { text: "print(\"Program name: %s\\n\", argv[0]);", reason: "`print` isn’t C." }], indent: 1, explanation: "Print the name of the executable." },
      { correct: "printf(\"Number of arguments supplied: %d\\n\", argc);", distractors: [{ text: "printf(\"Args=%d\\n\");", reason: "Missing argument to print." }, { text: "puts(argc);", reason: "Wrong type passed." }], indent: 1, explanation: "Print the total argument count." },
      { correct: "if (argc < 2) {", distractors: [{ text: "if (argc == 0) {", reason: "Impossible condition." }, { text: "if (argc <= 1) {", reason: "Works but differs from taught check." }], indent: 1, explanation: "Check if the user failed to provide any arguments." },
      { correct: "printf(\"Usage: %s [-m <message>] [-n <number>]\\n\", argv[0]);", distractors: [{ text: "puts(\"Usage: program [-m <msg>] [-n <num>]\");", reason: "Less detailed and wrong call." }, { text: "print(\"Usage: %s...\\n\", argv[0]);", reason: "`print` isn’t C." }], indent: 2, explanation: "Print a usage message if no arguments are given." },
      { correct: "return 1;", distractors: [{ text: "exit(1);", reason: "Bypasses `main` return." }, { text: "return;", reason: "Missing return value." }], indent: 2, explanation: "Exit with an error code." },
      { correct: "}", distractors: [{ text: "end if;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 1, explanation: "Close the argument check." },
      { correct: "// Loop through all provided arguments (starting from 1)", distractors: [{ text: "/* Arg loop */", reason: "Less descriptive." }, { text: "// for each arg", reason: "Generic comment." }], indent: 1, explanation: "Comment on argument loop." },
      { correct: "for (int i = 1; i < argc; i++) {", distractors: [{ text: "for (i = 1; i < argc; i++) {", reason: "`i` must be declared." }, { text: "while (i < argc) {", reason: "Wrong loop type." }], indent: 1, explanation: "Start a loop from index 1 to skip the program name." },
      { correct: "printf(\"Argument %d: %s\\n\", i, argv[i]);", distractors: [{ text: "puts(argv[i]);", reason: "No index or label." }, { text: "printf(\"%s\\n\", argv[i]);", reason: "Missing position number." }], indent: 2, explanation: "Print each argument." },
      { correct: "// Check for a specific flag, e.g., \"-m\" for message", distractors: [{ text: "// Flag -m", reason: "Too generic." }, { text: "/* message flag */", reason: "Less clear." }], indent: 2, explanation: "Comment on flag checking." },
      { correct: "if (strcmp(argv[i], \"-m\") == 0) {", distractors: [{ text: "if (argv[i] == \"-m\") {", reason: "Cannot compare strings with `==`." }, { text: "if (!strcmp(argv[i], \"-m\")) {", reason: "Also valid but checks `!0`—less explicit." }], indent: 2, explanation: "Use `strcmp` to check if the current argument is the '-m' flag." },
      { correct: "printf(\"  -> Found message flag! Message: %s\\n\", argv[i+1]);", distractors: [{ text: "puts(argv[i+1]);", reason: "No label or control." }, { text: "printf(\"Message: %d\\n\", argv[i+1]);", reason: "Wrong format for string." }], indent: 3, explanation: "If found, print the *next* argument as the message." },
      { correct: "i++; // Increment i to skip the message argument in the next loop", distractors: [{ text: "i += 2; // Skip two args", reason: "Over-increments." }, { text: "continue; // Skip next iteration", reason: "Misuses `continue`." }], indent: 3, explanation: "Crucially, increment the counter to avoid re-processing the flag's value." },
      { correct: "}", distractors: [{ text: "end if;", reason: "Not C syntax." }, { text: "];", reason: "Invalid closure." }], indent: 2, explanation: "Close the '-m' flag check." },
      { correct: "// Check for a specific flag, e.g., \"-n\" for number", distractors: [{ text: "// Flag -n", reason: "Too generic." }, { text: "/* number flag */", reason: "Less clear." }], indent: 2, explanation: "Comment on another flag." },
      { correct: "else if (strcmp(argv[i], \"-n\") == 0) {", distractors: [{ text: "if (!strcmp(argv[i], \"-n\")) {", reason: "Valid but less explicit." }, { text: "if (argv[i][1] == 'n') {", reason: "Only checks char, not full string." }], indent: 2, explanation: "Check for the '-n' flag." },
      { correct: "int num = atoi(argv[i+1]);", distractors: [{ text: "int num = (int)argv[i+1];", reason: "Cannot cast string pointer to int." }, { text: "int num = strtol(argv[i+1], NULL, 10);", reason: "Valid but not taught here." }], indent: 3, explanation: "Use `atoi` to convert the next argument from a string to an integer." },
      { correct: "printf(\"  -> Found number flag! Value squared: %d\\n\", num * num);", distractors: [{ text: "printf(\"Number: %d\\n\", num);", reason: "Different calculation." }, { text: "puts(\"Number flag found\");", reason: "No numeric output." }], indent: 3, explanation: "Print a calculation based on the parsed number." },
      { correct: "i++; // Increment i to skip the number argument", distractors: [{ text: "i += 2; // Skip two args", reason: "Over-increments." }, { text: "continue;", reason: "Misuses `continue`." }], indent: 3, explanation: "Increment the counter again." },
      { correct: "}", distractors: [{ text: "end if;", reason: "Not C syntax." }, { text: "];", reason: "Invalid closure." }], indent: 2, explanation: "Close the '-n' flag check." },
      { correct: "}", distractors: [{ text: "end for;", reason: "Not C syntax." }, { text: "];", reason: "Invalid closure." }], indent: 1, explanation: "Close the argument processing loop." },
      { correct: "return 0;", distractors: [{ text: "exit(0);", reason: "Bypasses `main` return." }, { text: "return;", reason: "Missing return value." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the main function." }
    ]
  },

  // Level 38: Error Handling with `errno` and `perror`
  {
    goal: "Demonstrate proper error handling by checking for a NULL return from fopen, then using `errno`, `perror`, and `strerror`.",
    concepts: "Error handling, errno, perror, strerror, FILE I/O",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for I/O functions." },
      { correct: "#include <stdlib.h>", distractors: [{ text: "#include <stdlib>", reason: "Missing `.h`." }, { text: "#include <unistd.h>", reason: "Not needed here." }], indent: 0, explanation: "Include for exit()." },
      { correct: "#include <string.h>", distractors: [{ text: "#include <cstring>", reason: "C++ header." }, { text: "#include <strings.h>", reason: "POSIX header." }], indent: 0, explanation: "Include for `strerror`." },
      { correct: "#include <errno.h>", distractors: [{ text: "#include <error.h>", reason: "Wrong header." }, { text: "#include <err.h>", reason: "Non-standard." }], indent: 0, explanation: "Include to get the declaration of the `errno` variable." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "Wrong return type." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start main function." },
      { correct: "FILE *fp;", distractors: [{ text: "int fp;", reason: "Wrong type." }, { text: "FILE fp;", reason: "Must be pointer." }], indent: 1, explanation: "Declare a file pointer." },
      { correct: "// Attempt to open a file that does not exist", distractors: [{ text: "/* Open file */", reason: "Too generic." }, { text: "// Try read mode", reason: "Less descriptive." }], indent: 1, explanation: "Comment on the intended failing operation." },
      { correct: "fp = fopen(\"non_existent_file.txt\", \"r\");", distractors: [{ text: "fopen(\"non_existent_file.txt\",\"w\");", reason: "Write mode creates file instead of failing." }, { text: "fopen(\"file.txt\",\"r\");", reason: "Different filename." }], indent: 1, explanation: "Try to open a non-existent file in read mode, which will fail." },
      { correct: "// Check if fopen() failed", distractors: [{ text: "/* Error check */", reason: "Less clear." }, { text: "// Verify file", reason: "Too generic." }], indent: 1, explanation: "Comment on the error check." },
      { correct: "if (fp == NULL) {", distractors: [{ text: "if (!fp) {", reason: "Equivalent but less explicit." }, { text: "if (fp = NULL) {", reason: "Assignment, not comparison." }], indent: 1, explanation: "A `NULL` return value from `fopen` indicates that an error occurred." },
      { correct: "// When a standard library function fails, it sets the global `errno` variable.", distractors: [{ text: "/* errno explained */", reason: "Less explicit." }, { text: "// errno holds error code", reason: "Less formal." }], indent: 2, explanation: "Explain `errno`." },
      { correct: "printf(\"fopen() failed. The error number is: %d\\n\", errno);", distractors: [{ text: "printf(\"Error: %s\\n\", errno);", reason: "Wrong format for integer." }, { text: "puts(errno);", reason: "Wrong function and type." }], indent: 2, explanation: "Print the raw integer error code stored in `errno`." },
      { correct: "// Method 1: Use perror() to print a descriptive error message", distractors: [{ text: "// Method 1: perror", reason: "Too short." }, { text: "/* perror usage */", reason: "Less instructional." }], indent: 2, explanation: "Explain perror." },
      { correct: "// perror() prints your custom message, followed by a colon,", distractors: [{ text: "// Prints error", reason: "Less detailed." }, { text: "/* Colon output */", reason: "Too vague." }], indent: 2, explanation: "Explain perror's output format." },
      { correct: "// and the string equivalent of the current errno value.", distractors: [{ text: "// Also uses strerror", reason: "Hints next method." }, { text: "/* strerror equivalent */", reason: "Less clear." }], indent: 2, explanation: "Continue explaining perror's output." },
      { correct: "perror(\"Error reported by perror\");", distractors: [{ text: "printf(\"Error: %s\\n\", perror);", reason: "`perror` doesn’t return a string." }, { text: "perror(errno);", reason: "`perror` takes string message, not int." }], indent: 2, explanation: "Call `perror` with a custom prefix for the error message." },
      { correct: "// Method 2: Use strerror() to get the error string yourself", distractors: [{ text: "// Method 2: strerror", reason: "Too brief." }, { text: "/* strerror usage */", reason: "Less explanatory." }], indent: 2, explanation: "Explain strerror." },
      { correct: "printf(\"Error reported by strerror: %s\\n\", strerror(errno));", distractors: [{ text: "printf(\"Error: %s\\n\", errno);", reason: "Prints integer as string." }, { text: "puts(strerror);", reason: "`strerror` is function, not string." }], indent: 2, explanation: "Use `strerror` to get the string for the current `errno` value and print it." },
      { correct: "exit(EXIT_FAILURE); // Use standard macro for failure exit code", distractors: [{ text: "exit(1);", reason: "Hard-coded rather than macro." }, { text: "return EXIT_FAILURE;", reason: "After perror, return is okay but bypasses exit." }], indent: 2, explanation: "Exit the program with a failure status." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "];", reason: "Wrong bracket." }], indent: 1, explanation: "Close the error handling block." },
      { correct: "// This part of the code will not be reached", distractors: [{ text: "// Success path", reason: "Misleading—won’t be reached here." }, { text: "/* Unreachable */", reason: "Less descriptive." }], indent: 1, explanation: "Comment on code flow." },
      { correct: "printf(\"File opened successfully!\\n\");", distractors: [{ text: "puts(\"File opened!\");", reason: "Less detailed." }, { text: "print(\"File opened successfully!\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "A success message that won't print in this case." },
      { correct: "fclose(fp);", distractors: [{ text: "close(fp);", reason: "POSIX call, not `FILE*`." }, { text: "fclose(\"non_existent_file.txt\");", reason: "Wrong argument type." }], indent: 1, explanation: "Closing the file." },
      { correct: "return 0; // Or EXIT_SUCCESS", distractors: [{ text: "return;", reason: "Missing return value." }, { text: "exit(EXIT_SUCCESS);", reason: "Bypasses `main` return." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close main function." }
    ]
  },

  // Level 39: `const` Correctness with Pointers
  {
    goal: "Understand and demonstrate the three main uses of `const` with pointers to enforce code correctness.",
    concepts: "`const` keyword, pointers, pointer to const, const pointer, const pointer to const",
    sequence: [
        { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Including `<stdlib.h>` isn’t needed here; `<stdio.h>` is required for `printf`." }], indent: 0, explanation: "Include for standard I/O." },
        { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "C standard requires `int main()` for proper return type." }], indent: 0, explanation: "Start the main function." },
        { correct: "int val1 = 10;", distractors: [{ "text": "const int val1 = 10;", reason: "Using `const` here prevents modification, but we need `val1` modifiable later." }], indent: 1, explanation: "A modifiable integer value." },
        { correct: "int val2 = 20;", distractors: [{ "text": "int val2;", reason: "Uninitialized variable; could lead to undefined behavior when used." }], indent: 1, explanation: "Another modifiable integer value." },
        { correct: "// --- 1. Pointer to a `const` Integer ---", distractors: [{ "text": "// Pointer to a constant integer", reason: "Too vague and lacks proper formatting; comments should be clear." }], indent: 1, explanation: "The data pointed to is constant, but the pointer itself can change." },
        { correct: "const int* ptr_to_const;", distractors: [{ "text": "int* const ptr_to_const;", reason: "This declares a constant pointer to a modifiable integer, not a pointer to a constant integer." }, { "text": "const int ptr_to_const;", reason: "This declares a constant integer, not a pointer." }], indent: 1, explanation: "Declare a pointer that points to an integer that cannot be changed through this pointer." },
        { correct: "ptr_to_const = &val1;", distractors: [{ "text": "*ptr_to_const = val1;", reason: "Tries to modify the value through the pointer, which is illegal with `const int*`." }], indent: 1, explanation: "Point it to `val1`. This is allowed." },
        { correct: "printf(\"Value via ptr_to_const: %d\\n\", *ptr_to_const);", distractors: [{ "text": "printf(\"Value: %d\\n\", ptr_to_const);", reason: "Prints the pointer address instead of the value; needs dereference with `*`." }], indent: 1, explanation: "Reading the value is fine." },
        { correct: "// *ptr_to_const = 15; // COMPILE ERROR! Cannot change the value.", distractors: [{ "text": "*ptr_to_const = 15;", reason: "Uncommented, this would attempt an illegal modification through a `const` pointer." }], indent: 1, explanation: "This line is commented out because it would not compile. You cannot modify the data via this pointer." },
        { correct: "ptr_to_const = &val2;", distractors: [{ "text": "ptr_to_const = val2;", reason: "Assigns the value instead of the address; pointer needs `&`." }], indent: 1, explanation: "Pointing to a different address *is* allowed. The pointer itself is not constant." },
        { correct: "printf(\"Pointer was changed to point to val2: %d\\n\", *ptr_to_const);", distractors: [{ "text": "printf(\"Value: %d\\n\", &val2);", reason: "Prints the address of `val2` instead of the value via the pointer." }], indent: 1, explanation: "Show that the pointer was successfully reassigned." },
        { correct: "// --- 2. `const` Pointer to an Integer ---", distractors: [{ "text": "// Constant pointer", reason: "Incomplete and unclear; should specify it’s a pointer to a modifiable integer." }], indent: 1, explanation: "The pointer itself is constant, but the data it points to can be changed." },
        { correct: "int* const const_ptr = &val1;", distractors: [{ "text": "int* const const_ptr;", reason: "A constant pointer must be initialized at declaration." }, { "text": "const int* const_ptr = &val1;", reason: "Omits `const` on the pointer; this is a pointer to a `const int` instead." }], indent: 1, explanation: "Declare a constant pointer. It must be initialized immediately and can never be reassigned." },
        { correct: "printf(\"\\nValue via const_ptr: %d\\n\", *const_ptr);", distractors: [{ "text": "printf(\"Value: %d\\n\", const_ptr);", reason: "Prints the pointer address instead of the value." }], indent: 1, explanation: "Reading the value is fine." },
        { correct: "*const_ptr = 15; // Allowed! The data can be changed.", distractors: [{ "text": "const_ptr = &val2;", reason: "Tries to reassign the constant pointer, which is illegal." }], indent: 1, explanation: "Modifying the data *through* the pointer is allowed." },
        { correct: "printf(\"Value was changed via const_ptr: %d\\n\", *const_ptr);", distractors: [{ "text": "printf(\"Value: %d\\n\", val1);", reason: "Correct value but bypasses the pointer, missing the demonstration." }], indent: 1, explanation: "Show that the underlying `val1` was modified." },
        { correct: "// const_ptr = &val2; // COMPILE ERROR! Cannot change the pointer itself.", distractors: [{ "text": "const_ptr = &val2;", reason: "Uncommented, this would illegally reassign a constant pointer." }], indent: 1, explanation: "This line is commented out as it would fail. The pointer's address is fixed." },
        { correct: "// --- 3. `const` Pointer to a `const` Integer ---", distractors: [{ "text": "// Fully constant pointer", reason: "Ambiguous and less precise; should clarify both pointer and data are constant." }], indent: 1, explanation: "Neither the pointer nor the data it points to can be changed." },
        { correct: "const int* const fully_const_ptr = &val2;", distractors: [{ "text": "int* fully_const_ptr = &val2;", reason: "Missing both `const` qualifiers; neither pointer nor data is protected." }], indent: 1, explanation: "Declare a pointer where both the pointer and the data are constant." },
        { correct: "printf(\"\\nValue via fully_const_ptr: %d\\n\", *fully_const_ptr);", distractors: [{ "text": "printf(\"Value: %d\\n\", fully_const_ptr);", reason: "Prints the address instead of the value." }], indent: 1, explanation: "Reading is the only operation allowed." },
        { correct: "// *fully_const_ptr = 25; // COMPILE ERROR!", distractors: [{ "text": "*fully_const_ptr = 25;", reason: "Uncommented, this illegally tries to modify a `const` value." }], indent: 1, explanation: "Cannot modify the data." },
        { correct: "// fully_const_ptr = &val1; // COMPILE ERROR!", distractors: [{ "text": "fully_const_ptr = &val1;", reason: "Uncommented, this illegally tries to reassign a `const` pointer." }], indent: 1, explanation: "Cannot reassign the pointer." },
        { correct: "return 0;", distractors: [{ "text": "return;", reason: "Missing return value; `main` should return an `int`." }], indent: 1, explanation: "Indicate successful execution." },
        { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax; function blocks use `}` not `};`." }], indent: 0, explanation: "Close the main function." }
    ]
  },

  // Level 40: The `volatile` Keyword
  {
    goal: "Understand the purpose of the `volatile` keyword to prevent compiler optimizations on variables that can change unexpectedly.",
    concepts: "`volatile` keyword, pointers, compiler optimization (conceptual)",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "`<stdlib.h>` isn’t needed here; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for standard I/O." },
  { correct: "// `volatile` tells the compiler that a variable's value may change", distractors: [{ "text": "// volatile variable", reason: "Too brief; lacks explanation of its effect on the compiler." }], indent: 0, explanation: "Conceptual explanation of volatile." },
  { correct: "// at any time without any action being taken by the code the compiler sees.", distractors: [{ "text": "// at any time", reason: "Incomplete; misses the key point about compiler visibility." }], indent: 0, explanation: "Continuing the explanation." },
  { correct: "// For example, a hardware status register.", distractors: [{ "text": "// Like an integer", reason: "Misleading; doesn’t relate to the hardware context." }], indent: 0, explanation: "Providing a common use case." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Incorrect return type; `main` must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "// We simulate a hardware register using a global variable.", distractors: [{ "text": "// Global variable", reason: "Lacks context; doesn’t explain the simulation purpose." }], indent: 1, explanation: "Comment on the simulation setup." },
  { correct: "volatile int mock_hardware_register = 0;", distractors: [{ "text": "int mock_hardware_register = 0;", reason: "Without `volatile`, the compiler might optimize the loop, causing an infinite loop." }], indent: 1, explanation: "Declare a `volatile` integer to simulate a memory-mapped register." },
  { correct: "int non_volatile_var = 0;", distractors: [{ "text": "int non_volatile_var;", reason: "Uninitialized; could lead to unpredictable behavior." }], indent: 1, explanation: "Declare a normal variable for comparison." },
  { correct: "printf(\"Waiting for `volatile` register to become non-zero...\\n\");", distractors: [{ "text": "printf(\"Waiting...\\n\");", reason: "Less informative; doesn’t specify what’s being waited for." }], indent: 1, explanation: "Informational message." },
  { correct: "printf(\"(In a real program, an external event or hardware would change this.)\\n\");", distractors: [{ "text": "printf(\"(Hardware changes this)\\n\");", reason: "Too concise; lacks context about simulation." }], indent: 1, explanation: "Clarify the simulation." },
  { correct: "// This loop will reliably re-read the `volatile` variable from memory on each iteration.", distractors: [{ "text": "// Loop reads variable", reason: "Vague; misses the key role of `volatile`." }], indent: 1, explanation: "Explain the effect of `volatile` on the loop." },
  { correct: "while (mock_hardware_register == 0) {", distractors: [{ "text": "while(1) { if (mock_hardware_register != 0) break; }", reason: "Functionally similar but less clear and concise." }], indent: 1, explanation: "Start a loop that waits for the `volatile` variable to change." },
  { correct: "  // In this simulation, we change it ourselves after a delay.", distractors: [{ "text": "// Change variable", reason: "Too generic; doesn’t mention simulation or delay." }], indent: 2, explanation: "Comment on the manual change." },
  { correct: "  static int counter = 0;", distractors: [{ "text": "int counter = 0;", reason: "Non-static resets each iteration, breaking the delay logic." }], indent: 2, explanation: "Use a static counter to trigger the change only once." },
  { correct: "  if (counter == 50000000) { // Artificial delay", distractors: [{ "text": "if (counter = 50000000) {", reason: "Uses assignment (`=`) instead of comparison (`==`), always true." }], indent: 2, explanation: "Create an artificial delay before changing the value." },
  { correct: "    mock_hardware_register = 1;", distractors: [{ "text": "&mock_hardware_register = 1;", reason: "Cannot assign to an address; variable isn’t a pointer." }], indent: 3, explanation: "Simulate the external event changing the register's value." },
  { correct: "  }", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a block; uses struct style." }], indent: 2, explanation: "Close the if." },
  { correct: "  counter++;", distractors: [{ "text": "counter = counter + 1;", reason: "Works but `++` is simpler and more idiomatic." }], indent: 2, explanation: "Increment the delay counter." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect closing syntax for a loop block." }], indent: 1, explanation: "Close the `while` loop." },
  { correct: "printf(\"...`volatile` register changed! Loop exited.\\n\");", distractors: [{ "text": "printf(\"Loop exited\\n\");", reason: "Lacks detail about why the loop exited." }], indent: 1, explanation: "Confirm that the loop has been successfully exited." },
  { correct: "// A compiler might optimize `while(non_volatile_var == 0)` into an infinite loop", distractors: [{ "text": "// Loop might not work", reason: "Unclear; doesn’t explain optimization risk." }], indent: 1, explanation: "Explain the potential problem without volatile." },
  { correct: "// because it sees that nothing inside the loop changes `non_volatile_var`.", distractors: [{ "text": "// because of the variable", reason: "Incomplete and vague; misses the optimization point." }], indent: 1, explanation: "Continue the explanation of the optimization." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "Returns error code; 0 indicates success." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a function." }], indent: 0, explanation: "Close the main function." }
]
  },

  // Level 41: Unions for Type Punning
  {
    goal: "Use a `union` to store a value as one type and access its memory representation through another type (type punning).",
    concepts: "union, memory representation, type punning, hexadecimal",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed here; `<stdio.h>` suffices for I/O." }], indent: 0, explanation: "Include for standard I/O." },
  { correct: "// A union allows storing different data types in the same memory location.", distractors: [{ "text": "// Union for multiple types", reason: "Less precise; doesn’t explain memory sharing." }], indent: 0, explanation: "Explanation of a union." },
  { correct: "typedef union {", distractors: [{ "text": "union {", reason: "Missing `typedef` means no type alias is created." }], indent: 0, explanation: "Begin defining a union with a typedef." },
  { correct: "  unsigned int int_val;", distractors: [{ "text": "int int_val;", reason: "Signed int might confuse byte interpretation due to sign extension." }], indent: 1, explanation: "A member to hold a 4-byte integer." },
  { correct: "  unsigned char bytes[4];", distractors: [{ "text": "char bytes[4];", reason: "Signed char could misrepresent byte values." }], indent: 1, explanation: "A member to access the same 4 bytes individually." },
  { correct: "} IntConverter;", distractors: [{ "text": "} int_converter;", reason: "Incorrect `typedef` syntax; defines a variable, not a type." }], indent: 0, explanation: "Create the alias `IntConverter` for the union." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Incorrect; `main` must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "IntConverter converter;", distractors: [{ "text": "IntConverter *converter;", reason: "Declares a pointer but doesn’t allocate memory." }], indent: 1, explanation: "Declare a variable of our union type." },
  { correct: "printf(\"Size of union: %zu bytes\\n\", sizeof(IntConverter));", distractors: [{ "text": "printf(\"Size: %zu\\n\", sizeof(unsigned int) + sizeof(unsigned char[4]));", reason: "Unions use the largest member’s size, not the sum." }], indent: 1, explanation: "Print the size of the union. It will be large enough for its largest member." },
  { correct: "// Assign a value to the integer member.", distractors: [{ "text": "// Set integer", reason: "Too vague; doesn’t specify the member." }], indent: 1, explanation: "Comment on assigning a value." },
  { correct: "converter.int_val = 0x1A2B3C4D; // A hexadecimal integer", distractors: [{ "text": "converter.bytes = {0x1A, 0x2B, 0x3C, 0x4D};", reason: "Cannot assign an array like this after declaration." }], indent: 1, explanation: "Store a hexadecimal value in the `int_val` member." },
  { correct: "printf(\"Stored integer value: 0x%X\\n\\n\", converter.int_val);", distractors: [{ "text": "printf(\"Value: %d\\n\", converter.int_val);", reason: "Prints decimal instead of hex, missing the point." }], indent: 1, explanation: "Print the integer value to confirm it was stored." },
  { correct: "// Now, access the *same memory* through the bytes array.", distractors: [{ "text": "// Access bytes", reason: "Lacks emphasis on shared memory." }], indent: 1, explanation: "Explain the type punning step." },
  { correct: "printf(\"Individual bytes (memory layout depends on endianness):\\n\");", distractors: [{ "text": "printf(\"Bytes:\\n\");", reason: "Misses endianness note, reducing clarity." }], indent: 1, explanation: "Note that the output order depends on system architecture (Little Endian vs. Big Endian)." },
  { correct: "for (int i = 0; i < 4; i++) {", distractors: [{ "text": "for (int i = 0; i <= 4; i++) {", reason: "Accesses beyond the array bounds (4 bytes)." }], indent: 1, explanation: "Loop through the 4 bytes of the union." },
  { correct: "printf(\"Byte %d: 0x%02X\\n\", i, converter.bytes[i]);", distractors: [{ "text": "printf(\"Byte %d: 0x%02X\\n\", i, converter.int_val[i]);", reason: "Cannot index an integer; must use the `bytes` member." }], indent: 2, explanation: "Print each byte's value in hexadecimal format." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a loop." }], indent: 1, explanation: "Close the loop." },
  { correct: "// Modify a single byte and see its effect on the integer.", distractors: [{ "text": "// Change byte", reason: "Doesn’t explain the effect on the union." }], indent: 1, explanation: "Demonstrate modifying memory through one member affects the other." },
  { correct: "printf(\"\\nModifying Byte 0 to 0xEE...\\n\");", distractors: [{ "text": "printf(\"Changing byte\\n\");", reason: "Less specific; misses what’s being changed." }], indent: 1, explanation: "Informational message." },
  { correct: "converter.bytes[0] = 0xEE;", distractors: [{ "text": "converter.int_val = 0xEE;", reason: "Overwrites the whole integer, not just one byte." }], indent: 1, explanation: "Change the value of the first byte in the array." },
  { correct: "printf(\"New integer value: 0x%X\\n\", converter.int_val);", distractors: [{ "text": "printf(\"Value: %d\\n\", converter.int_val);", reason: "Decimal format obscures the byte change." }], indent: 1, explanation: "Print the `int_val` again to see how it has changed." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "Incorrect; 0 indicates success." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Wrong syntax for function close." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 42: Advanced Preprocessor Macros
  {
    goal: "Create and use advanced preprocessor macros with arguments, demonstrating common pitfalls and the stringizing (#) operator.",
    concepts: "Preprocessor, macros, #define, macro arguments, operator precedence, stringizing operator (#)",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <string.h>", reason: "Not needed here; `<stdio.h>` covers I/O." }], indent: 0, explanation: "Include standard I/O." },
  { correct: "// A simple but FLAWED macro for squaring a number", distractors: [{ "text": "// Square macro", reason: "Doesn’t warn about the flaw." }], indent: 0, explanation: "Introduce a macro with a common flaw." },
  { correct: "#define FLAWED_SQUARE(x) x * x", distractors: [{ "text": "#define FLAWED_SQUARE(x) x^2", reason: "`^` is bitwise XOR, not exponentiation." }], indent: 0, explanation: "Define the flawed macro without parentheses." },
  { correct: "// A robust macro needs parentheses to handle operator precedence", distractors: [{ "text": "// Robust macro", reason: "Misses the precedence explanation." }], indent: 0, explanation: "Introduce the corrected version." },
  { correct: "#define SQUARE(x) ((x) * (x))", distractors: [{ "text": "#define SQUARE(x) (x*x)", reason: "Parentheses around the result but not arguments; fails with `SQUARE(2+3)`." }], indent: 0, explanation: "Define a robust macro with full parentheses for safety." },
  { correct: "// A macro using the stringizing operator (#) to print a variable's name and value", distractors: [{ "text": "// Print macro", reason: "Doesn’t mention stringizing operator." }], indent: 0, explanation: "Introduce the stringizing operator." },
  { correct: "#define PRINT_VAR(var) printf(#var \" = %d\\n\", var)", distractors: [{ "text": "#define PRINT_VAR(var) printf(\"var = %d\\n\", var)", reason: "Prints literal 'var' instead of the variable name." }], indent: 0, explanation: "Define a macro that turns its argument into a string literal." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "`main` must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "int a = 5;", distractors: [{ "text": "int a;", reason: "Uninitialized; undefined value when used." }], indent: 1, explanation: "Declare an integer variable." },
  { correct: "printf(\"Using robust SQUARE(5): %d\\n\", SQUARE(a));", distractors: [{ "text": "printf(\"Result: %d\\n\", SQUARE(5));", reason: "Uses literal but misses variable demo." }], indent: 1, explanation: "Demonstrate the correct macro." },
  { correct: "printf(\"Using robust SQUARE(2+3): %d\\n\", SQUARE(2+3));", distractors: [{ "text": "printf(\"SQUARE(5): %d\\n\", (2+3)*(2+3));", reason: "Manual expansion defeats the macro demo." }], indent: 1, explanation: "Show how the robust macro correctly handles expressions." },
  { correct: "printf(\"\\nNow, showing the FLAWED macro:\\n\");", distractors: [{ "text": "printf(\"Flawed macro:\\n\");", reason: "Less descriptive; misses transition context." }], indent: 1, explanation: "Header for the flawed example." },
  { correct: "printf(\"Using FLAWED_SQUARE(2+3): %d\\n\", FLAWED_SQUARE(2+3));", distractors: [{ "text": "printf(\"Result: %d\\n\", 2+3*2+3);", reason: "Hardcodes the wrong expansion, bypassing macro." }], indent: 1, explanation: "Demonstrate the flawed macro. It will expand to `2+3*2+3`, which equals 11, not 25." },
  { correct: "printf(\"  (Expands to 2 + 3 * 2 + 3, which is 11, not 25!)\\n\");", distractors: [{ "text": "printf(\"Wrong result\\n\");", reason: "Doesn’t explain why it’s wrong." }], indent: 1, explanation: "Explicitly explain the incorrect result." },
  { correct: "printf(\"\\nUsing the stringizing macro:\\n\");", distractors: [{ "text": "printf(\"Stringizing:\\n\");", reason: "Less clear; doesn’t specify macro." }], indent: 1, explanation: "Header for the stringizing example." },
  { correct: "int my_variable = 123;", distractors: [{ "text": "int my_variable;", reason: "Uninitialized; undefined when printed." }], indent: 1, explanation: "Declare a variable to be printed." },
  { correct: "PRINT_VAR(my_variable);", distractors: [{ "text": "printf(\"my_variable = %d\\n\", my_variable);", reason: "Correct output but bypasses the macro." }], indent: 1, explanation: "Call the PRINT_VAR macro. It will print 'my_variable = 123'." },
  { correct: "PRINT_VAR(a + my_variable);", distractors: [{ "text": "PRINT_VAR(\"a + my_variable\");", reason: "String literal prints as text, not an expression’s value." }], indent: 1, explanation: "Show that the macro can even stringize expressions." },
  { correct: "return 0;", distractors: [{ "text": "return;", reason: "Missing return value for `int main`." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for function close." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 43: `static` Variables and Functions
  {
    goal: "Understand the two main uses of the `static` keyword: creating variables with persistent storage and functions with internal linkage.",
    concepts: "`static` keyword, variable lifetime vs. scope, internal linkage",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is enough for I/O." }], indent: 0, explanation: "Include standard I/O." },
  { correct: "// A static function has internal linkage, meaning it is only visible within this file.", distractors: [{ "text": "// Static function", reason: "Doesn’t explain internal linkage." }], indent: 0, explanation: "Explain static functions." },
  { correct: "static void static_helper_function() {", distractors: [{ "text": "void static_helper_function() {", reason: "Without `static`, it has external linkage." }], indent: 0, explanation: "Define a `static` function." },
  { correct: "printf(\"  -> Inside the static helper function.\\n\");", distractors: [{ "text": "printf(\"Inside function\\n\");", reason: "Less specific; misses context." }], indent: 1, explanation: "Action of the static function." },
  { correct: "}", distractors: [{ "text": "};", reason: "Wrong syntax for function block." }], indent: 0, explanation: "Close the static function." },
  { correct: "// This function demonstrates a static local variable.", distractors: [{ "text": "// Static variable", reason: "Doesn’t specify it’s local or its purpose." }], indent: 0, explanation: "Explain static local variables." },
  { correct: "void counter_function() {", distractors: [{ "text": "int counter_function() {", reason: "Wrong return type; no value returned here." }], indent: 0, explanation: "Define a function that will use a static variable." },
  { correct: "static int call_count = 0;", distractors: [{ "text": "int call_count = 0;", reason: "Non-static resets each call, losing persistence." }], indent: 1, explanation: "Declare a `static` local variable. It is initialized only the first time the function is called." },
  { correct: "call_count++;", distractors: [{ "text": "call_count = 1;", reason: "Overwrites instead of incrementing." }], indent: 1, explanation: "Increment the counter." },
  { correct: "printf(\"This function has been called %d time(s).\\n\", call_count);", distractors: [{ "text": "printf(\"Called %d\\n\", call_count);", reason: "Less clear; misses plurality context." }], indent: 1, explanation: "Print the current value of the persistent counter." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect block closure." }], indent: 0, explanation: "Close the counter function." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "// --- Demonstrate static local variable ---", distractors: [{ "text": "// Static demo", reason: "Less descriptive; doesn’t specify what’s demonstrated." }], indent: 1, explanation: "Header for first demonstration." },
  { correct: "counter_function();", distractors: [{ "text": "counter_function;", reason: "Missing `()`; doesn’t call the function." }], indent: 1, explanation: "Call the function the first time. Output: 1." },
  { correct: "counter_function();", distractors: [{ "text": "counter_function(1);", reason: "Function takes no arguments; this won’t compile." }], indent: 1, explanation: "Call again. The `call_count` variable remembers its value. Output: 2." },
  { correct: "counter_function();", distractors: [{ "text": "call_count++;", reason: "Tries to access `call_count` directly, but it’s out of scope." }], indent: 1, explanation: "Call a third time. Output: 3." },
  { correct: "// `call_count` is not accessible here in main, its scope is the function.", distractors: [{ "text": "// Can’t use call_count", reason: "Doesn’t explain scope vs. lifetime." }], indent: 1, explanation: "Explain that lifetime and scope are different." },
  { correct: "// --- Demonstrate static function ---", distractors: [{ "text": "// Function demo", reason: "Misses the `static` focus." }], indent: 1, explanation: "Header for second demonstration." },
  { correct: "printf(\"\\nCalling the static helper function from main:\\n\");", distractors: [{ "text": "printf(\"Calling function:\\n\");", reason: "Doesn’t specify it’s static." }], indent: 1, explanation: "Informational message." },
  { correct: "static_helper_function();", distractors: [{ "text": "static_helper_function;", reason: "Missing `()`; doesn’t invoke the function." }], indent: 1, explanation: "Call the static function. This is allowed because we are in the same file where it was defined." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 44: Flexible Array Members
  {
    goal: "Define and use a struct with a flexible array member to create a variable-sized object.",
    concepts: "struct, flexible array member, dynamic memory allocation, sizeof",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <math.h>", reason: "Unrelated; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <stdlib.h>", distractors: [{ "text": "#include <stdio.h>", reason: "Already included; `<stdlib.h>` is for `malloc`." }], indent: 0, explanation: "Include for malloc/free." },
  { correct: "#include <string.h>", distractors: [{ "text": "#include <strings.h>", reason: "Wrong header; `<string.h>` is standard for `memcpy`." }], indent: 0, explanation: "Include for strcpy/memcpy." },
  { correct: "// A struct with a flexible array member must have at least one other member.", distractors: [{ "text": "// Flexible array struct", reason: "Doesn’t mention the requirement." }], indent: 0, explanation: "Rule for flexible array members." },
  { correct: "// The flexible array member must be the LAST member of the struct.", distractors: [{ "text": "// Last member", reason: "Misses why it’s required." }], indent: 0, explanation: "Another critical rule." },
  { correct: "typedef struct {", distractors: [{ "text": "struct {", reason: "Missing `typedef` means no alias is created." }], indent: 0, explanation: "Begin defining the struct." },
  { correct: "  size_t length;", distractors: [{ "text": "int length;", reason: "`int` might be too small for large sizes; `size_t` is preferred." }], indent: 1, explanation: "A member to store the length of the flexible data part." },
  { correct: "  char data[];", distractors: [{ "text": "char data[1];", reason: "Struct hack; less flexible than `[]`." }], indent: 1, explanation: "Declare the flexible array member. It has an incomplete type." },
  { correct: "} StringPacket;", distractors: [{ "text": "} string_packet;", reason: "Incorrect `typedef` syntax; defines a variable." }], indent: 0, explanation: "Create the `StringPacket` alias." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "const char* message = \"Hello Flexible Array!\";", distractors: [{ "text": "char message[] = \"Hello Flexible Array!\";", reason: "Works but isn’t a pointer; less flexible for this demo." }], indent: 1, explanation: "The string data we want to store." },
  { correct: "size_t message_len = strlen(message);", distractors: [{ "text": "int message_len = strlen(message);", reason: "`size_t` is safer for lengths; `int` might overflow." }], indent: 1, explanation: "Get the length of the string." },
  { correct: "// Allocate memory for the struct AND the flexible array data.", distractors: [{ "text": "// Allocate memory", reason: "Doesn’t specify the flexible array part." }], indent: 1, explanation: "Explain the special allocation." },
  { correct: "StringPacket *packet = malloc(sizeof(StringPacket) + message_len + 1);", distractors: [{ "text": "StringPacket *packet = malloc(sizeof(StringPacket));", reason: "Doesn’t allocate space for the flexible array." }], indent: 1, explanation: "Allocate space for the base struct PLUS the length of our message PLUS 1 for the null terminator." },
  { correct: "if (!packet) { return 1; } // Check for malloc failure", distractors: [{ "text": "if (packet == NULL) { exit(1); }", reason: "Works but `exit` skips cleanup; `return` is cleaner here." }], indent: 1, explanation: "Always check the result of malloc." },
  { correct: "// Now, initialize the packet", distractors: [{ "text": "// Initialize", reason: "Too vague; doesn’t specify what’s initialized." }], indent: 1, explanation: "Comment on initialization." },
  { correct: "packet->length = message_len;", distractors: [{ "text": "packet.length = message_len;", reason: "Incorrect syntax; `->` needed for pointers." }], indent: 1, explanation: "Store the length of the string in the `length` member." },
  { correct: "memcpy(packet->data, message, message_len + 1);", distractors: [{ "text": "strcpy(packet->data, message);", reason: "Works but `memcpy` is used here for demonstration." }], indent: 1, explanation: "Copy the message string into the `data` flexible array member." },
  { correct: "// Use the created packet", distractors: [{ "text": "// Use packet", reason: "Less informative; doesn’t specify creation." }], indent: 1, explanation: "Comment on using the data." },
  { correct: "printf(\"Packet created.\\n\");", distractors: [{ "text": "printf(\"Created\\n\");", reason: "Doesn’t specify what was created." }], indent: 1, explanation: "Confirmation message." },
  { correct: "printf(\"  Stored length: %zu\\n\", packet->length);", distractors: [{ "text": "printf(\"Length: %d\\n\", packet->length);", reason: "`%d` is for `int`; `size_t` needs `%zu`." }], indent: 1, explanation: "Print the stored length." },
  { correct: "printf(\"  Stored data: %s\\n\", packet->data);", distractors: [{ "text": "printf(\"Data: %s\\n\", packet);", reason: "Prints the struct pointer, not the data string." }], indent: 1, explanation: "Print the stored string." },
  { correct: "printf(\"  sizeof(*packet): %zu (shows size of base struct only!)\\n\", sizeof(*packet));", distractors: [{ "text": "printf(\"Size: %zu\\n\", sizeof(packet));", reason: "Size of pointer, not struct." }], indent: 1, explanation: "`sizeof` on a struct with a flexible array member does not include the flexible part's size." },
  { correct: "// Clean up", distractors: [{ "text": "// Free memory", reason: "Slightly less broad; ‘clean up’ covers more." }], indent: 1, explanation: "Comment on cleanup." },
  { correct: "free(packet);", distractors: [{ "text": "free(packet->data);", reason: "Flexible array is part of the struct; only one `free` needed." }], indent: 1, explanation: "A single `free` call releases all the memory for the struct and the flexible array." },
  { correct: "return 0;", distractors: [{ "text": "return;", reason: "Missing value for `int main`." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 45: Variable-Length Arrays (VLAs)
  {
    goal: "Create and use a Variable-Length Array (VLA), whose size is determined at runtime rather than compile time.",
    concepts: "Variable-Length Arrays (VLA), stack memory, runtime sizing, C99 standard",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; VLAs don’t use `malloc`." }], indent: 0, explanation: "Include standard I/O." },
  { correct: "void process_vla(int size, int vla[size]);", distractors: [{ "text": "void process_vla(int vla[]);", reason: "Missing size parameter; VLAs need it explicitly." }], indent: 0, explanation: "Prototype a function that can accept a VLA." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "int desired_size;", distractors: [{ "text": "int desired_size = 0;", reason: "Initialized to 0; user input would be ignored." }], indent: 1, explanation: "Declare a variable to hold the runtime size." },
  { correct: "printf(\"Enter the desired size for the array: \");", distractors: [{ "text": "printf(\"Size: \");", reason: "Less clear; doesn’t prompt for input." }], indent: 1, explanation: "Prompt the user for input." },
  { correct: "scanf(\"%d\", &desired_size);", distractors: [{ "text": "scanf(\"%d\", desired_size);", reason: "Missing `&`; needs address of variable." }], indent: 1, explanation: "Read the size from the user." },
  { correct: "if (desired_size <= 0) {", distractors: [{ "text": "if (desired_size < 0) {", reason: "Misses invalid case of 0 size." }], indent: 1, explanation: "Add a check for invalid input." },
  { correct: "printf(\"Size must be positive.\\n\");", distractors: [{ "text": "printf(\"Error\\n\");", reason: "Doesn’t explain the error." }], indent: 2, explanation: "Error message." },
  { correct: "return 1;", distractors: [{ "text": "exit(1);", reason: "Works but `return` is simpler in `main`." }], indent: 2, explanation: "Exit with an error code." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the validation block." },
  { correct: "// Declare a Variable-Length Array (VLA) on the stack", distractors: [{ "text": "// VLA", reason: "Doesn’t mention stack allocation." }], indent: 1, explanation: "Comment explaining the VLA declaration." },
  { correct: "int my_vla[desired_size];", distractors: [{ "text": "int *my_vla = malloc(desired_size * sizeof(int));", reason: "Uses heap, not stack; VLAs are simpler." }], indent: 1, explanation: "The array's size is not a compile-time constant, but the variable `desired_size`." },
  { correct: "printf(\"VLA of %d integers created on the stack.\\n\", desired_size);", distractors: [{ "text": "printf(\"Array created\\n\");", reason: "Doesn’t confirm VLA or size." }], indent: 1, explanation: "Confirmation message." },
  { correct: "// Note: VLAs were introduced in C99 but became an optional feature in C11.", distractors: [{ "text": "// VLAs in C", reason: "Lacks version history." }], indent: 1, explanation: "Important note about compiler support for VLAs." },
  { correct: "// Initialize the VLA", distractors: [{ "text": "// Set values", reason: "Less specific; doesn’t mention VLA." }], indent: 1, explanation: "Comment on initialization." },
  { correct: "for (int i = 0; i < desired_size; i++) {", distractors: [{ "text": "for (int i = 0; i <= desired_size; i++) {", reason: "Exceeds array bounds." }], indent: 1, explanation: "Loop up to the runtime size." },
  { correct: "my_vla[i] = i * 10;", distractors: [{ "text": "my_vla[i] = i;", reason: "Works but less illustrative." }], indent: 2, explanation: "Assign a value to each element." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the initialization loop." },
  { correct: "// Pass the VLA to a function", distractors: [{ "text": "// Use VLA", reason: "Doesn’t mention passing." }], indent: 1, explanation: "Comment on passing the VLA." },
  { correct: "process_vla(desired_size, my_vla);", distractors: [{ "text": "process_vla(my_vla);", reason: "Missing size parameter." }], indent: 1, explanation: "Call the function, passing the size and the array." },
  { correct: "// No need to `free()` a VLA, it is deallocated when it goes out of scope.", distractors: [{ "text": "// Free VLA", reason: "Misleading; VLAs don’t need `free`." }], indent: 1, explanation: "Key difference between stack (VLA) and heap (malloc) memory." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 is error; 0 is success." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main." },
  { correct: "void process_vla(int size, int vla[size]) {", distractors: [{ "text": "void process_vla(int size, int vla[]) {", reason: "Doesn’t specify VLA size." }], indent: 0, explanation: "Define the function that accepts the VLA." },
  { correct: "printf(\"Inside process_vla. Array contents:\\n\");", distractors: [{ "text": "printf(\"Contents:\\n\");", reason: "Doesn’t specify function context." }], indent: 1, explanation: "Header message." },
  { correct: "for (int i = 0; i < size; i++) {", distractors: [{ "text": "for (int i = 0; i <= size; i++) {", reason: "Exceeds bounds." }], indent: 1, explanation: "Loop through the passed VLA." },
  { correct: "printf(\"%d \", vla[i]);", distractors: [{ "text": "printf(\"%d\\n\", vla[i]);", reason: "Prints each on a new line; intended as a list." }], indent: 2, explanation: "Print each element." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the loop." },
  { correct: "printf(\"\\n\");", distractors: [{ "text": "printf(\"\");", reason: "Doesn’t add a newline." }], indent: 1, explanation: "Final newline." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close the function." }
]
  },

  // Level 46: `goto` for Centralized Cleanup
  {
    goal: "Demonstrate a legitimate use of `goto` for centralized error handling and resource cleanup.",
    concepts: "`goto`, labels, resource management, error handling",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <string.h>", reason: "Not needed; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <stdlib.h>", distractors: [{ "text": "#include <stdio.h>", reason: "Already included; `<stdlib.h>` is for `malloc`." }], indent: 0, explanation: "Include for malloc/free." },
  { correct: "// While `goto` is often discouraged, one of its accepted uses", distractors: [{ "text": "// Goto usage", reason: "Doesn’t explain its purpose." }], indent: 0, explanation: "Preface about goto usage." },
  { correct: "// is to handle cleanup in a function with multiple resources and exit points.", distractors: [{ "text": "// Cleanup", reason: "Misses context about resources and exits." }], indent: 0, explanation: "Continuing the explanation." },
  { correct: "void process_resources() {", distractors: [{ "text": "int process_resources() {", reason: "No return value needed here." }], indent: 0, explanation: "Define the function that will use goto." },
  { correct: "FILE *file1 = NULL;", distractors: [{ "text": "FILE file1;", reason: "Incorrect; `FILE` is a pointer type." }], indent: 1, explanation: "Declare a pointer for the first resource." },
  { correct: "char *buffer = NULL;", distractors: [{ "text": "char buffer[1024];", reason: "Static array doesn’t need freeing; we’re demoing dynamic allocation." }], indent: 1, explanation: "Declare a pointer for the second resource." },
  { correct: "int error_status = 0;", distractors: [{ "text": "int error_status;", reason: "Uninitialized; could be misleading." }], indent: 1, explanation: "A variable to hold the final status." },
  { correct: "printf(\"Attempting to allocate resources...\\n\");", distractors: [{ "text": "printf(\"Starting...\\n\");", reason: "Less specific; doesn’t mention resources." }], indent: 1, explanation: "Informational message." },
  { correct: "file1 = fopen(\"output.tmp\", \"w\");", distractors: [{ "text": "file1 = fopen(\"output.tmp\", \"r\");", reason: "Read mode doesn’t allow writing." }], indent: 1, explanation: "Attempt to allocate the first resource (open a file)." },
  { correct: "if (file1 == NULL) {", distractors: [{ "text": "if (!file1) {", reason: "Same but less explicit; `== NULL` is clearer." }], indent: 1, explanation: "Check if the first allocation failed." },
  { correct: "  perror(\"Failed to open file1\");", distractors: [{ "text": "printf(\"Error\\n\");", reason: "`perror` provides specific error info." }], indent: 2, explanation: "Print an error." },
  { correct: "  error_status = -1;", distractors: [{ "text": "error_status = 1;", reason: "Positive values typically mean success; -1 indicates error." }], indent: 2, explanation: "Set the error status." },
  { correct: "  goto cleanup;", distractors: [{ "text": "return;", reason: "Exits without cleanup." }], indent: 2, explanation: "Jump to the centralized cleanup block." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the first error check." },
  { correct: "printf(\"  -> File opened successfully.\\n\");", distractors: [{ "text": "printf(\"Success\\n\");", reason: "Less informative." }], indent: 1, explanation: "Success message for resource 1." },
  { correct: "buffer = malloc(1024);", distractors: [{ "text": "buffer = malloc(1024 * sizeof(char));", reason: "Redundant; `sizeof(char)` is 1." }], indent: 1, explanation: "Attempt to allocate the second resource (memory)." },
  { correct: "if (buffer == NULL) {", distractors: [{ "text": "if (buffer) {", reason: "Reverses logic; checks success instead of failure." }], indent: 1, explanation: "Check if the second allocation failed." },
  { correct: "  perror(\"Failed to allocate buffer\");", distractors: [{ "text": "printf(\"Malloc failed\\n\");", reason: "Doesn’t show system error." }], indent: 2, explanation: "Print an error." },
  { correct: "  error_status = -1;", distractors: [{ "text": "error_status = 0;", reason: "0 implies success, not failure." }], indent: 2, explanation: "Set the error status." },
  { correct: "  goto cleanup;", distractors: [{ "text": "return;", reason: "Skips cleanup." }], indent: 2, explanation: "Jump to the same cleanup block." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the second error check." },
  { correct: "printf(\"  -> Buffer allocated successfully.\\n\");", distractors: [{ "text": "printf(\"Buffer OK\\n\");", reason: "Less clear." }], indent: 1, explanation: "Success message for resource 2." },
  { correct: "printf(\"...All resources allocated. Performing work...\\n\");", distractors: [{ "text": "printf(\"Working...\\n\");", reason: "Doesn’t confirm allocation." }], indent: 1, explanation: "Simulate doing work with the resources." },
  { correct: "cleanup:", distractors: [{ "text": "label cleanup;", reason: "Incorrect label syntax." }], indent: 0, explanation: "Define the label. The `goto` statements will jump here." },
  { correct: "printf(\"\\n--- Reached cleanup block ---\\n\");", distractors: [{ "text": "printf(\"Cleanup\\n\");", reason: "Less distinctive." }], indent: 1, explanation: "Indicate that the cleanup code is running." },
  { correct: "if (buffer) {", distractors: [{ "text": "if (buffer != NULL) { free(buffer); }", reason: "Redundant; `if (buffer)` is sufficient." }], indent: 1, explanation: "Check if the buffer was allocated before trying to free it." },
  { correct: "  free(buffer);", distractors: [{ "text": "delete buffer;", reason: "C++ syntax, not C." }], indent: 2, explanation: "Free the buffer." },
  { correct: "  printf(\"  -> Buffer freed.\\n\");", distractors: [{ "text": "printf(\"Freed\\n\");", reason: "Doesn’t specify what was freed." }], indent: 2, explanation: "Confirmation." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close buffer check." },
  { correct: "if (file1) {", distractors: [{ "text": "if (file1 == 0) {", reason: "Reverses logic; checks if null instead of not null." }], indent: 1, explanation: "Check if the file was opened before trying to close it." },
  { correct: "  fclose(file1);", distractors: [{ "text": "close(file1);", reason: "Wrong function; `fclose` is for `FILE*`." }], indent: 2, explanation: "Close the file." },
  { correct: "  printf(\"  -> File closed.\\n\");", distractors: [{ "text": "printf(\"Closed\\n\");", reason: "Doesn’t specify what was closed." }], indent: 2, explanation: "Confirmation." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close file check." },
  { correct: "if (error_status != 0) { printf(\"Function finished with errors.\\n\"); }", distractors: [{ "text": "printf(\"Error status: %d\\n\", error_status);", reason: "Always prints; we only want error case." }], indent: 1, explanation: "Report final status." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close the function." },
  { correct: "int main() { process_resources(); return 0; }", distractors: [{ "text": "void main() { process_resources(); }", reason: "Must return `int` and value." }], indent: 0, explanation: "Main function to run the demo." }
]
  },

  // Level 47: Memory Alignment (`_Alignas`, `_Alignof`)
  {
    goal: "Understand and control memory alignment of structs using C11's `_Alignas` and `_Alignof` operators.",
    concepts: "Memory alignment, _Alignas, _Alignof, sizeof, C11 standard",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is enough." }], indent: 0, explanation: "Include for standard I/O." },
  { correct: "#include <stdalign.h>", distractors: [{ "text": "#include <align.h>", reason: "Wrong header; `<stdalign.h>` is standard." }], indent: 0, explanation: "Include for the more readable `alignas` and `alignof` macros." },
  { correct: "// --- A default-aligned struct ---", distractors: [{ "text": "// Default struct", reason: "Doesn’t mention alignment." }], indent: 0, explanation: "Comment for the first struct." },
  { correct: "struct DefaultAligned {", distractors: [{ "text": "typedef struct DefaultAligned {", reason: "Unnecessary `typedef` here; just defining a struct." }], indent: 0, explanation: "Begin definition of a normal struct." },
  { correct: "  char a;", distractors: [{ "text": "int a;", reason: "Changes alignment; we want minimal size first." }], indent: 1, explanation: "A 1-byte char." },
  { correct: "  int b;", distractors: [{ "text": "short b;", reason: "Alters padding demo; `int` is typically 4 bytes." }], indent: 1, explanation: "A 4-byte int." },
  { correct: "  char c;", distractors: [{ "text": "char *c;", reason: "Pointer changes size and alignment needs." }], indent: 1, explanation: "Another 1-byte char." },
  { correct: "};", distractors: [{ "text": "}", reason: "Missing semicolon; struct definition needs it." }], indent: 0, explanation: "Close the struct. The compiler will add padding for default alignment." },
  { correct: "// --- A struct with specific alignment ---", distractors: [{ "text": "// Aligned struct", reason: "Doesn’t specify it’s specific alignment." }], indent: 0, explanation: "Comment for the specially-aligned struct." },
  { correct: "// Use `alignas` (from <stdalign.h>) which is a macro for `_Alignas`", distractors: [{ "text": "// Use alignas", reason: "Misses header and macro info." }], indent: 0, explanation: "Explain the `alignas` macro." },
  { correct: "struct alignas(16) CustomAligned {", distractors: [{ "text": "struct CustomAligned alignas(16) {", reason: "Incorrect syntax; `alignas` precedes `struct`." }], indent: 0, explanation: "Define a struct and force it to be aligned on a 16-byte boundary." },
  { correct: "  char a;", distractors: [{ "text": "int a;", reason: "Changes size and padding demo." }], indent: 1, explanation: "A 1-byte char." },
  { correct: "  int b;", distractors: [{ "text": "short b;", reason: "Alters intended alignment effect." }], indent: 1, explanation: "A 4-byte int." },
  { correct: "  char c;", distractors: [{ "text": "char *c;", reason: "Pointer changes alignment needs." }], indent: 1, explanation: "Another 1-byte char." },
  { correct: "};", distractors: [{ "text": "}", reason: "Missing semicolon." }], indent: 0, explanation: "Close the struct." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "printf(\"--- Default Aligned Struct ---\\n\");", distractors: [{ "text": "printf(\"Default:\\n\");", reason: "Less descriptive." }], indent: 1, explanation: "Header for the first analysis." },
  { correct: "// `alignof` (macro for `_Alignof`) gets the alignment requirement of a type.", distractors: [{ "text": "// alignof", reason: "Doesn’t explain its purpose or origin." }], indent: 1, explanation: "Explain the `alignof` macro." },
  { correct: "printf(\"Required alignment: %zu\\n\", alignof(struct DefaultAligned));", distractors: [{ "text": "printf(\"Alignment: %d\\n\", alignof(struct DefaultAligned));", reason: "`%d` is wrong for `size_t`; use `%zu`." }], indent: 1, explanation: "Print the default alignment requirement (usually that of the largest member, e.g., 4 for `int`)." },
  { correct: "printf(\"Size with padding:  %zu\\n\", sizeof(struct DefaultAligned));", distractors: [{ "text": "printf(\"Size: %zu\\n\", sizeof(char) + sizeof(int) + sizeof(char));", reason: "Ignores padding." }], indent: 1, explanation: "Print the size, which will include padding bytes to meet alignment rules (e.g., 12 bytes)." },
  { correct: "printf(\"\\n--- Custom Aligned Struct ---\\n\");", distractors: [{ "text": "printf(\"Custom:\\n\");", reason: "Misses alignment context." }], indent: 1, explanation: "Header for the second analysis." },
  { correct: "printf(\"Required alignment: %zu\\n\", alignof(struct CustomAligned));", distractors: [{ "text": "printf(\"Alignment: %d\\n\", alignof(struct CustomAligned));", reason: "Wrong format specifier." }], indent: 1, explanation: "Print the required alignment, which we forced to be 16." },
  { correct: "printf(\"Size with padding:  %zu\\n\", sizeof(struct CustomAligned));", distractors: [{ "text": "printf(\"Size: %zu\\n\", 1+4+1);", reason: "Sum ignores alignment padding." }], indent: 1, explanation: "Print the size, which will now be a multiple of 16 (e.g., 16 bytes)." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 is error; 0 is success." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 48: Introduction to Atomics
  {
    goal: "Use C11 atomic types and operations from `<stdatomic.h>` to perform thread-safe modifications to a variable.",
    concepts: "Atomics, stdatomic.h, atomic_int, atomic_store, atomic_load, atomic_fetch_add, thread safety (conceptual)",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` covers I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <stdatomic.h>", distractors: [{ "text": "#include <atomic.h>", reason: "Wrong header; `<stdatomic.h>` is C11 standard." }], indent: 0, explanation: "Include the C11 standard header for atomic operations." },
  { correct: "// Atomics are used for lock-free programming, often in multi-threaded code.", distractors: [{ "text": "// Atomics", reason: "Doesn’t explain usage." }], indent: 0, explanation: "Explain the primary use case for atomics." },
  { correct: "// Operations like `i++` are not atomic. They are a read-modify-write sequence.", distractors: [{ "text": "// i++ isn’t safe", reason: "Misses why it’s unsafe." }], indent: 0, explanation: "Explain why `++` isn't thread-safe." },
  { correct: "// An atomic operation is guaranteed to execute completely without interruption.", distractors: [{ "text": "// Atomic ops", reason: "Lacks detail on atomicity." }], indent: 0, explanation: "Define an atomic operation." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "// Declare an atomic integer variable.", distractors: [{ "text": "// Atomic variable", reason: "Doesn’t specify type." }], indent: 1, explanation: "Comment on declaration." },
  { correct: "atomic_int shared_counter;", distractors: [{ "text": "int shared_counter;", reason: "Not atomic; not thread-safe." }], indent: 1, explanation: "Use `atomic_int` to declare an integer that can be safely manipulated by multiple threads." },
  { correct: "// 1. Initialize the atomic variable using atomic_store.", distractors: [{ "text": "// Set atomic", reason: "Less precise; misses method." }], indent: 1, explanation: "Explain atomic initialization." },
  { correct: "atomic_store(&shared_counter, 0);", distractors: [{ "text": "shared_counter = 0;", reason: "Not guaranteed atomic." }], indent: 1, explanation: "Safely store the initial value of 0 into the atomic variable." },
  { correct: "printf(\"Initial value (read with atomic_load): %d\\n\", atomic_load(&shared_counter));", distractors: [{ "text": "printf(\"Value: %d\\n\", shared_counter);", reason: "Direct access isn’t atomic." }], indent: 1, explanation: "Safely read the current value using `atomic_load`." },
  { correct: "// 2. Atomically add a value and get the *old* value back.", distractors: [{ "text": "// Add value", reason: "Doesn’t mention atomicity or return value." }], indent: 1, explanation: "Explain atomic fetch-and-add." },
  { correct: "int old_value = atomic_fetch_add(&shared_counter, 10);", distractors: [{ "text": "int old_value = shared_counter += 10;", reason: "Not atomic." }], indent: 1, explanation: "Atomically add 10 to the counter and return the value the counter held *before* the addition." },
  { correct: "printf(\"Called atomic_fetch_add(10). Old value was: %d\\n\", old_value);", distractors: [{ "text": "printf(\"Old: %d\\n\", old_value);", reason: "Less descriptive." }], indent: 1, explanation: "Print the returned old value." },
  { correct: "int new_value = atomic_load(&shared_counter);", distractors: [{ "text": "int new_value = shared_counter;", reason: "Non-atomic read." }], indent: 1, explanation: "Safely load the new, current value." },
  { correct: "printf(\"Current value is now: %d\\n\", new_value);", distractors: [{ "text": "printf(\"New: %d\\n\", new_value);", reason: "Less clear." }], indent: 1, explanation: "Print the new value to show the result of the addition." },
  { correct: "// 3. Atomically subtract a value.", distractors: [{ "text": "// Subtract", reason: "Misses atomicity." }], indent: 1, explanation: "Explain atomic subtraction." },
  { correct: "atomic_fetch_sub(&shared_counter, 3);", distractors: [{ "text": "shared_counter -= 3;", reason: "Not atomic." }], indent: 1, explanation: "Atomically subtract 3 from the counter." },
  { correct: "printf(\"Called atomic_fetch_sub(3). Current value is: %d\\n\", atomic_load(&shared_counter));", distractors: [{ "text": "printf(\"Value: %d\\n\", shared_counter);", reason: "Non-atomic read." }], indent: 1, explanation: "Load and print the final value." },
  { correct: "// Other atomic operations include exchange, compare-and-swap, and bitwise ops.", distractors: [{ "text": "// More atomics", reason: "Doesn’t list examples." }], indent: 1, explanation: "Mention other available atomic functions." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 is error." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main function." }
]
  },
  // Level 49: Non-Local Jumps with setjmp/longjmp
  {
    goal: "Implement an exception-like error recovery mechanism using `setjmp` to save an execution context and `longjmp` to return to it from a nested function.",
    concepts: "`setjmp`, `longjmp`, `<setjmp.h>`, non-local gotos, stack unwinding",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is sufficient." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <setjmp.h>", distractors: [{ "text": "#include <jmp.h>", reason: "Wrong header; `<setjmp.h>` is correct." }], indent: 0, explanation: "Include the header for non-local jump functionality." },
  { correct: "// `jmp_buf` is a type that holds the information needed to restore a calling environment.", distractors: [{ "text": "// jmp_buf", reason: "Doesn’t explain its purpose." }], indent: 0, explanation: "Explain the jmp_buf type." },
  { correct: "jmp_buf error_handler_buffer;", distractors: [{ "text": "jmp_buf *error_handler_buffer;", reason: "`jmp_buf` is an array type, not a pointer." }], indent: 0, explanation: "Declare a global jump buffer to store the program's state." },
  { correct: "void function_c(int should_error) {", distractors: [{ "text": "int function_c(int should_error) {", reason: "No return value needed." }], indent: 0, explanation: "Define a deeply nested function that might 'throw' an error." },
  { correct: "printf(\"  -> Entered function_c.\\n\");", distractors: [{ "text": "printf(\"Entered\\n\");", reason: "Less specific." }], indent: 1, explanation: "Trace message." },
  { correct: "if (should_error) {", distractors: [{ "text": "if (should_error == 1) {", reason: "Redundant; any non-zero value is true." }], indent: 2, explanation: "Check if we need to trigger the error." },
  { correct: "printf(\"  !! Error in function_c! Jumping back to main...\\n\");", distractors: [{ "text": "printf(\"Error\\n\");", reason: "Doesn’t indicate action." }], indent: 3, explanation: "Error message." },
  { correct: "longjmp(error_handler_buffer, 404);", distractors: [{ "text": "setjmp(error_handler_buffer);", reason: "`setjmp` saves; `longjmp` jumps." }], indent: 3, explanation: "Jump back to where `setjmp` was called, making it return the value 404." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 2, explanation: "Close the error check." },
  { correct: "printf(\"  -> Exited function_c normally.\\n\");", distractors: [{ "text": "printf(\"Exited\\n\");", reason: "Less clear." }], indent: 1, explanation: "Trace message for the non-error path." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close function_c." },
  { correct: "void function_b() { printf(\" -> Entered function_b.\\n\"); function_c(1); printf(\" -> Exited function_b normally.\\n\"); }", distractors: [{ "text": "void function_b() { function_c(1); }", reason: "Misses tracing for clarity." }], indent: 0, explanation: "An intermediate function in the call stack." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start the main function." },
  { correct: "// `setjmp` returns 0 on its initial call.", distractors: [{ "text": "// setjmp", reason: "Doesn’t explain behavior." }], indent: 1, explanation: "Explain `setjmp`'s return value." },
  { correct: "// If `longjmp` is called, `setjmp` returns the value passed to `longjmp`.", distractors: [{ "text": "// longjmp changes setjmp", reason: "Vague; misses return value detail." }], indent: 1, explanation: "Explain how `longjmp` affects `setjmp`." },
  { correct: "int return_code = setjmp(error_handler_buffer);", distractors: [{ "text": "int return_code = longjmp(error_handler_buffer, 0);", reason: "`longjmp` jumps, doesn’t set." }], indent: 1, explanation: "Set the recovery point. On the first run, it returns 0." },
  { correct: "if (return_code == 0) {", distractors: [{ "text": "if (!return_code) {", reason: "Same but less explicit." }], indent: 1, explanation: "This block acts as the 'try' block, executing on the initial run." },
  { correct: "printf(\"Initial call to setjmp returned 0. Running main logic...\\n\");", distractors: [{ "text": "printf(\"Starting...\\n\");", reason: "Misses `setjmp` context." }], indent: 2, explanation: "Trace message." },
  { correct: "function_b();", distractors: [{ "text": "function_c(1);", reason: "Bypasses call stack demo." }], indent: 2, explanation: "Call the function that will eventually trigger the error." },
  { correct: "printf(\"Main logic finished without errors.\\n\");", distractors: [{ "text": "printf(\"Done\\n\");", reason: "Less informative." }], indent: 2, explanation: "This line will be skipped due to the `longjmp`." },
  { correct: "} else {", distractors: [{ "text": "} if (return_code) {", reason: "Incorrect structure; `else` is needed." }], indent: 1, explanation: "This block acts as the 'catch' block. It runs when `longjmp` is called." },
  { correct: "printf(\"longjmp was called! setjmp returned %d.\\n\", return_code);", distractors: [{ "text": "printf(\"Error: %d\\n\", return_code);", reason: "Less specific about `longjmp`." }], indent: 2, explanation: "Handle the 'error' and print the code passed by `longjmp`." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the if/else block." },
  { correct: "printf(\"Program finished.\\n\");", distractors: [{ "text": "printf(\"End\\n\");", reason: "Less clear." }], indent: 1, explanation: "This line runs regardless of the path taken." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 is error." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 50: The `restrict` Keyword
  {
    goal: "Understand how the `restrict` keyword informs the compiler that pointers do not alias, allowing for better optimization.",
    concepts: "`restrict` keyword, pointer aliasing, compiler optimization",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is sufficient." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <setjmp.h>", distractors: [{ "text": "#include <jmp.h>", reason: "Wrong header; `<setjmp.h>` is correct." }], indent: 0, explanation: "Include the header for non-local jump functionality." },
  { correct: "// `jmp_buf` is a type that holds the information needed to restore a calling environment.", distractors: [{ "text": "// jmp_buf", reason: "Doesn’t explain its purpose." }], indent: 0, explanation: "Explain the jmp_buf type." },
  { correct: "jmp_buf error_handler_buffer;", distractors: [{ "text": "jmp_buf *error_handler_buffer;", reason: "`jmp_buf` is an array type, not a pointer." }], indent: 0, explanation: "Declare a global jump buffer to store the program's state." },
  { correct: "void function_c(int should_error) {", distractors: [{ "text": "int function_c(int should_error) {", reason: "No return value needed." }], indent: 0, explanation: "Define a deeply nested function that might 'throw' an error." },
  { correct: "printf(\"  -> Entered function_c.\\n\");", distractors: [{ "text": "printf(\"Entered\\n\");", reason: "Less specific." }], indent: 1, explanation: "Trace message." },
  { correct: "if (should_error) {", distractors: [{ "text": "if (should_error == 1) {", reason: "Redundant; any non-zero value is true." }], indent: 2, explanation: "Check if we need to trigger the error." },
  { correct: "printf(\"  !! Error in function_c! Jumping back to main...\\n\");", distractors: [{ "text": "printf(\"Error\\n\");", reason: "Doesn’t indicate action." }], indent: 3, explanation: "Error message." },
  { correct: "longjmp(error_handler_buffer, 404);", distractors: [{ "text": "setjmp(error_handler_buffer);", reason: "`setjmp` saves; `longjmp` jumps." }], indent: 3, explanation: "Jump back to where `setjmp` was called, making it return the value 404." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 2, explanation: "Close the error check." },
  { correct: "printf(\"  -> Exited function_c normally.\\n\");", distractors: [{ "text": "printf(\"Exited\\n\");", reason: "Less clear." }], indent: 1, explanation: "Trace message for the non-error path." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close function_c." },
  { correct: "void function_b() { printf(\" -> Entered function_b.\\n\"); function_c(1); printf(\" -> Exited function_b normally.\\n\"); }", distractors: [{ "text": "void function_b() { function_c(1); }", reason: "Misses tracing for clarity." }], indent: 0, explanation: "An intermediate function in the call stack." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start the main function." },
  { correct: "// `setjmp` returns 0 on its initial call.", distractors: [{ "text": "// setjmp", reason: "Doesn’t explain behavior." }], indent: 1, explanation: "Explain `setjmp`'s return value." },
  { correct: "// If `longjmp` is called, `setjmp` returns the value passed to `longjmp`.", distractors: [{ "text": "// longjmp changes setjmp", reason: "Vague; misses return value detail." }], indent: 1, explanation: "Explain how `longjmp` affects `setjmp`." },
  { correct: "int return_code = setjmp(error_handler_buffer);", distractors: [{ "text": "int return_code = longjmp(error_handler_buffer, 0);", reason: "`longjmp` jumps, doesn’t set." }], indent: 1, explanation: "Set the recovery point. On the first run, it returns 0." },
  { correct: "if (return_code == 0) {", distractors: [{ "text": "if (!return_code) {", reason: "Same but less explicit." }], indent: 1, explanation: "This block acts as the 'try' block, executing on the initial run." },
  { correct: "printf(\"Initial call to setjmp returned 0. Running main logic...\\n\");", distractors: [{ "text": "printf(\"Starting...\\n\");", reason: "Misses `setjmp` context." }], indent: 2, explanation: "Trace message." },
  { correct: "function_b();", distractors: [{ "text": "function_c(1);", reason: "Bypasses call stack demo." }], indent: 2, explanation: "Call the function that will eventually trigger the error." },
  { correct: "printf(\"Main logic finished without errors.\\n\");", distractors: [{ "text": "printf(\"Done\\n\");", reason: "Less informative." }], indent: 2, explanation: "This line will be skipped due to the `longjmp`." },
  { correct: "} else {", distractors: [{ "text": "} if (return_code) {", reason: "Incorrect structure; `else` is needed." }], indent: 1, explanation: "This block acts as the 'catch' block. It runs when `longjmp` is called." },
  { correct: "printf(\"longjmp was called! setjmp returned %d.\\n\", return_code);", distractors: [{ "text": "printf(\"Error: %d\\n\", return_code);", reason: "Less specific about `longjmp`." }], indent: 2, explanation: "Handle the 'error' and print the code passed by `longjmp`." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the if/else block." },
  { correct: "printf(\"Program finished.\\n\");", distractors: [{ "text": "printf(\"End\\n\");", reason: "Less clear." }], indent: 1, explanation: "This line runs regardless of the path taken." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 is error." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 51: Generic Selection with _Generic
  {
    goal: "Use C11's `_Generic` keyword to create a macro that calls a different function based on the type of its argument.",
    concepts: "`_Generic` keyword, type-based selection, macros, C11 standard",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is enough." }], indent: 0, explanation: "Include for I/O functions." },
  { correct: "// Define functions for handling specific types", distractors: [{ "text": "// Functions", reason: "Doesn’t specify purpose." }], indent: 0, explanation: "Comment on helper functions." },
  { correct: "void print_int(int i) { printf(\"INT: %d\\n\", i); }", distractors: [{ "text": "int print_int(int i) { printf(\"INT: %d\\n\", i); }", reason: "No return value needed." }], indent: 0, explanation: "A function that handles integers." },
  { correct: "void print_double(double d) { printf(\"DOUBLE: %f\\n\", d); }", distractors: [{ "text": "void print_double(float d) { printf(\"FLOAT: %f\\n\", d); }", reason: "Float promotes to double in `_Generic`." }], indent: 0, explanation: "A function that handles doubles." },
  { correct: "void print_string(char* s) { printf(\"STRING: \\\"%s\\\"\\n\", s); }", distractors: [{ "text": "void print_string(char s) { printf(\"CHAR: %c\\n\", s); }", reason: "Handles char, not string." }], indent: 0, explanation: "A function that handles character strings." },
  { correct: "// `_Generic` is a compile-time construct that selects an expression", distractors: [{ "text": "// _Generic", reason: "No explanation." }], indent: 0, explanation: "Explain `_Generic`." },
  { correct: "// based on the type of its controlling expression.", distractors: [{ "text": "// Type selection", reason: "Misses compile-time detail." }], indent: 0, explanation: "Continue explanation." },
  { correct: "#define print(X) _Generic((X), \\", distractors: [{ "text": "#define print(X) _Generic(X, \\", reason: "Missing parentheses; type evaluation needs them." }], indent: 0, explanation: "Start defining the macro. The `\\` allows continuing on the next line." },
  { correct: "    int: print_int, \\", distractors: [{ "text": "\"int\": print_int, \\", reason: "Types aren’t strings in `_Generic`." }], indent: 1, explanation: "If `X` is `int`, select `print_int`." },
  { correct: "    double: print_double, \\", distractors: [{ "text": "float: print_double, \\", reason: "Float promotes to double; use `double`." }], indent: 1, explanation: "If `X` is `double`, select `print_double`." },
  { correct: "    char*: print_string, \\", distractors: [{ "text": "char[]: print_string, \\", reason: "Arrays decay to pointers; `char*` is correct." }], indent: 1, explanation: "If `X` is `char*`, select `print_string`." },
  { correct: "    default: print_int \\", distractors: [{ "text": "default: printf, \\", reason: "`printf` isn’t type-specific like the others." }], indent: 1, explanation: "A default case is required if the type might not match any other case." },
  { correct: ")(X)", distractors: [{ "text": "(X);", reason: "Semicolon inside macro is incorrect." }], indent: 0, explanation: "Call the selected function pointer with `(X)`." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "int my_int = 123;", distractors: [{ "text": "int my_int;", reason: "Uninitialized." }], indent: 1, explanation: "Declare an integer." },
  { correct: "double my_double = 3.14;", distractors: [{ "text": "float my_double = 3.14;", reason: "Promotes to double in `_Generic`." }], indent: 1, explanation: "Declare a double." },
  { correct: "char* my_string = \"Hello C11!\";", distractors: [{ "text": "char my_string = 'H';", reason: "Single char, not string." }], indent: 1, explanation: "Declare a string." },
  { correct: "printf(\"Calling generic print() macro...\\n\");", distractors: [{ "text": "printf(\"Starting...\\n\");", reason: "Doesn’t mention macro." }], indent: 1, explanation: "Informational message." },
  { correct: "print(my_int);", distractors: [{ "text": "print_int(my_int);", reason: "Bypasses `_Generic` demo." }], indent: 1, explanation: "`_Generic` selects `print_int`." },
  { correct: "print(my_double);", distractors: [{ "text": "print_double(my_double);", reason: "Misses macro usage." }], indent: 1, explanation: "`_Generic` selects `print_double`." },
  { correct: "print(my_string);", distractors: [{ "text": "print_string(my_string);", reason: "Direct call defeats purpose." }], indent: 1, explanation: "`_Generic` selects `print_string`." },
  { correct: "print(5.5f); // A float is promoted to double and matches", distractors: [{ "text": "print(5);", reason: "Less illustrative; uses int." }], indent: 1, explanation: "Show type promotion with generic selection." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 is error." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 52: Signal Handling
  {
    goal: "Catch the `SIGINT` signal (generated by Ctrl+C) and execute a custom handler function instead of terminating immediately.",
    concepts: "Signal handling, `<signal.h>`, `signal()`, `SIGINT`, signal handlers",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "`<stdlib.h>` is included later for `exit`; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <signal.h>", distractors: [{ "text": "#include <sig.h>", reason: "Incorrect header; the standard header is `<signal.h>`." }], indent: 0, explanation: "Include the header for signal handling functions." },
  { correct: "#include <stdlib.h>", distractors: [{ "text": "#include <stdio.h>", reason: "Already included; `<stdlib.h>` is for `exit()`." }], indent: 0, explanation: "Include for `exit()`." },
  { correct: "// A signal handler is a function that is called when a signal is received.", distractors: [{ "text": "// Signal handler", reason: "Lacks explanation of its purpose." }], indent: 0, explanation: "Explain what a signal handler is." },
  { correct: "// It must take an integer (the signal number) as an argument.", distractors: [{ "text": "// Takes an integer", reason: "Does not specify that the integer is the signal number." }], indent: 0, explanation: "Explain the required function signature." },
  { correct: "void handle_sigint(int sig_num) {", distractors: [{ "text": "void handle_sigint() {", reason: "Signal handlers must take an integer parameter for the signal number." }], indent: 0, explanation: "Define our custom signal handler." },
  { correct: "// Note: Only async-safe functions are strictly allowed in a handler.", distractors: [{ "text": "// Any function can be used in a handler.", reason: "Incorrect; only async-safe functions are safe to use in signal handlers." }], indent: 1, explanation: "Important note on signal safety." },
  { correct: "// `printf` is used here for demonstration but isn’t officially safe.", distractors: [{ "text": "// `printf` is safe to use in signal handlers.", reason: "Incorrect; `printf` is not async-safe and should be avoided in signal handlers." }], indent: 1, explanation: "Clarify `printf` usage." },
  { correct: "printf(\"\\nCaught signal %d (SIGINT). Exiting gracefully.\\n\", sig_num);", distractors: [{ "text": "printf(\"Caught signal\\n\");", reason: "Does not provide the signal number or specify the signal type." }], indent: 1, explanation: "Print a message inside the handler." },
  { correct: "exit(0);", distractors: [{ "text": "return;", reason: "Signal handlers should not return; use `exit` to terminate the program." }], indent: 1, explanation: "Perform a graceful exit." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax; function blocks use `}` not `};`." }], indent: 0, explanation: "Close the handler function." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "C standard requires `int main()` for proper return type." }], indent: 0, explanation: "Start main function." },
  { correct: "// The `signal()` function registers a handler for a specific signal.", distractors: [{ "text": "// `signal()` is used to handle signals.", reason: "Too vague; does not explain that it registers a handler." }], indent: 1, explanation: "Explain `signal`." },
  { correct: "signal(SIGINT, handle_sigint);", distractors: [{ "text": "signal(SIGINT, handle_sigint());", reason: "Calls the function immediately instead of registering it." }, { "text": "handle_sigint(SIGINT);", reason: "Directly calls the handler instead of registering it with `signal()`." }], indent: 1, explanation: "Register `handle_sigint` for `SIGINT`." },
  { correct: "printf(\"Signal handler registered for SIGINT (Ctrl+C).\\n\");", distractors: [{ "text": "printf(\"Handler set\\n\");", reason: "Less informative; does not specify the signal or key combination." }], indent: 1, explanation: "Confirmation message." },
  { correct: "printf(\"Program is now in an infinite loop. Press Ctrl+C to exit.\\n\");", distractors: [{ "text": "printf(\"Running...\\n\");", reason: "Does not instruct the user on how to exit the program." }], indent: 1, explanation: "Instruct the user how to trigger the signal." },
  { correct: "int counter = 0;", distractors: [{ "text": "volatile int counter = 0;", reason: "Not necessary here; the loop is for demonstration, not for signal handling." }], indent: 1, explanation: "A counter for the loop." },
  { correct: "while (1) {", distractors: [{ "text": "while (counter < 100) {", reason: "Finite loop; the point is to have an infinite loop interrupted by the signal." }], indent: 1, explanation: "Start an infinite loop." },
  { correct: "printf(\"...running loop, iteration %d\\r\", counter++);", distractors: [{ "text": "printf(\"Running...\\n\");", reason: "Does not show progress or use carriage return for overwriting." }], indent: 2, explanation: "Show progress; `\\r` returns cursor to start." },
  { correct: "fflush(stdout);", distractors: [{ "text": "fflush(stdin);", reason: "Flushes input buffer, which is not needed here." }], indent: 2, explanation: "Flush output so it appears immediately." },
  { correct: "for (long i = 0; i < 50000000; i++); // Artificial delay", distractors: [{ "text": "sleep(1);", reason: "Requires `<unistd.h>`, which is not included, and is less portable." }], indent: 2, explanation: "A simple busy-wait delay." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a loop." }], indent: 1, explanation: "Close the loop." },
  { correct: "// Code beyond this point is unreachable because the handler exits.", distractors: [{ "text": "// Handler might return.", reason: "Incorrect; the handler uses `exit` and does not return." }], indent: 1, explanation: "Comment on flow." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success, but this line is unreachable." }], indent: 1, explanation: "Will never be executed." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a function." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 53: Opaque Pointers for Encapsulation
  {
    goal: "Create an abstract data type with a hidden implementation using an opaque pointer (incomplete type).",
    concepts: "Opaque pointers, incomplete types, encapsulation, information hiding, API design",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "`<stdlib.h>` is included later for `exit`; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <signal.h>", distractors: [{ "text": "#include <sig.h>", reason: "Incorrect header; the standard header is `<signal.h>`." }], indent: 0, explanation: "Include the header for signal handling functions." },
  { correct: "#include <stdlib.h>", distractors: [{ "text": "#include <stdio.h>", reason: "Already included; `<stdlib.h>` is for `exit()`." }], indent: 0, explanation: "Include for `exit()`." },
  { correct: "// A signal handler is a function that is called when a signal is received.", distractors: [{ "text": "// Signal handler", reason: "Lacks explanation of its purpose." }], indent: 0, explanation: "Explain what a signal handler is." },
  { correct: "// It must take an integer (the signal number) as an argument.", distractors: [{ "text": "// Takes an integer", reason: "Does not specify that the integer is the signal number." }], indent: 0, explanation: "Explain the required function signature." },
  { correct: "void handle_sigint(int sig_num) {", distractors: [{ "text": "void handle_sigint() {", reason: "Signal handlers must take an integer parameter for the signal number." }], indent: 0, explanation: "Define our custom signal handler." },
  { correct: "// Note: Only async-safe functions are strictly allowed in a handler.", distractors: [{ "text": "// Any function can be used in a handler.", reason: "Incorrect; only async-safe functions are safe to use in signal handlers." }], indent: 1, explanation: "Important note on signal safety." },
  { correct: "// `printf` is used here for demonstration but isn’t officially safe.", distractors: [{ "text": "// `printf` is safe to use in signal handlers.", reason: "Incorrect; `printf` is not async-safe and should be avoided in signal handlers." }], indent: 1, explanation: "Clarify `printf` usage." },
  { correct: "printf(\"\\nCaught signal %d (SIGINT). Exiting gracefully.\\n\", sig_num);", distractors: [{ "text": "printf(\"Caught signal\\n\");", reason: "Does not provide the signal number or specify the signal type." }], indent: 1, explanation: "Print a message inside the handler." },
  { correct: "exit(0);", distractors: [{ "text": "return;", reason: "Signal handlers should not return; use `exit` to terminate the program." }], indent: 1, explanation: "Perform a graceful exit." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax; function blocks use `}` not `};`." }], indent: 0, explanation: "Close the handler function." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "C standard requires `int main()` for proper return type." }], indent: 0, explanation: "Start main function." },
  { correct: "// The `signal()` function registers a handler for a specific signal.", distractors: [{ "text": "// `signal()` is used to handle signals.", reason: "Too vague; does not explain that it registers a handler." }], indent: 1, explanation: "Explain `signal`." },
  { correct: "signal(SIGINT, handle_sigint);", distractors: [{ "text": "signal(SIGINT, handle_sigint());", reason: "Calls the function immediately instead of registering it." }, { "text": "handle_sigint(SIGINT);", reason: "Directly calls the handler instead of registering it with `signal()`." }], indent: 1, explanation: "Register `handle_sigint` for `SIGINT`." },
  { correct: "printf(\"Signal handler registered for SIGINT (Ctrl+C).\\n\");", distractors: [{ "text": "printf(\"Handler set\\n\");", reason: "Less informative; does not specify the signal or key combination." }], indent: 1, explanation: "Confirmation message." },
  { correct: "printf(\"Program is now in an infinite loop. Press Ctrl+C to exit.\\n\");", distractors: [{ "text": "printf(\"Running...\\n\");", reason: "Does not instruct the user on how to exit the program." }], indent: 1, explanation: "Instruct the user how to trigger the signal." },
  { correct: "int counter = 0;", distractors: [{ "text": "volatile int counter = 0;", reason: "Not necessary here; the loop is for demonstration, not for signal handling." }], indent: 1, explanation: "A counter for the loop." },
  { correct: "while (1) {", distractors: [{ "text": "while (counter < 100) {", reason: "Finite loop; the point is to have an infinite loop interrupted by the signal." }], indent: 1, explanation: "Start an infinite loop." },
  { correct: "printf(\"...running loop, iteration %d\\r\", counter++);", distractors: [{ "text": "printf(\"Running...\\n\");", reason: "Does not show progress or use carriage return for overwriting." }], indent: 2, explanation: "Show progress; `\\r` returns cursor to start." },
  { correct: "fflush(stdout);", distractors: [{ "text": "fflush(stdin);", reason: "Flushes input buffer, which is not needed here." }], indent: 2, explanation: "Flush output so it appears immediately." },
  { correct: "for (long i = 0; i < 50000000; i++); // Artificial delay", distractors: [{ "text": "sleep(1);", reason: "Requires `<unistd.h>`, which is not included, and is less portable." }], indent: 2, explanation: "A simple busy-wait delay." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a loop." }], indent: 1, explanation: "Close the loop." },
  { correct: "// Code beyond this point is unreachable because the handler exits.", distractors: [{ "text": "// Handler might return.", reason: "Incorrect; the handler uses `exit` and does not return." }], indent: 1, explanation: "Comment on flow." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success, but this line is unreachable." }], indent: 1, explanation: "Will never be executed." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a function." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 54: Standard Library `qsort`
  {
    goal: "Sort an array of structs using the standard library's generic `qsort` function by providing a custom comparison function.",
    concepts: "`qsort`, `<stdlib.h>`, function pointers, comparison functions, generic programming",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <string.h>", reason: "Included later for `strcmp`; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <stdlib.h>", distractors: [{ "text": "#include <math.h>", reason: "Not needed; `<stdlib.h>` is for `qsort`." }], indent: 0, explanation: "Include for `qsort`." },
  { correct: "#include <string.h>", distractors: [{ "text": "#include <strings.h>", reason: "Non-standard header; use `<string.h>` for `strcmp`." }], indent: 0, explanation: "Include for `strcmp`." },
  { correct: "typedef struct { int id; char name[20]; } User;", distractors: [{ "text": "struct User { int id; char name[20]; };", reason: "Missing `typedef`; would require `struct User` each time." }], indent: 0, explanation: "Define a User struct we want to sort." },
  { correct: "// `qsort` needs a comparison function with a specific signature:", distractors: [{ "text": "// Comparison function", reason: "Does not specify the required signature." }], indent: 0, explanation: "Explain requirement." },
  { correct: "// `int func(const void* a, const void* b)`", distractors: [{ "text": "// `int func(void* a, void* b)`", reason: "Parameters should be `const void*` to indicate they are not modified." }], indent: 0, explanation: "Show required signature." },
  { correct: "// It returns < 0 if a < b, 0 if a == b, > 0 if a > b.", distractors: [{ "text": "// Returns a boolean value.", reason: "Incorrect; it must return an integer indicating order." }], indent: 0, explanation: "Explain return values." },
  { correct: "int compareUsersByID(const void* a, const void* b) {", distractors: [{ "text": "int compareUsersByID(void* a, void* b) {", reason: "Should use `const void*` for clarity and safety." }], indent: 0, explanation: "Define comparison by ID." },
  { correct: "// Cast the void pointers back to the correct struct pointer type.", distractors: [{ "text": "// No casting needed.", reason: "Incorrect; `void*` must be cast to access members." }], indent: 1, explanation: "Explain casting." },
  { correct: "const User* userA = (const User*)a;", distractors: [{ "text": "User* userA = a;", reason: "Missing cast; `a` is `void*`, not `User*`." }], indent: 1, explanation: "Cast the first argument." },
  { correct: "const User* userB = (const User*)b;", distractors: [{ "text": "User* userB = b;", reason: "Again, missing cast." }], indent: 1, explanation: "Cast the second argument." },
  { correct: "if (userA->id < userB->id) return -1;", distractors: [{ "text": "return userA->id - userB->id;", reason: "Can cause integer overflow; better to use explicit comparisons." }], indent: 1, explanation: "Return -1 if A's ID is smaller." },
  { correct: "if (userA->id > userB->id) return 1;", distractors: [{ "text": "return 1;", reason: "Always returns 1, ignoring the condition." }], indent: 1, explanation: "Return 1 if A's ID is larger." },
  { correct: "return 0;", distractors: [{ "text": "return userA->id == userB->id;", reason: "Returns a boolean, not an integer as required." }], indent: 1, explanation: "Return 0 if equal." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close comparison function." },
  { correct: "int compareUsersByName(const void* a, const void* b) {", distractors: [{ "text": "int compareUsersByName(const char* a, const char* b) {", reason: "Parameters should be `const void*`, not `const char*`." }], indent: 0, explanation: "Define comparison by name." },
  { correct: "const User* userA = (const User*)a;", distractors: [{ "text": "const char* userA = (const char*)a;", reason: "Incorrect type; should be `User*`." }], indent: 1, explanation: "Cast arguments." },
  { correct: "const User* userB = (const User*)b;", distractors: [{ "text": "const char* userB = (const char*)b;", reason: "Incorrect type." }], indent: 1, explanation: "Cast arguments." },
  { correct: "return strcmp(userA->name, userB->name);", distractors: [{ "text": "return userA->name - userB->name;", reason: "Subtracting pointers is meaningless for comparison." }], indent: 1, explanation: "`strcmp` returns the correct ordering." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close name comparison." },
  { correct: "void printUsers(User arr[], int size) {", distractors: [{ "text": "void printUsers(User* arr, int size) {", reason: "Same as correct; arrays decay to pointers." }], indent: 0, explanation: "Helper to print the array." },
  { correct: "for (int i = 0; i < size; i++) { printf(\"ID: %d, Name: %s\\n\", arr[i].id, arr[i].name); }", distractors: [{ "text": "for (int i = 0; i < size; i++) { printf(\"%d %s\\n\", arr[i].id, arr[i].name); }", reason: "Lacks labels, making output less clear." }], indent: 1, explanation: "Loop and print each user." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close print helper." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main." },
  { correct: "User users[] = { {3, \"Charlie\"}, {1, \"Alice\"}, {4, \"David\"}, {2, \"Bob\"} };", distractors: [{ "text": "User users[4];", reason: "Uninitialized; would have garbage values." }], indent: 1, explanation: "Declare unsorted array." },
  { correct: "int n = sizeof(users) / sizeof(users[0]);", distractors: [{ "text": "int n = 4;", reason: "Hardcoded size; less flexible if array changes." }], indent: 1, explanation: "Calculate element count." },
  { correct: "printf(\"--- Original Array ---\\n\"); printUsers(users, n);", distractors: [{ "text": "printUsers(users, 4);", reason: "Hardcoded size; better to use calculated `n`." }], indent: 1, explanation: "Print original state." },
  { correct: "// Sort by ID", distractors: [{ "text": "// Sort", reason: "Does not specify sorting criterion." }], indent: 1, explanation: "Comment on ID sort." },
  { correct: "qsort(users, n, sizeof(User), compareUsersByID);", distractors: [{ "text": "qsort(users, n, sizeof(User*), compareUsersByID);", reason: "Uses pointer size instead of element size, leading to incorrect sorting." }, { "text": "qsort(users, sizeof(users), sizeof(User), compareUsersByID);", reason: "Second argument should be number of elements, not total size." }], indent: 1, explanation: "Call `qsort` by ID." },
  { correct: "printf(\"\\n--- Sorted by ID ---\\n\"); printUsers(users, n);", distractors: [{ "text": "printf(\"Sorted:\\n\"); printUsers(users, n);", reason: "Does not specify sorting criterion." }], indent: 1, explanation: "Print sorted by ID." },
  { correct: "// Sort by Name", distractors: [{ "text": "// Sort again", reason: "Does not specify new criterion." }], indent: 1, explanation: "Comment on name sort." },
  { correct: "qsort(users, n, sizeof(User), compareUsersByName);", distractors: [{ "text": "qsort(users, n, sizeof(User), compareUsersByID);", reason: "Uses wrong comparison function." }], indent: 1, explanation: "Call `qsort` by name." },
  { correct: "printf(\"\\n--- Sorted by Name ---\\n\"); printUsers(users, n);", distractors: [{ "text": "printf(\"Sorted:\\n\"); printUsers(users, n);", reason: "Does not specify sorting criterion." }], indent: 1, explanation: "Print sorted by name." },
  { correct: "return 0; }", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 55: Variadic Functions
  {
    goal: "Create and use a variadic function that can accept a variable number of arguments, similar to `printf`.",
    concepts: "Variadic functions, `<stdarg.h>`, `va_list`, `va_start`, `va_arg`, `va_end`",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <stdarg.h>", distractors: [{ "text": "#include <varargs.h>", reason: "Obsolete header; use `<stdarg.h>` for variadic functions." }], indent: 0, explanation: "Include for variable argument macros." },
  { correct: "// A variadic function must have at least one named parameter.", distractors: [{ "text": "// Variadic function", reason: "Does not mention the requirement for a named parameter." }], indent: 0, explanation: "Rule for variadic functions." },
  { correct: "// The ellipsis `...` indicates that more arguments may follow.", distractors: [{ "text": "// `...` for extra args", reason: "Less precise; does not explain the syntax." }], indent: 0, explanation: "Explain the `...` syntax." },
  { correct: "int sum_integers(int num_args, ...) {", distractors: [{ "text": "int sum_integers(...) {", reason: "Variadic functions must have at least one named parameter before the ellipsis." }], indent: 0, explanation: "Define a function with a count and variable args." },
  { correct: "int sum = 0;", distractors: [{ "text": "int sum;", reason: "Uninitialized variable; could lead to undefined behavior." }], indent: 1, explanation: "Initialize sum." },
  { correct: "// 1. Declare a `va_list` variable to hold the arguments.", distractors: [{ "text": "// Use va_list", reason: "Does not explain its purpose." }], indent: 1, explanation: "Explain `va_list`." },
  { correct: "va_list arg_pointer;", distractors: [{ "text": "va_list *arg_pointer;", reason: "`va_list` is typically an array type, not a pointer." }], indent: 1, explanation: "Declare the argument list." },
  { correct: "// 2. Initialize the `va_list` with `va_start`.", distractors: [{ "text": "// Start va_list", reason: "Less informative." }], indent: 1, explanation: "Explain `va_start`." },
  { correct: "// It needs the `va_list` and the last named parameter.", distractors: [{ "text": "// Needs va_list", reason: "Omits the last named parameter requirement." }], indent: 1, explanation: "Explain arguments to `va_start`." },
  { correct: "va_start(arg_pointer, num_args);", distractors: [{ "text": "va_start(arg_pointer);", reason: "Missing the last named parameter, which is required." }, { "text": "va_start(arg_pointer, sum);", reason: "Incorrect; `sum` is not the last named parameter." }], indent: 1, explanation: "Initialize for retrieval." },
  { correct: "// 3. Access the arguments with `va_arg`.", distractors: [{ "text": "// Get arguments", reason: "Does not specify the macro used." }], indent: 1, explanation: "Explain `va_arg`." },
  { correct: "for (int i = 0; i < num_args; i++) {", distractors: [{ "text": "while (1) {", reason: "Infinite loop; needs a condition to stop." }], indent: 1, explanation: "Loop for each argument." },
  { correct: "sum += va_arg(arg_pointer, int);", distractors: [{ "text": "sum += va_arg(arg_pointer, double);", reason: "Incorrect type; expects `int`, not `double`." }, { "text": "sum += *va_arg(arg_pointer, int);", reason: "Unnecessary dereference; `va_arg` returns the value." }], indent: 2, explanation: "Retrieve and add an `int`." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close loop." },
  { correct: "// 4. Clean up the `va_list` with `va_end`.", distractors: [{ "text": "// End va_list", reason: "Does not emphasize cleanup." }], indent: 1, explanation: "Explain `va_end`." },
  { correct: "va_end(arg_pointer);", distractors: [{ "text": "va_end();", reason: "Must pass the `va_list` variable." }], indent: 1, explanation: "Cleanup." },
  { correct: "return sum;", distractors: [{ "text": "return 0;", reason: "Always returns 0, ignoring the sum." }], indent: 1, explanation: "Return the sum." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close variadic function." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main." },
  { correct: "printf(\"Calling sum_integers(3, 10, 20, 30)...\\n\");", distractors: [{ "text": "printf(\"Calling sum_integers\\n\");", reason: "Does not show arguments." }], indent: 1, explanation: "Informational." },
  { correct: "int result1 = sum_integers(3, 10, 20, 30);", distractors: [{ "text": "int result1 = sum_integers(2, 10, 20, 30);", reason: "Mismatches `num_args` with actual arguments, leading to undefined behavior." }], indent: 1, explanation: "Call with three args." },
  { correct: "printf(\"Result 1: %d\\n\", result1);", distractors: [{ "text": "printf(\"Result: %d\\n\", sum_integers(3, 10, 20, 30));", reason: "Redundant call; `result1` is already computed." }], indent: 1, explanation: "Print result." },
  { correct: "printf(\"\\nCalling sum_integers(5, 1, 2, 3, 4, 5)...\\n\");", distractors: [{ "text": "printf(\"Calling again\\n\");", reason: "Does not specify arguments." }], indent: 1, explanation: "Informational." },
  { correct: "int result2 = sum_integers(5, 1, 2, 3, 4, 5);", distractors: [{ "text": "int result2 = sum_integers(5, 1, 2, 3);", reason: "Provides fewer arguments than specified, causing undefined behavior." }], indent: 1, explanation: "Call with five args." },
  { correct: "printf(\"Result 2: %d\\n\", result2);", distractors: [{ "text": "printf(\"Result: %d\\n\", result2);", reason: "Minor difference; 'Result 2' is clearer." }], indent: 1, explanation: "Print result." },
  { correct: "return 0; }", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 56: Bit-fields in Structs
  {
    goal: "Use bit-fields within a struct to pack data tightly and reduce memory usage.",
    concepts: "struct, bit-fields, memory optimization, sizeof",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "// --- A standard struct for comparison ---", distractors: [{ "text": "// Normal struct", reason: "Less precise; does not indicate it's for comparison." }], indent: 0, explanation: "Comment for the non-bit-field struct." },
  { correct: "struct NormalFlags {", distractors: [{ "text": "typedef struct NormalFlags {", reason: "Unnecessary `typedef`; just defining a struct." }], indent: 0, explanation: "Define a regular struct." },
  { correct: "  unsigned int is_active;", distractors: [{ "text": "int is_active;", reason: "Signed int is unnecessary for flags; unsigned is clearer." }], indent: 1, explanation: "Each `unsigned int` likely takes 4 bytes." },
  { correct: "  unsigned int is_visible;", distractors: [{ "text": "unsigned char is_visible;", reason: "Changes size; we want to show waste in memory usage." }], indent: 1, explanation: "Another 4 bytes." },
  { correct: "  unsigned int access_level; // 0-7", distractors: [{ "text": "unsigned int access_level : 3;", reason: "Bit-field syntax in a non-bit-field struct." }], indent: 1, explanation: "Even though only a few bits needed, this takes 4 bytes." },
  { correct: "};", distractors: [{ "text": "}", reason: "Missing semicolon; struct definition requires it." }], indent: 0, explanation: "Close the regular struct." },
  { correct: "// --- A struct using bit-fields ---", distractors: [{ "text": "// Bit-field struct", reason: "Does not emphasize comparison." }], indent: 0, explanation: "Comment for the bit-field struct." },
  { correct: "struct BitFieldFlags {", distractors: [{ "text": "struct BitFieldFlags { int flags : 32; };", reason: "Uses bit-field but misses the point of packing multiple fields." }], indent: 0, explanation: "Define a struct using bit-fields." },
  { correct: "// The colon `:` followed by a number specifies the number of bits.", distractors: [{ "text": "// Bit-field syntax", reason: "Does not explain the syntax clearly." }], indent: 1, explanation: "Explain bit-field syntax." },
  { correct: "  unsigned int is_active    : 1;", distractors: [{ "text": "unsigned int is_active : 32;", reason: "Uses 32 bits, which is the same as a full `unsigned int`, defeating the purpose." }], indent: 1, explanation: "Allocate exactly 1 bit for this flag." },
  { correct: "  unsigned int is_visible   : 1;", distractors: [{ "text": "unsigned int is_visible : 2;", reason: "Only 1 bit is needed; 2 bits are unnecessary." }], indent: 1, explanation: "Allocate exactly 1 bit for this flag." },
  { correct: "  unsigned int access_level : 3;", distractors: [{ "text": "unsigned int access_level : 2;", reason: "2 bits can only store 0-3, but we need 0-7." }], indent: 1, explanation: "Allocate 3 bits (values 0-7)." },
  { correct: "  unsigned int            : 27;", distractors: [{ "text": "unsigned int padding : 27;", reason: "Named padding is unnecessary; unnamed is sufficient." }], indent: 1, explanation: "Unnamed bit-field to pad up to 32 bits." },
  { correct: "};", distractors: [{ "text": "}", reason: "Missing semicolon." }], indent: 0, explanation: "Close the bit-field struct." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main." },
  { correct: "printf(\"--- Memory Usage Comparison ---\\n\");", distractors: [{ "text": "printf(\"Memory usage:\\n\");", reason: "Less specific; does not indicate comparison." }], indent: 1, explanation: "Header." },
  { correct: "printf(\"sizeof(NormalFlags):   %zu bytes\\n\", sizeof(struct NormalFlags));", distractors: [{ "text": "printf(\"Size: %d\\n\", sizeof(struct NormalFlags));", reason: "Uses `%d` instead of `%zu` for `size_t`." }], indent: 1, explanation: "Print size of the normal struct." },
  { correct: "printf(\"sizeof(BitFieldFlags): %zu bytes\\n\", sizeof(struct BitFieldFlags));", distractors: [{ "text": "printf(\"Size: %zu\\n\", sizeof(struct BitFieldFlags) * 8);", reason: "Prints bits instead of bytes." }], indent: 1, explanation: "Print size of the bit-field struct." },
  { correct: "// Using the bit-field struct", distractors: [{ "text": "// Bit-fields", reason: "Does not specify usage." }], indent: 1, explanation: "Comment on usage." },
  { correct: "struct BitFieldFlags my_flags;", distractors: [{ "text": "struct NormalFlags my_flags;", reason: "Uses the wrong struct type." }], indent: 1, explanation: "Declare a bit-field struct variable." },
  { correct: "my_flags.is_active = 1;", distractors: [{ "text": "my_flags.is_active = 2;", reason: "A 1-bit field can only hold 0 or 1; 2 would be truncated to 0." }], indent: 1, explanation: "Assign a value to a bit-field." },
  { correct: "my_flags.is_visible = 0;", distractors: [{ "text": "my_flags.is_visible = -1;", reason: "Bit-fields are unsigned; -1 would be interpreted as a large positive number." }], indent: 1, explanation: "Set another bit-field member." },
  { correct: "my_flags.access_level = 5;", distractors: [{ "text": "my_flags.access_level = 8;", reason: "3 bits can only hold 0-7; 8 would wrap around to 0." }], indent: 1, explanation: "Set the 3-bit member." },
  { correct: "printf(\"\\n--- Accessing Bit-Fields ---\\n\");", distractors: [{ "text": "printf(\"Accessing:\\n\");", reason: "Less specific." }], indent: 1, explanation: "Header." },
  { correct: "if (my_flags.is_active) {", distractors: [{ "text": "if (my_flags.is_active == 1) {", reason: "Unnecessary; `if (my_flags.is_active)` is sufficient." }], indent: 1, explanation: "Check a bit-field." },
  { correct: "  printf(\"The system is active.\\n\");", distractors: [{ "text": "printf(\"Active\\n\");", reason: "Less descriptive." }], indent: 2, explanation: "Conditional message." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close if." },
  { correct: "printf(\"Access Level: %u\\n\", my_flags.access_level);", distractors: [{ "text": "printf(\"Access Level: %d\\n\", my_flags.access_level);", reason: "Uses `%d` for signed int; bit-fields are unsigned, so `%u` is better." }], indent: 1, explanation: "Print the 3-bit member." },
  { correct: "// Note: You cannot take the address (`&`) of a bit-field member.", distractors: [{ "text": "// Bit-fields have addresses.", reason: "Incorrect; bit-fields do not have addresses." }], indent: 1, explanation: "Important limitation." },
  { correct: "return 0; }", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 57: Formatted String I/O (`sscanf`, `sprintf`)
  {
    goal: "Use `sprintf` to format data into a string buffer and `sscanf` to parse data out of a string.",
    concepts: "`sprintf`, `sscanf`, string buffers, formatted I/O",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` includes `sprintf` and `sscanf`." }], indent: 0, explanation: "Include for `sprintf`, `sscanf`, and `printf`." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "// --- Using `sprintf` to write formatted data to a string ---", distractors: [{ "text": "// sprintf", reason: "Does not explain its purpose." }], indent: 1, explanation: "Header for `sprintf` section." },
  { correct: "char buffer[100];", distractors: [{ "text": "char *buffer;", reason: "Uninitialized pointer; must allocate space." }, { "text": "char buffer[10];", reason: "Buffer too small; risk of overflow." }], indent: 1, explanation: "Declare a buffer for the formatted string." },
  { correct: "char* name = \"Alex\";", distractors: [{ "text": "char name[] = \"Alex\";", reason: "Array instead of pointer; both work, but pointer is used here." }], indent: 1, explanation: "Data to be formatted." },
  { correct: "int score = 42;", distractors: [{ "text": "int score;", reason: "Uninitialized; would print garbage." }], indent: 1, explanation: "More data to be formatted." },
  { correct: "int chars_written = sprintf(buffer, \"Player: %s, Score: %d\", name, score);", distractors: [{ "text": "int chars_written = printf(\"Player: %s, Score: %d\", name, score);", reason: "`printf` writes to stdout, not to the buffer." }, { "text": "sprintf(buffer, \"Player: %s, Score: %d\", name, score);", reason: "Does not capture the number of characters written." }], indent: 1, explanation: "`sprintf` writes formatted data into `buffer` and returns the character count." },
  { correct: "printf(\"`sprintf` demo:\\n\");", distractors: [{ "text": "printf(\"Demo:\\n\");", reason: "Less specific." }], indent: 1, explanation: "Header." },
  { correct: "printf(\"  - Buffer content: \\\"%s\\\"\\n\", buffer);", distractors: [{ "text": "printf(\"Buffer: %s\\n\", buffer);", reason: "Does not escape the string for clarity." }], indent: 1, explanation: "Print buffer contents." },
  { correct: "printf(\"  - Characters written: %d\\n\", chars_written);", distractors: [{ "text": "printf(\"Chars: %d\\n\", chars_written);", reason: "Less descriptive." }], indent: 1, explanation: "Print return value of `sprintf`." },
  { correct: "// --- Using `sscanf` to parse formatted data from a string ---", distractors: [{ "text": "// sscanf", reason: "Does not explain its purpose." }], indent: 1, explanation: "Header for `sscanf` section." },
  { correct: "const char* data_string = \"Timestamp:2025-06-28,ID:12345\";", distractors: [{ "text": "char data_string[] = \"Timestamp:2025-06-28,ID:12345\";", reason: "Array instead of pointer; both work." }], indent: 1, explanation: "String containing structured data." },
  { correct: "// Declare variables to hold the parsed data.", distractors: [{ "text": "// Variables", reason: "Does not specify they are for parsed data." }], indent: 1, explanation: "Comment on destination variables." },
  { correct: "int year, month, day, id;", distractors: [{ "text": "int year, month, day; char id[10];", reason: "ID is an integer, not a string." }], indent: 1, explanation: "Declare integer variables." },
  { correct: "// The format string for `sscanf` can include literal text to match.", distractors: [{ "text": "// Format string", reason: "Does not mention literal text matching." }], indent: 1, explanation: "Explain `sscanf` format strings." },
  { correct: "int items_matched = sscanf(data_string, \"Timestamp:%d-%d-%d,ID:%d\", &year, &month, &day, &id);", distractors: [{ "text": "int items_matched = sscanf(data_string, \"%d-%d-%d,%d\", &year, &month, &day, &id);", reason: "Missing literal text; would not match the input string." }, { "text": "sscanf(data_string, \"Timestamp:%d-%d-%d,ID:%d\", year, month, day, id);", reason: "Forgot to pass addresses with `&`." }, { "text": "int items_matched = scanf(\"Timestamp:%d-%d-%d,ID:%d\", &year, &month, &day, &id);", reason: "`scanf` reads from stdin, not from a string." }], indent: 1, explanation: "`sscanf` parses the string into variables and returns the count matched." },
  { correct: "printf(\"\\n`sscanf` demo:\\n\");", distractors: [{ "text": "printf(\"Demo:\\n\");", reason: "Less specific." }], indent: 1, explanation: "Header." },
  { correct: "printf(\"  - Successfully matched %d items.\\n\", items_matched);", distractors: [{ "text": "printf(\"Matched: %d\\n\", items_matched);", reason: "Less descriptive." }], indent: 1, explanation: "Print return value of `sscanf`." },
  { correct: "printf(\"  - Parsed Year: %d\\n\", year);", distractors: [{ "text": "printf(\"Year: %d\\n\", &year);", reason: "Prints address instead of value." }], indent: 1, explanation: "Print parsed year." },
  { correct: "printf(\"  - Parsed Month: %d\\n\", month);", distractors: [{ "text": "printf(\"Month: %s\\n\", month);", reason: "Uses `%s` for an integer." }], indent: 1, explanation: "Print parsed month." },
  { correct: "printf(\"  - Parsed Day: %d\\n\", day);", distractors: [{ "text": "printf(\"Day: %d\\n\", day);", reason: "Same as correct; no mistake." }], indent: 1, explanation: "Print parsed day." },
  { correct: "printf(\"  - Parsed ID: %d\\n\", id);", distractors: [{ "text": "printf(\"ID: %s\\n\", id);", reason: "Uses `%s` for an integer." }], indent: 1, explanation: "Print parsed ID." },
  { correct: "return 0; }", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 58: File Positioning (`fseek`, `ftell`)
  {
    goal: "Manipulate the file position indicator using `fseek` to read from arbitrary locations and `ftell` to determine the current position.",
    concepts: "File I/O, file position, `fseek`, `ftell`, `rewind`, `SEEK_SET`, `SEEK_CUR`, `SEEK_END`",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` includes file I/O functions." }], indent: 0, explanation: "Include for I/O." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "const char* filename = \"test_seek.txt\";", distractors: [{ "text": "char filename[] = \"test_seek.txt\";", reason: "Array instead of pointer; both work." }], indent: 1, explanation: "Name of the test file." },
  { correct: "FILE* fp = fopen(filename, \"w+\");", distractors: [{ "text": "FILE* fp = fopen(filename, \"r\");", reason: "\"r\" is read-only; \"w+\" allows reading and writing." }, { "text": "FILE* fp = fopen(\"test_seek.txt\", \"w+\");", reason: "Hardcodes filename; using a variable is better." }], indent: 1, explanation: "Open a file for writing and reading ('w+')." },
  { correct: "if (!fp) { return 1; }", distractors: [{ "text": "if (fp == NULL) { exit(1); }", reason: "Uses `exit` instead of `return`; `return` is sufficient in `main`." }], indent: 1, explanation: "Error check." },
  { correct: "fputs(\"0123456789abcdefghijklmnopqrstuvwxyz\", fp);", distractors: [{ "text": "fprintf(fp, \"0123456789abcdefghijklmnopqrstuvwxyz\");", reason: "`fprintf` is for formatted output; `fputs` is simpler for strings." }], indent: 1, explanation: "Write known content to the file." },
  { correct: "// --- Using ftell to get current position ---", distractors: [{ "text": "// ftell", reason: "Does not explain its purpose." }], indent: 1, explanation: "Header for `ftell`." },
  { correct: "long pos = ftell(fp);", distractors: [{ "text": "int pos = ftell(fp);", reason: "`ftell` returns `long`, not `int`; could truncate on large files." }], indent: 1, explanation: "Get current file position (end of file)." },
  { correct: "printf(\"After writing, position is at: %ld\\n\", pos);", distractors: [{ "text": "printf(\"Position: %d\\n\", pos);", reason: "Uses `%d` for `long`; should be `%ld`." }], indent: 1, explanation: "Print the position (file size)." },
  { correct: "// --- Using rewind to go to the beginning ---", distractors: [{ "text": "// Rewind", reason: "Does not explain its effect." }], indent: 1, explanation: "Header for `rewind`." },
  { correct: "rewind(fp);", distractors: [{ "text": "fseek(fp, 0, SEEK_SET);", reason: "Same effect, but `rewind` is simpler for this purpose." }], indent: 1, explanation: "Move to the beginning of the file." },
  { correct: "printf(\"After rewind, position is at: %ld\\n\", ftell(fp));", distractors: [{ "text": "printf(\"Position: %ld\\n\", 0);", reason: "Assumes position without checking." }], indent: 1, explanation: "Confirm position is 0." },
  { correct: "// --- Using fseek to jump to a specific offset ---", distractors: [{ "text": "// fseek", reason: "Does not specify its usage." }], indent: 1, explanation: "Header for `fseek`." },
  { correct: "// `fseek` parameters: file pointer, offset, and origin.", distractors: [{ "text": "// fseek params", reason: "Does not explain the parameters." }], indent: 1, explanation: "Explain `fseek` parameters." },
  { correct: "if (fseek(fp, 10, SEEK_SET) != 0) { return 1; }", distractors: [{ "text": "fseek(fp, 10, SEEK_SET);", reason: "Does not check return value; `fseek` can fail." }, { "text": "if (fseek(fp, 10, SEEK_CUR) != 0) { return 1; }", reason: "Uses `SEEK_CUR` instead of `SEEK_SET`, changing the offset meaning." }], indent: 1, explanation: "Move 10 bytes from the beginning." },
  { correct: "printf(\"After fseek(10, SEEK_SET), position is at: %ld\\n\", ftell(fp));", distractors: [{ "text": "printf(\"Position: 10\\n\");", reason: "Assumes success without checking." }], indent: 1, explanation: "Confirm the new position." },
  { correct: "char c = fgetc(fp);", distractors: [{ "text": "int c = fgetc(fp);", reason: "Better to use `int` to handle EOF, but `char` works for this demo." }], indent: 1, explanation: "Read a character at the new position." },
  { correct: "printf(\"Character at position 10 is: '%c'\\n\", c); // Should be 'a'", distractors: [{ "text": "printf(\"Char: %c\\n\", c);", reason: "Less specific." }], indent: 1, explanation: "Verify the character." },
  { correct: "// --- Using fseek to jump from the end ---", distractors: [{ "text": "// Seek from end", reason: "Does not explain the action." }], indent: 1, explanation: "Header for `SEEK_END`." },
  { correct: "fseek(fp, -6, SEEK_END);", distractors: [{ "text": "fseek(fp, 6, SEEK_END);", reason: "Positive offset from end would seek past the end, which is invalid for reading." }, { "text": "fseek(fp, -6, SEEK_SET);", reason: "Negative offset from beginning is invalid." }], indent: 1, explanation: "Move 6 bytes backward from end." },
  { correct: "printf(\"After fseek(-6, SEEK_END), position is at: %ld\\n\", ftell(fp));", distractors: [{ "text": "printf(\"Position: %ld\\n\", pos - 6);", reason: "Assumes `pos` is still the file size; better to use `ftell`." }], indent: 1, explanation: "Confirm the new position." },
  { correct: "char buffer[10] = {0};", distractors: [{ "text": "char buffer[10];", reason: "Uninitialized; could contain garbage." }], indent: 1, explanation: "Buffer for remaining data." },
  { correct: "fgets(buffer, 10, fp);", distractors: [{ "text": "fread(buffer, 1, 10, fp);", reason: "`fread` reads binary data; `fgets` is for strings." }], indent: 1, explanation: "Read the rest of the file into buffer." },
  { correct: "printf(\"Reading from there until end: \\\"%s\\\"\\n\", buffer); // Should be \"uvwxyz\"", distractors: [{ "text": "printf(\"Data: %s\\n\", buffer);", reason: "Less specific." }], indent: 1, explanation: "Verify content." },
  { correct: "fclose(fp);", distractors: [{ "text": "close(fp);", reason: "Wrong function; `fclose` is for `FILE*`." }], indent: 1, explanation: "Close the file." },
  { correct: "return 0; }", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success." }], indent: 0, explanation: "Close main." }
]
  },

    // Level 59: Resizing Memory with `realloc`
    {
        goal: "Dynamically resize an existing memory block using `realloc` to make it larger and smaller.",
        concepts: "`realloc`, dynamic memory, memory management, NULL return",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include for I/O." },
            { correct: '#include <stdlib.h>', distractors: [], indent: 0, explanation: "Include for `malloc` and `realloc`." },
            { correct: 'void print_array(int* arr, int size) {', distractors: [], indent: 0, explanation: "A helper function to print an array's contents." },
            { correct: '  printf("Array (size %d): ", size);', distractors: [], indent: 1, explanation: "Print a header with the size." },
            { correct: '  for(int i=0; i<size; i++) { printf("%d ", arr[i]); }', distractors: [], indent: 1, explanation: "Loop and print each element." },
            { correct: '  printf("\\n");', distractors: [], indent: 1, explanation: "Print a newline." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close the helper function." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: 'int initial_size = 5;', distractors: [], indent: 1, explanation: "Define the initial size of our dynamic array." },
            { correct: '// 1. Allocate an initial block of memory', distractors: [], indent: 1, explanation: "First step: `malloc`." },
            { correct: 'int* numbers = (int*)malloc(initial_size * sizeof(int));', distractors: [], indent: 1, explanation: "Allocate memory for 5 integers." },
            { correct: 'if (!numbers) { return 1; }', distractors: [], indent: 1, explanation: "Always check if allocation succeeded." },
            { correct: 'for (int i=0; i<initial_size; i++) { numbers[i] = i+1; }', distractors: [], indent: 1, explanation: "Initialize the allocated memory with values 1 through 5." },
            { correct: 'print_array(numbers, initial_size);', distractors: [], indent: 1, explanation: "Print the initial array." },
            { correct: '// 2. Expand the memory block using `realloc`', distractors: [], indent: 1, explanation: "Second step: expand." },
            { correct: 'int new_size = 10;', distractors: [], indent: 1, explanation: "Define the new, larger size." },
            { correct: 'int* temp = (int*)realloc(numbers, new_size * sizeof(int));', distractors: [{text:'numbers = (int*)realloc(numbers, new_size * sizeof(int));', reason:'This is a common but dangerous pattern. If `realloc` fails, it returns NULL and the original `numbers` pointer would be overwritten and lost, causing a memory leak. Use a temporary pointer.'}], indent: 1, explanation: "Attempt to resize the memory block. `realloc` may move the entire block to a new location." },
            { correct: 'if (!temp) {', distractors: [], indent: 1, explanation: "Check if the reallocation failed." },
            { correct: '  printf("Failed to reallocate memory!\\n");', distractors: [], indent: 2, explanation: "Error message." },
            { correct: '  free(numbers); // Free the original block before exiting', distractors: [], indent: 2, explanation: "On failure, the original memory is still valid and must be freed." },
            { correct: '  return 1;', distractors: [], indent: 2, explanation: "Exit with an error." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close error check." },
            { correct: 'numbers = temp;', distractors: [], indent: 1, explanation: "If successful, assign the new memory location back to the original pointer." },
            { correct: 'for(int i=initial_size; i<new_size; i++) { numbers[i] = i+1; }', distractors: [], indent: 1, explanation: "Initialize the *new* part of the expanded array." },
            { correct: 'print_array(numbers, new_size);', distractors: [], indent: 1, explanation: "Print the larger array." },
            { correct: '// 3. Shrink the memory block', distractors: [], indent: 1, explanation: "Third step: shrink." },
            { correct: 'int final_size = 3;', distractors: [], indent: 1, explanation: "Define the final, smaller size." },
            { correct: 'numbers = (int*)realloc(numbers, final_size * sizeof(int));', distractors: [], indent: 1, explanation: "Shrinking a block will usually not fail, so we can often assign directly (though using a temp pointer is always safest)." },
            { correct: 'print_array(numbers, final_size);', distractors: [], indent: 1, explanation: "Print the shrunken array." },
            { correct: 'free(numbers);', distractors: [], indent: 1, explanation: "Free the final memory block." },
            { correct: 'return 0; }', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 60: Generic Memory Manipulation (memcpy, memmove, memset)
    {
        goal: "Use the generic memory manipulation functions `memset`, `memcpy`, and `memmove` from `<string.h>`.",
        concepts: "`memset`, `memcpy`, `memmove`, `sizeof`, pointers, overlapping memory",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include for I/O." },
            { correct: '#include <string.h>', distractors: [], indent: 0, explanation: "Include for `mem...` functions." },
            { correct: 'typedef struct { int id; double val; } Data;', distractors: [], indent: 0, explanation: "A simple struct for demonstration." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: '// --- 1. `memset`: Fill a block of memory with a specific value ---', distractors: [], indent: 1, explanation: "Introduce `memset`." },
            { correct: 'int my_array[5];', distractors: [], indent: 1, explanation: "Declare an uninitialized array." },
            { correct: 'memset(my_array, 0, 5 * sizeof(int));', distractors: [{text:'memset(my_array, 0, 5);', reason:'The third argument is the number of *bytes* to set. You must multiply the number of elements by the size of each element.'}, {text:'for(int i=0; i<5; i++) { my_array[i] = 0; }', reason:'A loop is a valid way to zero an array, but `memset` is often a faster, single function call to do the same for raw bytes.'}], indent: 1, explanation: "Set all bytes in `my_array` to 0. This is a common way to zero-initialize." },
            { correct: 'printf("Array after memset to 0: %d %d %d\\n", my_array[0], my_array[1], my_array[2]);', distractors: [], indent: 1, explanation: "Verify the array is zeroed." },
            { correct: '// --- 2. `memcpy`: Copy memory from a source to a destination ---', distractors: [], indent: 1, explanation: "Introduce `memcpy`." },
            { correct: 'Data source = { .id = 101, .val = 3.14 };', distractors: [], indent: 1, explanation: "Create a source struct." },
            { correct: 'Data dest;', distractors: [], indent: 1, explanation: "Create a destination struct." },
            { correct: 'memcpy(&dest, &source, sizeof(Data));', distractors: [{text:'dest = source;', reason:'Struct assignment with `=` works and is often clearer. `memcpy` is more general and useful when you just have void pointers or need to copy raw byte blocks.'}, {text:'memcpy(&dest, &source, sizeof(Data*));', reason:'The size must be of the data itself (`sizeof(Data)`), not the size of a pointer to the data.'}], indent: 1, explanation: "Copy all bytes from `source` to `dest`. `memcpy` behavior is undefined if memory regions overlap." },
            { correct: 'printf("Copied struct: ID=%d, Val=%f\\n", dest.id, dest.val);', distractors: [], indent: 1, explanation: "Verify the copy was successful." },
            { correct: '// --- 3. `memmove`: Safely copy memory, even if regions overlap ---', distractors: [], indent: 1, explanation: "Introduce `memmove`." },
            { correct: 'char text[] = "hello world";', distractors: [], indent: 1, explanation: "Create a string to work with." },
            { correct: '// We want to copy "world" over "hello" to get "world world"', distractors: [], indent: 1, explanation: "Define the goal for the overlapping copy." },
            { correct: '// The source is `text+6` ("world"), destination is `text` ("hello")', distractors: [], indent: 1, explanation: "Identify the source and destination pointers." },
            { correct: '// These regions overlap, so `memcpy` is unsafe. `memmove` is required.', distractors: [], indent: 1, explanation: "Explain why `memmove` is needed." },
            { correct: 'memmove(text, text + 6, 5);', distractors: [{text:'memcpy(text, text + 6, 5);', reason:'Using `memcpy` on overlapping regions results in *undefined behavior*. `memmove` correctly handles this by using an intermediate buffer if necessary.'}], indent: 1, explanation: "Safely copy 5 bytes from `text+6` to `text`." },
            { correct: 'printf("String after memmove: \\"%s\\"\\n", text);', distractors: [], indent: 1, explanation: "Verify the result is 'world world'." },
            { correct: 'return 0; }', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 61: Standard Library `bsearch`
    {
        goal: "Use the standard library's `bsearch` function to perform a binary search on a sorted array of structs.",
        concepts: "`bsearch`, binary search, `<stdlib.h>`, function pointers, comparison functions",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include for I/O." },
            { correct: '#include <stdlib.h>', distractors: [], indent: 0, explanation: "Include for `bsearch` and `qsort`." },
            { correct: 'typedef struct { int key; char* value; } Item;', distractors: [], indent: 0, explanation: "Define a key-value item struct." },
            { correct: '// Comparison function for qsort and bsearch. Must have this signature.', distractors: [], indent: 0, explanation: "Comment on the required comparison function." },
            { correct: 'int compareItems(const void* a, const void* b) {', distractors: [], indent: 0, explanation: "Define the comparison function." },
            { correct: '// For bsearch, one argument will be a pointer to the key,', distractors: [], indent: 1, explanation: "Explain `bsearch`'s use of the comparator." },
            { correct: '// and the other will be a pointer to an element in the array.', distractors: [], indent: 1, explanation: "Continue explanation." },
            { correct: 'const int* key = (const int*)a;', distractors: [], indent: 1, explanation: "Cast the first argument, which `bsearch` will pass as our key." },
            { correct: 'const Item* item = (const Item*)b;', distractors: [], indent: 1, explanation: "Cast the second argument, which will be an element from the array." },
            { correct: 'return (*key - item->key);', distractors: [{text:'return (item->key - *key);', reason:'The order is important. `bsearch` relies on the comparison being consistent. This would reverse the search logic.'}], indent: 1, explanation: "Return the difference to determine ordering. This simple subtraction works for integers." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close the comparison function." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: '// bsearch requires the array to be sorted first!', distractors: [], indent: 1, explanation: "Crucial prerequisite for binary search." },
            { correct: 'Item items[] = { {10, "Ten"}, {50, "Fifty"}, {20, "Twenty"}, {40, "Forty"}, {30, "Thirty"} };', distractors: [], indent: 1, explanation: "Create an unsorted array of items." },
            { correct: 'int n = sizeof(items) / sizeof(items[0]);', distractors: [], indent: 1, explanation: "Calculate the number of items." },
            { correct: '// We need a different comparator for qsort, as it compares two full elements', distractors: [], indent: 1, explanation: "Explain why a different comparator is needed for qsort." },
            { correct: 'int qsort_compare(const void*a, const void*b) { return ((Item*)a)->key - ((Item*)b)->key; }', distractors: [], indent: 1, explanation: "Define a simple, in-line comparator for `qsort`." },
            { correct: 'qsort(items, n, sizeof(Item), qsort_compare);', distractors: [], indent: 1, explanation: "Sort the array by key." },
            { correct: 'printf("Sorted array ready for searching...\\n");', distractors: [], indent: 1, explanation: "Confirmation message." },
            { correct: '// Now, search for an item with a specific key.', distractors: [], indent: 1, explanation: "Comment on the search operation." },
            { correct: 'int key_to_find = 40;', distractors: [], indent: 1, explanation: "The key we want to find." },
            { correct: 'printf("Searching for item with key: %d\\n", key_to_find);', distractors: [], indent: 1, explanation: "Informational message." },
            { correct: 'Item* found_item = bsearch(&key_to_find, items, n, sizeof(Item), compareItems);', distractors: [{text:'Item* found_item = bsearch(key_to_find, ...);', reason:'The first argument must be a pointer to the key you are searching for, not the key value itself.'}], indent: 1, explanation: "Call `bsearch`: pass a pointer to the key, the array, count, element size, and the comparator." },
            { correct: '// Check the result', distractors: [], indent: 1, explanation: "Comment on checking the return value." },
            { correct: 'if (found_item != NULL) {', distractors: [], indent: 1, explanation: "`bsearch` returns a pointer to the found item, or NULL if not found." },
            { correct: 'printf("Found! Value is \\"%s\\".\\n", found_item->value);', distractors: [], indent: 2, explanation: "Print the value of the found item." },
            { correct: '} else {', distractors: [], indent: 1, explanation: "Handle the case where the item was not found." },
            { correct: 'printf("Item with key %d not found.\\n", key_to_find);', distractors: [], indent: 2, explanation: "Not found message." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close the if/else block." },
            { correct: 'return 0; }', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 62: String Tokenizing with `strtok`
    {
        goal: "Parse a string into tokens (substrings) based on a delimiter using the `strtok` function.",
        concepts: "`strtok`, string parsing, delimiters, static internal state, side effects",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include for I/O." },
            { correct: '#include <string.h>', distractors: [], indent: 0, explanation: "Include for `strtok`." },
            { correct: '// `strtok` is used to split a string into a series of tokens.', distractors: [], indent: 0, explanation: "Explain `strtok`." },
            { correct: '// WARNING: `strtok` MODIFIES the original string by inserting null characters!', distractors: [], indent: 0, explanation: "Crucial warning about `strtok`'s side effects." },
            { correct: '// It is also NOT re-entrant or thread-safe due to its use of a static internal buffer.', distractors: [], indent: 0, explanation: "Another important warning." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: 'char data_string[] = "-l /usr/bin -p 8080 -v";', distractors: [{text:'const char* data_string = ...;', reason:'You cannot use `strtok` on a string literal, because it must be modifiable. You must use a character array.'}], indent: 1, explanation: "Create a modifiable character array to be tokenized." },
            { correct: 'printf("Original string: \\"%s\\"\\n", data_string);', distractors: [], indent: 1, explanation: "Show the original string." },
            { correct: 'const char* delimiters = " ";', distractors: [{text:'const char* delimiters = \',\';', reason:'The delimiters argument must be a string (a character array), even if it only contains one character.'}], indent: 1, explanation: "Define the delimiter characters. Here, we're just splitting by space." },
            { correct: '// The first call to `strtok` requires the string.', distractors: [], indent: 1, explanation: "Explain the first call." },
            { correct: 'char* token = strtok(data_string, delimiters);', distractors: [], indent: 1, explanation: "Get the first token. `strtok` returns a pointer to it." },
            { correct: '// Subsequent calls use NULL to continue tokenizing the same string.', distractors: [], indent: 1, explanation: "Explain subsequent calls." },
            { correct: 'while (token != NULL) {', distractors: [], indent: 1, explanation: "Loop as long as `strtok` keeps returning valid tokens." },
            { correct: 'printf("Token: %s\\n", token);', distractors: [], indent: 2, explanation: "Print the current token." },
            { correct: 'token = strtok(NULL, delimiters);', distractors: [{text:'token = strtok(data_string, delimiters);', reason:'If you pass the original string again, `strtok` will just restart from the beginning and return the first token repeatedly.'}], indent: 2, explanation: "Get the *next* token from the same string by passing NULL." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close the loop." },
            { correct: 'printf("\\nOriginal string after strtok: ");', distractors: [], indent: 1, explanation: "Header to show the modified string." },
            { correct: '// The original string has been modified with null terminators (`\\0`).', distractors: [], indent: 1, explanation: "Explain the side effect." },
            { correct: 'for(int i=0; i<strlen(data_string); i++) {', distractors: [], indent: 1, explanation: "Loop to inspect the raw bytes." },
            { correct: '  putchar(data_string[i] ? data_string[i] : \'*\'); // Print `*` for null char', distractors: [], indent: 2, explanation: "Print each character, replacing the nulls `strtok` inserted with a visible character." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close the inspection loop." },
            { correct: 'printf("\\n");', distractors: [], indent: 1, explanation: "Final newline." },
            { correct: 'return 0; }', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 63: Formatted File I/O (fprintf, fscanf)
    {
        goal: "Write structured data to a human-readable text file with `fprintf` and read it back with `fscanf`.",
        concepts: "`fprintf`, `fscanf`, formatted file I/O, text files",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include for file I/O." },
            { correct: '#include <stdlib.h>', distractors: [], indent: 0, explanation: "Include for `exit`." },
            { correct: 'typedef struct { int id; char name[20]; } Record;', distractors: [], indent: 0, explanation: "A simple struct to read and write." },
            { correct: 'const char* filename = "data.txt";', distractors: [], indent: 0, explanation: "The name of our text file." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: '// --- Write formatted data to a text file ---', distractors: [], indent: 1, explanation: "Header for writing." },
            { correct: 'Record records_out[] = { {1, "CPU"}, {2, "Memory"}, {3, "Disk"} };', distractors: [], indent: 1, explanation: "An array of data to write." },
            { correct: 'FILE *fp = fopen(filename, "w");', distractors: [{text:'FILE *fp = fopen(filename, "wb");', reason:'"wb" is for binary mode. For human-readable text, use "w".'}], indent: 1, explanation: "Open the file in write mode." },
            { correct: 'if (!fp) { perror("fopen for write"); exit(1); }', distractors: [], indent: 1, explanation: "Error check." },
            { correct: 'printf("Writing to %s...\\n", filename);', distractors: [], indent: 1, explanation: "Informational message." },
            { correct: 'for (int i=0; i<3; i++) {', distractors: [], indent: 1, explanation: "Loop through the data to write." },
            { correct: 'fprintf(fp, "%d %s\\n", records_out[i].id, records_out[i].name);', distractors: [{text:'printf("%d %s\\n", ...);', reason:'`printf` writes to the console. `fprintf` takes a `FILE*` as its first argument and writes to that file.'}], indent: 2, explanation: "Write the ID and name for each record to the file, separated by a space and followed by a newline." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close the writing loop." },
            { correct: 'fclose(fp);', distractors: [], indent: 1, explanation: "Close the file." },
            { correct: '// --- Read formatted data from the text file ---', distractors: [], indent: 1, explanation: "Header for reading." },
            { correct: 'Record records_in[3];', distractors: [], indent: 1, explanation: "An array to hold the data we read back." },
            { correct: 'fp = fopen(filename, "r");', distractors: [], indent: 1, explanation: "Re-open the file in read mode." },
            { correct: 'if (!fp) { perror("fopen for read"); exit(1); }', distractors: [], indent: 1, explanation: "Error check." },
            { correct: 'printf("Reading from %s...\\n", filename);', distractors: [], indent: 1, explanation: "Informational message." },
            { correct: 'int i = 0;', distractors: [], indent: 1, explanation: "An index for our read-in array." },
            { correct: 'while (fscanf(fp, "%d %s", &records_in[i].id, records_in[i].name) == 2) {', distractors: [{text:'while (!feof(fp)) { fscanf(...); }', reason:'It is better to check the return value of `fscanf`. It returns the number of items successfully scanned. Checking `feof` before a read can lead to errors.'}], indent: 1, explanation: "Loop while `fscanf` successfully scans 2 items (an int and a string) per line." },
            { correct: 'i++;', distractors: [], indent: 2, explanation: "Increment the array index." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close the reading loop." },
            { correct: 'fclose(fp);', distractors: [], indent: 1, explanation: "Close the file." },
            { correct: '// Verify the data', distractors: [], indent: 1, explanation: "Comment on verification." },
            { correct: 'for (int j=0; j<i; j++) {', distractors: [], indent: 1, explanation: "Loop through the records that were read." },
            { correct: 'printf("Record %d -> ID: %d, Name: %s\\n", j, records_in[j].id, records_in[j].name);', distractors: [], indent: 2, explanation: "Print the data to confirm it was read correctly." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close the verification loop." },
            { correct: 'return 0; }', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 64: Character Classification (`<ctype.h>`)
    {
        goal: "Analyze a string by classifying each character using the functions from `<ctype.h>`.",
        concepts: "Character classification, `<ctype.h>`, `isalpha`, `isdigit`, `isspace`, `ispunct`, text parsing",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include for I/O." },
            { correct: '#include <ctype.h>', distractors: [], indent: 0, explanation: "Include the header for character type functions." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: 'const char* text = "Hello, C World! Version 1.2.3 is here.";', distractors: [], indent: 1, explanation: "The input string to analyze." },
            { correct: '// Initialize counters for different character types.', distractors: [], indent: 1, explanation: "Comment on counters." },
            { correct: 'int alpha_count = 0;', distractors: [], indent: 1, explanation: "Counter for alphabetic characters." },
            { correct: 'int digit_count = 0;', distractors: [], indent: 1, explanation: "Counter for digits." },
            { correct: 'int space_count = 0;', distractors: [], indent: 1, explanation: "Counter for whitespace characters." },
            { correct: 'int punct_count = 0;', distractors: [], indent: 1, explanation: "Counter for punctuation characters." },
            { correct: 'int upper_count = 0;', distractors: [], indent: 1, explanation: "Counter for uppercase letters." },
            { correct: 'int lower_count = 0;', distractors: [], indent: 1, explanation: "Counter for lowercase letters." },
            { correct: 'int i = 0;', distractors: [], indent: 1, explanation: "Initialize a loop counter." },
            { correct: 'printf("Analyzing string: \\"%s\\"\\n", text);', distractors: [], indent: 1, explanation: "Print the string being analyzed." },
            { correct: 'while (text[i] != \'\\0\') {', distractors: [], indent: 1, explanation: "Loop through every character in the string." },
            { correct: 'char c = text[i];', distractors: [], indent: 2, explanation: "Get the current character." },
            { correct: 'if (isalpha(c)) { alpha_count++; }', distractors: [], indent: 2, explanation: "Check if the character is a letter (a-z, A-Z)." },
            { correct: 'if (isdigit(c)) { digit_count++; }', distractors: [], indent: 2, explanation: "Check if the character is a digit (0-9)." },
            { correct: 'if (isspace(c)) { space_count++; }', distractors: [], indent: 2, explanation: "Check if the character is whitespace (space, tab, newline, etc.)." },
            { correct: 'if (ispunct(c)) { punct_count++; }', distractors: [], indent: 2, explanation: "Check if the character is punctuation." },
            { correct: 'if (isupper(c)) { upper_count++; }', distractors: [], indent: 2, explanation: "Check if the character is an uppercase letter." },
            { correct: 'if (islower(c)) { lower_count++; }', distractors: [], indent: 2, explanation: "Check if the character is a lowercase letter." },
            { correct: 'i++;', distractors: [], indent: 2, explanation: "Move to the next character." },
            { correct: '}', distractors: [], indent: 1, explanation: "Close the loop." },
            { correct: 'printf("\\n--- Analysis Results ---\\n");', distractors: [], indent: 1, explanation: "Header for the results." },
            { correct: 'printf("Alphabetic Chars: %d\\n", alpha_count);', distractors: [], indent: 1, explanation: "Print the alphabet count." },
            { correct: 'printf("  (Upper: %d, Lower: %d)\\n", upper_count, lower_count);', distractors: [], indent: 1, explanation: "Print the case breakdown." },
            { correct: 'printf("Digits:           %d\\n", digit_count);', distractors: [], indent: 1, explanation: "Print the digit count." },
            { correct: 'printf("Whitespace:       %d\\n", space_count);', distractors: [], indent: 1, explanation: "Print the whitespace count." },
            { correct: 'printf("Punctuation:      %d\\n", punct_count);', distractors: [], indent: 1, explanation: "Print the punctuation count." },
            { correct: 'return 0; }', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 65: Debugging with `assert`
    {
        goal: "Use the `assert` macro from `<assert.h>` to check for program invariants and preconditions, and understand how it can be disabled.",
        concepts: "`assert`, `<assert.h>`, debugging, preconditions, `NDEBUG` macro",
        sequence: [
            { correct: '#define NDEBUG // Uncomment this line to disable assertions', distractors: [], indent: 0, explanation: "Introduce the NDEBUG macro, which disables `assert`. Keep it commented out for now." },
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include for I/O." },
            { correct: '#include <assert.h>', distractors: [], indent: 0, explanation: "Include the header for the `assert` macro." },
            { correct: '// `assert(expression)` checks if an expression is true.', distractors: [], indent: 0, explanation: "Explain the purpose of `assert`." },
            { correct: '// If the expression is false (0), it prints an error message to stderr', distractors: [], indent: 0, explanation: "Explain what happens on failure." },
            { correct: '// with the file name, line number, and expression text, then aborts the program.', distractors: [], indent: 0, explanation: "Continue explaining failure behavior." },
            { correct: 'double divide(double a, double b) {', distractors: [], indent: 0, explanation: "Define a function where a precondition is important." },
            { correct: '// Precondition: The divisor `b` must not be zero.', distractors: [], indent: 1, explanation: "State the function's precondition." },
            { correct: 'assert(b != 0.0);', distractors: [{text:'if (b == 0.0) { return 0.0; }', reason:'Returning a value is one way to handle an error, but `assert` is for catching *programmer errors* during development. It indicates a condition that should *never* happen in a correct program.'}], indent: 1, explanation: "Use `assert` to enforce the precondition. If this fails, it indicates a bug in the code that *called* this function." },
            { correct: 'return a / b;', distractors: [], indent: 1, explanation: "Perform the division if the assertion passes." },
            { correct: '}', distractors: [], indent: 0, explanation: "Close the divide function." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main." },
            { correct: 'double x = 10.0;', distractors: [], indent: 1, explanation: "Declare a numerator." },
            { correct: 'double y = 2.0;', distractors: [], indent: 1, explanation: "Declare a valid denominator." },
            { correct: 'printf("--- Demonstrating `assert` ---\\n");', distractors: [], indent: 1, explanation: "Header." },
            { correct: 'printf("Calling divide(10.0, 2.0)...\\n");', distractors: [], indent: 1, explanation: "Informational message for the valid call." },
            { correct: 'double result = divide(x, y);', distractors: [], indent: 1, explanation: "Call the function with valid arguments. The assertion will pass." },
            { correct: 'printf("Result: %f\\n", result);', distractors: [], indent: 1, explanation: "Print the successful result." },
            { correct: 'printf("\\nNow, calling divide(10.0, 0.0) to trigger the assertion...\\n");', distractors: [], indent: 1, explanation: "Informational message for the invalid call." },
            { correct: 'printf("(If NDEBUG is not defined, the program will abort here.)\\n");', distractors: [], indent: 1, explanation: "Explain what the user should expect." },
            { correct: 'result = divide(x, 0.0);', distractors: [], indent: 1, explanation: "Call the function with invalid arguments. This will trigger the `assert` and terminate the program." },
            { correct: '// The following lines will not be reached if assertions are enabled.', distractors: [], indent: 1, explanation: "Comment on unreachable code." },
            { correct: 'printf("This line will not print if assert is triggered.\\n");', distractors: [], indent: 1, explanation: "An example of unreachable code." },
            { correct: 'return 0; }', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 66: Data Type Limits
    {
        goal: "Query and print the value ranges and precision limits of fundamental data types using the constants from `<limits.h>` and `<float.h>`.",
        concepts: "Data type limits, `<limits.h>`, `<float.h>`, portability, integer and floating point representation",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include for I/O." },
            { correct: '#include <limits.h>', distractors: [], indent: 0, explanation: "Include for integer type limit constants." },
            { correct: '#include <float.h>', distractors: [], indent: 0, explanation: "Include for floating-point type limit constants." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: 'printf("--- Integer Type Limits from <limits.h> ---\\n");', distractors: [], indent: 1, explanation: "Header for integer limits." },
            { correct: 'printf("Number of bits in a char: %d\\n", CHAR_BIT);', distractors: [], indent: 1, explanation: "Print the number of bits in a byte (usually 8)." },
            { correct: 'printf("Minimum value of char: %d\\n", CHAR_MIN);', distractors: [], indent: 1, explanation: "Print the minimum value for a char." },
            { correct: 'printf("Maximum value of char: %d\\n", CHAR_MAX);', distractors: [], indent: 1, explanation: "Print the maximum value for a char." },
            { correct: 'printf("Minimum value of int: %d\\n", INT_MIN);', distractors: [], indent: 1, explanation: "Print the minimum value for a standard integer." },
            { correct: 'printf("Maximum value of int: %d\\n", INT_MAX);', distractors: [], indent: 1, explanation: "Print the maximum value for a standard integer." },
            { correct: 'printf("Maximum value of unsigned int: %u\\n", UINT_MAX);', distractors: [{text:'printf("Max unsigned int: %d\\n", UINT_MAX);', reason:'`UINT_MAX` is a very large positive number. Printing it with `%d` (signed decimal) will cause it to wrap around and appear as -1. `%u` (unsigned decimal) is required.'}], indent: 1, explanation: "Print the maximum value for an unsigned integer." },
            { correct: 'printf("Maximum value of long long: %lld\\n", LLONG_MAX);', distractors: [], indent: 1, explanation: "Print the maximum value for a long long, using the `%lld` format specifier." },
            { correct: 'printf("Maximum value of unsigned long long: %llu\\n", ULLONG_MAX);', distractors: [], indent: 1, explanation: "Print the maximum for an unsigned long long, using `%llu`." },
            { correct: 'printf("\\n--- Floating-Point Type Limits from <float.h> ---\\n");', distractors: [], indent: 1, explanation: "Header for floating-point limits." },
            { correct: 'printf("Minimum positive value of float: %e\\n", FLT_MIN);', distractors: [], indent: 1, explanation: "Print the smallest positive number a float can represent, using scientific notation `%e`." },
            { correct: 'printf("Maximum value of float: %e\\n", FLT_MAX);', distractors: [], indent: 1, explanation: "Print the largest number a float can represent." },
            { correct: 'printf("Float precision (decimal digits): %d\\n", FLT_DIG);', distractors: [], indent: 1, explanation: "Print the number of decimal digits of precision for a float." },
            { correct: 'printf("Float epsilon (smallest x such that 1.0+x != 1.0): %e\\n", FLT_EPSILON);', distractors: [], indent: 1, explanation: "Print the epsilon, which represents the difference between 1.0 and the next representable float value." },
            { correct: 'printf("Maximum value of double: %e\\n", DBL_MAX);', distractors: [], indent: 1, explanation: "Print the maximum value for a double." },
            { correct: 'printf("Double precision (decimal digits): %d\\n", DBL_DIG);', distractors: [], indent: 1, explanation: "Print the number of decimal digits of precision for a double." },
            { correct: 'return 0; }', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 67: Token-Pasting Operator (##)
    {
        goal: "Use the preprocessor's token-pasting operator (`##`) to create macros that generate identifiers like variable or function names.",
        concepts: "Preprocessor, macros, token-pasting operator (##), metaprogramming",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include for I/O." },
            { correct: '// The `##` operator, or token-paster, concatenates two tokens in a macro expansion.', distractors: [], indent: 0, explanation: "Explain the `##` operator." },
            { correct: '// It allows us to generate code dynamically at compile time.', distractors: [], indent: 0, explanation: "Explain its use case." },
            { correct: '#define CREATE_VARIABLE(type, name) type var_##name', distractors: [{text:'#define CREATE_VARIABLE(type, name) type var_#name', reason:'The stringizing operator `#` would create a string literal "name", resulting in `type var_"name"`, which is a syntax error. `##` is needed to paste `var_` and `name` together into a single identifier.'}], indent: 0, explanation: "Define a macro to declare a variable with a prefixed name." },
            { correct: '#define CALL_FUNCTION(name) func_##name()', distractors: [], indent: 0, explanation: "Define a macro to call a function with a prefixed name." },
            { correct: '// Define some functions that the macro can call', distractors: [], indent: 0, explanation: "Comment on function definitions." },
            { correct: 'void func_start() { printf("Start function called.\\n"); }', distractors: [], indent: 0, explanation: "Define the start function." },
            { correct: 'void func_stop() { printf("Stop function called.\\n"); }', distractors: [], indent: 0, explanation: "Define the stop function." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: 'printf("--- Using `##` to create variable names ---\\n");', distractors: [], indent: 1, explanation: "Header for the variable example." },
            { correct: '// This line `CREATE_VARIABLE(int, counter);` will expand to `int var_counter;`', distractors: [], indent: 1, explanation: "Explain the macro expansion." },
            { correct: 'CREATE_VARIABLE(int, counter);', distractors: [], indent: 1, explanation: "Use the macro to declare an integer." },
            { correct: 'CREATE_VARIABLE(double, temperature);', distractors: [], indent: 1, explanation: "Use the macro to declare a double." },
            { correct: '// Now we can use the variables that the macro created.', distractors: [], indent: 1, explanation: "Comment on using the generated variables." },
            { correct: 'var_counter = 100;', distractors: [], indent: 1, explanation: "Assign a value to the generated integer variable." },
            { correct: 'var_temperature = 98.6;', distractors: [], indent: 1, explanation: "Assign a value to the generated double variable." },
            { correct: 'printf("var_counter = %d\\n", var_counter);', distractors: [], indent: 1, explanation: "Print the integer's value." },
            { correct: 'printf("var_temperature = %f\\n", var_temperature);', distractors: [], indent: 1, explanation: "Print the double's value." },
            { correct: 'printf("\\n--- Using `##` to create function calls ---\\n");', distractors: [], indent: 1, explanation: "Header for the function call example." },
            { correct: '// `CALL_FUNCTION(start);` will expand to `func_start();`', distractors: [], indent: 1, explanation: "Explain the next macro expansion." },
            { correct: 'CALL_FUNCTION(start);', distractors: [], indent: 1, explanation: "Use the macro to call the start function." },
            { correct: 'CALL_FUNCTION(stop);', distractors: [], indent: 1, explanation: "Use the macro to call the stop function." },
            { correct: 'return 0; }', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 68: Wide Characters and Locales
    {
        goal: "Use wide characters (`wchar_t`) and set the program's locale to correctly handle and print non-ASCII text.",
        concepts: "Wide characters, `<wchar.h>`, `<locale.h>`, `wchar_t`, `L` prefix, `wprintf`, `setlocale`",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [], indent: 0, explanation: "Include for standard I/O." },
            { correct: '#include <wchar.h>', distractors: [], indent: 0, explanation: "Include the header for wide character functions and types." },
            { correct: '#include <locale.h>', distractors: [], indent: 0, explanation: "Include the header for locale settings." },
            { correct: 'int main() {', distractors: [], indent: 0, explanation: "Start main function." },
            { correct: '// A normal char string cannot reliably store characters outside the ASCII set.', distractors: [], indent: 1, explanation: "Explain the limitation of `char`." },
            { correct: 'const char* narrow_string = "Euro: €";', distractors: [], indent: 1, explanation: "A narrow string. How the '€' is stored is implementation-defined (e.g., UTF-8)." },
            { correct: '// A wide character string uses `wchar_t` and is prefixed with `L`.', distractors: [], indent: 1, explanation: "Introduce wide strings." },
            { correct: 'const wchar_t* wide_string = L"Euro: €, Złoty: zł, Pi: π";', distractors: [{text:'const wchar_t* wide_string = "Euro: €";', reason:'A wide string literal must be prefixed with `L` to tell the compiler to create an array of `wchar_t` instead of `char`.'}], indent: 1, explanation: "Declare a wide character string literal." },
            { correct: '// To correctly print wide characters, we need to set the program\'s locale.', distractors: [], indent: 1, explanation: "Explain the need for setting a locale." },
            { correct: '// An empty string "" tells `setlocale` to use the user\'s default environment locale.', distractors: [], indent: 1, explanation: "Explain the `setlocale` argument." },
            { correct: 'setlocale(LC_ALL, "");', distractors: [{text:'setlocale(LC_CTYPE, "");', reason:'`LC_CTYPE` sets only the character handling category. `LC_ALL` sets all locale categories, which is generally what you want for full support.'}], indent: 1, explanation: "Set the program's locale to the system default." },
            { correct: 'printf("--- Printing Strings ---\\n");', distractors: [], indent: 1, explanation: "Header." },
            { correct: 'printf("Attempting to print narrow string: %s\\n", narrow_string);', distractors: [], indent: 1, explanation: "Printing the narrow string. It may or may not display correctly depending on the console." },
            { correct: '// To print a wide string, we must use `wprintf`.', distractors: [], indent: 1, explanation: "Introduce `wprintf`." },
            { correct: '// It uses a wide format string (prefixed with `L`) and the `%ls` specifier.', distractors: [], indent: 1, explanation: "Explain `wprintf` format specifiers." },
            { correct: 'wprintf(L"Printing wide string with wprintf: %ls\\n", wide_string);', distractors: [{text:'printf("Wide string: %ls\\n", wide_string);', reason:'`printf` is not guaranteed to correctly handle the `%ls` specifier for wide strings. `wprintf` is the designated function.'}, {text:'wprintf(L"Wide string: %s\\n", wide_string);', reason:'`wprintf` expects the wide string format specifier `%ls`, not the narrow `%s`.'}], indent: 1, explanation: "Use `wprintf` to correctly print the wide character string." },
            { correct: 'printf("\\n--- Sizing ---\\n");', distractors: [], indent: 1, explanation: "Header for size comparison." },
            { correct: 'printf("sizeof(char): %zu byte\\n", sizeof(char));', distractors: [], indent: 1, explanation: "`char` is guaranteed to be 1 byte." },
            { correct: 'printf("sizeof(wchar_t): %zu bytes\\n", sizeof(wchar_t));', distractors: [], indent: 1, explanation: "`wchar_t` is larger, typically 2 or 4 bytes, to accommodate larger character sets." },
            { correct: 'return 0; }', distractors: [], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 69: command-line to-do list
    {
        "goal": "Build a command-line to-do list application that persists tasks to a file.",
        concepts: "structs, dynamic arrays, realloc, file I/O (fprintf, fscanf), argc/argv parsing, strcmp",
        sequence: [
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Include for standard input/output functions." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Include for memory allocation (`malloc`, `realloc`, `free`) and string conversion." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "Include for string manipulation functions like `strcpy` and `strcmp`." },
            { correct: "#define MAX_TASK_LEN 256", distractors: [], indent: 0, "explanation": "Define a constant for the maximum length of a single task description." },
            { correct: "#define TASKS_FILENAME \"tasks.txt\"", distractors: [], indent: 0, "explanation": "Define the filename where tasks will be stored." },
            { correct: "// Define a structure to hold information about a single task.", distractors: [], indent: 0, "explanation": "Comment explaining the purpose of the Task struct." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin defining the Task structure with a typedef for convenience." },
            { correct: "  int id;", distractors: [], indent: 1, "explanation": "A unique identifier for each task." },
            { correct: "  char description[MAX_TASK_LEN];", distractors: [], indent: 1, "explanation": "The text description of the task." },
            { correct: "  int is_complete;", distractors: [], indent: 1, "explanation": "A flag (0 or 1) to indicate if the task is completed." },
            { correct: "} Task;", distractors: [], indent: 0, "explanation": "Create the alias `Task` for our struct." },
            { correct: "// Global variables to hold the list of tasks.", distractors: [], indent: 0, "explanation": "Comment explaining the global task list." },
            { correct: "Task* tasks = NULL;", distractors: [], indent: 0, "explanation": "A dynamic array to store all tasks. Initialize to NULL." },
            { correct: "int task_count = 0;", distractors: [], indent: 0, "explanation": "A counter for the number of tasks currently in the list." },
            { correct: "// --- Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare all our functions upfront for organization." },
            { correct: "void load_tasks_from_file();", distractors: [], indent: 0, "explanation": "Prototype for the function that loads tasks from the file." },
            { correct: "void save_tasks_to_file();", distractors: [], indent: 0, "explanation": "Prototype for the function that saves tasks to the file." },
            { correct: "void add_task(const char* description);", distractors: [], indent: 0, "explanation": "Prototype for adding a new task." },
            { correct: "void list_tasks();", distractors: [], indent: 0, "explanation": "Prototype for listing all tasks." },
            { correct: "void complete_task(int id);", distractors: [], indent: 0, "explanation": "Prototype for marking a task as complete." },
            { correct: "void print_usage();", distractors: [], indent: 0, "explanation": "Prototype for printing help information." },
            { correct: "// --- Main Function: Program Entry Point & Argument Parsing ---", distractors: [], indent: 0, "explanation": "The main driver of our application." },
            { correct: "int main(int argc, char* argv[]) {", distractors: [], indent: 0, "explanation": "Start main, accepting command-line arguments." },
            { correct: "load_tasks_from_file();", distractors: [], indent: 1, "explanation": "The first action is to load any existing tasks from our file." },
            { correct: "if (argc < 2) {", distractors: [], indent: 1, "explanation": "Check if the user provided any command." },
            { correct: "  print_usage();", distractors: [], indent: 2, "explanation": "If no command is given, show the usage instructions." },
            { correct: "  return 1;", distractors: [], indent: 2, "explanation": "Exit with an error code." },
            { correct: "}", distractors: [], indent: 1, "explanation": "Close the argument count check." },
            { correct: "// Compare the first argument to determine the command.", distractors: [], indent: 1, "explanation": "Comment explaining command parsing." },
            { correct: "if (strcmp(argv[1], \"add\") == 0) {", distractors: [], indent: 1, "explanation": "Check if the command is 'add'." },
            { correct: "  if (argc < 3) {", distractors: [], indent: 2, "explanation": "The 'add' command requires a task description." },
            { correct: "    printf(\"Error: 'add' command requires a description.\\n\");", distractors: [], indent: 3, "explanation": "Print an error if the description is missing." },
            { correct: "    print_usage();", distractors: [], indent: 3, "explanation": "Show usage." },
            { correct: "  } else {", distractors: [], indent: 2, "explanation": "If the description exists..." },
            { correct: "    add_task(argv[2]);", distractors: [], indent: 3, "explanation": "Call the add_task function with the provided description." },
            { correct: "  }", distractors: [], indent: 2, "explanation": "Close the add command logic." },
            { correct: "} else if (strcmp(argv[1], \"list\") == 0) {", distractors: [], indent: 1, "explanation": "Check if the command is 'list'." },
            { correct: "  list_tasks();", distractors: [], indent: 2, "explanation": "Call the function to list all tasks." },
            { correct: "} else if (strcmp(argv[1], \"complete\") == 0) {", distractors: [], indent: 1, "explanation": "Check if the command is 'complete'." },
            { correct: "  if (argc < 3) {", distractors: [], indent: 2, "explanation": "The 'complete' command requires a task ID." },
            { correct: "    printf(\"Error: 'complete' command requires a task ID.\\n\");", distractors: [], indent: 3, "explanation": "Print an error if the ID is missing." },
            { correct: "    print_usage();", distractors: [], indent: 3, "explanation": "Show usage." },
            { correct: "  } else {", distractors: [], indent: 2, "explanation": "If the ID is provided..." },
            { correct: "    complete_task(atoi(argv[2]));", distractors: [], indent: 3, "explanation": "Convert the ID from a string to an integer with `atoi` and call the function." },
            { correct: "  }", distractors: [], indent: 2, "explanation": "Close the complete command logic." },
            { correct: "} else {", distractors: [], indent: 1, "explanation": "Handle any unknown commands." },
            { correct: "  printf(\"Error: Unknown command '%s'\\n\", argv[1]);", distractors: [], indent: 2, "explanation": "Print an error for an unrecognized command." },
            { correct: "  print_usage();", distractors: [], indent: 2, "explanation": "Show usage." },
            { correct: "}", distractors: [], indent: 1, "explanation": "Close the command parsing logic." },
            { correct: "free(tasks);", distractors: [], indent: 1, "explanation": "Before exiting, free the memory allocated for the tasks array." },
            { correct: "return 0;", distractors: [], indent: 1, "explanation": "Indicate successful execution." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the main function." },
            { correct: "// --- Function Implementations ---", distractors: [], indent: 0, "explanation": "Define the functions declared earlier." },
            { correct: "void load_tasks_from_file() {", distractors: [], indent: 0, "explanation": "Implementation for loading tasks." },
            { correct: "  FILE* fp = fopen(TASKS_FILENAME, \"r\");", distractors: [], indent: 1, "explanation": "Open the tasks file in read mode." },
            { correct: "  if (fp == NULL) {", distractors: [], indent: 1, "explanation": "If the file doesn't exist (e.g., first run), it's not an error." },
            { correct: "    return; // No tasks to load.", distractors: [], indent: 2, "explanation": "Simply return and start with an empty list." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the file check." },
            { correct: "  Task temp_task;", distractors: [], indent: 1, "explanation": "A temporary struct to hold data read from a line." },
            { correct: "  while(fscanf(fp, \"%d,%d,%[^\n]\n\", &temp_task.id, &temp_task.is_complete, temp_task.description) == 3) {", distractors: [], indent: 1, "explanation": "Read each line using a format string. `%[^\\n]` reads all characters until a newline." },
            { correct: "    add_task(temp_task.description); // Add task, but will get a new ID", distractors: [], indent: 2, "explanation": "Use our existing `add_task` logic to add the loaded task." },
            { correct: "    tasks[task_count - 1].is_complete = temp_task.is_complete; // Restore completion status", distractors: [], indent: 2, "explanation": "Update the completion status from the file." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the reading loop." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the file." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the load function." },
            { correct: "void save_tasks_to_file() {", distractors: [], indent: 0, "explanation": "Implementation for saving tasks." },
            { correct: "  FILE* fp = fopen(TASKS_FILENAME, \"w\");", distractors: [], indent: 1, "explanation": "Open the file in write mode, overwriting the old file." },
            { correct: "  if (fp == NULL) { perror(\"Error saving tasks\"); return; }", distractors: [], indent: 1, "explanation": "Handle potential errors with opening the file for writing." },
            { correct: "  for (int i = 0; i < task_count; i++) {", distractors: [], indent: 1, "explanation": "Loop through every task in our list." },
            { correct: "    fprintf(fp, \"%d,%d,%s\\n\", tasks[i].id, tasks[i].is_complete, tasks[i].description);", distractors: [], indent: 2, "explanation": "Write the task's data to the file in a comma-separated format." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the writing loop." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the file." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the save function." },
            { correct: "void add_task(const char* description) {", distractors: [], indent: 0, "explanation": "Implementation for adding a task." },
            { correct: "  task_count++;", distractors: [], indent: 1, "explanation": "Increment the total number of tasks." },
            { correct: "  Task* new_tasks = realloc(tasks, task_count * sizeof(Task));", distractors: [], indent: 1, "explanation": "Resize the dynamic array to make room for the new task. Using a temp pointer is safer but omitted for brevity." },
            { correct: "  if (new_tasks == NULL) { perror(\"Failed to add task\"); task_count--; return; }", distractors: [], indent: 1, "explanation": "Check if reallocation failed and revert the count." },
            { correct: "  tasks = new_tasks;", distractors: [], indent: 1, "explanation": "Assign the new memory block back to our global pointer." },
            { correct: "  tasks[task_count - 1].id = task_count;", distractors: [], indent: 1, "explanation": "Set the ID of the new task (simple 1-based indexing)." },
            { correct: "  tasks[task_count - 1].is_complete = 0;", distractors: [], indent: 1, "explanation": "New tasks are not complete by default." },
            { correct: "  strncpy(tasks[task_count - 1].description, description, MAX_TASK_LEN - 1);", distractors: [], indent: 1, "explanation": "Copy the description into the new task struct using `strncpy` for safety." },
            { correct: "  tasks[task_count - 1].description[MAX_TASK_LEN - 1] = '\\0';", distractors: [], indent: 1, "explanation": "Ensure the description is null-terminated." },
            { correct: "  printf(\"Added task %d: '%s'\\n\", task_count, description);", distractors: [], indent: 1, "explanation": "Print a confirmation message." },
            { correct: "  save_tasks_to_file();", distractors: [], indent: 1, "explanation": "Save the updated list to the file immediately." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the add function." },
            { correct: "void list_tasks() {", distractors: [], indent: 0, "explanation": "Implementation for listing tasks." },
            { correct: "  printf(\"\\n--- TO-DO LIST ---\\n\");", distractors: [], indent: 1, "explanation": "Print a header." },
            { correct: "  if (task_count == 0) {", distractors: [], indent: 1, "explanation": "Check if there are no tasks." },
            { correct: "    printf(\"No tasks found.\\n\");", distractors: [], indent: 2, "explanation": "Message for an empty list." },
            { correct: "  } else {", distractors: [], indent: 1, "explanation": "If there are tasks..." },
            { correct: "    for (int i = 0; i < task_count; i++) {", distractors: [], indent: 2, "explanation": "Loop through all tasks." },
            { correct: "      char status_char = tasks[i].is_complete ? 'X' : ' ';", distractors: [], indent: 3, "explanation": "Use a ternary operator to determine the status character." },
            { correct: "      printf(\"[%c] %d: %s\\n\", status_char, tasks[i].id, tasks[i].description);", distractors: [], indent: 3, "explanation": "Print the formatted task line." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the loop." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the else block." },
            { correct: "  printf(\"--------------------\\n\");", distractors: [], indent: 1, "explanation": "Print a footer." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the list function." },
            { correct: "void complete_task(int id) {", distractors: [], indent: 0, "explanation": "Implementation for completing a task." },
            { correct: "  if (id <= 0 || id > task_count) {", distractors: [], indent: 1, "explanation": "Validate the provided ID." },
            { correct: "    printf(\"Error: Invalid task ID %d\\n\", id);", distractors: [], indent: 2, "explanation": "Print an error for an invalid ID." },
            { correct: "    return;", distractors: [], indent: 2, "explanation": "Exit the function." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the validation." },
            { correct: "  tasks[id - 1].is_complete = 1;", distractors: [], indent: 1, "explanation": "Set the completion flag for the correct task (adjusting for 0-based array index)." },
            { correct: "  printf(\"Completed task %d: '%s'\\n\", id, tasks[id-1].description);", distractors: [], indent: 1, "explanation": "Print a confirmation message." },
            { correct: "  save_tasks_to_file();", distractors: [], indent: 1, "explanation": "Save the changes to the file." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the complete function." },
            { correct: "void print_usage() {", distractors: [], indent: 0, "explanation": "Implementation for printing usage." },
            { correct: "  printf(\"\\nUsage:\\n\");", distractors: [], indent: 1, "explanation": "Print usage header." },
            { correct: "  printf(\"  todo add \\\"<task description>\\\"  - Adds a new task\\n\");", distractors: [], indent: 1, "explanation": "Explain the 'add' command." },
            { correct: "  printf(\"  todo list                       - Lists all tasks\\n\");", distractors: [], indent: 1, "explanation": "Explain the 'list' command." },
            { correct: "  printf(\"  todo complete <task_id>         - Marks a task as complete\\n\");", distractors: [], indent: 1, "explanation": "Explain the 'complete' command." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the print_usage function." }
        ]
    },
    // Level 70: analyze data from CSV files
    {
        "goal": "Read and analyze data from a CSV file containing city population records.",
        concepts: "fgets, strtok, realloc, structs, file I/O, atof, error handling",
        sequence: [
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Include for file operations and printing." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Include for memory management and `atof`." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "Include for `strtok`, `strcpy`." },
            { correct: "#define MAX_LINE_LEN 512", distractors: [], indent: 0, "explanation": "Define max length for a line read from the file." },
            { correct: "#define MAX_FIELD_LEN 128", distractors: [], indent: 0, "explanation": "Define max length for any single field (like city name)." },
            { correct: "// Structure to hold the parsed data for one city.", distractors: [], indent: 0, "explanation": "Comment explaining the CityData struct." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin defining the CityData struct." },
            { correct: "  char name[MAX_FIELD_LEN];", distractors: [], indent: 1, "explanation": "The name of the city." },
            { correct: "  char country[MAX_FIELD_LEN];", distractors: [], indent: 1, "explanation": "The country of the city." },
            { correct: "  double population_millions;", distractors: [], indent: 1, "explanation": "The city's population in millions." },
            { correct: "} CityData;", distractors: [], indent: 0, "explanation": "Create the `CityData` alias." },
            { correct: "// --- Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare functions before use." },
            { correct: "int parse_csv(const char* filename, CityData** data_arr);", distractors: [], indent: 0, "explanation": "A function to parse the CSV, which will return the number of records found." },
            { correct: "void analyze_data(CityData* data_arr, int count);", distractors: [], indent: 0, "explanation": "A function to perform analysis on the parsed data." },
            { correct: "void free_data(CityData* data_arr);", distractors: [], indent: 0, "explanation": "A function to free the dynamically allocated memory." },
            { correct: "// --- Main Function ---", distractors: [], indent: 0, "explanation": "The main driver of the program." },
            { correct: "int main(int argc, char* argv[]) {", distractors: [], indent: 0, "explanation": "Start main, accepting command-line arguments." },
            { correct: "if (argc != 2) {", distractors: [], indent: 1, "explanation": "Check that the user provided exactly one argument: the filename." },
            { correct: "  printf(\"Usage: %s <csv_filename>\\n\", argv[0]);", distractors: [], indent: 2, "explanation": "Print usage instructions if the argument count is wrong." },
            { correct: "  return 1;", distractors: [], indent: 2, "explanation": "Exit with an error." },
            { correct: "}", distractors: [], indent: 1, "explanation": "Close argument check." },
            { correct: "CityData* all_cities = NULL;", distractors: [], indent: 1, "explanation": "Initialize the pointer for our dynamic array to NULL." },
            { correct: "int record_count = parse_csv(argv[1], &all_cities);", distractors: [], indent: 1, "explanation": "Call the parser, passing the filename and the address of our pointer." },
            { correct: "if (record_count > 0) {", distractors: [], indent: 1, "explanation": "If any records were successfully parsed..." },
            { correct: "  analyze_data(all_cities, record_count);", distractors: [], indent: 2, "explanation": "Perform the data analysis." },
            { correct: "  free_data(all_cities);", distractors: [], indent: 2, "explanation": "Free the allocated memory." },
            { correct: "}", distractors: [], indent: 1, "explanation": "Close the check." },
            { correct: "return 0;", distractors: [], indent: 1, "explanation": "Indicate successful execution." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the main function." },
            { correct: "// --- Function Implementations ---", distractors: [], indent: 0, "explanation": "Define the functions." },
            { correct: "int parse_csv(const char* filename, CityData** data_arr_ptr) {", distractors: [], indent: 0, "explanation": "Start the parser function definition. It takes a double pointer to modify the caller's pointer." },
            { correct: "  FILE* fp = fopen(filename, \"r\");", distractors: [], indent: 1, "explanation": "Open the specified file for reading." },
            { correct: "  if (!fp) { perror(\"Error opening file\"); return -1; }", distractors: [], indent: 1, "explanation": "Handle file open errors." },
            { correct: "  char line[MAX_LINE_LEN];", distractors: [], indent: 1, "explanation": "A buffer to hold one line from the file." },
            { correct: "  int count = 0;", distractors: [], indent: 1, "explanation": "A counter for the number of records parsed." },
            { correct: "  // Skip the header line", distractors: [], indent: 1, "explanation": "It's common for CSV files to have a header on the first line." },
            { correct: "  fgets(line, MAX_LINE_LEN, fp);", distractors: [], indent: 1, "explanation": "Read and discard the first line." },
            { correct: "  while (fgets(line, MAX_LINE_LEN, fp)) {", distractors: [], indent: 1, "explanation": "Loop, reading one line at a time into the buffer." },
            { correct: "    count++;", distractors: [], indent: 2, "explanation": "Increment the record counter." },
            { correct: "    *data_arr_ptr = realloc(*data_arr_ptr, count * sizeof(CityData));", distractors: [], indent: 2, "explanation": "Resize the dynamic array to fit the new record." },
            { correct: "    if (!(*data_arr_ptr)) { perror(\"realloc failed\"); fclose(fp); return -1; }", distractors: [], indent: 2, "explanation": "Check if reallocation failed." },
            { correct: "    CityData* current_record = &((*data_arr_ptr)[count - 1]);", distractors: [], indent: 2, "explanation": "Get a pointer to the newly allocated record for easier access." },
            { correct: "    // Tokenize the line", distractors: [], indent: 2, "explanation": "Comment on parsing the line." },
            { correct: "    char* token = strtok(line, \",\");", distractors: [], indent: 2, "explanation": "Get the first token (city name)." },
            { correct: "    if (token) strncpy(current_record->name, token, MAX_FIELD_LEN - 1);", distractors: [], indent: 2, "explanation": "If the token is valid, copy it to the struct." },
            { correct: "    token = strtok(NULL, \",\");", distractors: [], indent: 2, "explanation": "Get the second token (country name)." },
            { correct: "    if (token) strncpy(current_record->country, token, MAX_FIELD_LEN - 1);", distractors: [], indent: 2, "explanation": "Copy the country name." },
            { correct: "    token = strtok(NULL, \",\n\");", distractors: [], indent: 2, "explanation": "Get the third token (population), also using newline as a delimiter." },
            { correct: "    if (token) current_record->population_millions = atof(token);", distractors: [], indent: 2, "explanation": "Use `atof` (ASCII to float/double) to convert the population string to a number." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the file reading loop." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the file." },
            { correct: "  printf(\"Parsed %d records from %s\\n\", count, filename);", distractors: [], indent: 1, "explanation": "Print a summary of the parsing." },
            { correct: "  return count;", distractors: [], indent: 1, "explanation": "Return the total number of records parsed." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the parser function." },
            { correct: "void analyze_data(CityData* data_arr, int count) {", distractors: [], indent: 0, "explanation": "Implementation of the analysis function." },
            { correct: "  printf(\"\\n--- Data Analysis ---\\n\");", distractors: [], indent: 1, "explanation": "Print a header." },
            { correct: "  double total_population = 0.0;", distractors: [], indent: 1, "explanation": "Initialize a variable to accumulate the total population." },
            { correct: "  int us_cities_count = 0;", distractors: [], indent: 1, "explanation": "A counter for a specific query." },
            { correct: "  CityData* largest_city = &data_arr[0];", distractors: [], indent: 1, "explanation": "Assume the first city is the largest to start." },
            { correct: "  for (int i = 0; i < count; i++) {", distractors: [], indent: 1, "explanation": "Loop through all the parsed records." },
            { correct: "    total_population += data_arr[i].population_millions;", distractors: [], indent: 2, "explanation": "Add the current city's population to the total." },
            { correct: "    if (strcmp(data_arr[i].country, \"USA\") == 0) {", distractors: [], indent: 2, "explanation": "Check if the city is in the USA." },
            { correct: "      us_cities_count++;", distractors: [], indent: 3, "explanation": "Increment the USA city counter." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close country check." },
            { correct: "    if (data_arr[i].population_millions > largest_city->population_millions) {", distractors: [], indent: 2, "explanation": "Check if the current city is larger than the largest one found so far." },
            { correct: "      largest_city = &data_arr[i];", distractors: [], indent: 3, "explanation": "If it is, update our pointer to the largest city." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close largest city check." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the analysis loop." },
            { correct: "  // Print the results of the analysis", distractors: [], indent: 1, "explanation": "Comment on printing results." },
            { correct: "  double average_population = total_population / count;", distractors: [], indent: 1, "explanation": "Calculate the average population." },
            { correct: "  printf(\"Average population: %.2f million\\n\", average_population);", distractors: [], indent: 1, "explanation": "Print the average." },
            { correct: "  printf(\"Number of cities in USA: %d\\n\", us_cities_count);", distractors: [], indent: 1, "explanation": "Print the count of US cities." },
            { correct: "  printf(\"Largest city found: %s, %s (%.2f million)\\n\", largest_city->name, largest_city->country, largest_city->population_millions);", distractors: [], indent: 1, "explanation": "Print the details of the largest city found." },
            { correct: "  printf(\"---------------------\\n\");", distractors: [], indent: 1, "explanation": "Print a footer." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the analysis function." },
            { correct: "void free_data(CityData* data_arr) {", distractors: [], indent: 0, "explanation": "Implementation of the memory cleanup function." },
            { correct: "  free(data_arr);", distractors: [], indent: 1, "explanation": "Free the entire dynamic array." },
            { correct: "  printf(\"Memory has been freed.\\n\");", distractors: [], indent: 1, "explanation": "Confirmation message." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the free function." }
        ]
    },
    // Level 71: parsing .ini configuration files
    {
        "goal": "Build a reusable library for parsing .ini configuration files using opaque pointers and linked lists.",
        concepts: "Opaque pointers, linked lists, dynamic memory, file I/O, `strtok`, `strcpy`, encapsulation, API design",
        sequence: [
            { correct: "// === Stage 1: The Public API Header File (e.g., 'ini_parser.h') ===", distractors: [], indent: 0, "explanation": "We begin by defining the public interface that users of our library will see. Implementation details will be hidden." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Include for file operations, needed for function prototypes." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Include for `size_t` and memory allocation." },
            { correct: "// 1. Forward-declare the main struct without revealing its members.", distractors: [], indent: 0, "explanation": "This is the core of the opaque pointer technique. Users know the type `struct IniConfig` exists but not what's inside." },
            { correct: "struct IniConfig;", distractors: [], indent: 0, "explanation": "This makes `struct IniConfig` an incomplete type in this header." },
            { correct: "// 2. Create a typedef for a pointer to the opaque struct.", distractors: [], indent: 0, "explanation": "Users will interact exclusively with this handle, not the struct itself." },
            { correct: "typedef struct IniConfig* IniHandle;", distractors: [], indent: 0, "explanation": "Define `IniHandle` as the public type." },
            { correct: "// 3. Declare the public API functions.", distractors: [], indent: 0, "explanation": "These are the functions users can call." },
            { correct: "IniHandle ini_load(const char* filename);", distractors: [], indent: 0, "explanation": "Prototype for the function that loads and parses an INI file." },
            { correct: "const char* ini_get_string(IniHandle handle, const char* section, const char* key);", distractors: [], indent: 0, "explanation": "Prototype to get a string value from a specific section and key." },
            { correct: "int ini_get_integer(IniHandle handle, const char* section, const char* key, int default_val);", distractors: [], indent: 0, "explanation": "Prototype to get an integer value, with a default if not found." },
            { correct: "void ini_free(IniHandle handle);", distractors: [], indent: 0, "explanation": "Prototype for the function that frees all memory associated with the INI configuration." },
            { correct: "// === Stage 2: The Private Implementation File (e.g., 'ini_parser.c') ===", distractors: [], indent: 0, "explanation": "Now we switch to the source file where all the private logic and data structures are defined." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "Include for `strcpy`, `strtok`, `strcmp`." },
            { correct: "#include <ctype.h>", distractors: [], indent: 0, "explanation": "Include for `isspace` to trim whitespace." },
            { correct: "// #include \"ini_parser.h\" // In a real project, you'd include the header.", distractors: [], indent: 0, "explanation": "Include our own public header to ensure our definitions match the declarations." },
            { correct: "// 4. Define the private data structures.", distractors: [], indent: 0, "explanation": "These structs are the hidden implementation of our INI parser." },
            { correct: "typedef struct KeyValuePair {", distractors: [], indent: 0, "explanation": "A struct to hold a single key-value pair." },
            { correct: "  char* key;", distractors: [], indent: 1, "explanation": "The key string." },
            { correct: "  char* value;", distractors: [], indent: 1, "explanation": "The value string." },
            { correct: "  struct KeyValuePair* next;", distractors: [], indent: 1, "explanation": "Pointer to the next pair in the section." },
            { correct: "} KeyValuePair;", distractors: [], indent: 0, "explanation": "Close the KeyValuePair definition." },
            { correct: "typedef struct Section {", distractors: [], indent: 0, "explanation": "A struct to hold a section name and a list of its pairs." },
            { correct: "  char* name;", distractors: [], indent: 1, "explanation": "The name of the section (e.g., '[database]')." },
            { correct: "  KeyValuePair* pairs;", distractors: [], indent: 1, "explanation": "A pointer to the head of the linked list of key-value pairs." },
            { correct: "  struct Section* next;", distractors: [], indent: 1, "explanation": "Pointer to the next section in the file." },
            { correct: "} Section;", distractors: [], indent: 0, "explanation": "Close the Section definition." },
            { correct: "// 5. Provide the full definition for the previously opaque struct.", distractors: [], indent: 0, "explanation": "Here we complete the type that was hidden from the user." },
            { correct: "struct IniConfig {", distractors: [], indent: 0, "explanation": "The main handle struct." },
            { correct: "  Section* head;", distractors: [], indent: 1, "explanation": "It simply contains a pointer to the head of the sections linked list." },
            { correct: "};", distractors: [], indent: 0, "explanation": "Close the main struct definition." },
            { correct: "// 6. A helper function to trim leading/trailing whitespace.", distractors: [], indent: 0, "explanation": "Utility function for cleaning up parsed strings." },
            { correct: "char* trim_whitespace(char* str) {", distractors: [], indent: 0, "explanation": "Start the trim function." },
            { correct: "  char* end;", distractors: [], indent: 1, "explanation": "Declare a pointer to find the end of the string." },
            { correct: "  while (isspace((unsigned char)*str)) str++;", distractors: [], indent: 1, "explanation": "Move the start pointer forward past any leading whitespace." },
            { correct: "  if (*str == 0) return str;", distractors: [], indent: 1, "explanation": "If the whole string was whitespace, it's now empty." },
            { correct: "  end = str + strlen(str) - 1;", distractors: [], indent: 1, "explanation": "Point `end` to the last character." },
            { correct: "  while (end > str && isspace((unsigned char)*end)) end--;", distractors: [], indent: 1, "explanation": "Move `end` backward past any trailing whitespace." },
            { correct: "  end[1] = '\\0';", distractors: [], indent: 1, "explanation": "Write a null terminator after the last non-space character." },
            { correct: "  return str;", distractors: [], indent: 1, "explanation": "Return the pointer to the trimmed string." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the trim function." },
            { correct: "// 7. Implementation of the `ini_load` function.", distractors: [], indent: 0, "explanation": "This is the largest and most complex function." },
            { correct: "IniHandle ini_load(const char* filename) {", distractors: [], indent: 0, "explanation": "Start the definition of `ini_load`." },
            { correct: "  IniHandle handle = malloc(sizeof(struct IniConfig));", distractors: [], indent: 1, "explanation": "Allocate memory for the main config handle." },
            { correct: "  if (!handle) return NULL;", distractors: [], indent: 1, "explanation": "Check for allocation failure." },
            { correct: "  handle->head = NULL;", distractors: [], indent: 1, "explanation": "Initialize the head of the sections list to NULL." },
            { correct: "  FILE* fp = fopen(filename, \"r\");", distractors: [], indent: 1, "explanation": "Open the INI file for reading." },
            { correct: "  if (!fp) { free(handle); return NULL; }", distractors: [], indent: 1, "explanation": "If the file can't be opened, clean up and return NULL." },
            { correct: "  char line[512];", distractors: [], indent: 1, "explanation": "A buffer to read each line of the file." },
            { correct: "  Section* current_section = NULL;", distractors: [], indent: 1, "explanation": "A pointer to keep track of the section we are currently parsing." },
            { correct: "  while (fgets(line, sizeof(line), fp)) {", distractors: [], indent: 1, "explanation": "Loop, reading the file line by line." },
            { correct: "    char* trimmed_line = trim_whitespace(line);", distractors: [], indent: 2, "explanation": "Clean up the line first." },
            { correct: "    if (trimmed_line[0] == '#' || trimmed_line[0] == ';') continue; // Skip comments", distractors: [], indent: 2, "explanation": "Ignore lines that are comments." },
            { correct: "    if (trimmed_line[0] == '[') { // This is a section header", distractors: [], indent: 2, "explanation": "Check for a section header like `[database]`." },
            { correct: "      char* section_name = strtok(trimmed_line + 1, \"]\");", distractors: [], indent: 3, "explanation": "Use `strtok` to extract the name from between the brackets." },
            { correct: "      if (section_name) {", distractors: [], indent: 3, "explanation": "If a name was successfully extracted..." },
            { correct: "        current_section = malloc(sizeof(Section));", distractors: [], indent: 4, "explanation": "Allocate memory for a new Section struct." },
            { correct: "        current_section->name = strdup(section_name);", distractors: [], indent: 4, "explanation": "`strdup` allocates memory and copies the string in one step." },
            { correct: "        current_section->pairs = NULL;", distractors: [], indent: 4, "explanation": "Initialize the key-value pair list for this section." },
            { correct: "        current_section->next = handle->head;", distractors: [], indent: 4, "explanation": "Link the new section to the front of the main sections list." },
            { correct: "        handle->head = current_section;", distractors: [], indent: 4, "explanation": "Update the main handle's head to point to the new section." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close section name check." },
            { correct: "    } else if (current_section && strchr(trimmed_line, '=')) { // This is a key-value pair", distractors: [], indent: 2, "explanation": "Check if this line is a key-value pair within the current section." },
            { correct: "      char* key = strtok(trimmed_line, \"=\");", distractors: [], indent: 3, "explanation": "Get the part before the '=' as the key." },
            { correct: "      char* value = strtok(NULL, \"\"); // Get the rest of the line as the value", distractors: [], indent: 3, "explanation": "Get everything after the '=' as the value." },
            { correct: "      if (key && value) {", distractors: [], indent: 3, "explanation": "If both key and value were found..." },
            { correct: "        KeyValuePair* new_pair = malloc(sizeof(KeyValuePair));", distractors: [], indent: 4, "explanation": "Allocate memory for the new key-value pair." },
            { correct: "        new_pair->key = strdup(trim_whitespace(key));", distractors: [], indent: 4, "explanation": "Allocate and copy the trimmed key." },
            { correct: "        new_pair->value = strdup(trim_whitespace(value));", distractors: [], indent: 4, "explanation": "Allocate and copy the trimmed value." },
            { correct: "        new_pair->next = current_section->pairs;", distractors: [], indent: 4, "explanation": "Link the new pair to the front of the current section's pair list." },
            { correct: "        current_section->pairs = new_pair;", distractors: [], indent: 4, "explanation": "Update the section's head to point to the new pair." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close key/value check." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the else-if." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the `while fgets` loop." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the file." },
            { correct: "  return handle;", distractors: [], indent: 1, "explanation": "Return the fully parsed config handle." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the `ini_load` function." },
            { correct: "// 8. Implementation of getter functions.", distractors: [], indent: 0, "explanation": "Define the functions to retrieve data." },
            { correct: "const char* ini_get_string(IniHandle handle, const char* section, const char* key) {", distractors: [], indent: 0, "explanation": "Start the string getter function." },
            { correct: "  for (Section* s = handle->head; s != NULL; s = s->next) {", distractors: [], indent: 1, "explanation": "Iterate through the list of sections." },
            { correct: "    if (strcmp(s->name, section) == 0) {", distractors: [], indent: 2, "explanation": "If we find the correct section..." },
            { correct: "      for (KeyValuePair* p = s->pairs; p != NULL; p = p->next) {", distractors: [], indent: 3, "explanation": "Iterate through that section's list of key-value pairs." },
            { correct: "        if (strcmp(p->key, key) == 0) {", distractors: [], indent: 4, "explanation": "If we find the correct key..." },
            { correct: "          return p->value; // Found it!", distractors: [], indent: 5, "explanation": "Return the associated value." },
            { correct: "        }", distractors: [], indent: 4, "explanation": "Close key check." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close pairs loop." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close section check." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close sections loop." },
            { correct: "  return NULL; // Not found", distractors: [], indent: 1, "explanation": "If we finish the loops without a match, return NULL." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the string getter." },
            { correct: "int ini_get_integer(IniHandle handle, const char* section, const char* key, int default_val) {", distractors: [], indent: 0, "explanation": "Start the integer getter function." },
            { correct: "  const char* val_str = ini_get_string(handle, section, key);", distractors: [], indent: 1, "explanation": "First, try to get the value as a string." },
            { correct: "  if (val_str) {", distractors: [], indent: 1, "explanation": "If the string was found..." },
            { correct: "    return atoi(val_str);", distractors: [], indent: 2, "explanation": "Use `atoi` to convert it to an integer and return it." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close check." },
            { correct: "  return default_val;", distractors: [], indent: 1, "explanation": "If the string was not found, return the provided default value." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the integer getter." },
            { correct: "// 9. Implementation of the cleanup function.", distractors: [], indent: 0, "explanation": "Define the function to free all allocated memory." },
            { correct: "void ini_free(IniHandle handle) {", distractors: [], indent: 0, "explanation": "Start the free function." },
            { correct: "  Section* current_section = handle->head;", distractors: [], indent: 1, "explanation": "Get the head of the sections list." },
            { correct: "  while (current_section) {", distractors: [], indent: 1, "explanation": "Loop through all sections." },
            { correct: "    KeyValuePair* current_pair = current_section->pairs;", distractors: [], indent: 2, "explanation": "Get the head of the current section's pair list." },
            { correct: "    while (current_pair) {", distractors: [], indent: 2, "explanation": "Loop through all pairs in this section." },
            { correct: "      KeyValuePair* next_pair = current_pair->next;", distractors: [], indent: 3, "explanation": "Save the pointer to the next pair before freeing the current one." },
            { correct: "      free(current_pair->key);", distractors: [], indent: 3, "explanation": "Free the key string." },
            { correct: "      free(current_pair->value);", distractors: [], indent: 3, "explanation": "Free the value string." },
            { correct: "      free(current_pair);", distractors: [], indent: 3, "explanation": "Free the KeyValuePair struct itself." },
            { correct: "      current_pair = next_pair;", distractors: [], indent: 3, "explanation": "Move to the next pair." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close pairs loop." },
            { correct: "    Section* next_section = current_section->next;", distractors: [], indent: 2, "explanation": "Save the pointer to the next section." },
            { correct: "    free(current_section->name);", distractors: [], indent: 2, "explanation": "Free the section name string." },
            { correct: "    free(current_section);", distractors: [], indent: 2, "explanation": "Free the Section struct itself." },
            { correct: "    current_section = next_section;", distractors: [], indent: 2, "explanation": "Move to the next section." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close sections loop." },
            { correct: "  free(handle);", distractors: [], indent: 1, "explanation": "Finally, free the main handle struct." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the free function." },
            { correct: "// === Stage 3: The Main Program File (e.g., 'main.c') ===", distractors: [], indent: 0, "explanation": "A separate file that demonstrates how a user would use our library." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start the main user program." },
            { correct: "  // In a real project, this file would be in `config.ini`", distractors: [], indent: 1, "explanation": "Simulate the INI file content." },
            { correct: "  FILE* f = fopen(\"config.ini\", \"w\");", distractors: [], indent: 1, "explanation": "Create the dummy INI file for our test." },
            { correct: "  fprintf(f, \"; user settings\\n[user]\\nname=Alice\\nemail=alice@example.com\\n\");", distractors: [], indent: 1, "explanation": "Write the user section." },
            { correct: "  fprintf(f, \"\\n[database]\\nhost=localhost\\nport=5432\\n\");", distractors: [], indent: 1, "explanation": "Write the database section." },
            { correct: "  fclose(f);", distractors: [], indent: 1, "explanation": "Close the dummy file." },
            { correct: "  printf(\"Loading config.ini...\\n\");", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  IniHandle config = ini_load(\"config.ini\");", distractors: [], indent: 1, "explanation": "Load the configuration using our library's API." },
            { correct: "  if (!config) { printf(\"Failed to load config.\\n\"); return 1; }", distractors: [], indent: 1, "explanation": "Check if loading was successful." },
            { correct: "  printf(\"--- Retrieving Values ---\\n\");", distractors: [], indent: 1, "explanation": "Header for value retrieval." },
            { correct: "  const char* user_name = ini_get_string(config, \"user\", \"name\");", distractors: [], indent: 1, "explanation": "Get the user's name." },
            { correct: "  int db_port = ini_get_integer(config, \"database\", \"port\", 0);", distractors: [], indent: 1, "explanation": "Get the database port as an integer." },
            { correct: "  const char* db_pass = ini_get_string(config, \"database\", \"password\");", distractors: [], indent: 1, "explanation": "Attempt to get a key that doesn't exist." },
            { correct: "  printf(\"User Name: %s\\n\", user_name ? user_name : \"not found\");", distractors: [], indent: 1, "explanation": "Print the retrieved user name, handling a NULL return." },
            { correct: "  printf(\"Database Port: %d\\n\", db_port);", distractors: [], indent: 1, "explanation": "Print the retrieved database port." },
            { correct: "  printf(\"Database Password: %s\\n\", db_pass ? db_pass : \"not found\");", distractors: [], indent: 1, "explanation": "Show that the non-existent key was not found." },
            { correct: "  printf(\"--- Cleaning Up ---\\n\");", distractors: [], indent: 1, "explanation": "Header for cleanup." },
            { correct: "  ini_free(config);", distractors: [], indent: 1, "explanation": "Free all memory associated with the config using our API." },
            { correct: "  printf(\"Configuration freed successfully.\\n\");", distractors: [], indent: 1, "explanation": "Confirmation message." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
    // Level 72: stores records in a binary file
    {
        "goal": "Create a command-line contact book that stores records in a binary file.",
        concepts: "Binary I/O (`fread`/`fwrite`), struct serialization, `argc`/`argv`, `realloc`, `strstr`",
        sequence: [
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Include for standard I/O functions." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Include for memory management and exit()." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "Include for string manipulation functions." },
            { correct: "#define FILENAME \"contacts.dat\"", distractors: [], indent: 0, "explanation": "Define the name of our binary data file." },
            { correct: "#define MAX_NAME 50", distractors: [], indent: 0, "explanation": "Define the max length for a contact's name." },
            { correct: "#define MAX_EMAIL 50", distractors: [], indent: 0, "explanation": "Define the max length for a contact's email." },
            { correct: "// Define the structure for a single contact.", distractors: [], indent: 0, "explanation": "This struct will be written directly to the file." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin defining the Contact struct." },
            { correct: "  int id;", distractors: [], indent: 1, "explanation": "A unique ID for the contact." },
            { correct: "  char name[MAX_NAME];", distractors: [], indent: 1, "explanation": "Fixed-size array for the name." },
            { correct: "  char email[MAX_EMAIL];", distractors: [], indent: 1, "explanation": "Fixed-size array for the email." },
            { correct: "} Contact;", distractors: [], indent: 0, "explanation": "Create the `Contact` alias." },
            { correct: "// Global variables for our in-memory list of contacts.", distractors: [], indent: 0, "explanation": "Comment on the global contact list." },
            { correct: "Contact* contacts = NULL;", distractors: [], indent: 0, "explanation": "Pointer for the dynamic array of contacts." },
            { correct: "int contact_count = 0;", distractors: [], indent: 0, "explanation": "The number of contacts currently loaded." },
            { correct: "// --- Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare all functions before use." },
            { correct: "void load_contacts();", distractors: [], indent: 0, "explanation": "Prototype for loading contacts from the binary file." },
            { correct: "void save_contacts();", distractors: [], indent: 0, "explanation": "Prototype for saving the contact list to the binary file." },
            { correct: "void add_contact(const char* name, const char* email);", distractors: [], indent: 0, "explanation": "Prototype for adding a new contact." },
            { correct: "void list_contacts();", distractors: [], indent: 0, "explanation": "Prototype for listing all loaded contacts." },
            { correct: "void search_contacts(const char* query);", distractors: [], indent: 0, "explanation": "Prototype for searching contacts by name." },
            { correct: "void print_usage(const char* prog_name);", distractors: [], indent: 0, "explanation": "Prototype for printing help info." },
            { correct: "// --- Main Function: Entry Point & Command Parser ---", distractors: [], indent: 0, "explanation": "The main driver of the application." },
            { correct: "int main(int argc, char* argv[]) {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "load_contacts();", distractors: [], indent: 1, "explanation": "First, load existing contacts from the data file." },
            { correct: "if (argc < 2) { print_usage(argv[0]); return 1; }", distractors: [], indent: 1, "explanation": "If no command is given, print usage and exit." },
            { correct: "const char* command = argv[1];", distractors: [], indent: 1, "explanation": "Get the command from the arguments." },
            { correct: "if (strcmp(command, \"add\") == 0) {", distractors: [], indent: 1, "explanation": "Check if the command is 'add'." },
            { correct: "  if (argc != 4) {", distractors: [], indent: 2, "explanation": "The 'add' command needs a name and an email." },
            { correct: "    printf(\"Error: 'add' requires a name and an email.\\n\");", distractors: [], indent: 3, "explanation": "Show an error message." },
            { correct: "    print_usage(argv[0]);", distractors: [], indent: 3, "explanation": "Print usage." },
            { correct: "  } else {", distractors: [], indent: 2, "explanation": "If arguments are correct..." },
            { correct: "    add_contact(argv[2], argv[3]);", distractors: [], indent: 3, "explanation": "Call the add function with the provided name and email." },
            { correct: "  }", distractors: [], indent: 2, "explanation": "Close add logic." },
            { correct: "} else if (strcmp(command, \"list\") == 0) {", distractors: [], indent: 1, "explanation": "Check if the command is 'list'." },
            { correct: "  list_contacts();", distractors: [], indent: 2, "explanation": "Call the list function." },
            { correct: "} else if (strcmp(command, \"search\") == 0) {", distractors: [], indent: 1, "explanation": "Check if the command is 'search'." },
            { correct: "  if (argc != 3) {", distractors: [], indent: 2, "explanation": "The 'search' command requires a query term." },
            { correct: "    printf(\"Error: 'search' requires a name to search for.\\n\");", distractors: [], indent: 3, "explanation": "Show an error message." },
            { correct: "    print_usage(argv[0]);", distractors: [], indent: 3, "explanation": "Print usage." },
            { correct: "  } else {", distractors: [], indent: 2, "explanation": "If query is provided..." },
            { correct: "    search_contacts(argv[2]);", distractors: [], indent: 3, "explanation": "Call the search function." },
            { correct: "  }", distractors: [], indent: 2, "explanation": "Close search logic." },
            { correct: "} else {", distractors: [], indent: 1, "explanation": "Handle unknown commands." },
            { correct: "  printf(\"Error: Unknown command '%s'.\\n\", command);", distractors: [], indent: 2, "explanation": "Print an error for unrecognized commands." },
            { correct: "  print_usage(argv[0]);", distractors: [], indent: 2, "explanation": "Print usage." },
            { correct: "}", distractors: [], indent: 1, "explanation": "Close command parsing logic." },
            { correct: "if (contacts) { free(contacts); }", distractors: [], indent: 1, "explanation": "Before exiting, free the main contacts array if it was allocated." },
            { correct: "return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." },
            { correct: "// --- Function Implementations ---", distractors: [], indent: 0, "explanation": "Define the functions." },
            { correct: "void save_contacts() {", distractors: [], indent: 0, "explanation": "Start the `save_contacts` implementation." },
            { correct: "  FILE* fp = fopen(FILENAME, \"wb\");", distractors: [], indent: 1, "explanation": "Open the file in binary write mode ('wb')." },
            { correct: "  if (!fp) { perror(\"Failed to save contacts\"); return; }", distractors: [], indent: 1, "explanation": "Handle file open error." },
            { correct: "  // First, write the number of records. This makes loading much easier.", distractors: [], indent: 1, "explanation": "Comment on the file format design." },
            { correct: "  fwrite(&contact_count, sizeof(int), 1, fp);", distractors: [], indent: 1, "explanation": "Write the integer `contact_count` to the start of the file." },
            { correct: "  // Then, write the entire array of structs in one block.", distractors: [], indent: 1, "explanation": "Comment on writing the data block." },
            { correct: "  fwrite(contacts, sizeof(Contact), contact_count, fp);", distractors: [], indent: 1, "explanation": "Write the raw bytes of the `contacts` array directly to the file." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the file." },
            { correct: "  printf(\"Contacts saved successfully.\\n\");", distractors: [], indent: 1, "explanation": "Confirmation message." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `save_contacts`." },
            { correct: "void load_contacts() {", distractors: [], indent: 0, "explanation": "Start the `load_contacts` implementation." },
            { correct: "  FILE* fp = fopen(FILENAME, \"rb\");", distractors: [], indent: 1, "explanation": "Open the file in binary read mode ('rb')." },
            { correct: "  if (!fp) { return; } // File doesn't exist yet, which is fine.", distractors: [], indent: 1, "explanation": "If there's no file, there's nothing to load." },
            { correct: "  // First, read the number of records.", distractors: [], indent: 1, "explanation": "Comment on reading the count." },
            { correct: "  fread(&contact_count, sizeof(int), 1, fp);", distractors: [], indent: 1, "explanation": "Read the integer from the file into our global `contact_count` variable." },
            { correct: "  if (contact_count > 0) {", distractors: [], indent: 1, "explanation": "If there are records to read..." },
            { correct: "    contacts = malloc(contact_count * sizeof(Contact));", distractors: [], indent: 2, "explanation": "Allocate exactly enough memory for all the contacts." },
            { correct: "    if (!contacts) { perror(\"Failed to allocate memory for contacts\"); fclose(fp); exit(1); }", distractors: [], indent: 2, "explanation": "Handle memory allocation failure." },
            { correct: "    // Read the entire block of contact data from the file.", distractors: [], indent: 2, "explanation": "Comment on reading the data block." },
            { correct: "    fread(contacts, sizeof(Contact), contact_count, fp);", distractors: [], indent: 2, "explanation": "Read the raw byte data from the file directly into our newly allocated array." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the if block." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the file." },
            { correct: "  printf(\"Loaded %d contacts.\\n\", contact_count);", distractors: [], indent: 1, "explanation": "Confirmation message." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `load_contacts`." },
            { correct: "void add_contact(const char* name, const char* email) {", distractors: [], indent: 0, "explanation": "Start `add_contact` implementation." },
            { correct: "  contact_count++;", distractors: [], indent: 1, "explanation": "Increment the global counter." },
            { correct: "  contacts = realloc(contacts, contact_count * sizeof(Contact));", distractors: [], indent: 1, "explanation": "Resize the contacts array to make space for one more." },
            { correct: "  if (!contacts) { perror(\"Failed to realloc for new contact\"); exit(1); }", distractors: [], indent: 1, "explanation": "Handle reallocation failure." },
            { correct: "  Contact* new_contact = &contacts[contact_count - 1];", distractors: [], indent: 1, "explanation": "Get a pointer to the new slot at the end of the array." },
            { correct: "  new_contact->id = contact_count;", distractors: [], indent: 1, "explanation": "Assign the new ID." },
            { correct: "  strncpy(new_contact->name, name, MAX_NAME - 1);", distractors: [], indent: 1, "explanation": "Safely copy the name." },
            { correct: "  new_contact->name[MAX_NAME - 1] = '\\0';", distractors: [], indent: 1, "explanation": "Ensure null termination." },
            { correct: "  strncpy(new_contact->email, email, MAX_EMAIL - 1);", distractors: [], indent: 1, "explanation": "Safely copy the email." },
            { correct: "  new_contact->email[MAX_EMAIL - 1] = '\\0';", distractors: [], indent: 1, "explanation": "Ensure null termination." },
            { correct: "  save_contacts();", distractors: [], indent: 1, "explanation": "Call save to persist the new addition to the file." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `add_contact`." },
            { correct: "void list_contacts() {", distractors: [], indent: 0, "explanation": "Start `list_contacts` implementation." },
            { correct: "  printf(\"\\n--- Contact List (%d) ---\\n\", contact_count);", distractors: [], indent: 1, "explanation": "Print a formatted header." },
            { correct: "  for (int i=0; i < contact_count; i++) {", distractors: [], indent: 1, "explanation": "Loop through all loaded contacts." },
            { correct: "    printf(\"ID: %-3d | Name: %-20s | Email: %s\\n\", contacts[i].id, contacts[i].name, contacts[i].email);", distractors: [], indent: 2, "explanation": "Print the details of each contact with nice formatting." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the loop." },
            { correct: "  printf(\"----------------------------\\n\");", distractors: [], indent: 1, "explanation": "Print a footer." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `list_contacts`." },
            { correct: "void search_contacts(const char* query) {", distractors: [], indent: 0, "explanation": "Start `Contactss` implementation." },
            { correct: "  printf(\"\\n--- Search Results for \\\"%s\\\" ---\\n\", query);", distractors: [], indent: 1, "explanation": "Print a search header." },
            { correct: "  int found_count = 0;", distractors: [], indent: 1, "explanation": "A counter for the number of matches." },
            { correct: "  for (int i=0; i < contact_count; i++) {", distractors: [], indent: 1, "explanation": "Loop through all contacts." },
            { correct: "    // `strstr` finds the first occurrence of a substring. It's case-sensitive.", distractors: [], indent: 2, "explanation": "Explain `strstr`." },
            { correct: "    if (strstr(contacts[i].name, query) != NULL) {", distractors: [{text:"if (strcmp(contacts[i].name, query) == 0) {", reason:"`strcmp` only finds exact matches. `strstr` finds the query as a substring anywhere within the name, which is better for searching."}], indent: 2, "explanation": "Use `strstr` to see if the query appears anywhere in the contact's name." },
            { correct: "      printf(\"ID: %-3d | Name: %-20s | Email: %s\\n\", contacts[i].id, contacts[i].name, contacts[i].email);", distractors: [], indent: 3, "explanation": "If it's a match, print the contact's details." },
            { correct: "      found_count++;", distractors: [], indent: 3, "explanation": "Increment the match counter." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the if block." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the search loop." },
            { correct: "  if (found_count == 0) {", distractors: [], indent: 1, "explanation": "Check if no matches were found." },
            { correct: "    printf(\"No contacts found matching your query.\\n\");", distractors: [], indent: 2, "explanation": "Print a not-found message." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the check." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `Contactss`." },
            { correct: "void print_usage(const char* prog_name) {", distractors: [], indent: 0, "explanation": "Start `print_usage` implementation." },
            { correct: "  printf(\"\\nUsage: %s <command> [options]\\n\", prog_name);", distractors: [], indent: 1, "explanation": "Print main usage line." },
            { correct: "  printf(\"Commands:\\n\");", distractors: [], indent: 1, "explanation": "Header for commands." },
            { correct: "  printf(\"  list                            - Show all contacts.\\n\");", distractors: [], indent: 1, "explanation": "Explain list command." },
            { correct: "  printf(\"  add <name> <email>            - Add a new contact.\\n\");", distractors: [], indent: 1, "explanation": "Explain add command." },
            { correct: "  printf(\"  search <name_query>           - Search for contacts by name.\\n\");", distractors: [], indent: 1, "explanation": "Explain search command." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `print_usage`." }
        ]
    },
    // Level 73: storing key-value pairs in a hash table
    {
        "goal": "Build a read-only parser for a subset of JSON, storing key-value pairs in a hash table.",
        concepts: "Hash tables, hashing functions, linked lists, dynamic memory, string parsing, `strtok`",
        sequence: [
            { correct: "// --- Stage 1: Core Data Structures ---", distractors: [], indent: 0, "explanation": "First, we define the structures needed to store our parsed JSON data." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Include for standard I/O." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Include for memory allocation." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "Include for string manipulation." },
            { correct: "#define HASH_TABLE_SIZE 64", distractors: [], indent: 0, "explanation": "Define the size of our hash table. A power of 2 is often chosen." },
            { correct: "// A Key-Value pair, forming a node in a linked list for collision handling.", distractors: [], indent: 0, "explanation": "Comment on the K-V pair struct." },
            { correct: "typedef struct KeyValuePair {", distractors: [], indent: 0, "explanation": "Begin KeyValuePair definition." },
            { correct: "  char* key;", distractors: [], indent: 1, "explanation": "The JSON key (string)." },
            { correct: "  char* value;", distractors: [], indent: 1, "explanation": "The JSON value (stored as a string)." },
            { correct: "  struct KeyValuePair* next;", distractors: [], indent: 1, "explanation": "Pointer to the next item in the case of a hash collision." },
            { correct: "} KeyValuePair;", distractors: [], indent: 0, "explanation": "Close the KeyValuePair typedef." },
            { correct: "// The Hash Table structure itself.", distractors: [], indent: 0, "explanation": "Comment on the main Hash Table struct." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin HashTable definition." },
            { correct: "  KeyValuePair* buckets[HASH_TABLE_SIZE];", distractors: [], indent: 1, "explanation": "An array of pointers, where each element (bucket) is the head of a linked list." },
            { correct: "} HashTable;", distractors: [], indent: 0, "explanation": "Close the HashTable typedef." },
            { correct: "// --- Stage 2: Hash Table Functions ---", distractors: [], indent: 0, "explanation": "Now, we implement the core functions to operate on our hash table." },
            { correct: "unsigned long hash_function(const char* str) {", distractors: [], indent: 0, "explanation": "Define a hashing function to convert a string key into an index." },
            { correct: "  unsigned long hash = 5381;", distractors: [], indent: 1, "explanation": "Start with a magic prime number (part of the djb2 algorithm)." },
            { correct: "  int c;", distractors: [], indent: 1, "explanation": "A variable to hold the current character." },
            { correct: "  while ((c = *str++)) {", distractors: [], indent: 1, "explanation": "Loop through each character of the string." },
            { correct: "    hash = ((hash << 5) + hash) + c; /* hash * 33 + c */", distractors: [], indent: 2, "explanation": "Apply the djb2 hashing algorithm logic." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the loop." },
            { correct: "  return hash % HASH_TABLE_SIZE;", distractors: [], indent: 1, "explanation": "Use the modulo operator to ensure the hash fits within our table size." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the hash function." },
            { correct: "HashTable* ht_create() {", distractors: [], indent: 0, "explanation": "A 'constructor' function to create and initialize a new hash table." },
            { correct: "  HashTable* ht = malloc(sizeof(HashTable));", distractors: [], indent: 1, "explanation": "Allocate memory for the main table structure." },
            { correct: "  if (!ht) return NULL;", distractors: [], indent: 1, "explanation": "Handle allocation failure." },
            { correct: "  memset(ht->buckets, 0, sizeof(ht->buckets));", distractors: [], indent: 1, "explanation": "Use `memset` to initialize all bucket pointers to NULL." },
            { correct: "  return ht;", distractors: [], indent: 1, "explanation": "Return the newly created hash table." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the create function." },
            { correct: "void ht_set(HashTable* ht, const char* key, const char* value) {", distractors: [], indent: 0, "explanation": "Function to insert a key-value pair into the hash table." },
            { correct: "  unsigned long index = hash_function(key);", distractors: [], indent: 1, "explanation": "Calculate the index for this key." },
            { correct: "  KeyValuePair* new_pair = malloc(sizeof(KeyValuePair));", distractors: [], indent: 1, "explanation": "Allocate memory for the new key-value pair node." },
            { correct: "  new_pair->key = strdup(key);", distractors: [], indent: 1, "explanation": "Use `strdup` to allocate and copy the key." },
            { correct: "  new_pair->value = strdup(value);", distractors: [], indent: 1, "explanation": "Use `strdup` to allocate and copy the value." },
            { correct: "  // Insert at the head of the linked list for this bucket (handles collisions).", distractors: [], indent: 1, "explanation": "Comment on collision handling." },
            { correct: "  new_pair->next = ht->buckets[index];", distractors: [], indent: 1, "explanation": "The new pair's `next` points to the current head of the list." },
            { correct: "  ht->buckets[index] = new_pair;", distractors: [], indent: 1, "explanation": "The new pair becomes the new head of the list." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the set function." },
            { correct: "const char* ht_get(HashTable* ht, const char* key) {", distractors: [], indent: 0, "explanation": "Function to retrieve a value from the hash table by its key." },
            { correct: "  unsigned long index = hash_function(key);", distractors: [], indent: 1, "explanation": "Calculate the index where the key should be." },
            { correct: "  KeyValuePair* current = ht->buckets[index];", distractors: [], indent: 1, "explanation": "Get the head of the linked list at that index." },
            { correct: "  while (current) {", distractors: [], indent: 1, "explanation": "Traverse the linked list (if any)." },
            { correct: "    if (strcmp(current->key, key) == 0) {", distractors: [], indent: 2, "explanation": "Compare the current node's key with the key we're looking for." },
            { correct: "      return current->value; // Found it!", distractors: [], indent: 3, "explanation": "If it's a match, return the value." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the string comparison." },
            { correct: "    current = current->next;", distractors: [], indent: 2, "explanation": "Move to the next node in the list." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the traversal loop." },
            { correct: "  return NULL; // Key not found.", distractors: [], indent: 1, "explanation": "If the loop finishes, the key was not in the table." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the get function." },
            { correct: "void ht_free(HashTable* ht) {", distractors: [], indent: 0, "explanation": "Function to free all memory used by the hash table." },
            { correct: "  for (int i = 0; i < HASH_TABLE_SIZE; i++) {", distractors: [], indent: 1, "explanation": "Iterate through every bucket in the table." },
            { correct: "    KeyValuePair* current = ht->buckets[i];", distractors: [], indent: 2, "explanation": "Get the head of the list for the current bucket." },
            { correct: "    while (current) {", distractors: [], indent: 2, "explanation": "Loop through the linked list to free each node." },
            { correct: "      KeyValuePair* next = current->next;", distractors: [], indent: 3, "explanation": "Save the next pointer before freeing the current node." },
            { correct: "      free(current->key);", distractors: [], indent: 3, "explanation": "Free the key string." },
            { correct: "      free(current->value);", distractors: [], indent: 3, "explanation": "Free the value string." },
            { correct: "      free(current);", distractors: [], indent: 3, "explanation": "Free the node struct itself." },
            { correct: "      current = next;", distractors: [], indent: 3, "explanation": "Move to the next node." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the inner loop." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the outer loop." },
            { correct: "  free(ht);", distractors: [], indent: 1, "explanation": "Finally, free the hash table structure itself." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the free function." },
            { correct: "// --- Stage 3: The JSON Parser Logic ---", distractors: [], indent: 0, "explanation": "This function will take a raw string and parse it into our hash table." },
            { correct: "HashTable* json_parse(char* json_string) {", distractors: [], indent: 0, "explanation": "The main parser function." },
            { correct: "  HashTable* ht = ht_create();", distractors: [], indent: 1, "explanation": "Create a new hash table to store the results." },
            { correct: "  if (!ht) return NULL;", distractors: [], indent: 1, "explanation": "Handle creation failure." },
            { correct: "  // This is a simplified parser: it assumes a flat JSON object.", distractors: [], indent: 1, "explanation": "Note about the limitations of this simple parser." },
            { correct: "  const char* delimiters = \"\\\"\\t\\n\\r ,{}\";", distractors: [], indent: 1, "explanation": "Define all the characters we want `strtok` to split on or ignore." },
            { correct: "  char* token = strtok(json_string, delimiters);", distractors: [], indent: 1, "explanation": "Get the first token." },
            { correct: "  while (token) {", distractors: [], indent: 1, "explanation": "Loop while we have tokens." },
            { correct: "    char* key = token;", distractors: [], indent: 2, "explanation": "Assume the current token is a key." },
            { correct: "    char* value_token = strtok(NULL, \":\"); // Find the colon", distractors: [], indent: 2, "explanation": "Find the colon separator." },
            { correct: "    value_token = strtok(NULL, delimiters); // The next token is the value", distractors: [], indent: 2, "explanation": "Get the actual value token." },
            { correct: "    if (key && value_token) {", distractors: [], indent: 2, "explanation": "If we successfully found a key and a value..." },
            { correct: "      ht_set(ht, key, value_token);", distractors: [], indent: 3, "explanation": "Set the key-value pair in our hash table." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the if check." },
            { correct: "    token = strtok(NULL, delimiters);", distractors: [], indent: 2, "explanation": "Move to the next token, which should be the next key." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the parsing loop." },
            { correct: "  return ht;", distractors: [], indent: 1, "explanation": "Return the populated hash table." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the JSON parser function." },
            { correct: "// --- Stage 4: Main Program to Demonstrate the Parser ---", distractors: [], indent: 0, "explanation": "Now we write a `main` function to test our parser." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  // The JSON string we want to parse. Note: must be a modifiable char array.", distractors: [], indent: 1, "explanation": "Comment on the JSON source string." },
            { correct: "  char json_data[] = \"{ \\\"name\\\": \\\"Alice\\\", \\\"level\\\": 15, \\\"is_active\\\": true }\";", distractors: [], indent: 1, "explanation": "Define the source JSON data." },
            { correct: "  printf(\"Parsing JSON: %s\\n\\n\", json_data);", distractors: [], indent: 1, "explanation": "Print the source data." },
            { correct: "  HashTable* config = json_parse(json_data);", distractors: [], indent: 1, "explanation": "Call our parser to get the hash table." },
            { correct: "  if (!config) { printf(\"Failed to parse JSON.\\n\"); return 1; }", distractors: [], indent: 1, "explanation": "Handle parsing failure." },
            { correct: "  printf(\"--- Retrieving Parsed Values ---\\n\");", distractors: [], indent: 1, "explanation": "Header for the results." },
            { correct: "  const char* name = ht_get(config, \"name\");", distractors: [], indent: 1, "explanation": "Retrieve the 'name' value." },
            { correct: "  const char* level_str = ht_get(config, \"level\");", distractors: [], indent: 1, "explanation": "Retrieve the 'level' value (as a string)." },
            { correct: "  const char* active_str = ht_get(config, \"is_active\");", distractors: [], indent: 1, "explanation": "Retrieve the 'is_active' value (as a string)." },
            { correct: "  const char* not_found = ht_get(config, \"city\");", distractors: [], indent: 1, "explanation": "Attempt to retrieve a key that doesn't exist." },
            { correct: "  printf(\"Name: %s\\n\", name ? name : \"N/A\");", distractors: [], indent: 1, "explanation": "Print the name, checking for NULL." },
            { correct: "  if (level_str) { printf(\"Level: %d\\n\", atoi(level_str)); }", distractors: [], indent: 1, "explanation": "If level was found, convert to int and print." },
            { correct: "  printf(\"Is Active: %s\\n\", active_str ? active_str : \"N/A\");", distractors: [], indent: 1, "explanation": "Print the active status." },
            { correct: "  printf(\"City: %s\\n\", not_found ? not_found : \"N/A\");", distractors: [], indent: 1, "explanation": "Confirm that the non-existent key returned N/A." },
            { correct: "  printf(\"\\n--- Cleaning up ---\\n\");", distractors: [], indent: 1, "explanation": "Header for cleanup." },
            { correct: "  ht_free(config);", distractors: [], indent: 1, "explanation": "Free all memory used by the hash table and its contents." },
            { correct: "  printf(\"Memory freed successfully.\\n\");", distractors: [], indent: 1, "explanation": "Confirmation message." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
    // Level 74: rank the most frequent IP addresses in a log file
    {
        "goal": "Build a high-performance log analyzer to find and rank the most frequent IP addresses in a log file.",
        concepts: "Hash tables, `qsort`, file I/O, `fgets`, string parsing, performance",
        sequence: [
            { correct: "// --- Stage 1: Includes and Data Structures ---", distractors: [], indent: 0, "explanation": "Setup the necessary includes and the data structures for storing IP counts." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Memory management and `qsort`." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "String manipulation." },
            { correct: "#define HASH_TABLE_SIZE 1024", distractors: [], indent: 0, "explanation": "A larger hash table size for potentially many unique IPs." },
            { correct: "// A node in the hash table to store an IP and its frequency count.", distractors: [], indent: 0, "explanation": "Comment on the IP count struct." },
            { correct: "typedef struct IP_Entry {", distractors: [], indent: 0, "explanation": "Begin IP_Entry definition." },
            { correct: "  char ip_addr[16]; // xxx.xxx.xxx.xxx\\0", distractors: [], indent: 1, "explanation": "Fixed-size buffer to store the IP address string." },
            { correct: "  int count;", distractors: [], indent: 1, "explanation": "The frequency of this IP." },
            { correct: "  struct IP_Entry* next;", distractors: [], indent: 1, "explanation": "Pointer for collision handling linked list." },
            { correct: "} IP_Entry;", distractors: [], indent: 0, "explanation": "Close the IP_Entry typedef." },
            { correct: "// The Hash Table itself, an array of pointers to entries.", distractors: [], indent: 0, "explanation": "Comment on the hash table." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin HashTable definition." },
            { correct: "  IP_Entry* buckets[HASH_TABLE_SIZE];", distractors: [], indent: 1, "explanation": "The array of buckets, each being the head of a linked list." },
            { correct: "} HashTable;", distractors: [], indent: 0, "explanation": "Close the HashTable typedef." },
            { correct: "// --- Stage 2: Hash Table and Parser Implementation ---", distractors: [], indent: 0, "explanation": "Implement the functions needed to manage the hash table and process the log file." },
            { correct: "unsigned long hash_function(const char* str) {", distractors: [], indent: 0, "explanation": "The same djb2 hash function as before, good for general string hashing." },
            { correct: "  unsigned long hash = 5381;", distractors: [], indent: 1, "explanation": "Start with the magic prime." },
            { correct: "  int c; while ((c = *str++)) { hash = ((hash << 5) + hash) + c; }", distractors: [], indent: 1, "explanation": "Loop through the string and apply the hashing algorithm." },
            { correct: "  return hash % HASH_TABLE_SIZE;", distractors: [], indent: 1, "explanation": "Constrain the hash value to the table size." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the hash function." },
            { correct: "HashTable* ht_create() {", distractors: [], indent: 0, "explanation": "The constructor for our hash table." },
            { correct: "  HashTable* ht = malloc(sizeof(HashTable));", distractors: [], indent: 1, "explanation": "Allocate memory for the table structure." },
            { correct: "  memset(ht->buckets, 0, sizeof(ht->buckets));", distractors: [], indent: 1, "explanation": "Initialize all buckets to NULL." },
            { correct: "  return ht;", distractors: [], indent: 1, "explanation": "Return the new table." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the constructor." },
            { correct: "void ht_increment(HashTable* ht, const char* ip) {", distractors: [], indent: 0, "explanation": "A function to find an IP in the table and increment its count, or add it if not found." },
            { correct: "  unsigned long index = hash_function(ip);", distractors: [], indent: 1, "explanation": "Calculate the index for the given IP." },
            { correct: "  IP_Entry* current = ht->buckets[index];", distractors: [], indent: 1, "explanation": "Get the head of the list for this bucket." },
            { correct: "  while (current) {", distractors: [], indent: 1, "explanation": "Traverse the linked list to find an existing entry." },
            { correct: "    if (strcmp(current->ip_addr, ip) == 0) {", distractors: [], indent: 2, "explanation": "If the IP address already exists in the table..." },
            { correct: "      current->count++; // Increment count and we're done.", distractors: [], indent: 3, "explanation": "Increment its count." },
            { correct: "      return;", distractors: [], indent: 3, "explanation": "Exit the function." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the string compare." },
            { correct: "    current = current->next;", distractors: [], indent: 2, "explanation": "Move to the next entry in the list." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the traversal loop." },
            { correct: "  // If we get here, the IP was not found. We must add a new entry.", distractors: [], indent: 1, "explanation": "Comment on adding a new entry." },
            { correct: "  IP_Entry* new_entry = malloc(sizeof(IP_Entry));", distractors: [], indent: 1, "explanation": "Allocate memory for the new entry." },
            { correct: "  strncpy(new_entry->ip_addr, ip, 15);", distractors: [], indent: 1, "explanation": "Copy the IP address string into the new entry." },
            { correct: "  new_entry->ip_addr[15] = '\\0';", distractors: [], indent: 1, "explanation": "Ensure null termination." },
            { correct: "  new_entry->count = 1;", distractors: [], indent: 1, "explanation": "Initialize its count to 1." },
            { correct: "  new_entry->next = ht->buckets[index];", distractors: [], indent: 1, "explanation": "Link the new entry to the front of the list." },
            { correct: "  ht->buckets[index] = new_entry;", distractors: [], indent: 1, "explanation": "The new entry becomes the new head." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the increment function." },
            { correct: "int parse_log_file(const char* filename, HashTable* ht) {", distractors: [], indent: 0, "explanation": "Function to read the log file and populate the hash table." },
            { correct: "  FILE* fp = fopen(filename, \"r\");", distractors: [], indent: 1, "explanation": "Open the log file." },
            { correct: "  if (!fp) { perror(\"Failed to open log file\"); return 0; }", distractors: [], indent: 1, "explanation": "Handle file open error." },
            { correct: "  char line[256];", distractors: [], indent: 1, "explanation": "A buffer to hold each line." },
            { correct: "  int lines_processed = 0;", distractors: [], indent: 1, "explanation": "A counter for processed lines." },
            { correct: "  while (fgets(line, sizeof(line), fp)) {", distractors: [], indent: 1, "explanation": "Read the file line by line." },
            { correct: "    // Assuming the IP address is the first word on the line.", distractors: [], indent: 2, "explanation": "State our assumption about the log format." },
            { correct: "    char* ip = strtok(line, \" \\t\\n\");", distractors: [], indent: 2, "explanation": "Use `strtok` to extract the first token (the IP)." },
            { correct: "    if (ip) {", distractors: [], indent: 2, "explanation": "If a token was found..." },
            { correct: "      ht_increment(ht, ip);", distractors: [], indent: 3, "explanation": "Increment the count for this IP in our hash table." },
            { correct: "      lines_processed++;", distractors: [], indent: 3, "explanation": "Increment the line counter." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the if block." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the while loop." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the log file." },
            { correct: "  return lines_processed;", distractors: [], indent: 1, "explanation": "Return the total number of lines processed." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the log parser function." },
            { correct: "// --- Stage 3: Analysis and Reporting ---", distractors: [], indent: 0, "explanation": "Functions to convert the hash table data into a sortable array and print the results." },
            { correct: "int compare_entries_by_count(const void* a, const void* b) {", distractors: [], indent: 0, "explanation": "A comparison function for `qsort` to sort entries by count in descending order." },
            { correct: "  IP_Entry* entryA = *(IP_Entry**)a;", distractors: [], indent: 1, "explanation": "We will be sorting an array of *pointers* to entries, so we need to dereference twice." },
            { correct: "  IP_Entry* entryB = *(IP_Entry**)b;", distractors: [], indent: 1, "explanation": "Cast and dereference the second argument." },
            { correct: "  return entryB->count - entryA->count; // Descending order", distractors: [], indent: 1, "explanation": "Subtract B from A to sort from highest to lowest." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the comparison function." },
            { correct: "void report_top_ips(HashTable* ht, int top_n) {", distractors: [], indent: 0, "explanation": "The main analysis and reporting function." },
            { correct: "  // First, count the total number of unique IPs.", distractors: [], indent: 1, "explanation": "Comment on the first step." },
            { correct: "  int unique_ips = 0;", distractors: [], indent: 1, "explanation": "Initialize a counter." },
            { correct: "  for (int i=0; i<HASH_TABLE_SIZE; i++) {", distractors: [], indent: 1, "explanation": "Loop through all buckets." },
            { correct: "    for (IP_Entry* c = ht->buckets[i]; c != NULL; c = c->next) { unique_ips++; }", distractors: [], indent: 2, "explanation": "Traverse each linked list and increment the counter." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the counting loop." },
            { correct: "  printf(\"\\n--- Analysis Report ---\\n\");", distractors: [], indent: 1, "explanation": "Print a report header." },
            { correct: "  printf(\"Found %d unique IP addresses.\\n\", unique_ips);", distractors: [], indent: 1, "explanation": "Print the unique IP count." },
            { correct: "  if (unique_ips == 0) return;", distractors: [], indent: 1, "explanation": "If no IPs were found, we can stop here." },
            { correct: "  // Create a flat array of pointers to all entries to make it sortable.", distractors: [], indent: 1, "explanation": "Comment on creating the sortable array." },
            { correct: "  IP_Entry** sortable_array = malloc(unique_ips * sizeof(IP_Entry*));", distractors: [], indent: 1, "explanation": "Allocate memory for an array of pointers." },
            { correct: "  int idx = 0;", distractors: [], indent: 1, "explanation": "An index for our new flat array." },
            { correct: "  for (int i=0; i<HASH_TABLE_SIZE; i++) {", distractors: [], indent: 1, "explanation": "Loop through the hash table buckets again." },
            { correct: "    for (IP_Entry* c = ht->buckets[i]; c != NULL; c = c->next) {", distractors: [], indent: 2, "explanation": "Traverse each linked list." },
            { correct: "      sortable_array[idx++] = c;", distractors: [], indent: 3, "explanation": "Copy the pointer to the entry into our flat array." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close inner loop." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close outer loop." },
            { correct: "  // Sort the flat array using qsort.", distractors: [], indent: 1, "explanation": "Comment on the sorting step." },
            { correct: "  qsort(sortable_array, unique_ips, sizeof(IP_Entry*), compare_entries_by_count);", distractors: [], indent: 1, "explanation": "Call `qsort` on our array of pointers." },
            { correct: "  printf(\"\\n--- Top %d Most Frequent IPs ---\\n\", top_n);", distractors: [], indent: 1, "explanation": "Print a header for the final results." },
            { correct: "  for (int i = 0; i < top_n && i < unique_ips; i++) {", distractors: [], indent: 1, "explanation": "Loop to print the top N results, ensuring we don't go out of bounds." },
            { correct: "    printf(\"%3d. IP: %-15s | Count: %d\\n\", i + 1, sortable_array[i]->ip_addr, sortable_array[i]->count);", distractors: [], indent: 2, "explanation": "Print the ranked IP address and its count." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the printing loop." },
            { correct: "  free(sortable_array);", distractors: [], indent: 1, "explanation": "Free the temporary sortable array." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the reporting function." },
            { correct: "// --- Stage 4: Main Program Driver ---", distractors: [], indent: 0, "explanation": "The main function to tie it all together." },
            { correct: "int main(int argc, char* argv[]) {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  if (argc != 2) { printf(\"Usage: %s <logfile>\\n\", argv[0]); return 1; }", distractors: [], indent: 1, "explanation": "Check for the correct number of arguments." },
            { correct: "  HashTable* ht = ht_create();", distractors: [], indent: 1, "explanation": "Create our hash table." },
            { correct: "  printf(\"Processing log file: %s\\n\", argv[1]);", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  parse_log_file(argv[1], ht);", distractors: [], indent: 1, "explanation": "Parse the specified log file." },
            { correct: "  report_top_ips(ht, 10);", distractors: [], indent: 1, "explanation": "Generate and print a report for the top 10 IPs." },
            { correct: "  // The `ht_free` function would go here to clean up memory.", distractors: [], indent: 1, "explanation": "Comment on where final cleanup would occur." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
     // Level 75: reusable dynamic array (vector)
    {
        "goal": "Build a generic, reusable dynamic array (vector) library that manages its own memory.",
        concepts: "void* pointers, realloc, API design, qsort, function pointers, encapsulation",
        sequence: [
            { correct: "// === Stage 1: The Public API Header File (e.g., 'vector.h') ===", distractors: [], indent: 0, "explanation": "We define the public interface for our vector library. All implementation details will be hidden." },
            { correct: "#include <stdlib.h> // For size_t", distractors: [], indent: 0, "explanation": "Include for the `size_t` type." },
            { correct: "// Opaque declaration of the Vector struct. The user doesn't know what's inside.", distractors: [], indent: 0, "explanation": "Forward-declare the struct to hide its implementation." },
            { correct: "struct Vector;", distractors: [], indent: 0, "explanation": "Declare the incomplete type `struct Vector`." },
            { correct: "typedef struct Vector* VectorHandle;", distractors: [], indent: 0, "explanation": "Create a handle that users will interact with." },
            { correct: "// --- Public API Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare the functions that make up our library's API." },
            { correct: "VectorHandle vector_create();", distractors: [], indent: 0, "explanation": "Creates and returns a new, empty vector." },
            { correct: "void vector_destroy(VectorHandle vec);", distractors: [], indent: 0, "explanation": "Frees all memory associated with the vector." },
            { correct: "size_t vector_size(const VectorHandle vec);", distractors: [], indent: 0, "explanation": "Returns the number of elements currently in the vector." },
            { correct: "void vector_push_back(VectorHandle vec, void* item);", distractors: [], indent: 0, "explanation": "Adds an item to the end of the vector." },
            { correct: "void* vector_get(const VectorHandle vec, size_t index);", distractors: [], indent: 0, "explanation": "Retrieves the item at a specific index." },
            { correct: "void* vector_pop_back(VectorHandle vec);", distractors: [], indent: 0, "explanation": "Removes and returns the last item from the vector." },
            { correct: "void vector_sort(VectorHandle vec, int (*compare_func)(const void*, const void*));", distractors: [], indent: 0, "explanation": "Sorts the vector using a user-provided comparison function." },
            { correct: "// === Stage 2: The Private Implementation File (e.g., 'vector.c') ===", distractors: [], indent: 0, "explanation": "Here, we define the hidden structures and implement the API functions." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Include for error messages." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "Include for memory operations if needed." },
            { correct: "// #include \"vector.h\" // In a real project, include the header.", distractors: [], indent: 0, "explanation": "Include our own header to link implementation to declaration." },
            { correct: "#define INITIAL_CAPACITY 8", distractors: [], indent: 0, "explanation": "Define the initial number of elements the vector can hold." },
            { correct: "// Full, private definition of the Vector struct.", distractors: [], indent: 0, "explanation": "Complete the opaque type definition." },
            { correct: "struct Vector {", distractors: [], indent: 0, "explanation": "Begin the struct definition." },
            { correct: "  void** items; // A dynamic array of void pointers, for generic storage.", distractors: [], indent: 1, "explanation": "The core data store. A pointer-to-a-pointer holds an array of pointers." },
            { correct: "  size_t size;", distractors: [], indent: 1, "explanation": "The current number of elements stored in the vector." },
            { correct: "  size_t capacity;", distractors: [], indent: 1, "explanation": "The total number of elements the `items` array can currently hold." },
            { correct: "};", distractors: [], indent: 0, "explanation": "Close the struct definition." },
            { correct: "// A private helper function to handle resizing.", distractors: [], indent: 0, "explanation": "This logic is internal to the library." },
            { correct: "static int vector_resize(VectorHandle vec, size_t new_capacity) {", distractors: [], indent: 0, "explanation": "Define the resize function." },
            { correct: "  void** new_items = realloc(vec->items, new_capacity * sizeof(void*));", distractors: [], indent: 1, "explanation": "Attempt to resize the `items` array." },
            { correct: "  if (!new_items) return -1; // Failure", distractors: [], indent: 1, "explanation": "If realloc fails, return an error code." },
            { correct: "  vec->items = new_items;", distractors: [], indent: 1, "explanation": "On success, update the items pointer." },
            { correct: "  vec->capacity = new_capacity;", distractors: [], indent: 1, "explanation": "Update the capacity." },
            { correct: "  return 0; // Success", distractors: [], indent: 1, "explanation": "Return success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the resize function." },
            { correct: "VectorHandle vector_create() {", distractors: [], indent: 0, "explanation": "Implement the 'constructor'." },
            { correct: "  VectorHandle vec = malloc(sizeof(struct Vector));", distractors: [], indent: 1, "explanation": "Allocate memory for the main Vector struct." },
            { correct: "  if (!vec) return NULL;", distractors: [], indent: 1, "explanation": "Handle allocation failure." },
            { correct: "  vec->items = malloc(INITIAL_CAPACITY * sizeof(void*));", distractors: [], indent: 1, "explanation": "Allocate the initial array for the items." },
            { correct: "  if (!vec->items) { free(vec); return NULL; }", distractors: [], indent: 1, "explanation": "If item allocation fails, clean up and return NULL." },
            { correct: "  vec->size = 0;", distractors: [], indent: 1, "explanation": "The vector starts empty." },
            { correct: "  vec->capacity = INITIAL_CAPACITY;", distractors: [], indent: 1, "explanation": "Set the initial capacity." },
            { correct: "  return vec;", distractors: [], indent: 1, "explanation": "Return the newly created vector handle." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `vector_create`." },
            { correct: "void vector_destroy(VectorHandle vec) {", distractors: [], indent: 0, "explanation": "Implement the 'destructor'." },
            { correct: "  if (!vec) return;", distractors: [], indent: 1, "explanation": "Safety check for a NULL handle." },
            { correct: "  free(vec->items); // Free the array of items first.", distractors: [], indent: 1, "explanation": "Free the dynamically allocated array of pointers." },
            { correct: "  free(vec);      // Then free the struct itself.", distractors: [], indent: 1, "explanation": "Free the main vector management struct." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `vector_destroy`." },
            { correct: "size_t vector_size(const VectorHandle vec) { return vec ? vec->size : 0; }", distractors: [], indent: 0, "explanation": "Implement the size getter with a safety check." },
            { correct: "void vector_push_back(VectorHandle vec, void* item) {", distractors: [], indent: 0, "explanation": "Implement the function to add an item." },
            { correct: "  if (!vec) return;", distractors: [], indent: 1, "explanation": "Safety check." },
            { correct: "  if (vec->size == vec->capacity) {", distractors: [], indent: 1, "explanation": "Check if the vector is full." },
            { correct: "    // Double the capacity when resizing.", distractors: [], indent: 2, "explanation": "A common growth strategy." },
            { correct: "    int success = vector_resize(vec, vec->capacity * 2);", distractors: [], indent: 2, "explanation": "Call the internal resize function." },
            { correct: "    if (success != 0) { return; } // Abort push on resize failure.", distractors: [], indent: 2, "explanation": "Handle resize failure." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the capacity check." },
            { correct: "  vec->items[vec->size] = item;", distractors: [], indent: 1, "explanation": "Place the new item at the end of the array." },
            { correct: "  vec->size++;", distractors: [], indent: 1, "explanation": "Increment the size." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `vector_push_back`." },
            { correct: "void* vector_get(const VectorHandle vec, size_t index) {", distractors: [], indent: 0, "explanation": "Implement the item getter." },
            { correct: "  if (!vec || index >= vec->size) {", distractors: [], indent: 1, "explanation": "Perform bounds checking." },
            { correct: "    return NULL; // Out of bounds", distractors: [], indent: 2, "explanation": "Return NULL if the index is invalid." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close bounds check." },
            { correct: "  return vec->items[index];", distractors: [], indent: 1, "explanation": "Return the void pointer at the specified index." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `vector_get`." },
            { correct: "void* vector_pop_back(VectorHandle vec) {", distractors: [], indent: 0, "explanation": "Implement popping the last element." },
            { correct: "  if (!vec || vec->size == 0) return NULL;", distractors: [], indent: 1, "explanation": "Check if the vector is valid and not empty." },
            { correct: "  vec->size--;", distractors: [], indent: 1, "explanation": "Decrement the size first." },
            { correct: "  return vec->items[vec->size];", distractors: [], indent: 1, "explanation": "Return the item that is now at the new (decremented) size index." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `vector_pop_back`." },
            { correct: "void vector_sort(VectorHandle vec, int (*compare_func)(const void*, const void*)) {", distractors: [], indent: 0, "explanation": "Implement the generic sort function." },
            { correct: "  if (!vec || !compare_func) return;", distractors: [], indent: 1, "explanation": "Check for valid arguments." },
            { correct: "  qsort(vec->items, vec->size, sizeof(void*), compare_func);", distractors: [], indent: 1, "explanation": "Call the standard library `qsort` on our internal item array." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `vector_sort`." },
            { correct: "// === Stage 3: The Main Program to Demonstrate the Vector Library ===", distractors: [], indent: 0, "explanation": "A `main` function to test our new vector library." },
            { correct: "// A comparison function for qsort to compare strings.", distractors: [], indent: 0, "explanation": "Helper function for sorting." },
            { correct: "int strcmp_qsort(const void* a, const void* b) {", distractors: [], indent: 0, "explanation": "Define the string comparator." },
            { correct: "  const char* str_a = *(const char**)a;", distractors: [], indent: 1, "explanation": "`qsort` passes pointers to the elements. Our elements are `char*`, so `a` is a `char**`. We dereference it once." },
            { correct: "  const char* str_b = *(const char**)b;", distractors: [], indent: 1, "explanation": "Dereference the second argument." },
            { correct: "  return strcmp(str_a, str_b);", distractors: [], indent: 1, "explanation": "Use the standard `strcmp` to perform the comparison." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the comparator." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  printf(\"Creating a vector for strings...\\n\");", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  VectorHandle my_vec = vector_create();", distractors: [], indent: 1, "explanation": "Create the vector." },
            { correct: "  // Push items onto the vector.", distractors: [], indent: 1, "explanation": "Comment on adding items." },
            { correct: "  vector_push_back(my_vec, \"Charlie\");", distractors: [], indent: 1, "explanation": "Add the first string. A string literal is a `char*`, which becomes a `void*`." },
            { correct: "  vector_push_back(my_vec, \"Alice\");", distractors: [], indent: 1, "explanation": "Add the second string." },
            { correct: "  vector_push_back(my_vec, \"David\");", distractors: [], indent: 1, "explanation": "Add the third string." },
            { correct: "  vector_push_back(my_vec, \"Bob\");", distractors: [], indent: 1, "explanation": "Add the fourth string." },
            { correct: "  printf(\"Vector size: %zu\\n\", vector_size(my_vec));", distractors: [], indent: 1, "explanation": "Check the size." },
            { correct: "  printf(\"Vector contents:\\n\");", distractors: [], indent: 1, "explanation": "Header for printing." },
            { correct: "  for (size_t i = 0; i < vector_size(my_vec); i++) {", distractors: [], indent: 1, "explanation": "Loop through the vector." },
            { correct: "    char* item = (char*)vector_get(my_vec, i);", distractors: [], indent: 2, "explanation": "Get the `void*` item and cast it back to a `char*`." },
            { correct: "    printf(\"  - %s\\n\", item);", distractors: [], indent: 2, "explanation": "Print the string." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close loop." },
            { correct: "  printf(\"\\nSorting the vector...\\n\");", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  vector_sort(my_vec, strcmp_qsort);", distractors: [], indent: 1, "explanation": "Call our sort function, passing our string comparator." },
            { correct: "  printf(\"Sorted vector contents:\\n\");", distractors: [], indent: 1, "explanation": "Header for printing sorted." },
            { correct: "  for (size_t i = 0; i < vector_size(my_vec); i++) {", distractors: [], indent: 1, "explanation": "Loop through again." },
            { correct: "    printf(\"  - %s\\n\", (char*)vector_get(my_vec, i));", distractors: [], indent: 2, "explanation": "Print the now-sorted items." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close loop." },
            { correct: "  printf(\"\\nPopping last item: %s\\n\", (char*)vector_pop_back(my_vec));", distractors: [], indent: 1, "explanation": "Demonstrate popping an item." },
            { correct: "  printf(\"Final vector size: %zu\\n\", vector_size(my_vec));", distractors: [], indent: 1, "explanation": "Check the new size." },
            { correct: "  printf(\"Destroying vector...\\n\");", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  vector_destroy(my_vec);", distractors: [], indent: 1, "explanation": "Clean up all memory." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
     // Level 76: Time-To-Live (TTL) expiration policy
    {
        "goal": "Build an in-memory key-value cache with a Time-To-Live (TTL) expiration policy.",
        concepts: "Hash tables, time.h, dynamic memory, API design, caching logic",
        sequence: [
            { correct: "// --- Stage 1: Includes and Core Data Structures ---", distractors: [], indent: 0, "explanation": "Define the necessary includes and the structs for our cache." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Memory management." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "String manipulation." },
            { correct: "#include <time.h>", distractors: [], indent: 0, "explanation": "Include for `time()` function to handle expirations." },
            { correct: "#include <unistd.h> // For sleep()", distractors: [], indent: 0, "explanation": "Include for the `sleep` function to demonstrate TTL." },
            { correct: "#define CACHE_SIZE 256", distractors: [], indent: 0, "explanation": "The number of buckets in our cache's hash table." },
            { correct: "// A single entry in the cache.", distractors: [], indent: 0, "explanation": "Comment on the CacheEntry struct." },
            { correct: "typedef struct CacheEntry {", distractors: [], indent: 0, "explanation": "Begin CacheEntry definition." },
            { correct: "  char* key;", distractors: [], indent: 1, "explanation": "The key for this cache entry." },
            { correct: "  char* value;", distractors: [], indent: 1, "explanation": "The value associated with the key." },
            { correct: "  time_t expiration_time;", distractors: [], indent: 1, "explanation": "The UNIX timestamp when this entry becomes invalid." },
            { correct: "  struct CacheEntry* next;", distractors: [], indent: 1, "explanation": "Pointer to the next entry in case of hash collision." },
            { correct: "} CacheEntry;", distractors: [], indent: 0, "explanation": "Close the CacheEntry typedef." },
            { correct: "// The main cache structure, which is a hash table.", distractors: [], indent: 0, "explanation": "Comment on the main Cache struct." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin Cache definition." },
            { correct: "  CacheEntry* buckets[CACHE_SIZE];", distractors: [], indent: 1, "explanation": "The array of buckets, each pointing to the head of a linked list." },
            { correct: "} Cache;", distractors: [], indent: 0, "explanation": "Close the Cache typedef." },
            { correct: "// --- Stage 2: Hash Function and Cache API Implementation ---", distractors: [], indent: 0, "explanation": "Implement the core logic for creating, managing, and accessing the cache." },
            { correct: "unsigned long hash_function(const char* str) {", distractors: [], indent: 0, "explanation": "The djb2 hash function, which is good for string keys." },
            { correct: "  unsigned long hash = 5381; int c; while ((c = *str++)) { hash = ((hash << 5) + hash) + c; } return hash % CACHE_SIZE;", distractors: [], indent: 1, "explanation": "The compact implementation of the djb2 algorithm." },
            { correct: "Cache* cache_create() {", distractors: [], indent: 0, "explanation": "A 'constructor' to create and initialize a new cache." },
            { correct: "  Cache* cache = malloc(sizeof(Cache));", distractors: [], indent: 1, "explanation": "Allocate memory for the cache structure." },
            { correct: "  if (!cache) return NULL;", distractors: [], indent: 1, "explanation": "Handle allocation failure." },
            { correct: "  memset(cache->buckets, 0, sizeof(cache->buckets));", distractors: [], indent: 1, "explanation": "Initialize all bucket pointers to NULL." },
            { correct: "  return cache;", distractors: [], indent: 1, "explanation": "Return the new cache." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `cache_create`." },
            { correct: "void cache_set(Cache* cache, const char* key, const char* value, int ttl_seconds) {", distractors: [], indent: 0, "explanation": "Function to set a key-value pair with a specific Time-To-Live." },
            { correct: "  unsigned long index = hash_function(key);", distractors: [], indent: 1, "explanation": "Calculate the bucket index for this key." },
            { correct: "  // First, check if the key already exists to update it in-place.", distractors: [], indent: 1, "explanation": "Comment on the update-or-insert logic." },
            { correct: "  CacheEntry* current = cache->buckets[index];", distractors: [], indent: 1, "explanation": "Get the head of the list for this bucket." },
            { correct: "  while (current) {", distractors: [], indent: 1, "explanation": "Traverse the linked list." },
            { correct: "    if (strcmp(current->key, key) == 0) {", distractors: [], indent: 2, "explanation": "If the key is found..." },
            { correct: "      free(current->value); // Free the old value", distractors: [], indent: 3, "explanation": "Free the old value string to prevent a memory leak." },
            { correct: "      current->value = strdup(value); // Set the new value", distractors: [], indent: 3, "explanation": "Allocate and copy the new value string." },
            { correct: "      current->expiration_time = (ttl_seconds > 0) ? (time(NULL) + ttl_seconds) : 0;", distractors: [], indent: 3, "explanation": "Update the expiration time. A TTL of 0 or less means it never expires." },
            { correct: "      return; // Update complete", distractors: [], indent: 3, "explanation": "Exit the function." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close string compare." },
            { correct: "    current = current->next;", distractors: [], indent: 2, "explanation": "Move to the next entry." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the update search loop." },
            { correct: "  // If key not found, create a new entry.", distractors: [], indent: 1, "explanation": "Comment on the new entry logic." },
            { correct: "  CacheEntry* new_entry = malloc(sizeof(CacheEntry));", distractors: [], indent: 1, "explanation": "Allocate a new CacheEntry struct." },
            { correct: "  new_entry->key = strdup(key);", distractors: [], indent: 1, "explanation": "Allocate and copy the key." },
            { correct: "  new_entry->value = strdup(value);", distractors: [], indent: 1, "explanation": "Allocate and copy the value." },
            { correct: "  new_entry->expiration_time = (ttl_seconds > 0) ? (time(NULL) + ttl_seconds) : 0;", distractors: [], indent: 1, "explanation": "Calculate the expiration timestamp." },
            { correct: "  new_entry->next = cache->buckets[index];", distractors: [], indent: 1, "explanation": "Insert the new entry at the head of the list." },
            { correct: "  cache->buckets[index] = new_entry;", distractors: [], indent: 1, "explanation": "The new entry becomes the new head." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `cache_set`." },
            { correct: "const char* cache_get(Cache* cache, const char* key) {", distractors: [], indent: 0, "explanation": "Function to get a value from the cache, checking for expiration." },
            { correct: "  unsigned long index = hash_function(key);", distractors: [], indent: 1, "explanation": "Calculate the bucket index." },
            { correct: "  CacheEntry* current = cache->buckets[index];", distractors: [], indent: 1, "explanation": "Get the head of the list." },
            { correct: "  while (current) {", distractors: [], indent: 1, "explanation": "Traverse the list." },
            { correct: "    if (strcmp(current->key, key) == 0) {", distractors: [], indent: 2, "explanation": "If the key matches..." },
            { correct: "      // Check for expiration. A 0 expiration time means it never expires.", distractors: [], indent: 3, "explanation": "Comment on the expiration check." },
            { correct: "      if (current->expiration_time != 0 && time(NULL) > current->expiration_time) {", distractors: [], indent: 3, "explanation": "Check if the entry has a TTL and if the current time has passed it." },
            { correct: "        // Entry is expired. We should ideally remove it here (lazy deletion).", distractors: [], indent: 4, "explanation": "Comment on lazy deletion." },
            { correct: "        printf(\" (Cache MISS: key '%s' found but is expired) \", key);", distractors: [], indent: 4, "explanation": "Log that the item expired." },
            { correct: "        return NULL;", distractors: [], indent: 4, "explanation": "Return NULL as if the item was not found." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close expiration check." },
            { correct: "      printf(\" (Cache HIT: key '%s' found) \", key);", distractors: [], indent: 3, "explanation": "Log a successful cache hit." },
            { correct: "      return current->value;", distractors: [], indent: 3, "explanation": "Return the valid value." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close key compare." },
            { correct: "    current = current->next;", distractors: [], indent: 2, "explanation": "Move to the next entry." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close traversal loop." },
            { correct: "  printf(\" (Cache MISS: key '%s' not found) \", key);", distractors: [], indent: 1, "explanation": "Log a cache miss if the key was never found." },
            { correct: "  return NULL;", distractors: [], indent: 1, "explanation": "Return NULL for a miss." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `cache_get`." },
            { correct: "void cache_destroy(Cache* cache) { /* ... similar to previous ht_free ... */ }", distractors: [], indent: 0, "explanation": "The destroy function would be nearly identical to the hash table free function in the last level." },
            { correct: "// --- Stage 3: Main Program to Demonstrate the Cache ---", distractors: [], indent: 0, "explanation": "A `main` function to test our cache's functionality." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  Cache* my_cache = cache_create();", distractors: [], indent: 1, "explanation": "Create a new cache instance." },
            { correct: "  printf(\"Setting cache entries...\\n\");", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  cache_set(my_cache, \"user:1\", \"Alice\", 2); // Expires in 2 seconds.", distractors: [], indent: 1, "explanation": "Set an entry with a short TTL." },
            { correct: "  cache_set(my_cache, \"user:2\", \"Bob\", 0); // Never expires.", distractors: [], indent: 1, "explanation": "Set a persistent entry." },
            { correct: "  printf(\"\\n--- Initial Get ---\\n\");", distractors: [], indent: 1, "explanation": "Header for the first retrieval attempt." },
            { correct: "  const char* val1 = cache_get(my_cache, \"user:1\");", distractors: [], indent: 1, "explanation": "Get the first user." },
            { correct: "  printf(\"-> Value for user:1 is %s\\n\", val1 ? val1 : \"NULL\");", distractors: [], indent: 1, "explanation": "Print the result." },
            { correct: "  const char* val2 = cache_get(my_cache, \"user:2\");", distractors: [], indent: 1, "explanation": "Get the second user." },
            { correct: "  printf(\"-> Value for user:2 is %s\\n\", val2 ? val2 : \"NULL\");", distractors: [], indent: 1, "explanation": "Print the result." },
            { correct: "  printf(\"\\nSleeping for 3 seconds to allow user:1 to expire...\\n\");", distractors: [], indent: 1, "explanation": "Informational message about the delay." },
            { correct: "  sleep(3);", distractors: [], indent: 1, "explanation": "Pause the program for 3 seconds." },
            { correct: "  printf(\"\\n--- Get After Expiration ---\\n\");", distractors: [], indent: 1, "explanation": "Header for the second retrieval attempt." },
            { correct: "  val1 = cache_get(my_cache, \"user:1\");", distractors: [], indent: 1, "explanation": "Attempt to get the first user again." },
            { correct: "  printf(\"-> Value for user:1 is %s\\n\", val1 ? val1 : \"NULL\");", distractors: [], indent: 1, "explanation": "Print the result, which should now be NULL." },
            { correct: "  val2 = cache_get(my_cache, \"user:2\");", distractors: [], indent: 1, "explanation": "Get the second user again." },
            { correct: "  printf(\"-> Value for user:2 is %s\\n\", val2 ? val2 : \"NULL\");", distractors: [], indent: 1, "explanation": "Print the result, which should still be valid." },
            { correct: "  // cache_destroy(my_cache); // Cleanup would happen here.", distractors: [], indent: 1, "explanation": "Comment on where final cleanup would occur." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
    // Level 77: integer arithmetic to avoid floating-point errors
    {
        "goal": "Build a library for high-precision monetary calculations using integer arithmetic to avoid floating-point errors.",
        concepts: "Integer arithmetic, opaque pointers, API design, string parsing, rounding",
        sequence: [
            { correct: "// === Stage 1: The Public API Header File ('money.h') ===", distractors: [], indent: 0, "explanation": "We define the public interface for our high-precision money library." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard includes." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Standard includes." },
            { correct: "// 1. Opaque declaration of the Money struct.", distractors: [], indent: 0, "explanation": "Hide the internal representation of money from the user." },
            { correct: "struct Money;", distractors: [], indent: 0, "explanation": "Forward-declare the struct, making it an incomplete type." },
            { correct: "typedef struct Money* MoneyHandle;", distractors: [], indent: 0, "explanation": "Users of the library will only use this pointer handle." },
            { correct: "// --- Public API Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare the library's functions." },
            { correct: "MoneyHandle money_from_cents(long long cents);", distractors: [], indent: 0, "explanation": "Creates a Money object from a raw integer of cents." },
            { correct: "MoneyHandle money_from_string(const char* str);", distractors: [], indent: 0, "explanation": "Creates a Money object by parsing a string like \"-123.45\"." },
            { correct: "void money_destroy(MoneyHandle m);", distractors: [], indent: 0, "explanation": "Frees the memory for a Money object." },
            { correct: "char* money_to_string(MoneyHandle m);", distractors: [], indent: 0, "explanation": "Converts a Money object back into a formatted string (e.g., \"$123.45\"). Caller must free the string." },
            { correct: "MoneyHandle money_add(MoneyHandle m1, MoneyHandle m2);", distractors: [], indent: 0, "explanation": "Adds two Money objects and returns a new one with the result." },
            { correct: "MoneyHandle money_multiply(MoneyHandle m, double factor);", distractors: [], indent: 0, "explanation": "Multiplies a Money object by a float/double (e.g., for interest) and returns a new object." },
            { correct: "// === Stage 2: The Private Implementation ('money.c') ===", distractors: [], indent: 0, "explanation": "Implement the hidden logic of our library." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "Include for string functions." },
            { correct: "#include <math.h> // For round()", distractors: [], indent: 0, "explanation": "Include for the rounding function." },
            { correct: "// #include \"money.h\" // In a real project", distractors: [], indent: 0, "explanation": "Link implementation to the public header." },
            { correct: "// 2. Full, private definition of the Money struct.", distractors: [], indent: 0, "explanation": "The internal representation is a 64-bit integer of cents." },
            { correct: "struct Money { long long cents; };", distractors: [], indent: 0, "explanation": "This stores monetary values like $123.45 as the integer 12345." },
            { correct: "MoneyHandle money_from_cents(long long cents) {", distractors: [], indent: 0, "explanation": "Implement the constructor from cents." },
            { correct: "  MoneyHandle m = malloc(sizeof(struct Money));", distractors: [], indent: 1, "explanation": "Allocate memory for the struct." },
            { correct: "  if (!m) return NULL;", distractors: [], indent: 1, "explanation": "Handle allocation failure." },
            { correct: "  m->cents = cents;", distractors: [], indent: 1, "explanation": "Set the internal value." },
            { correct: "  return m;", distractors: [], indent: 1, "explanation": "Return the new handle." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the function." },
            { correct: "void money_destroy(MoneyHandle m) {", distractors: [], indent: 0, "explanation": "Implement the destructor." },
            { correct: "  free(m);", distractors: [], indent: 1, "explanation": "Free the memory associated with the handle." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the destructor." },
            { correct: "MoneyHandle money_from_string(const char* str) {", distractors: [], indent: 0, "explanation": "Implement the string parser." },
            { correct: "  double val_double = atof(str);", distractors: [], indent: 1, "explanation": "Use `atof` to convert the string to a double initially." },
            { correct: "  long long cents = round(val_double * 100.0);", distractors: [{ "text": "long long cents = val_double * 100;", reason: "This can introduce precision errors (e.g., 1.29 * 100 might become 128.999...). Using `round()` ensures we get the nearest whole cent."}], indent: 1, "explanation": "Convert the double value to cents, rounding carefully to handle precision issues." },
            { correct: "  return money_from_cents(cents);", distractors: [], indent: 1, "explanation": "Call our other constructor to create the object." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the string parser." },
            { correct: "char* money_to_string(MoneyHandle m) {", distractors: [], indent: 0, "explanation": "Implement the formatter." },
            { correct: "  if (!m) return NULL;", distractors: [], indent: 1, "explanation": "Handle null input." },
            { correct: "  long long dollars = m->cents / 100;", distractors: [], indent: 1, "explanation": "Calculate the dollar part using integer division." },
            { correct: "  long long cents_part = llabs(m->cents % 100);", distractors: [], indent: 1, "explanation": "Calculate the cents part using modulo. `llabs` gets the absolute value." },
            { correct: "  char* buffer = malloc(32);", distractors: [], indent: 1, "explanation": "Allocate a buffer for the result string." },
            { correct: "  if (!buffer) return NULL;", distractors: [], indent: 1, "explanation": "Handle allocation failure." },
            { correct: "  sprintf(buffer, \"%s$%lld.%02lld\", (m->cents < 0 ? \"-\" : \"\"), llabs(dollars), cents_part);", distractors: [], indent: 1, "explanation": "Use `sprintf` to format the string, handling negative signs and ensuring cents are zero-padded." },
            { correct: "  return buffer;", distractors: [], indent: 1, "explanation": "Return the newly created string." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the formatter." },
            { correct: "MoneyHandle money_add(MoneyHandle m1, MoneyHandle m2) {", distractors: [], indent: 0, "explanation": "Implement the addition function." },
            { correct: "  if (!m1 || !m2) return NULL;", distractors: [], indent: 1, "explanation": "Handle null inputs." },
            { correct: "  long long result_cents = m1->cents + m2->cents;", distractors: [], indent: 1, "explanation": "The core logic is a simple integer addition." },
            { correct: "  return money_from_cents(result_cents);", distractors: [], indent: 1, "explanation": "Return a new Money object with the result." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `money_add`." },
            { correct: "MoneyHandle money_multiply(MoneyHandle m, double factor) {", distractors: [], indent: 0, "explanation": "Implement multiplication by a factor." },
            { correct: "  if (!m) return NULL;", distractors: [], indent: 1, "explanation": "Handle null input." },
            { correct: "  double result_as_double = (double)m->cents * factor;", distractors: [], indent: 1, "explanation": "Perform the multiplication using floating-point math." },
            { correct: "  long long result_cents = round(result_as_double);", distractors: [], indent: 1, "explanation": "Round the result back to the nearest cent to maintain precision." },
            { correct: "  return money_from_cents(result_cents);", distractors: [], indent: 1, "explanation": "Return a new Money object." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `money_multiply`." },
            { correct: "// === Stage 3: The Main Program to Demonstrate the Library ===", distractors: [], indent: 0, "explanation": "A `main` function to test our high-precision library." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  printf(\"--- High-Precision Money Demo ---\\n\");", distractors: [], indent: 1, "explanation": "Header." },
            { correct: "  MoneyHandle price = money_from_string(\"199.99\");", distractors: [], indent: 1, "explanation": "Create a `price` object from a string." },
            { correct: "  MoneyHandle tax = money_from_string(\"12.00\");", distractors: [], indent: 1, "explanation": "Create a `tax` object." },
            { correct: "  char* price_str = money_to_string(price);", distractors: [], indent: 1, "explanation": "Convert price back to a string for printing." },
            { correct: "  char* tax_str = money_to_string(tax);", distractors: [], indent: 1, "explanation": "Convert tax back to a string." },
            { correct: "  printf(\"Initial Price: %s\\nTax: %s\\n\", price_str, tax_str);", distractors: [], indent: 1, "explanation": "Print initial values." },
            { correct: "  free(price_str); free(tax_str);", distractors: [], indent: 1, "explanation": "Free the strings returned by `money_to_string`." },
            { correct: "  MoneyHandle total = money_add(price, tax);", distractors: [], indent: 1, "explanation": "Calculate the total price." },
            { correct: "  char* total_str = money_to_string(total);", distractors: [], indent: 1, "explanation": "Convert total to a string." },
            { correct: "  printf(\"Total after addition: %s\\n\", total_str);", distractors: [], indent: 1, "explanation": "Print the total." },
            { correct: "  free(total_str);", distractors: [], indent: 1, "explanation": "Free the total string." },
            { correct: "  printf(\"\\nCalculating with 5.5%% interest rate...\\n\");", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  MoneyHandle total_with_interest = money_multiply(total, 1.055);", distractors: [], indent: 1, "explanation": "Apply an interest rate." },
            { correct: "  char* interest_str = money_to_string(total_with_interest);", distractors: [], indent: 1, "explanation": "Convert the new total to a string." },
            { correct: "  printf(\"Total with interest: %s\\n\", interest_str);", distractors: [], indent: 1, "explanation": "Print the final value." },
            { correct: "  free(interest_str);", distractors: [], indent: 1, "explanation": "Free the final string." },
            { correct: "  // Cleanup all money objects", distractors: [], indent: 1, "explanation": "Comment on cleanup." },
            { correct: "  money_destroy(price);", distractors: [], indent: 1, "explanation": "Free the price object." },
            { correct: "  money_destroy(tax);", distractors: [], indent: 1, "explanation": "Free the tax object." },
            { correct: "  money_destroy(total);", distractors: [], indent: 1, "explanation": "Free the total object." },
            { correct: "  money_destroy(total_with_interest);", distractors: [], indent: 1, "explanation": "Free the last object." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
 // Level 78: generate a per-account summary report
    {
        "goal": "Process a CSV file of financial transactions to generate a per-account summary report.",
        concepts: "Hash tables, `fgets`, `strtok`, data aggregation, file I/O, reporting",
        sequence: [
            { correct: "// === Stage 1: Setup and Data Structures ===", distractors: [], indent: 0, "explanation": "Define the necessary includes and the data structures for storing our aggregated results." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Memory management and `atof`." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "String manipulation." },
            { correct: "#define HASH_TABLE_SIZE 512", distractors: [], indent: 0, "explanation": "The number of buckets in our hash table for accounts." },
            { correct: "#define MAX_ID_LEN 64", distractors: [], indent: 0, "explanation": "The maximum length of an account ID string." },
            { correct: "// A struct to hold the aggregated data for a single account.", distractors: [], indent: 0, "explanation": "Comment on the AccountData struct." },
            { correct: "typedef struct AccountData {", distractors: [], indent: 0, "explanation": "Begin AccountData definition." },
            { correct: "  char id[MAX_ID_LEN];", distractors: [], indent: 1, "explanation": "The account ID string." },
            { correct: "  long long total_credit_cents;", distractors: [], indent: 1, "explanation": "Sum of all credits for this account, in cents." },
            { correct: "  long long total_debit_cents;", distractors: [], indent: 1, "explanation": "Sum of all debits for this account, in cents." },
            { correct: "  int transaction_count;", distractors: [], indent: 1, "explanation": "Total number of transactions for this account." },
            { correct: "  struct AccountData* next;", distractors: [], indent: 1, "explanation": "Pointer for hash collision linked list." },
            { correct: "} AccountData;", distractors: [], indent: 0, "explanation": "Close the AccountData typedef." },
            { correct: "typedef struct { AccountData* buckets[HASH_TABLE_SIZE]; } HashTable;", distractors: [], indent: 0, "explanation": "Define the hash table structure." },
            { correct: "// --- Stage 2: Hash Table and Parser Implementation ---", distractors: [], indent: 0, "explanation": "Implement the core logic." },
            { correct: "unsigned long hash_function(const char* str) {", distractors: [], indent: 0, "explanation": "The djb2 hash function for string keys." },
            { correct: "  unsigned long hash = 5381; int c; while((c = *str++)) hash = ((hash << 5) + hash) + c;", distractors: [], indent: 1, "explanation": "Compact implementation of the hashing algorithm." },
            { correct: "  return hash % HASH_TABLE_SIZE;", distractors: [], indent: 1, "explanation": "Constrain the hash to the table size." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the hash function." },
            { correct: "HashTable* ht_create() {", distractors: [], indent: 0, "explanation": "The constructor for our hash table." },
            { correct: "  HashTable* ht = malloc(sizeof(HashTable));", distractors: [], indent: 1, "explanation": "Allocate memory for the table." },
            { correct: "  memset(ht->buckets, 0, sizeof(ht->buckets));", distractors: [], indent: 1, "explanation": "Initialize all buckets to NULL." },
            { correct: "  return ht;", distractors: [], indent: 1, "explanation": "Return the new table." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the constructor." },
            { correct: "AccountData* ht_get_or_create_account(HashTable* ht, const char* account_id) {", distractors: [], indent: 0, "explanation": "A key function to find an existing account entry or create a new one." },
            { correct: "  unsigned long index = hash_function(account_id);", distractors: [], indent: 1, "explanation": "Calculate the index for this account ID." },
            { correct: "  AccountData* current = ht->buckets[index];", distractors: [], indent: 1, "explanation": "Get the head of the list for this bucket." },
            { correct: "  while (current) {", distractors: [], indent: 1, "explanation": "Traverse the list to find an existing entry." },
            { correct: "    if (strcmp(current->id, account_id) == 0) return current;", distractors: [], indent: 2, "explanation": "If the account is found, return a pointer to it immediately." },
            { correct: "    current = current->next;", distractors: [], indent: 2, "explanation": "Move to the next entry." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the search loop." },
            { correct: "  // If we get here, the account is new. Create and insert it.", distractors: [], indent: 1, "explanation": "Comment on the creation logic." },
            { correct: "  AccountData* new_account = malloc(sizeof(AccountData));", distractors: [], indent: 1, "explanation": "Allocate memory for the new account data struct." },
            { correct: "  strncpy(new_account->id, account_id, MAX_ID_LEN - 1);", distractors: [], indent: 1, "explanation": "Copy the account ID." },
            { correct: "  new_account->id[MAX_ID_LEN - 1] = '\\0';", distractors: [], indent: 1, "explanation": "Ensure null termination." },
            { correct: "  new_account->total_credit_cents = 0;", distractors: [], indent: 1, "explanation": "Initialize credit total to zero." },
            { correct: "  new_account->total_debit_cents = 0;", distractors: [], indent: 1, "explanation": "Initialize debit total to zero." },
            { correct: "  new_account->transaction_count = 0;", distractors: [], indent: 1, "explanation": "Initialize transaction count to zero." },
            { correct: "  new_account->next = ht->buckets[index];", distractors: [], indent: 1, "explanation": "Link the new account to the front of the list." },
            { correct: "  ht->buckets[index] = new_account;", distractors: [], indent: 1, "explanation": "The new account becomes the new head of the list." },
            { correct: "  return new_account;", distractors: [], indent: 1, "explanation": "Return the pointer to the newly created account." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the get/create function." },
            { correct: "void process_transactions(const char* filename, HashTable* ht) {", distractors: [], indent: 0, "explanation": "The main file processing and data aggregation function." },
            { correct: "  FILE* fp = fopen(filename, \"r\");", distractors: [], indent: 1, "explanation": "Open the CSV file." },
            { correct: "  if (!fp) { perror(\"Error opening transactions file\"); return; }", distractors: [], indent: 1, "explanation": "Handle file open errors." },
            { correct: "  char line_buffer[512];", distractors: [], indent: 1, "explanation": "A buffer to read each line." },
            { correct: "  fgets(line_buffer, sizeof(line_buffer), fp); // Skip header row", distractors: [], indent: 1, "explanation": "Read and discard the first line (CSV header)." },
            { correct: "  while(fgets(line_buffer, sizeof(line_buffer), fp)) {", distractors: [], indent: 1, "explanation": "Loop, reading one transaction line at a time." },
            { correct: "    // Parse the line: txn_id,acct_id,type,amount", distractors: [], indent: 2, "explanation": "Comment on the expected format." },
            { correct: "    char* txn_id_str = strtok(line_buffer, \",\");", distractors: [], indent: 2, "explanation": "Get the transaction ID token (we'll ignore it)." },
            { correct: "    char* acct_id_str = strtok(NULL, \",\");", distractors: [], indent: 2, "explanation": "Get the account ID token." },
            { correct: "    char* type_str = strtok(NULL, \",\");", distractors: [], indent: 2, "explanation": "Get the transaction type token ('credit' or 'debit')." },
            { correct: "    char* amount_str = strtok(NULL, \",\n\");", distractors: [], indent: 2, "explanation": "Get the amount token." },
            { correct: "    if (acct_id_str && type_str && amount_str) {", distractors: [], indent: 2, "explanation": "Check that all necessary tokens were found." },
            { correct: "      AccountData* account = ht_get_or_create_account(ht, acct_id_str);", distractors: [], indent: 3, "explanation": "Get the data bucket for this account." },
            { correct: "      long long amount_cents = round(atof(amount_str) * 100);", distractors: [], indent: 3, "explanation": "Convert the amount string to a precise integer of cents." },
            { correct: "      if (strcmp(type_str, \"credit\") == 0) {", distractors: [], indent: 3, "explanation": "If the type is 'credit'..." },
            { correct: "        account->total_credit_cents += amount_cents;", distractors: [], indent: 4, "explanation": "Add to the credit total." },
            { correct: "      } else if (strcmp(type_str, \"debit\") == 0) {", distractors: [], indent: 3, "explanation": "If the type is 'debit'..." },
            { correct: "        account->total_debit_cents += amount_cents;", distractors: [], indent: 4, "explanation": "Add to the debit total." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close type check." },
            { correct: "      account->transaction_count++;", distractors: [], indent: 3, "explanation": "Increment the transaction count for this account." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close token check." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the file reading loop." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the file." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the processing function." },
            { correct: "void print_report(HashTable* ht) {", distractors: [], indent: 0, "explanation": "A function to generate and print the final report." },
            { correct: "  printf(\"\\n--- Transaction Summary Report ---\\n\");", distractors: [], indent: 1, "explanation": "Print a report header." },
            { correct: "  printf(\"%-15s | %-10s | %-15s | %-15s | %-15s\\n\", \"Account ID\", \"Txn Count\", \"Total Debit\", \"Total Credit\", \"Net Balance\");", distractors: [], indent: 1, "explanation": "Print the table column headers with formatting." },
            { correct: "  printf(\"--------------------------------------------------------------------------------\\n\");", distractors: [], indent: 1, "explanation": "Print a separator line." },
            { correct: "  for (int i = 0; i < HASH_TABLE_SIZE; i++) {", distractors: [], indent: 1, "explanation": "Iterate through every bucket in the hash table." },
            { correct: "    for (AccountData* current = ht->buckets[i]; current != NULL; current = current->next) {", distractors: [], indent: 2, "explanation": "Iterate through every account in the bucket's linked list." },
            { correct: "      long long net_cents = current->total_credit_cents - current->total_debit_cents;", distractors: [], indent: 3, "explanation": "Calculate the net balance in cents." },
            { correct: "      // Print formatted data for the current account.", distractors: [], indent: 3, "explanation": "Comment on printing the row." },
            { correct: "      printf(\"%-15s | %-10d | $%8.2f   | $%13.2f   | $%13.2f\\n\",", distractors: [], indent: 3, "explanation": "Use a formatted `printf` to create a clean table row." },
            { correct: "             current->id, ", distractors: [], indent: 15, "explanation": "Print the account ID." },
            { correct: "             current->transaction_count,", distractors: [], indent: 15, "explanation": "Print the transaction count." },
            { correct: "             (double)current->total_debit_cents / 100.0,", distractors: [], indent: 15, "explanation": "Calculate and print total debits in dollars." },
            { correct: "             (double)current->total_credit_cents / 100.0,", distractors: [], indent: 15, "explanation": "Calculate and print total credits in dollars." },
            { correct: "             (double)net_cents / 100.0);", distractors: [], indent: 15, "explanation": "Calculate and print the net balance in dollars." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the inner loop." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the outer loop." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the report function." },
            { correct: "// --- Main Program Driver ---", distractors: [], indent: 0, "explanation": "The main function to tie it all together." },
            { correct: "int main(int argc, char* argv[]) {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  if (argc != 2) { printf(\"Usage: %s <transactions.csv>\\n\", argv[0]); return 1; }", distractors: [], indent: 1, "explanation": "Check for the CSV filename argument." },
            { correct: "  HashTable* account_data = ht_create();", distractors: [], indent: 1, "explanation": "Create the hash table." },
            { correct: "  printf(\"Processing file: %s\\n\", argv[1]);", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  process_transactions(argv[1], account_data);", distractors: [], indent: 1, "explanation": "Call the main processing function." },
            { correct: "  print_report(account_data);", distractors: [], indent: 1, "explanation": "Generate and print the final report." },
            { correct: "  // ht_destroy(account_data); // A full implementation would free all memory here.", distractors: [], indent: 1, "explanation": "Comment on where final cleanup would occur." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
     // Level 79:  load world data from external files
    {
        "goal": "Build a text adventure engine that loads its world data from external files.",
        concepts: "Data-driven design, file I/O, `sscanf`, `strtok`, structs, dynamic arrays, game loops",
        sequence: [
            { correct: "// === Stage 1: Setup and Core Data Structures ===", distractors: [], indent: 0, "explanation": "Define the necessary includes and the data structures for our game world." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O for `printf`, file functions, etc." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "For memory allocation (`malloc`, `realloc`, `free`)." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "For string manipulation (`strcmp`, `strcpy`, `strtok`)." },
            { correct: "#define MAX_DESC_LEN 256", distractors: [], indent: 0, "explanation": "Define max length for room and object descriptions." },
            { correct: "#define MAX_NAME_LEN 64", distractors: [], indent: 0, "explanation": "Define max length for room and object names." },
            { correct: "// --- Data Structures ---", distractors: [], indent: 0, "explanation": "Defining the blueprints for our game world entities." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "A structure to represent a single Room in the game." },
            { correct: "  int id;", distractors: [], indent: 1, "explanation": "A unique ID for this room." },
            { correct: "  char name[MAX_NAME_LEN];", distractors: [], indent: 1, "explanation": "The name of the room (e.g., \"A dark cave\")." },
            { correct: "  char description[MAX_DESC_LEN];", distractors: [], indent: 1, "explanation": "The longer description of the room." },
            { correct: "  int north, south, east, west;", distractors: [], indent: 1, "explanation": "IDs of the rooms connected in each direction. -1 means no exit." },
            { correct: "} Room;", distractors: [], indent: 0, "explanation": "Close the Room struct typedef." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "A structure to represent a single Object (or Item)." },
            { correct: "  int id;", distractors: [], indent: 1, "explanation": "A unique ID for this object." },
            { correct: "  char name[MAX_NAME_LEN];", distractors: [], indent: 1, "explanation": "The name of the object (e.g., \"rusty key\")." },
            { correct: "  char description[MAX_DESC_LEN];", distractors: [], indent: 1, "explanation": "The description when a player 'looks' at it." },
            { correct: "  int location_id; // Room ID, or -1 for player's inventory", distractors: [], indent: 1, "explanation": "The ID of the room where the object is located." },
            { correct: "} Object;", distractors: [], indent: 0, "explanation": "Close the Object struct typedef." },
            { correct: "// --- Global Game State ---", distractors: [], indent: 0, "explanation": "Global variables to hold all loaded game data and the player's state." },
            { correct: "Room* rooms = NULL;", distractors: [], indent: 0, "explanation": "Dynamic array to store all room data." },
            { correct: "int room_count = 0;", distractors: [], indent: 0, "explanation": "Number of rooms loaded." },
            { correct: "Object* objects = NULL;", distractors: [], indent: 0, "explanation": "Dynamic array to store all object data." },
            { correct: "int object_count = 0;", distractors: [], indent: 0, "explanation": "Number of objects loaded." },
            { correct: "int player_location_id = 0;", distractors: [], indent: 0, "explanation": "The ID of the room the player is currently in." },
            { correct: "// --- Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare our functions before they are used." },
            { correct: "void load_data();", distractors: [], indent: 0, "explanation": "Main function to load all game data from files." },
            { correct: "void game_loop();", distractors: [], indent: 0, "explanation": "The main loop that waits for and processes player input." },
            { correct: "void do_look();", distractors: [], indent: 0, "explanation": "Handles the 'look' command." },
            { correct: "void do_move(const char* direction);", distractors: [], indent: 0, "explanation": "Handles movement commands like 'north', 'south'." },
            { correct: "void do_take(const char* object_name);", distractors: [], indent: 0, "explanation": "Handles the 'take' command." },
            { correct: "void do_inventory();", distractors: [], indent: 0, "explanation": "Handles the 'inventory' command." },
            { correct: "// --- Main Function ---", distractors: [], indent: 0, "explanation": "Program entry point." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  load_data();", distractors: [], indent: 1, "explanation": "Load all game world data from files." },
            { correct: "  if (room_count == 0) {", distractors: [], indent: 1, "explanation": "Check if any rooms were loaded." },
            { correct: "    printf(\"Error: No rooms loaded. Cannot start game.\\n\");", distractors: [], indent: 2, "explanation": "If no rooms, the game can't run." },
            { correct: "    return 1;", distractors: [], indent: 2, "explanation": "Exit with an error." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the check." },
            { correct: "  game_loop();", distractors: [], indent: 1, "explanation": "Start the main interactive game loop." },
            { correct: "  free(rooms);", distractors: [], indent: 1, "explanation": "After the game loop exits, free the rooms data." },
            { correct: "  free(objects);", distractors: [], indent: 1, "explanation": "Free the objects data." },
            { correct: "  printf(\"Thanks for playing!\\n\");", distractors: [], indent: 1, "explanation": "A parting message." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." },
            { correct: "// === Stage 2: Data Loading Implementation ===", distractors: [], indent: 0, "explanation": "Implement the functions that read from our data files." },
            { correct: "void load_data() {", distractors: [], indent: 0, "explanation": "Start the main data loading function." },
            { correct: "  // In a real project, these files would be separate. We simulate them here.", distractors: [], indent: 1, "explanation": "Comment on the simulated files." },
            { correct: "  FILE* f_rooms = fopen(\"rooms.dat\", \"w\");", distractors: [], indent: 1, "explanation": "Create a dummy rooms.dat file for the demo." },
            { correct: "  fprintf(f_rooms, \"0,Cave Entrance,You are at the mouth of a dark cave. A cold wind blows from within.,1,-1,-1,-1\\n\");", distractors: [], indent: 1, "explanation": "Write data for the first room." },
            { correct: "  fprintf(f_rooms, \"1,Inner Chamber,It is pitch black. You hear dripping water.,-1,0,-1,-1\\n\");", distractors: [], indent: 1, "explanation": "Write data for the second room." },
            { correct: "  fclose(f_rooms);", distractors: [], indent: 1, "explanation": "Close the dummy file." },
            { correct: "  FILE* f_objects = fopen(\"objects.dat\", \"w\");", distractors: [], indent: 1, "explanation": "Create a dummy objects.dat file." },
            { correct: "  fprintf(f_objects, \"0,lamp,A battered brass lamp.,0\\n\");", distractors: [], indent: 1, "explanation": "Write data for an object." },
            { correct: "  fprintf(f_objects, \"1,stone,A smooth, grey stone.,1\\n\");", distractors: [], indent: 1, "explanation": "Write data for another object." },
            { correct: "  fclose(f_objects);", distractors: [], indent: 1, "explanation": "Close the dummy file." },
            { correct: "  // Now, actually load the data.", distractors: [], indent: 1, "explanation": "Comment on the loading process." },
            { correct: "  FILE* fp = fopen(\"rooms.dat\", \"r\");", distractors: [], indent: 1, "explanation": "Open the rooms file for reading." },
            { correct: "  if (!fp) { perror(\"Could not open rooms.dat\"); return; }", distractors: [], indent: 1, "explanation": "Handle file open error." },
            { correct: "  char line[1024];", distractors: [], indent: 1, "explanation": "A buffer for reading lines." },
            { correct: "  while (fgets(line, sizeof(line), fp)) {", distractors: [], indent: 1, "explanation": "Read the rooms file line by line." },
            { correct: "    room_count++;", distractors: [], indent: 2, "explanation": "Increment room count." },
            { correct: "    rooms = realloc(rooms, room_count * sizeof(Room));", distractors: [], indent: 2, "explanation": "Resize the dynamic array for rooms." },
            { correct: "    sscanf(line, \"%d,%[^,],\\\"%[^\"]\\\",%d,%d,%d,%d\",", distractors: [], indent: 2, "explanation": "Use `sscanf` to parse the structured line. `%[^,]` reads until a comma, `\\\"%[^\"]\\\"` reads a quoted string." },
            { correct: "           &rooms[room_count-1].id, rooms[room_count-1].name, rooms[room_count-1].description,", distractors: [], indent: 11, "explanation": "Provide the destination variables for `sscanf`." },
            { correct: "           &rooms[room_count-1].north, &rooms[room_count-1].south, &rooms[room_count-1].east, &rooms[room_count-1].west);", distractors: [], indent: 11, "explanation": "Continue providing destination variables." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the rooms reading loop." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the rooms file." },
            { correct: "  fp = fopen(\"objects.dat\", \"r\");", distractors: [], indent: 1, "explanation": "Open the objects file for reading." },
            { correct: "  if (!fp) { perror(\"Could not open objects.dat\"); return; }", distractors: [], indent: 1, "explanation": "Handle file open error." },
            { correct: "  while (fgets(line, sizeof(line), fp)) {", distractors: [], indent: 1, "explanation": "Read the objects file line by line." },
            { correct: "    object_count++;", distractors: [], indent: 2, "explanation": "Increment object count." },
            { correct: "    objects = realloc(objects, object_count * sizeof(Object));", distractors: [], indent: 2, "explanation": "Resize the dynamic array for objects." },
            { correct: "    sscanf(line, \"%d,\\\"%[^\"]\\\",\\\"%[^\"]\\\",%d\", &objects[object_count-1].id, objects[object_count-1].name, objects[object_count-1].description, &objects[object_count-1].location_id);", distractors: [], indent: 2, "explanation": "Use `sscanf` to parse the object data line." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the objects reading loop." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the objects file." },
            { correct: "  printf(\"Loaded %d rooms and %d objects.\\n\", room_count, object_count);", distractors: [], indent: 1, "explanation": "Print a summary of what was loaded." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the `load_data` function." },
            { correct: "// === Stage 3: Game Logic Implementation ===", distractors: [], indent: 0, "explanation": "Implement the functions that control the gameplay." },
            { correct: "void game_loop() {", distractors: [], indent: 0, "explanation": "Start the main game loop." },
            { correct: "  char input[100];", distractors: [], indent: 1, "explanation": "A buffer to hold the player's command." },
            { correct: "  printf(\"\\n--------------------\\n\");", distractors: [], indent: 1, "explanation": "Print a separator." },
            { correct: "  do_look(); // Look around when the game starts", distractors: [], indent: 1, "explanation": "Give the player an initial description of their surroundings." },
            { correct: "  while (1) { // Loop forever until 'quit'", distractors: [], indent: 1, "explanation": "The main game loop." },
            { correct: "    printf(\"\\n> \");", distractors: [], indent: 2, "explanation": "Print the command prompt." },
            { correct: "    fgets(input, sizeof(input), stdin);", distractors: [], indent: 2, "explanation": "Read a full line of input from the player." },
            { correct: "    input[strcspn(input, \"\\n\")] = 0; // Remove trailing newline", distractors: [], indent: 2, "explanation": "Safely remove the newline character that `fgets` reads." },
            { correct: "    char* command = strtok(input, \" \");", distractors: [], indent: 2, "explanation": "Get the first word of the input as the command." },
            { correct: "    char* argument = strtok(NULL, \"\"); // Get the rest as the argument", distractors: [], indent: 2, "explanation": "Get the second part of the input (if any)." },
            { correct: "    if (command == NULL) continue;", distractors: [], indent: 2, "explanation": "If the user just pressed Enter, loop again." },
            { correct: "    if (strcmp(command, \"quit\") == 0) break;", distractors: [], indent: 2, "explanation": "Check for the 'quit' command to exit the loop." },
            { correct: "    else if (strcmp(command, \"look\") == 0) do_look();", distractors: [], indent: 2, "explanation": "Handle the 'look' command." },
            { correct: "    else if (strcmp(command, \"north\") == 0) do_move(\"north\");", distractors: [], indent: 2, "explanation": "Handle the 'north' command." },
            { correct: "    else if (strcmp(command, \"south\") == 0) do_move(\"south\");", distractors: [], indent: 2, "explanation": "Handle the 'south' command." },
            { correct: "    else if (strcmp(command, \"take\") == 0) do_take(argument);", distractors: [], indent: 2, "explanation": "Handle the 'take' command." },
            { correct: "    else if (strcmp(command, \"inventory\") == 0) do_inventory();", distractors: [], indent: 2, "explanation": "Handle the 'inventory' command." },
            { correct: "    else printf(\"I don't understand that command.\\n\");", distractors: [], indent: 2, "explanation": "Handle unknown commands." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the `while` loop." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `game_loop`." },
            { correct: "void do_look() {", distractors: [], indent: 0, "explanation": "Implement the look command." },
            { correct: "  Room current_room = rooms[player_location_id];", distractors: [], indent: 1, "explanation": "Get the current room's data." },
            { correct: "  printf(\"\\n%s\\n\", current_room.name);", distractors: [], indent: 1, "explanation": "Print the room's name." },
            { correct: "  printf(\"%s\\n\", current_room.description);", distractors: [], indent: 1, "explanation": "Print the room's description." },
            { correct: "  printf(\"Objects here: \");", distractors: [], indent: 1, "explanation": "Header for objects." },
            { correct: "  int objects_found = 0;", distractors: [], indent: 1, "explanation": "A flag to see if any objects are in the room." },
            { correct: "  for(int i=0; i<object_count; i++) {", distractors: [], indent: 1, "explanation": "Loop through all objects to see which are in the current room." },
            { correct: "    if (objects[i].location_id == player_location_id) {", distractors: [], indent: 2, "explanation": "Check if the object's location matches the player's." },
            { correct: "      printf(\"%s \", objects[i].name);", distractors: [], indent: 3, "explanation": "Print the name of the object." },
            { correct: "      objects_found = 1;", distractors: [], indent: 3, "explanation": "Set the flag." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the if." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the loop." },
            { correct: "  if (!objects_found) { printf(\"nothing.\"); }", distractors: [], indent: 1, "explanation": "If no objects were found, say so." },
            { correct: "  printf(\"\\n\");", distractors: [], indent: 1, "explanation": "Final newline." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `do_look`." },
            { correct: "void do_move(const char* direction) {", distractors: [], indent: 0, "explanation": "Implement movement." },
            { correct: "  Room current_room = rooms[player_location_id];", distractors: [], indent: 1, "explanation": "Get the current room." },
            { correct: "  int next_room_id = -1;", distractors: [], indent: 1, "explanation": "Initialize the next room ID to -1 (no exit)." },
            { correct: "  if (strcmp(direction, \"north\") == 0) next_room_id = current_room.north;", distractors: [], indent: 1, "explanation": "Check for north direction." },
            { correct: "  if (strcmp(direction, \"south\") == 0) next_room_id = current_room.south;", distractors: [], indent: 1, "explanation": "Check for south direction." },
            { correct: "  if (next_room_id != -1) {", distractors: [], indent: 1, "explanation": "If an exit exists in that direction..." },
            { correct: "    player_location_id = next_room_id;", distractors: [], indent: 2, "explanation": "Update the player's location." },
            { correct: "    do_look();", distractors: [], indent: 2, "explanation": "Automatically look around the new room." },
            { correct: "  } else {", distractors: [], indent: 1, "explanation": "If there's no exit..." },
            { correct: "    printf(\"You can't go that way.\\n\");", distractors: [], indent: 2, "explanation": "Print an error message." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the if/else." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `do_move`." }
        ]
    },
    // Level 80: architecture of an Entity Component System
    {
        "goal": "Implement the basic architecture of an Entity Component System (ECS) to manage game entities.",
        concepts: "Data-oriented design, structs, arrays, enums, bitmasks, game loops",
        sequence: [
            { correct: "// === Stage 1: Setup and Core ECS Definitions ===", distractors: [], indent: 0, "explanation": "Define the constants, data structures (components), and entity management system." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "For `memset`." },
            { correct: "#define MAX_ENTITIES 100", distractors: [], indent: 0, "explanation": "The maximum number of entities our simple game can have." },
            { correct: "// --- Components: Plain Old Data Structs ---", distractors: [], indent: 0, "explanation": "Components hold data, and nothing else. They have no logic." },
            { correct: "typedef struct { int x, y; } Position;", distractors: [], indent: 0, "explanation": "A component to store an entity's position." },
            { correct: "typedef struct { int dx, dy; } Velocity;", distractors: [], indent: 0, "explanation": "A component to store an entity's velocity." },
            { correct: "typedef struct { int hp; int max_hp; } Health;", distractors: [], indent: 0, "explanation": "A component to store an entity's health points." },
            { correct: "// --- Component Masks using Bitwise Flags ---", distractors: [], indent: 0, "explanation": "We use bitmasks to track which components an entity has." },
            { correct: "typedef enum {", distractors: [], indent: 0, "explanation": "Use an enum for readable flag names." },
            { correct: "  COMPONENT_NONE     = 0,", distractors: [], indent: 1, "explanation": "Represents an entity with no components." },
            { correct: "  COMPONENT_POSITION = 1 << 0, // 1", distractors: [], indent: 1, "explanation": "The bit for the Position component." },
            { correct: "  COMPONENT_VELOCITY = 1 << 1, // 2", distractors: [], indent: 1, "explanation": "The bit for the Velocity component." },
            { correct: "  COMPONENT_HEALTH   = 1 << 2  // 4", distractors: [], indent: 1, "explanation": "The bit for the Health component." },
            { correct: "} ComponentMask;", distractors: [], indent: 0, "explanation": "Close the enum definition." },
            { correct: "// --- The World: A struct to hold all our component arrays ---", distractors: [], indent: 0, "explanation": "The 'World' is the main container for all ECS data." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin the World definition." },
            { correct: "  int masks[MAX_ENTITIES]; // masks[i] stores the component mask for entity i", distractors: [], indent: 1, "explanation": "An array to track which components each entity has." },
            { correct: "  Position positions[MAX_ENTITIES];", distractors: [], indent: 1, "explanation": "A tightly packed array of all Position components." },
            { correct: "  Velocity velocities[MAX_ENTITIES];", distractors: [], indent: 1, "explanation": "A tightly packed array of all Velocity components." },
            { correct: "  Health healths[MAX_ENTITIES];", distractors: [], indent: 1, "explanation": "A tightly packed array of all Health components." },
            { correct: "} World;", distractors: [], indent: 0, "explanation": "Close the World definition." },
            { correct: "// --- Stage 2: Entity and System Implementations ---", distractors: [], indent: 0, "explanation": "Create functions to manage entities and the systems that operate on them." },
            { correct: "World world; // A global world object for simplicity.", distractors: [], indent: 0, "explanation": "Instantiate our game world." },
            { correct: "int next_entity_id = 0;", distractors: [], indent: 0, "explanation": "A simple counter to create new, unique entity IDs." },
            { correct: "void world_init() {", distractors: [], indent: 0, "explanation": "A function to initialize the world state." },
            { correct: "  memset(&world, 0, sizeof(World));", distractors: [], indent: 1, "explanation": "Use `memset` to zero out all component arrays and masks." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `world_init`." },
            { correct: "int create_entity() {", distractors: [], indent: 0, "explanation": "A function to create a new, empty entity." },
            { correct: "  if (next_entity_id >= MAX_ENTITIES) return -1; // Error, out of entities", distractors: [], indent: 1, "explanation": "Check if we've exceeded our maximum entity count." },
            { correct: "  world.masks[next_entity_id] = COMPONENT_NONE;", distractors: [], indent: 1, "explanation": "Initialize the mask for the new entity to NONE." },
            { correct: "  return next_entity_id++;", distractors: [], indent: 1, "explanation": "Return the new ID and then increment the global counter for the next one." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `create_entity`." },
            { correct: "// --- System Functions ---", distractors: [], indent: 0, "explanation": "Systems are functions that iterate over entities with specific components." },
            { correct: "void movement_system() {", distractors: [], indent: 0, "explanation": "This system updates the position of any entity that can move." },
            { correct: "  printf(\"-> Running Movement System...\\n\");", distractors: [], indent: 1, "explanation": "Trace message." },
            { correct: "  // Define the mask for entities this system cares about.", distractors: [], indent: 1, "explanation": "Comment on the system's component requirements." },
            { correct: "  const int required_mask = COMPONENT_POSITION | COMPONENT_VELOCITY;", distractors: [], indent: 1, "explanation": "This system needs entities with BOTH a Position and a Velocity." },
            { correct: "  for (int i = 0; i < next_entity_id; i++) {", distractors: [], indent: 1, "explanation": "Iterate through all created entities." },
            { correct: "    if ((world.masks[i] & required_mask) == required_mask) {", distractors: [], indent: 2, "explanation": "Use a bitwise AND to check if the entity has all the required components." },
            { correct: "      // This entity is affected by the movement system.", distractors: [], indent: 3, "explanation": "Comment on the system's logic." },
            { correct: "      world.positions[i].x += world.velocities[i].dx;", distractors: [], indent: 3, "explanation": "Update the x position using the x velocity." },
            { correct: "      world.positions[i].y += world.velocities[i].dy;", distractors: [], indent: 3, "explanation": "Update the y position using the y velocity." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the mask check." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the entity loop." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the movement system." },
            { correct: "void health_system() {", distractors: [], indent: 0, "explanation": "A system to report the health of entities that have it." },
            { correct: "  printf(\"-> Running Health System...\\n\");", distractors: [], indent: 1, "explanation": "Trace message." },
            { correct: "  for (int i = 0; i < next_entity_id; i++) {", distractors: [], indent: 1, "explanation": "Iterate through all entities." },
            { correct: "    if ((world.masks[i] & COMPONENT_HEALTH) != 0) {", distractors: [], indent: 2, "explanation": "Check if the entity has a Health component." },
            { correct: "      printf(\"  - Entity %d has %d/%d HP.\\n\", i, world.healths[i].hp, world.healths[i].max_hp);", distractors: [], indent: 3, "explanation": "Print the entity's health status." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the mask check." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the entity loop." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the health system." },
            { correct: "// --- Stage 3: Main Program to Demonstrate the ECS ---", distractors: [], indent: 0, "explanation": "Set up entities and run the systems." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  world_init();", distractors: [], indent: 1, "explanation": "Initialize the game world." },
            { correct: "  printf(\"--- Creating Entities ---\\n\");", distractors: [], indent: 1, "explanation": "Header for entity creation." },
            { correct: "  // Create a 'Player' entity that can move and has health.", distractors: [], indent: 1, "explanation": "Comment on the player entity." },
            { correct: "  int player = create_entity();", distractors: [], indent: 1, "explanation": "Create the first entity, with ID 0." },
            { correct: "  world.masks[player] = COMPONENT_POSITION | COMPONENT_VELOCITY | COMPONENT_HEALTH;", distractors: [], indent: 1, "explanation": "Assign multiple components to the player using bitwise OR." },
            { correct: "  world.positions[player] = (Position){ .x = 10, .y = 20 };", distractors: [], indent: 1, "explanation": "Set the player's initial position component data." },
            { correct: "  world.velocities[player] = (Velocity){ .dx = 1, .dy = -1 };", distractors: [], indent: 1, "explanation": "Set the player's velocity component data." },
            { correct: "  world.healths[player] = (Health){ .hp = 100, .max_hp = 100 };", distractors: [], indent: 1, "explanation": "Set the player's health component data." },
            { correct: "  // Create a 'Boulder' entity that can only move.", distractors: [], indent: 1, "explanation": "Comment on the boulder entity." },
            { correct: "  int boulder = create_entity();", distractors: [], indent: 1, "explanation": "Create the second entity, with ID 1." },
            { correct: "  world.masks[boulder] = COMPONENT_POSITION | COMPONENT_VELOCITY;", distractors: [], indent: 1, "explanation": "Assign Position and Velocity components." },
            { correct: "  world.positions[boulder] = (Position){ .x = 50, .y = 50 };", distractors: [], indent: 1, "explanation": "Set the boulder's position." },
            { correct: "  world.velocities[boulder] = (Velocity){ .dx = -2, .dy = 0 };", distractors: [], indent: 1, "explanation": "Set the boulder's velocity." },
            { correct: "  // Create a 'Tree' entity that only has a position.", distractors: [], indent: 1, "explanation": "Comment on the tree entity." },
            { correct: "  int tree = create_entity();", distractors: [], indent: 1, "explanation": "Create the third entity, with ID 2." },
            { correct: "  world.masks[tree] = COMPONENT_POSITION;", distractors: [], indent: 1, "explanation": "Assign only the Position component." },
            { correct: "  world.positions[tree] = (Position){ .x = 80, .y = 10 };", distractors: [], indent: 1, "explanation": "Set the tree's position." },
            { correct: "  printf(\"Entities created.\\n\");", distractors: [], indent: 1, "explanation": "Confirmation message." },
            { correct: "  // --- Main Game Loop Simulation ---", distractors: [], indent: 1, "explanation": "Simulate a few ticks of the game loop." },
            { correct: "  for (int frame = 1; frame <= 3; frame++) {", distractors: [], indent: 1, "explanation": "Loop for 3 frames." },
            { correct: "    printf(\"\\n--- Game Frame %d ---\\n\", frame);", distractors: [], indent: 2, "explanation": "Print the current frame number." },
            { correct: "    // In a real game, you would also handle input and rendering here.", distractors: [], indent: 2, "explanation": "Comment on other game loop parts." },
            { correct: "    movement_system();", distractors: [], indent: 2, "explanation": "Run the movement system to update all positions." },
            { correct: "    health_system();", distractors: [], indent: 2, "explanation": "Run the health system to report on health." },
            { correct: "    // Print the state of entities that moved", distractors: [], indent: 2, "explanation": "Comment on state reporting." },
            { correct: "    printf(\"Updated Positions:\\n\");", distractors: [], indent: 2, "explanation": "Header." },
            { correct: "    printf(\"  - Player at (%d, %d)\\n\", world.positions[player].x, world.positions[player].y);", distractors: [], indent: 2, "explanation": "Print player's new position." },
            { correct: "    printf(\"  - Boulder at (%d, %d)\\n\", world.positions[boulder].x, world.positions[boulder].y);", distractors: [], indent: 2, "explanation": "Print boulder's new position." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the game loop." },
            { correct: "  printf(\"\\nGame simulation finished.\\n\");", distractors: [], indent: 1, "explanation": "Final message." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
    // Level 81: Build an asset manager
    {
        "goal": "Build an asset manager to load game resources by name, using a hash table to prevent duplicate loads.",
        concepts: "Hash tables, resource management, file I/O, `strdup`, data-driven design",
        sequence: [
            { correct: "// === Stage 1: Setup and Data Structures ===", distractors: [], indent: 0, "explanation": "Define includes and the structures for our assets and asset manager." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Memory management." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "String manipulation." },
            { correct: "#define HASH_TABLE_SIZE 256", distractors: [], indent: 0, "explanation": "The number of buckets in our asset hash table." },
            { correct: "// A generic Asset struct. In a real engine, this might be a union or have a type enum.", distractors: [], indent: 0, "explanation": "Comment on the base Asset struct." },
            { correct: "typedef struct Asset {", distractors: [], indent: 0, "explanation": "Begin Asset definition. All assets share these properties." },
            { correct: "  char* name;", distractors: [], indent: 1, "explanation": "The name of the asset (e.g., \"player_sprite.png\"), used as the key." },
            { correct: "  void* data; // Pointer to the actual asset data (e.g., a Texture or Model struct).", distractors: [], indent: 1, "explanation": "A void pointer to hold any kind of asset data." },
            { correct: "  struct Asset* next;", distractors: [], indent: 1, "explanation": "Pointer for the hash table's collision-handling linked list." },
            { correct: "} Asset;", distractors: [], indent: 0, "explanation": "Close the Asset typedef." },
            { correct: "// A simple struct for a Texture asset.", distractors: [], indent: 0, "explanation": "Example of a specific asset type." },
            { correct: "typedef struct { int width, height, channels; } Texture;", distractors: [], indent: 0, "explanation": "Represents a loaded texture's metadata." },
            { correct: "// The AssetManager, which is a hash table.", distractors: [], indent: 0, "explanation": "Comment on the main manager struct." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin AssetManager definition." },
            { correct: "  Asset* buckets[HASH_TABLE_SIZE];", distractors: [], indent: 1, "explanation": "An array of pointers to Assets, forming the hash table." },
            { correct: "} AssetManager;", distractors: [], indent: 0, "explanation": "Close the AssetManager typedef." },
            { correct: "// --- Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare the public API of our asset manager." },
            { correct: "AssetManager* asset_manager_create();", distractors: [], indent: 0, "explanation": "Initializes the asset manager." },
            { correct: "Asset* asset_load(AssetManager* am, const char* name);", distractors: [], indent: 0, "explanation": "Loads an asset by name, preventing duplicates." },
            { correct: "Asset* asset_get(AssetManager* am, const char* name);", distractors: [], indent: 0, "explanation": "Retrieves an already loaded asset." },
            { correct: "void asset_manager_destroy(AssetManager* am);", distractors: [], indent: 0, "explanation": "Frees all loaded assets and the manager itself." },
            { correct: "// --- Stage 2: Hash and Asset Manager Implementation ---", distractors: [], indent: 0, "explanation": "Implement the core logic." },
            { correct: "unsigned long hash_function(const char* str) {", distractors: [], indent: 0, "explanation": "The djb2 hash function, good for string keys." },
            { correct: "  unsigned long hash = 5381; int c; while((c = *str++)) hash = ((hash << 5) + hash) + c;", distractors: [], indent: 1, "explanation": "A compact implementation of the hashing algorithm." },
            { correct: "  return hash % HASH_TABLE_SIZE;", distractors: [], indent: 1, "explanation": "Constrain the hash to the table size." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the hash function." },
            { correct: "AssetManager* asset_manager_create() {", distractors: [], indent: 0, "explanation": "The constructor for the asset manager." },
            { correct: "  AssetManager* am = malloc(sizeof(AssetManager));", distractors: [], indent: 1, "explanation": "Allocate memory for the manager." },
            { correct: "  if (!am) return NULL;", distractors: [], indent: 1, "explanation": "Handle allocation failure." },
            { correct: "  memset(am->buckets, 0, sizeof(am->buckets));", distractors: [], indent: 1, "explanation": "Initialize all buckets to NULL." },
            { correct: "  return am;", distractors: [], indent: 1, "explanation": "Return the new manager." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the constructor." },
            { correct: "Asset* asset_get(AssetManager* am, const char* name) {", distractors: [], indent: 0, "explanation": "Function to retrieve an asset from the manager." },
            { correct: "  unsigned long index = hash_function(name);", distractors: [], indent: 1, "explanation": "Calculate the index for the asset name." },
            { correct: "  for (Asset* asset = am->buckets[index]; asset != NULL; asset = asset->next) {", distractors: [], indent: 1, "explanation": "Traverse the linked list at the calculated index." },
            { correct: "    if (strcmp(asset->name, name) == 0) {", distractors: [], indent: 2, "explanation": "If the names match..." },
            { correct: "      return asset; // Found it", distractors: [], indent: 3, "explanation": "Return the pointer to the asset." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the string compare." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the traversal loop." },
            { correct: "  return NULL; // Not found in cache", distractors: [], indent: 1, "explanation": "Return NULL if the asset is not loaded." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `asset_get`." },
            { correct: "Asset* asset_load(AssetManager* am, const char* name) {", distractors: [], indent: 0, "explanation": "The main loading function." },
            { correct: "  // First, check if the asset is already loaded to prevent duplicate work.", distractors: [], indent: 1, "explanation": "This is the core caching logic." },
            { correct: "  Asset* existing_asset = asset_get(am, name);", distractors: [], indent: 1, "explanation": "Use our get function to check the cache." },
            { correct: "  if (existing_asset) {", distractors: [], indent: 1, "explanation": "If the asset was found..." },
            { correct: "    printf(\"INFO: Asset '%s' already loaded. Returning cached version.\\n\", name);", distractors: [], indent: 2, "explanation": "Print an informational message." },
            { correct: "    return existing_asset;", distractors: [], indent: 2, "explanation": "Return the existing asset handle." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the check." },
            { correct: "  // If not found, load it from disk (simulation).", distractors: [], indent: 1, "explanation": "Comment on the loading from disk part." },
            { correct: "  printf(\"INFO: Loading asset '%s' from disk...\\n\", name);", distractors: [], indent: 1, "explanation": "Simulate a disk read." },
            { correct: "  // In a real engine, you'd fopen(name, \"rb\") and read data.", distractors: [], indent: 1, "explanation": "Comment on real-world implementation." },
            { correct: "  Texture* tex_data = malloc(sizeof(Texture));", distractors: [], indent: 1, "explanation": "Simulate loading by allocating a Texture struct." },
            { correct: "  tex_data->width = 64; tex_data->height = 64; tex_data->channels = 4;", distractors: [], indent: 1, "explanation": "Populate the simulated texture data." },
            { correct: "  // Now, create the main Asset handle for it.", distractors: [], indent: 1, "explanation": "Comment on creating the asset handle." },
            { correct: "  Asset* new_asset = malloc(sizeof(Asset));", distractors: [], indent: 1, "explanation": "Allocate memory for the asset container." },
            { correct: "  new_asset->name = strdup(name);", distractors: [], indent: 1, "explanation": "Allocate and copy the asset name." },
            { correct: "  new_asset->data = tex_data;", distractors: [], indent: 1, "explanation": "Point the generic data pointer to our specific Texture data." },
            { correct: "  // Insert the new asset into the hash table.", distractors: [], indent: 1, "explanation": "Comment on inserting into the hash table." },
            { correct: "  unsigned long index = hash_function(name);", distractors: [], indent: 1, "explanation": "Calculate the index." },
            { correct: "  new_asset->next = am->buckets[index];", distractors: [], indent: 1, "explanation": "Insert at the head of the collision list." },
            { correct: "  am->buckets[index] = new_asset;", distractors: [], indent: 1, "explanation": "The new asset becomes the new head." },
            { correct: "  return new_asset;", distractors: [], indent: 1, "explanation": "Return the newly loaded asset." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `asset_load`." },
            { correct: "void asset_manager_destroy(AssetManager* am) {", distractors: [], indent: 0, "explanation": "The 'destructor' for the entire manager." },
            { correct: "  printf(\"INFO: Shutting down asset manager and freeing all assets.\\n\");", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  for (int i = 0; i < HASH_TABLE_SIZE; i++) {", distractors: [], indent: 1, "explanation": "Loop through every bucket." },
            { correct: "    Asset* asset = am->buckets[i];", distractors: [], indent: 2, "explanation": "Get the head of the current list." },
            { correct: "    while (asset) {", distractors: [], indent: 2, "explanation": "Traverse the list." },
            { correct: "      Asset* next = asset->next;", distractors: [], indent: 3, "explanation": "Save the next pointer." },
            { correct: "      printf(\"  - Freeing asset: %s\\n\", asset->name);", distractors: [], indent: 3, "explanation": "Log which asset is being freed." },
            { correct: "      free(asset->data); // Free the specific asset data (the Texture).", distractors: [], indent: 3, "explanation": "Free the `data` payload." },
            { correct: "      free(asset->name); // Free the name string.", distractors: [], indent: 3, "explanation": "Free the key." },
            { correct: "      free(asset);       // Free the container struct.", distractors: [], indent: 3, "explanation": "Free the `Asset` node." },
            { correct: "      asset = next;", distractors: [], indent: 3, "explanation": "Move to the next asset." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close inner loop." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close outer loop." },
            { correct: "  free(am);", distractors: [], indent: 1, "explanation": "Finally, free the manager itself." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `asset_manager_destroy`." },
            { correct: "// === Stage 3: Main Program to Demonstrate the Asset Manager ===", distractors: [], indent: 0, "explanation": "A `main` function to test our asset manager." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  AssetManager* am = asset_manager_create();", distractors: [], indent: 1, "explanation": "Initialize the asset manager." },
            { correct: "  printf(\"--- Asset Loading Simulation ---\\n\");", distractors: [], indent: 1, "explanation": "Header." },
            { correct: "  // Request assets. The manager will load them from 'disk'.", distractors: [], indent: 1, "explanation": "Comment on the first loading phase." },
            { correct: "  Asset* player_sprite = asset_load(am, \"player.png\");", distractors: [], indent: 1, "explanation": "Load the player sprite. This will read from 'disk'." },
            { correct: "  Asset* enemy_sprite = asset_load(am, \"enemy.png\");", distractors: [], indent: 1, "explanation": "Load the enemy sprite. Also reads from 'disk'." },
            { correct: "  Asset* background_music = asset_load(am, \"music.ogg\");", distractors: [], indent: 1, "explanation": "Load the music. Also reads from 'disk'." },
            { correct: "  printf(\"\\n--- Requesting Assets Again ---\\n\");", distractors: [], indent: 1, "explanation": "Header for the second phase." },
            { correct: "  // Requesting the same asset again should be fast and use the cache.", distractors: [], indent: 1, "explanation": "Demonstrate the caching behavior." },
            { correct: "  Asset* player_sprite_again = asset_load(am, \"player.png\");", distractors: [], indent: 1, "explanation": "Request 'player.png' again. This time it will be found in the hash table and returned immediately." },
            { correct: "  if (player_sprite == player_sprite_again) {", distractors: [], indent: 1, "explanation": "Check if the pointers are the same." },
            { correct: "    printf(\"SUCCESS: Pointers for original and cached 'player.png' are identical.\\n\");", distractors: [], indent: 2, "explanation": "Confirm that no new memory was allocated." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the check." },
            { correct: "  // Use a retrieved asset.", distractors: [], indent: 1, "explanation": "Comment on using an asset." },
            { correct: "  Asset* found_asset = asset_get(am, \"enemy.png\");", distractors: [], indent: 1, "explanation": "Get an asset using the `get` function." },
            { correct: "  if (found_asset) {", distractors: [], indent: 1, "explanation": "If found..." },
            { correct: "    Texture* tex = (Texture*)found_asset->data;", distractors: [], indent: 2, "explanation": "Cast the generic `void*` data back to its specific `Texture*` type." },
            { correct: "    printf(\"Retrieved enemy texture data: %dx%d, %d channels.\\n\", tex->width, tex->height, tex->channels);", distractors: [], indent: 2, "explanation": "Use the specific texture data." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the check." },
            { correct: "  printf(\"\\n--- System Shutdown ---\\n\");", distractors: [], indent: 1, "explanation": "Header for cleanup." },
            { correct: "  asset_manager_destroy(am);", distractors: [], indent: 1, "explanation": "Free all loaded assets and the manager itself." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
    // Level 82: Implement a Finite State Machine
    {
        "goal": "Implement a Finite State Machine (FSM) to control the behavior of a simple game AI.",
        concepts: "Finite State Machine (FSM), `enum`, `switch`, state transitions, game AI",
        sequence: [
            { correct: "// === Stage 1: Setup and Core FSM Structures ===", distractors: [], indent: 0, "explanation": "Define the states, and the data structures for our player and monster." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O." },
            { correct: "#include <stdlib.h> // For abs()", distractors: [], indent: 0, "explanation": "Include for the absolute value function." },
            { correct: "// 1. Define the possible states for our monster AI using an enum.", distractors: [], indent: 0, "explanation": "Enums are perfect for defining a fixed set of states." },
            { correct: "typedef enum {", distractors: [], indent: 0, "explanation": "Begin State enum." },
            { correct: "  STATE_IDLE,", distractors: [], indent: 1, "explanation": "The monster is waiting and doing nothing." },
            { correct: "  STATE_PATROLLING,", distractors: [], indent: 1, "explanation": "The monster is moving back and forth between two points." },
            { correct: "  STATE_CHASING,", distractors: [], indent: 1, "explanation": "The monster has detected the player and is moving towards them." },
            { correct: "  STATE_ATTACKING", distractors: [], indent: 1, "explanation": "The monster is close enough to the player to attack." },
            { correct: "} MonsterState;", distractors: [], indent: 0, "explanation": "Close the enum typedef." },
            { correct: "// 2. Define data structures for our game entities.", distractors: [], indent: 0, "explanation": "Structs to hold the data for the player and monster." },
            { correct: "typedef struct { int x, y; } Player;", distractors: [], indent: 0, "explanation": "A simple struct for the player's position." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "The main struct for our AI-controlled monster." },
            { correct: "  int x, y;", distractors: [], indent: 1, "explanation": "The monster's current position." },
            { correct: "  MonsterState current_state;", distractors: [], indent: 1, "explanation": "The current state of the monster's FSM." },
            { correct: "  int patrol_start_x; // The start point for its patrol route.", distractors: [], indent: 1, "explanation": "Data specific to the patrolling state." },
            { correct: "  int patrol_end_x;   // The end point for its patrol route.", distractors: [], indent: 1, "explanation": "More patrolling data." },
            { correct: "  int patrol_dir;", distractors: [], indent: 1, "explanation": "Current patrol direction (1 for right, -1 for left)." },
            { correct: "} Monster;", distractors: [], indent: 0, "explanation": "Close the Monster struct typedef." },
            { correct: "// --- Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare the functions for our state machine logic." },
            { correct: "void monster_init(Monster* m, int start_x, int patrol_end);", distractors: [], indent: 0, "explanation": "Initializes a monster's state." },
            { correct: "void monster_update(Monster* m, const Player* p);", distractors: [], indent: 0, "explanation": "The main FSM update function, called each game tick." },
            { correct: "void monster_print_status(const Monster* m);", distractors: [], indent: 0, "explanation": "A helper to print the monster's status." },
            { correct: "// --- Stage 2: FSM and Logic Implementation ---", distractors: [], indent: 0, "explanation": "Implement the functions that control the AI's behavior." },
            { correct: "void monster_init(Monster* m, int start_x, int patrol_end) {", distractors: [], indent: 0, "explanation": "Start the monster initializer function." },
            { correct: "  m->x = start_x;", distractors: [], indent: 1, "explanation": "Set initial X position." },
            { correct: "  m->y = 10;", distractors: [], indent: 1, "explanation": "Set a fixed Y position." },
            { correct: "  m->current_state = STATE_IDLE;", distractors: [], indent: 1, "explanation": "The monster always starts in the IDLE state." },
            { correct: "  m->patrol_start_x = start_x;", distractors: [], indent: 1, "explanation": "Set the left boundary for its patrol." },
            { correct: "  m->patrol_end_x = patrol_end;", distractors: [], indent: 1, "explanation": "Set the right boundary for its patrol." },
            { correct: "  m->patrol_dir = 1;", distractors: [], indent: 1, "explanation": "It starts by patrolling to the right." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the init function." },
            { correct: "const char* state_to_string(MonsterState state) {", distractors: [], indent: 0, "explanation": "A helper function to convert a state enum to a printable string." },
            { correct: "  switch(state) {", distractors: [], indent: 1, "explanation": "Use a switch statement for the conversion." },
            { correct: "    case STATE_IDLE: return \"IDLE\";", distractors: [], indent: 2, "explanation": "Return string for IDLE." },
            { correct: "    case STATE_PATROLLING: return \"PATROLLING\";", distractors: [], indent: 2, "explanation": "Return string for PATROLLING." },
            { correct: "    case STATE_CHASING: return \"CHASING\";", distractors: [], indent: 2, "explanation": "Return string for CHASING." },
            { correct: "    case STATE_ATTACKING: return \"ATTACKING\";", distractors: [], indent: 2, "explanation": "Return string for ATTACKING." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the switch." },
            { correct: "  return \"UNKNOWN\";", distractors: [], indent: 1, "explanation": "Return a default string." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the helper function." },
            { correct: "void monster_print_status(const Monster* m) {", distractors: [], indent: 0, "explanation": "Implementation of the status printing function." },
            { correct: "  printf(\"Monster is at (%d, %d) in state: %s\\n\", m->x, m->y, state_to_string(m->current_state));", distractors: [], indent: 1, "explanation": "Print the monster's position and current state." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `monster_print_status`." },
            { correct: "void monster_update(Monster* m, const Player* p) {", distractors: [], indent: 0, "explanation": "The main FSM logic function." },
            { correct: "  int distance_to_player = abs(p->x - m->x);", distractors: [], indent: 1, "explanation": "Calculate the horizontal distance to the player." },
            { correct: "  // The switch statement forms the core of the FSM.", distractors: [], indent: 1, "explanation": "Comment on the FSM's structure." },
            { correct: "  switch (m->current_state) {", distractors: [], indent: 1, "explanation": "Switch on the monster's current state." },
            { correct: "    case STATE_IDLE:", distractors: [], indent: 2, "explanation": "Logic for when the monster is IDLE." },
            { correct: "      printf(\"  IDLE: Monster is waiting...\\n\");", distractors: [], indent: 3, "explanation": "Action: Print a message." },
            { correct: "      // Transition logic: If player gets close, start chasing.", distractors: [], indent: 3, "explanation": "Comment on state transition." },
            { correct: "      if (distance_to_player < 10) {", distractors: [], indent: 3, "explanation": "Check for transition condition." },
            { correct: "        m->current_state = STATE_CHASING;", distractors: [], indent: 4, "explanation": "Change the state to CHASING." },
            { correct: "      } else {", distractors: [], indent: 3, "explanation": "If no transition..." },
            { correct: "        m->current_state = STATE_PATROLLING;", distractors: [], indent: 4, "explanation": "Transition to PATROLLING after one turn of being idle." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close else." },
            { correct: "      break;", distractors: [], indent: 3, "explanation": "Exit the switch statement for this state." },
            { correct: "    case STATE_PATROLLING:", distractors: [], indent: 2, "explanation": "Logic for when the monster is PATROLLING." },
            { correct: "      printf(\"  PATROL: Monster is moving...\\n\");", distractors: [], indent: 3, "explanation": "Action: Print a message." },
            { correct: "      m->x += m->patrol_dir;", distractors: [], indent: 3, "explanation": "Action: Move the monster in its current patrol direction." },
            { correct: "      if (m->x >= m->patrol_end_x || m->x <= m->patrol_start_x) {", distractors: [], indent: 3, "explanation": "Check if the monster has reached the end of its patrol route." },
            { correct: "        m->patrol_dir *= -1; // Reverse direction", distractors: [], indent: 4, "explanation": "If so, reverse its patrol direction." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close patrol boundary check." },
            { correct: "      // Transition logic: If player gets close, start chasing.", distractors: [], indent: 3, "explanation": "Comment on state transition." },
            { correct: "      if (distance_to_player < 10) {", distractors: [], indent: 3, "explanation": "Check transition condition." },
            { correct: "        m->current_state = STATE_CHASING;", distractors: [], indent: 4, "explanation": "Change the state to CHASING." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close check." },
            { correct: "      break;", distractors: [], indent: 3, "explanation": "Exit the switch." },
            { correct: "    case STATE_CHASING:", distractors: [], indent: 2, "explanation": "Logic for when the monster is CHASING." },
            { correct: "      printf(\"  CHASE: Monster sees player!\\n\");", distractors: [], indent: 3, "explanation": "Action: Print a message." },
            { correct: "      // Action: Move towards the player.", distractors: [], indent: 3, "explanation": "Comment on action." },
            { correct: "      if (p->x > m->x) m->x++;", distractors: [], indent: 3, "explanation": "If player is to the right, move right." },
            { correct: "      else if (p->x < m->x) m->x--;", distractors: [], indent: 3, "explanation": "If player is to the left, move left." },
            { correct: "      // Transition logic: If close enough, attack. If too far, go back to patrolling.", distractors: [], indent: 3, "explanation": "Comment on transitions." },
            { correct: "      if (distance_to_player < 2) {", distractors: [], indent: 3, "explanation": "Check for attack range." },
            { correct: "        m->current_state = STATE_ATTACKING;", distractors: [], indent: 4, "explanation": "Transition to ATTACKING state." },
            { correct: "      } else if (distance_to_player > 15) {", distractors: [], indent: 3, "explanation": "Check if player has escaped." },
            { correct: "        m->current_state = STATE_PATROLLING;", distractors: [], indent: 4, "explanation": "Transition back to PATROLLING." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close else-if." },
            { correct: "      break;", distractors: [], indent: 3, "explanation": "Exit the switch." },
            { correct: "    case STATE_ATTACKING:", distractors: [], indent: 2, "explanation": "Logic for when the monster is ATTACKING." },
            { correct: "      printf(\"  ATTACK: Monster is attacking the player!\\n\");", distractors: [], indent: 3, "explanation": "Action: Print attack message." },
            { correct: "      // Transition logic: If player moves away, go back to chasing.", distractors: [], indent: 3, "explanation": "Comment on transition." },
            { correct: "      if (distance_to_player >= 2) {", distractors: [], indent: 3, "explanation": "Check if player has moved out of attack range." },
            { correct: "        m->current_state = STATE_CHASING;", distractors: [], indent: 4, "explanation": "Transition back to CHASING." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close check." },
            { correct: "      break;", distractors: [], indent: 3, "explanation": "Exit the switch." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the `switch` statement." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `monster_update`." },
            { correct: "// === Stage 3: Main Game Loop Simulation ===", distractors: [], indent: 0, "explanation": "A `main` function to simulate the game and test the FSM." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  Player player = { .x = 0, .y = 10 };", distractors: [], indent: 1, "explanation": "Create the player at position 0." },
            { correct: "  Monster monster;", distractors: [], indent: 1, "explanation": "Declare a monster." },
            { correct: "  monster_init(&monster, 30, 40);", distractors: [], indent: 1, "explanation": "Initialize the monster with a patrol route from x=30 to x=40." },
            { correct: "  printf(\"--- Game Simulation Starting ---\\n\");", distractors: [], indent: 1, "explanation": "Header." },
            { correct: "  printf(\"Player starts at: %d\\n\", player.x);", distractors: [], indent: 1, "explanation": "Print initial player position." },
            { correct: "  monster_print_status(&monster);", distractors: [], indent: 1, "explanation": "Print initial monster status." },
            { correct: "  // Simulate 20 ticks of the game loop.", distractors: [], indent: 1, "explanation": "Comment on the simulation loop." },
            { correct: "  for (int tick = 1; tick <= 20; tick++) {", distractors: [], indent: 1, "explanation": "Loop for 20 game ticks." },
            { correct: "    printf(\"\\n--- Tick %d ---\\n\", tick);", distractors: [], indent: 2, "explanation": "Print the current tick number." },
            { correct: "    // Move the player slowly towards the monster.", distractors: [], indent: 2, "explanation": "Simulate player movement." },
            { correct: "    if (tick < 18) player.x++;", distractors: [], indent: 2, "explanation": "The player moves right for most of the simulation." },
            { correct: "    printf(\"Player moved to: %d\\n\", player.x);", distractors: [], indent: 2, "explanation": "Announce player's new position." },
            { correct: "    monster_update(&monster, &player);", distractors: [], indent: 2, "explanation": "Update the monster's FSM based on the player's new position." },
            { correct: "    monster_print_status(&monster);", distractors: [], indent: 2, "explanation": "Print the monster's resulting status." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the game loop." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
    // Level 83: foundational library for matrix mathematics
    {
        "goal": "Build a foundational library for matrix mathematics, including creation, destruction, and multiplication.",
        concepts: "structs, dynamic memory, 2D data in 1D arrays, API design, linear algebra algorithms",
        sequence: [
            { correct: "// === Stage 1: The Public API Header File ('matrix.h') ===", distractors: [], indent: 0, "explanation": "Define the public interface for our matrix library." },
            { correct: "#include <stdlib.h> // For size_t", distractors: [], indent: 0, "explanation": "Include for the `size_t` type." },
            { correct: "// Opaque declaration of the Matrix struct.", distractors: [], indent: 0, "explanation": "Hide the internal structure from the user." },
            { correct: "struct Matrix;", distractors: [], indent: 0, "explanation": "Forward-declare the struct, making it an incomplete type." },
            { correct: "typedef struct Matrix* MatrixHandle;", distractors: [], indent: 0, "explanation": "Create a handle that users will interact with." },
            { correct: "// --- Public API Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare the library's functions." },
            { correct: "MatrixHandle matrix_create(size_t rows, size_t cols);", distractors: [], indent: 0, "explanation": "Creates a new matrix of a given size, initialized to zero." },
            { correct: "void matrix_destroy(MatrixHandle mat);", distractors: [], indent: 0, "explanation": "Frees all memory associated with a matrix." },
            { correct: "double matrix_get(const MatrixHandle mat, size_t row, size_t col);", distractors: [], indent: 0, "explanation": "Gets the value at a specific row and column." },
            { correct: "void matrix_set(MatrixHandle mat, size_t row, size_t col, double value);", distractors: [], indent: 0, "explanation": "Sets the value at a specific row and column." },
            { correct: "void matrix_print(const MatrixHandle mat);", distractors: [], indent: 0, "explanation": "Prints the matrix to the console in a readable format." },
            { correct: "MatrixHandle matrix_multiply(const MatrixHandle m1, const MatrixHandle m2);", distractors: [], indent: 0, "explanation": "Multiplies two matrices and returns a new matrix with the result." },
            { correct: "// === Stage 2: The Private Implementation ('matrix.c') ===", distractors: [], indent: 0, "explanation": "Implement the hidden logic of our matrix library." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Include for `printf`." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "Include for `memset`." },
            { correct: "// #include \"matrix.h\" // In a real project", distractors: [], indent: 0, "explanation": "Link implementation to the public header." },
            { correct: "// Full, private definition of the Matrix struct.", distractors: [], indent: 0, "explanation": "Complete the opaque type definition." },
            { correct: "struct Matrix {", distractors: [], indent: 0, "explanation": "Begin the struct definition." },
            { correct: "  size_t rows;", distractors: [], indent: 1, "explanation": "The number of rows in the matrix." },
            { correct: "  size_t cols;", distractors: [], indent: 1, "explanation": "The number of columns in the matrix." },
            { correct: "  double* data; // Data stored in a flat, 1D array in row-major order.", distractors: [], indent: 1, "explanation": "The matrix elements, stored contiguously in memory for performance." },
            { correct: "};", distractors: [], indent: 0, "explanation": "Close the struct definition." },
            { correct: "MatrixHandle matrix_create(size_t rows, size_t cols) {", distractors: [], indent: 0, "explanation": "Implement the 'constructor'." },
            { correct: "  MatrixHandle mat = malloc(sizeof(struct Matrix));", distractors: [], indent: 1, "explanation": "Allocate memory for the main Matrix struct." },
            { correct: "  if (!mat) return NULL;", distractors: [], indent: 1, "explanation": "Handle allocation failure." },
            { correct: "  mat->rows = rows;", distractors: [], indent: 1, "explanation": "Set the number of rows." },
            { correct: "  mat->cols = cols;", distractors: [], indent: 1, "explanation": "Set the number of columns." },
            { correct: "  mat->data = malloc(rows * cols * sizeof(double));", distractors: [], indent: 1, "explanation": "Allocate memory for the actual matrix data." },
            { correct: "  if (!mat->data) { free(mat); return NULL; }", distractors: [], indent: 1, "explanation": "If data allocation fails, clean up the struct and return NULL." },
            { correct: "  memset(mat->data, 0, rows * cols * sizeof(double));", distractors: [], indent: 1, "explanation": "Initialize all elements of the matrix to zero." },
            { correct: "  return mat;", distractors: [], indent: 1, "explanation": "Return the new matrix handle." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `matrix_create`." },
            { correct: "void matrix_destroy(MatrixHandle mat) {", distractors: [], indent: 0, "explanation": "Implement the 'destructor'." },
            { correct: "  if (!mat) return;", distractors: [], indent: 1, "explanation": "Safety check for a NULL handle." },
            { correct: "  free(mat->data);", distractors: [], indent: 1, "explanation": "Free the data array first." },
            { correct: "  free(mat);", distractors: [], indent: 1, "explanation": "Then free the struct itself." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `matrix_destroy`." },
            { correct: "// Helper macro for converting 2D index to 1D index.", distractors: [], indent: 0, "explanation": "This macro simplifies accessing elements in the flat data array." },
            { correct: "#define IDX(mat, r, c) ((r) * (mat)->cols + (c))", distractors: [], indent: 0, "explanation": "Defines the row-major order indexing formula." },
            { correct: "double matrix_get(const MatrixHandle mat, size_t row, size_t col) {", distractors: [], indent: 0, "explanation": "Implement the getter function." },
            { correct: "  if (!mat || row >= mat->rows || col >= mat->cols) return 0.0; // Return 0 on error/out of bounds", distractors: [], indent: 1, "explanation": "Perform bounds checking." },
            { correct: "  return mat->data[IDX(mat, row, col)];", distractors: [], indent: 1, "explanation": "Use the IDX macro to get the value from the 1D array." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `matrix_get`." },
            { correct: "void matrix_set(MatrixHandle mat, size_t row, size_t col, double value) {", distractors: [], indent: 0, "explanation": "Implement the setter function." },
            { correct: "  if (!mat || row >= mat->rows || col >= mat->cols) return;", distractors: [], indent: 1, "explanation": "Perform bounds checking." },
            { correct: "  mat->data[IDX(mat, row, col)] = value;", distractors: [], indent: 1, "explanation": "Use the IDX macro to set the value in the 1D array." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `matrix_set`." },
            { correct: "void matrix_print(const MatrixHandle mat) {", distractors: [], indent: 0, "explanation": "Implement the print function." },
            { correct: "  if (!mat) return;", distractors: [], indent: 1, "explanation": "Safety check." },
            { correct: "  printf(\"Matrix (%zu x %zu):\\n\", mat->rows, mat->cols);", distractors: [], indent: 1, "explanation": "Print the dimensions of the matrix." },
            { correct: "  for (size_t r = 0; r < mat->rows; r++) {", distractors: [], indent: 1, "explanation": "Loop through each row." },
            { correct: "    printf(\"  [ \");", distractors: [], indent: 2, "explanation": "Print an opening bracket for the row." },
            { correct: "    for (size_t c = 0; c < mat->cols; c++) {", distractors: [], indent: 2, "explanation": "Loop through each column in the row." },
            { correct: "      printf(\"%8.2f \", matrix_get(mat, r, c));", distractors: [], indent: 3, "explanation": "Print each element with fixed formatting." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the column loop." },
            { correct: "    printf(\"]\\n\");", distractors: [], indent: 2, "explanation": "Print a closing bracket and a newline." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the row loop." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `matrix_print`." },
            { correct: "MatrixHandle matrix_multiply(const MatrixHandle m1, const MatrixHandle m2) {", distractors: [], indent: 0, "explanation": "Implement matrix multiplication (C = A * B)." },
            { correct: "  // The number of columns in m1 must equal the number of rows in m2.", distractors: [], indent: 1, "explanation": "State the rule for matrix multiplication compatibility." },
            { correct: "  if (!m1 || !m2 || m1->cols != m2->rows) return NULL;", distractors: [], indent: 1, "explanation": "Check if the matrices are compatible." },
            { correct: "  // The result matrix has the dimensions (rows of m1, cols of m2).", distractors: [], indent: 1, "explanation": "Define the dimensions of the result matrix." },
            { correct: "  MatrixHandle result = matrix_create(m1->rows, m2->cols);", distractors: [], indent: 1, "explanation": "Create the result matrix." },
            { correct: "  if (!result) return NULL;", distractors: [], indent: 1, "explanation": "Handle creation failure." },
            { correct: "  // Perform the multiplication using three nested loops.", distractors: [], indent: 1, "explanation": "Comment on the algorithm." },
            { correct: "  for (size_t i = 0; i < m1->rows; i++) {", distractors: [], indent: 1, "explanation": "Loop through each row of the first matrix (m1)." },
            { correct: "    for (size_t j = 0; j < m2->cols; j++) {", distractors: [], indent: 2, "explanation": "Loop through each column of the second matrix (m2)." },
            { correct: "      double sum = 0.0;", distractors: [], indent: 3, "explanation": "Initialize the sum for the dot product." },
            { correct: "      for (size_t k = 0; k < m1->cols; k++) {", distractors: [], indent: 3, "explanation": "Loop through the elements of the row/column." },
            { correct: "        sum += matrix_get(m1, i, k) * matrix_get(m2, k, j);", distractors: [], indent: 4, "explanation": "Calculate the dot product of m1's row `i` and m2's column `j`." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close the inner dot product loop." },
            { correct: "      matrix_set(result, i, j, sum);", distractors: [], indent: 3, "explanation": "Set the calculated sum into the result matrix." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the column loop." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the row loop." },
            { correct: "  return result;", distractors: [], indent: 1, "explanation": "Return the final result matrix." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `matrix_multiply`." },
            { correct: "// === Stage 3: The Main Program to Demonstrate the Library ===", distractors: [], indent: 0, "explanation": "A `main` function to test our matrix library." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  MatrixHandle A = matrix_create(2, 3);", distractors: [], indent: 1, "explanation": "Create a 2x3 matrix." },
            { correct: "  matrix_set(A, 0, 0, 1); matrix_set(A, 0, 1, 2); matrix_set(A, 0, 2, 3);", distractors: [], indent: 1, "explanation": "Populate the first row of matrix A." },
            { correct: "  matrix_set(A, 1, 0, 4); matrix_set(A, 1, 1, 5); matrix_set(A, 1, 2, 6);", distractors: [], indent: 1, "explanation": "Populate the second row of matrix A." },
            { correct: "  MatrixHandle B = matrix_create(3, 2);", distractors: [], indent: 1, "explanation": "Create a 3x2 matrix." },
            { correct: "  matrix_set(B, 0, 0, 7); matrix_set(B, 0, 1, 8);", distractors: [], indent: 1, "explanation": "Populate the first row of matrix B." },
            { correct: "  matrix_set(B, 1, 0, 9); matrix_set(B, 1, 1, 10);", distractors: [], indent: 1, "explanation": "Populate the second row of matrix B." },
            { correct: "  matrix_set(B, 2, 0, 11); matrix_set(B, 2, 1, 12);", distractors: [], indent: 1, "explanation": "Populate the third row of matrix B." },
            { correct: "  printf(\"--- Input Matrices ---\\n\");", distractors: [], indent: 1, "explanation": "Header." },
            { correct: "  matrix_print(A);", distractors: [], indent: 1, "explanation": "Print matrix A." },
            { correct: "  matrix_print(B);", distractors: [], indent: 1, "explanation": "Print matrix B." },
            { correct: "  printf(\"\\n--- Multiplying A * B ---\\n\");", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  MatrixHandle C = matrix_multiply(A, B);", distractors: [], indent: 1, "explanation": "Perform the multiplication." },
            { correct: "  if (C) {", distractors: [], indent: 1, "explanation": "If the multiplication was successful..." },
            { correct: "    matrix_print(C);", distractors: [], indent: 2, "explanation": "Print the resulting 2x2 matrix." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the if." },
            { correct: "  // Cleanup", distractors: [], indent: 1, "explanation": "Comment on cleanup." },
            { correct: "  matrix_destroy(A);", distractors: [], indent: 1, "explanation": "Free matrix A." },
            { correct: "  matrix_destroy(B);", distractors: [], indent: 1, "explanation": "Free matrix B." },
            { correct: "  matrix_destroy(C);", distractors: [], indent: 1, "explanation": "Free matrix C." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
    // Level 84: Implement the K-Nearest Neighbors
    {
        "goal": "Implement the K-Nearest Neighbors (KNN) machine learning algorithm to classify new data points.",
        concepts: "structs, dynamic arrays, file I/O, qsort, `sqrt`, implementing ML algorithms",
        sequence: [
            { correct: "// === Stage 1: Setup and Data Structures ===", distractors: [], indent: 0, "explanation": "Define includes and the structures for our data points." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Memory management, `qsort`, `atof`." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "String manipulation." },
            { correct: "#include <math.h>", distractors: [], indent: 0, "explanation": "For `sqrt` and `pow` to calculate distance." },
            { correct: "#define MAX_LABEL_LEN 32", distractors: [], indent: 0, "explanation": "Max length of a class label (e.g., \"Cat\", \"Dog\")." },
            { correct: "// A struct to represent a single labeled data point in our dataset.", distractors: [], indent: 0, "explanation": "Comment on the DataPoint struct." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin DataPoint definition." },
            { correct: "  double x, y; // The features of our data point (e.g., coordinates).", distractors: [], indent: 1, "explanation": "The two features for our 2D data." },
            { correct: "  char label[MAX_LABEL_LEN]; // The class label for this data point.", distractors: [], indent: 1, "explanation": "The correct classification for this point." },
            { correct: "} DataPoint;", distractors: [], indent: 0, "explanation": "Close the DataPoint typedef." },
            { correct: "// A helper struct to store a point and its distance to the query point.", distractors: [], indent: 0, "explanation": "This struct will be used for sorting." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin DistanceEntry definition." },
            { correct: "  DataPoint point;", distractors: [], indent: 1, "explanation": "A copy of the original data point." },
            { correct: "  double distance;", distractors: [], indent: 1, "explanation": "The calculated distance." },
            { correct: "} DistanceEntry;", distractors: [], indent: 0, "explanation": "Close the DistanceEntry typedef." },
            { correct: "// --- Global Dataset ---", distractors: [], indent: 0, "explanation": "Global variables to hold the loaded training data." },
            { correct: "DataPoint* training_data = NULL;", distractors: [], indent: 0, "explanation": "A dynamic array to store the dataset." },
            { correct: "int data_count = 0;", distractors: [], indent: 0, "explanation": "The number of records in the dataset." },
            { correct: "// --- Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare our functions before use." },
            { correct: "void load_dataset(const char* filename);", distractors: [], indent: 0, "explanation": "Loads the training data from a CSV file." },
            { correct: "double euclidean_distance(DataPoint p1, DataPoint p2);", distractors: [], indent: 0, "explanation": "Calculates the distance between two points." },
            { correct: "int compare_distances(const void* a, const void* b);", distractors: [], indent: 0, "explanation": "A `qsort` comparator to sort entries by distance." },
            { correct: "const char* classify_point(DataPoint query_point, int k);", distractors: [], indent: 0, "explanation": "The main KNN prediction function." },
            { correct: "// --- Stage 2: Core Logic Implementation ---", distractors: [], indent: 0, "explanation": "Implement the functions for loading, distance calculation, and classification." },
            { correct: "void load_dataset(const char* filename) {", distractors: [], indent: 0, "explanation": "Start the dataset loading function." },
            { correct: "  FILE* fp = fopen(filename, \"r\");", distractors: [], indent: 1, "explanation": "Open the CSV file." },
            { correct: "  if (!fp) { perror(\"Failed to open dataset\"); exit(1); }", distractors: [], indent: 1, "explanation": "Handle file open error." },
            { correct: "  char line[128];", distractors: [], indent: 1, "explanation": "A buffer to read each line." },
            { correct: "  fgets(line, sizeof(line), fp); // Skip header row", distractors: [], indent: 1, "explanation": "Assume a header row and discard it." },
            { correct: "  while (fgets(line, sizeof(line), fp)) {", distractors: [], indent: 1, "explanation": "Loop, reading one data point at a time." },
            { correct: "    data_count++;", distractors: [], indent: 2, "explanation": "Increment the data point counter." },
            { correct: "    training_data = realloc(training_data, data_count * sizeof(DataPoint));", distractors: [], indent: 2, "explanation": "Resize the dynamic array to fit the new point." },
            { correct: "    sscanf(line, \"%lf,%lf,%s\", &training_data[data_count-1].x, &training_data[data_count-1].y, training_data[data_count-1].label);", distractors: [], indent: 2, "explanation": "Use `sscanf` to parse the X, Y, and Label from the CSV line. `%lf` is for doubles." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the reading loop." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the file." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `load_dataset`." },
            { correct: "double euclidean_distance(DataPoint p1, DataPoint p2) {", distractors: [], indent: 0, "explanation": "Implement the distance formula." },
            { correct: "  double dx = p1.x - p2.x;", distractors: [], indent: 1, "explanation": "Calculate the difference in x coordinates." },
            { correct: "  double dy = p1.y - p2.y;", distractors: [], indent: 1, "explanation": "Calculate the difference in y coordinates." },
            { correct: "  return sqrt(pow(dx, 2) + pow(dy, 2));", distractors: [], indent: 1, "explanation": "Return the square root of the sum of squares." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `euclidean_distance`." },
            { correct: "int compare_distances(const void* a, const void* b) {", distractors: [], indent: 0, "explanation": "Implement the `qsort` comparator." },
            { correct: "  DistanceEntry* entryA = (DistanceEntry*)a;", distractors: [], indent: 1, "explanation": "Cast the void pointers to our helper struct type." },
            { correct: "  DistanceEntry* entryB = (DistanceEntry*)b;", distractors: [], indent: 1, "explanation": "Cast the second argument." },
            { correct: "  if (entryA->distance < entryB->distance) return -1;", distractors: [], indent: 1, "explanation": "Return -1 if A is closer." },
            { correct: "  if (entryA->distance > entryB->distance) return 1;", distractors: [], indent: 1, "explanation": "Return 1 if B is closer." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Return 0 if distances are equal." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the comparator." },
            { correct: "const char* classify_point(DataPoint query_point, int k) {", distractors: [], indent: 0, "explanation": "The main KNN prediction logic." },
            { correct: "  // 1. Calculate distance from the query point to all training points.", distractors: [], indent: 1, "explanation": "First step of KNN." },
            { correct: "  DistanceEntry* distances = malloc(data_count * sizeof(DistanceEntry));", distractors: [], indent: 1, "explanation": "Create a temporary array to hold all distances." },
            { correct: "  for (int i=0; i < data_count; i++) {", distractors: [], indent: 1, "explanation": "Loop through the entire training set." },
            { correct: "    distances[i].point = training_data[i];", distractors: [], indent: 2, "explanation": "Copy the data point." },
            { correct: "    distances[i].distance = euclidean_distance(query_point, training_data[i]);", distractors: [], indent: 2, "explanation": "Calculate and store its distance from the query point." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the distance calculation loop." },
            { correct: "  // 2. Sort the distances in ascending order.", distractors: [], indent: 1, "explanation": "Second step of KNN." },
            { correct: "  qsort(distances, data_count, sizeof(DistanceEntry), compare_distances);", distractors: [], indent: 1, "explanation": "Use `qsort` to sort the helper array by distance." },
            { correct: "  // 3. Find the most common label among the first 'k' neighbors.", distractors: [], indent: 1, "explanation": "Third step of KNN: Voting." },
            { correct: "  // (This is a simplified voting implementation for demonstration).", distractors: [], indent: 1, "explanation": "Note on the simple voting logic." },
            { correct: "  int max_votes = 0;", distractors: [], indent: 1, "explanation": "A counter for the winning vote count." },
            { correct: "  char* prediction = \"Unknown\";", distractors: [], indent: 1, "explanation": "A pointer to hold the predicted label." },
            { correct: "  for (int i = 0; i < k; i++) {", distractors: [], indent: 1, "explanation": "Outer loop: Iterate through the top K neighbors." },
            { correct: "    int current_votes = 0;", distractors: [], indent: 2, "explanation": "Counter for the votes of the current neighbor's label." },
            { correct: "    for (int j = 0; j < k; j++) {", distractors: [], indent: 2, "explanation": "Inner loop: Compare the current neighbor with all other K neighbors." },
            { correct: "      if (strcmp(distances[j].point.label, distances[i].point.label) == 0) {", distractors: [], indent: 3, "explanation": "If the labels match..." },
            { correct: "        current_votes++;", distractors: [], indent: 4, "explanation": "Increment the vote count for this label." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close string compare." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close inner loop." },
            { correct: "    if (current_votes > max_votes) {", distractors: [], indent: 2, "explanation": "If this label has more votes than the previous winner..." },
            { correct: "      max_votes = current_votes;", distractors: [], indent: 3, "explanation": "Update the max vote count." },
            { correct: "      prediction = distances[i].point.label;", distractors: [], indent: 3, "explanation": "This label is now the leading prediction." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close max votes check." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the voting loop." },
            { correct: "  free(distances);", distractors: [], indent: 1, "explanation": "Free the temporary distances array." },
            { correct: "  return prediction;", distractors: [], indent: 1, "explanation": "Return the final predicted label." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `classify_point`." },
            { correct: "// === Stage 3: Main Program to Run the Classifier ===", distractors: [], indent: 0, "explanation": "A `main` function to test our KNN implementation." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  // Create a dummy CSV file for the demo.", distractors: [], indent: 1, "explanation": "Simulate the training data file." },
            { correct: "  FILE* f = fopen(\"dataset.csv\", \"w\");", distractors: [], indent: 1, "explanation": "Create the file." },
            { correct: "  fprintf(f, \"x,y,label\\n1.0,1.1,ClassA\\n1.2,1.0,ClassA\\n0.0,0.1,ClassB\\n0.2,0.3,ClassB\\n\");", distractors: [], indent: 1, "explanation": "Write four data points, two for each class." },
            { correct: "  fclose(f);", distractors: [], indent: 1, "explanation": "Close the dummy file." },
            { correct: "  load_dataset(\"dataset.csv\");", distractors: [], indent: 1, "explanation": "Load the training data." },
            { correct: "  printf(\"Loaded %d data points.\\n\", data_count);", distractors: [], indent: 1, "explanation": "Confirmation message." },
            { correct: "  // Create a new point we want to classify.", distractors: [], indent: 1, "explanation": "Comment on the query point." },
            { correct: "  DataPoint new_point = { .x = 1.1, .y = 1.1 };", distractors: [], indent: 1, "explanation": "This point is visually close to 'ClassA'." },
            { correct: "  int k = 3;", distractors: [], indent: 1, "explanation": "Set the K value (number of neighbors to check)." },
            { correct: "  printf(\"\\nClassifying new point (%.1f, %.1f) with K=%d...\\n\", new_point.x, new_point.y, k);", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  const char* result = classify_point(new_point, k);", distractors: [], indent: 1, "explanation": "Run the classifier." },
            { correct: "  printf(\"Prediction: The new point belongs to %s\\n\", result);", distractors: [], indent: 1, "explanation": "Print the final prediction." },
            { correct: "  free(training_data);", distractors: [], indent: 1, "explanation": "Free the global dataset array." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
    // Level 85: custom file format for ML datasets
    {
        "goal": "Design and implement a custom binary file format for storing ML datasets efficiently.",
        concepts: "Binary file I/O, fwrite, fread, structs, data serialization, performance",
        sequence: [
            { correct: "// === Stage 1: Setup and File Format Definition ===", distractors: [], indent: 0, "explanation": "Define the necessary includes and the structures that will define our binary file layout." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O for file operations and printing." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "For memory management and string-to-number conversion." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "For string tokenizing." },
            { correct: "#include <stdint.h>", distractors: [], indent: 0, "explanation": "Include for fixed-width integer types like `uint32_t` for portability." },
            { correct: "// --- Our Custom Binary File Format Definition ---", distractors: [], indent: 0, "explanation": "A good binary format has a header to describe the contents." },
            { correct: "#define MAGIC_NUMBER 0x44415441 // Spells 'DATA' in ASCII", distractors: [], indent: 0, "explanation": "A magic number to identify our file type." },
            { correct: "#define FORMAT_VERSION 1", distractors: [], indent: 0, "explanation": "A version number for our format, allowing for future upgrades." },
            { correct: "// The header that will be at the very beginning of our binary file.", distractors: [], indent: 0, "explanation": "Comment on the file header struct." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin FileHeader definition." },
            { correct: "  uint32_t magic_number;", distractors: [], indent: 1, "explanation": "To confirm we're reading the right kind of file." },
            { correct: "  uint32_t version;", distractors: [], indent: 1, "explanation": "The version of the file format." },
            { correct: "  uint32_t num_records;", distractors: [], indent: 1, "explanation": "The total number of data records in the file." },
            { correct: "  uint32_t num_features;", distractors: [], indent: 1, "explanation": "The number of features (columns) per record." },
            { correct: "} FileHeader;", distractors: [], indent: 0, "explanation": "Close the FileHeader typedef." },
            { correct: "// The struct for a single data record.", distractors: [], indent: 0, "explanation": "Comment on the DataRecord struct." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin DataRecord definition." },
            { correct: "  float* features;", distractors: [], indent: 1, "explanation": "A dynamic array to hold the numerical features." },
            { correct: "  uint32_t label;", distractors: [], indent: 1, "explanation": "The integer class label for this record." },
            { correct: "} DataRecord;", distractors: [], indent: 0, "explanation": "Close the DataRecord typedef." },
            { correct: "// --- Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare the functions for our conversion tool." },
            { correct: "void convert_csv_to_binary(const char* csv_path, const char* bin_path);", distractors: [], indent: 0, "explanation": "The main conversion function." },
            { correct: "void verify_binary_file(const char* bin_path);", distractors: [], indent: 0, "explanation": "A function to read back and verify the binary file." },
            { correct: "// === Stage 2: The CSV to Binary Converter Tool ===", distractors: [], indent: 0, "explanation": "Implement the logic to read a CSV and write our custom binary format." },
            { correct: "void convert_csv_to_binary(const char* csv_path, const char* bin_path) {", distractors: [], indent: 0, "explanation": "Start the converter function implementation." },
            { correct: "  printf(\"--- Converting %s to %s ---\\n\", csv_path, bin_path);", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  FILE* f_csv = fopen(csv_path, \"r\");", distractors: [], indent: 1, "explanation": "Open the source CSV file for reading." },
            { correct: "  if (!f_csv) { perror(\"Failed to open CSV\"); return; }", distractors: [], indent: 1, "explanation": "Handle file open error." },
            { correct: "  // First pass over the CSV: count records and features.", distractors: [], indent: 1, "explanation": "We need to know the dimensions before we can write the binary header." },
            { correct: "  uint32_t record_count = 0;", distractors: [], indent: 1, "explanation": "Initialize record counter." },
            { correct: "  uint32_t feature_count = 0;", distractors: [], indent: 1, "explanation": "Initialize feature counter." },
            { correct: "  char line_buffer[1024];", distractors: [], indent: 1, "explanation": "A buffer to read lines." },
            { correct: "  if (fgets(line_buffer, sizeof(line_buffer), f_csv)) {", distractors: [], indent: 1, "explanation": "Read the header line to count features." },
            { correct: "    char* token = strtok(line_buffer, \",\\n\");", distractors: [], indent: 2, "explanation": "Get the first token." },
            { correct: "    while(token) { feature_count++; token = strtok(NULL, \",\\n\"); }", distractors: [], indent: 2, "explanation": "Loop through tokens to count them." },
            { correct: "    feature_count--; // The last column is the label, not a feature.", distractors: [], indent: 2, "explanation": "Adjust the count to exclude the label column." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the header processing." },
            { correct: "  while (fgets(line_buffer, sizeof(line_buffer), f_csv)) {", distractors: [], indent: 1, "explanation": "Now loop through the rest of the file just to count the lines (records)." },
            { correct: "    record_count++;", distractors: [], indent: 2, "explanation": "Increment the record count for each line." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the counting loop." },
            { correct: "  printf(\"Found %u records, each with %u features.\\n\", record_count, feature_count);", distractors: [], indent: 1, "explanation": "Print the discovered dimensions." },
            { correct: "  rewind(f_csv); // Go back to the start of the CSV file for the second pass.", distractors: [], indent: 1, "explanation": "Reset the file pointer to the beginning." },
            { correct: "  fgets(line_buffer, sizeof(line_buffer), f_csv); // Skip header again.", distractors: [], indent: 1, "explanation": "Discard the header line on the second pass too." },
            { correct: "  // Now, open the binary file for writing.", distractors: [], indent: 1, "explanation": "Comment on the write step." },
            { correct: "  FILE* f_bin = fopen(bin_path, \"wb\");", distractors: [], indent: 1, "explanation": "Open the destination file in binary write mode." },
            { correct: "  if (!f_bin) { perror(\"Failed to open binary file for writing\"); fclose(f_csv); return; }", distractors: [], indent: 1, "explanation": "Handle file open error." },
            { correct: "  // Create and write the header.", distractors: [], indent: 1, "explanation": "Comment on writing the header." },
            { correct: "  FileHeader header;", distractors: [], indent: 1, "explanation": "Declare a header struct." },
            { correct: "  header.magic_number = MAGIC_NUMBER;", distractors: [], indent: 1, "explanation": "Set the magic number." },
            { correct: "  header.version = FORMAT_VERSION;", distractors: [], indent: 1, "explanation": "Set the format version." },
            { correct: "  header.num_records = record_count;", distractors: [], indent: 1, "explanation": "Set the number of records." },
            { correct: "  header.num_features = feature_count;", distractors: [], indent: 1, "explanation": "Set the number of features." },
            { correct: "  fwrite(&header, sizeof(FileHeader), 1, f_bin);", distractors: [], indent: 1, "explanation": "Write the entire header struct to the file." },
            { correct: "  // Second pass: Read CSV data and write to binary file record by record.", distractors: [], indent: 1, "explanation": "Comment on the main conversion loop." },
            { correct: "  float* feature_buffer = malloc(feature_count * sizeof(float));", distractors: [], indent: 1, "explanation": "Allocate a reusable buffer to hold one record's features." },
            { correct: "  while (fgets(line_buffer, sizeof(line_buffer), f_csv)) {", distractors: [], indent: 1, "explanation": "Loop through the data lines of the CSV." },
            { correct: "    char* token = strtok(line_buffer, \",\");", distractors: [], indent: 2, "explanation": "Get the first token of the line." },
            { correct: "    for (uint32_t i = 0; i < feature_count; i++) {", distractors: [], indent: 2, "explanation": "Loop to read all the feature columns." },
            { correct: "      feature_buffer[i] = atof(token);", distractors: [], indent: 3, "explanation": "Convert the string token to a float and store it." },
            { correct: "      token = strtok(NULL, \",\");", distractors: [], indent: 3, "explanation": "Get the next token." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the feature reading loop." },
            { correct: "    uint32_t label = atoi(token); // The last token is the label", distractors: [], indent: 2, "explanation": "Convert the final token to an integer label." },
            { correct: "    // Write the features and label for this record to the binary file.", distractors: [], indent: 2, "explanation": "Comment on writing the record." },
            { correct: "    fwrite(feature_buffer, sizeof(float), feature_count, f_bin);", distractors: [], indent: 2, "explanation": "Write the feature data for this record." },
            { correct: "    fwrite(&label, sizeof(uint32_t), 1, f_bin);", distractors: [], indent: 2, "explanation": "Write the label for this record." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the main conversion loop." },
            { correct: "  printf(\"Conversion complete.\\n\");", distractors: [], indent: 1, "explanation": "Confirmation message." },
            { correct: "  // Cleanup.", distractors: [], indent: 1, "explanation": "Comment on cleanup." },
            { correct: "  free(feature_buffer);", distractors: [], indent: 1, "explanation": "Free the temporary buffer." },
            { correct: "  fclose(f_csv);", distractors: [], indent: 1, "explanation": "Close the CSV file." },
            { correct: "  fclose(f_bin);", distractors: [], indent: 1, "explanation": "Close the binary file." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the converter function." },
            { correct: "// === Stage 3: Verification Function ===", distractors: [], indent: 0, "explanation": "A function to read our custom binary file and prove it worked." },
            { correct: "void verify_binary_file(const char* bin_path) {", distractors: [], indent: 0, "explanation": "Start the verification function." },
            { correct: "  printf(\"\\n--- Verifying binary file: %s ---\\n\", bin_path);", distractors: [], indent: 1, "explanation": "Header message." },
            { correct: "  FILE* fp = fopen(bin_path, \"rb\");", distractors: [], indent: 1, "explanation": "Open the binary file for reading." },
            { correct: "  if (!fp) { perror(\"Failed to open binary file for verification\"); return; }", distractors: [], indent: 1, "explanation": "Handle file open error." },
            { correct: "  // Read and verify the header.", distractors: [], indent: 1, "explanation": "Comment on header verification." },
            { correct: "  FileHeader header;", distractors: [], indent: 1, "explanation": "Declare a struct to hold the read header." },
            { correct: "  if (fread(&header, sizeof(FileHeader), 1, fp) != 1) {", distractors: [], indent: 1, "explanation": "Read the header from the file." },
            { correct: "    printf(\"Could not read file header.\\n\"); fclose(fp); return;", distractors: [], indent: 2, "explanation": "Handle read error." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close read check." },
            { correct: "  printf(\"Header OK: Magic=0x%X, Version=%u, Records=%u, Features=%u\\n\",", distractors: [], indent: 1, "explanation": "Print the header data." },
            { correct: "         header.magic_number, header.version, header.num_records, header.num_features);", distractors: [], indent: 9, "explanation": "Continue printing header data." },
            { correct: "  if (header.magic_number != MAGIC_NUMBER) {", distractors: [], indent: 1, "explanation": "Validate the magic number." },
            { correct: "    printf(\"Error: Invalid magic number! This is not our file type.\\n\"); fclose(fp); return;", distractors: [], indent: 2, "explanation": "Error if magic number is wrong." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close magic number check." },
            { correct: "  // Read and print the first 3 records to verify.", distractors: [], indent: 1, "explanation": "Comment on verifying records." },
            { correct: "  printf(\"Displaying first 3 records...\\n\");", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  float* feature_buffer = malloc(header.num_features * sizeof(float));", distractors: [], indent: 1, "explanation": "Allocate a buffer to hold features for one record." },
            { correct: "  for (uint32_t i = 0; i < 3 && i < header.num_records; i++) {", distractors: [], indent: 1, "explanation": "Loop to read a few records." },
            { correct: "    uint32_t label;", distractors: [], indent: 2, "explanation": "A variable to hold the read label." },
            { correct: "    fread(feature_buffer, sizeof(float), header.num_features, fp);", distractors: [], indent: 2, "explanation": "Read the feature data for one record." },
            { correct: "    fread(&label, sizeof(uint32_t), 1, fp);", distractors: [], indent: 2, "explanation": "Read the label for that record." },
            { correct: "    printf(\"  Record %u: [ \", i);", distractors: [], indent: 2, "explanation": "Print a record header." },
            { correct: "    for (uint32_t j = 0; j < header.num_features; j++) {", distractors: [], indent: 2, "explanation": "Loop to print the features." },
            { correct: "      printf(\"%.2f \", feature_buffer[j]);", distractors: [], indent: 3, "explanation": "Print each feature." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the feature printing loop." },
            { correct: "    printf(\"] Label: %u\\n\", label);", distractors: [], indent: 2, "explanation": "Print the label." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the verification loop." },
            { correct: "  free(feature_buffer);", distractors: [], indent: 1, "explanation": "Free the buffer." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the file." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the verification function." },
            { correct: "// === Stage 4: Main Program Driver ===", distractors: [], indent: 0, "explanation": "A `main` function to run our tool." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  const char* csv_file = \"iris.csv\";", distractors: [], indent: 1, "explanation": "The name of our source CSV file." },
            { correct: "  const char* bin_file = \"iris.bin\";", distractors: [], indent: 1, "explanation": "The name of our destination binary file." },
            { correct: "  // Create a dummy CSV file for the demo.", distractors: [], indent: 1, "explanation": "Comment on creating dummy data." },
            { correct: "  FILE* f = fopen(csv_file, \"w\");", distractors: [], indent: 1, "explanation": "Open the CSV for writing." },
            { correct: "  fprintf(f, \"sepal_length,sepal_width,petal_length,petal_width,species\\n\");", distractors: [], indent: 1, "explanation": "Write the header." },
            { correct: "  fprintf(f, \"5.1,3.5,1.4,0.2,0\\n\");", distractors: [], indent: 1, "explanation": "Write the first data record (species 0)." },
            { correct: "  fprintf(f, \"7.0,3.2,4.7,1.4,1\\n\");", distractors: [], indent: 1, "explanation": "Write the second data record (species 1)." },
            { correct: "  fprintf(f, \"6.3,3.3,6.0,2.5,2\\n\");", distractors: [], indent: 1, "explanation": "Write the third data record (species 2)." },
            { correct: "  fprintf(f, \"4.9,3.0,1.4,0.2,0\\n\");", distractors: [], indent: 1, "explanation": "Write a fourth data record." },
            { correct: "  fclose(f);", distractors: [], indent: 1, "explanation": "Close the dummy CSV." },
            { correct: "  convert_csv_to_binary(csv_file, bin_file);", distractors: [], indent: 1, "explanation": "Run the conversion process." },
            { correct: "  verify_binary_file(bin_file);", distractors: [], indent: 1, "explanation": "Run the verification process." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
    // Level 86: Forward pass predictions
    {
        "goal": "Implement the forward pass of a simple, pre-trained neural network to make a prediction.",
        concepts: "Matrix multiplication, activation functions, structs, inference, deep learning fundamentals",
        sequence: [
            { correct: "// === Stage 1: Setup and Prerequisite Matrix Library ===", distractors: [], indent: 0, "explanation": "We need a basic matrix math library. We will include a simplified version here." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Memory management." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "For `memset`." },
            { correct: "#include <math.h>", distractors: [], indent: 0, "explanation": "For activation functions like `tanh`." },
            { correct: "typedef struct { size_t rows; size_t cols; float* data; } Matrix;", distractors: [], indent: 0, "explanation": "A simple struct to represent a matrix." },
            { correct: "#define M_AT(m, r, c) (m).data[(r) * (m).cols + (c)]", distractors: [], indent: 0, "explanation": "A macro for easy 2D access into the flat data array." },
            { correct: "Matrix matrix_create(size_t rows, size_t cols) {", distractors: [], indent: 0, "explanation": "Constructor for a Matrix." },
            { correct: "  Matrix m; m.rows = rows; m.cols = cols;", distractors: [], indent: 1, "explanation": "Declare and initialize rows/cols." },
            { correct: "  m.data = malloc(rows * cols * sizeof(float));", distractors: [], indent: 1, "explanation": "Allocate memory for the data." },
            { correct: "  memset(m.data, 0, rows * cols * sizeof(float));", distractors: [], indent: 1, "explanation": "Initialize the data to zero." },
            { correct: "  return m;", distractors: [], indent: 1, "explanation": "Return the new matrix." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `matrix_create`." },
            { correct: "void matrix_destroy(Matrix m) { free(m.data); }", distractors: [], indent: 0, "explanation": "Destructor for a Matrix." },
            { correct: "void matrix_print(Matrix m, const char* name) {", distractors: [], indent: 0, "explanation": "A function to print a matrix." },
            { correct: "  printf(\"%s (%zu x %zu):\\n\", name, m.rows, m.cols);", distractors: [], indent: 1, "explanation": "Print the name and dimensions." },
            { correct: "  for(size_t r=0; r<m.rows; ++r) {", distractors: [], indent: 1, "explanation": "Loop through rows." },
            { correct: "    printf(\"  [ \");", distractors: [], indent: 2, "explanation": "Print opening bracket." },
            { correct: "    for(size_t c=0; c<m.cols; ++c) printf(\"%6.2f \", M_AT(m, r, c));", distractors: [], indent: 2, "explanation": "Loop through columns and print each element." },
            { correct: "    printf(\"]\\n\");", distractors: [], indent: 2, "explanation": "Print closing bracket." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close row loop." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `matrix_print`." },
            { correct: "Matrix matrix_multiply(Matrix a, Matrix b) {", distractors: [], indent: 0, "explanation": "Implementation of matrix multiplication." },
            { correct: "  if (a.cols != b.rows) { printf(\"Matrix dimension mismatch!\\n\"); return (Matrix){0}; }", distractors: [], indent: 1, "explanation": "Check for compatible dimensions." },
            { correct: "  Matrix c = matrix_create(a.rows, b.cols);", distractors: [], indent: 1, "explanation": "Create the result matrix." },
            { correct: "  for (size_t i = 0; i < a.rows; i++) {", distractors: [], indent: 1, "explanation": "Loop through rows of A." },
            { correct: "    for (size_t j = 0; j < b.cols; j++) {", distractors: [], indent: 2, "explanation": "Loop through columns of B." },
            { correct: "      float sum = 0;", distractors: [], indent: 3, "explanation": "Initialize sum for dot product." },
            { correct: "      for (size_t k = 0; k < a.cols; k++) {", distractors: [], indent: 3, "explanation": "Loop for dot product." },
            { correct: "        sum += M_AT(a, i, k) * M_AT(b, k, j);", distractors: [], indent: 4, "explanation": "Perform the multiplication and add to sum." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close dot product loop." },
            { correct: "      M_AT(c, i, j) = sum;", distractors: [], indent: 3, "explanation": "Set the result in the new matrix." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close column loop." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close row loop." },
            { correct: "  return c;", distractors: [], indent: 1, "explanation": "Return the result." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `matrix_multiply`." },
            { correct: "Matrix matrix_add(Matrix a, Matrix b) {", distractors: [], indent: 0, "explanation": "Implementation of matrix addition." },
            { correct: "  if (a.rows != b.rows || a.cols != b.cols) { printf(\"Matrix dimension mismatch!\\n\"); return (Matrix){0}; }", distractors: [], indent: 1, "explanation": "Check that dimensions are identical." },
            { correct: "  Matrix c = matrix_create(a.rows, a.cols);", distractors: [], indent: 1, "explanation": "Create the result matrix." },
            { correct: "  for (size_t i = 0; i < a.rows * a.cols; i++) { c.data[i] = a.data[i] + b.data[i]; }", distractors: [], indent: 1, "explanation": "Add the elements one by one." },
            { correct: "  return c;", distractors: [], indent: 1, "explanation": "Return the result." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `matrix_add`." },
            { correct: "void matrix_apply_func(Matrix m, float (*func)(float)) {", distractors: [], indent: 0, "explanation": "A function to apply a function (like an activation function) to every element." },
            { correct: "  for(size_t i=0; i< m.rows * m.cols; i++) m.data[i] = func(m.data[i]);", distractors: [], indent: 1, "explanation": "Loop through all data and apply the function pointer." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `matrix_apply_func`." },
            { correct: "// === Stage 2: Neural Network Structures and Functions ===", distractors: [], indent: 0, "explanation": "Now, we define the structures for our neural network." },
            { correct: "// --- Activation Functions ---", distractors: [], indent: 0, "explanation": "Define some common activation functions." },
            { correct: "float activation_relu(float x) { return x > 0 ? x : 0; }", distractors: [], indent: 0, "explanation": "The Rectified Linear Unit (ReLU) activation function." },
            { correct: "float activation_tanh(float x) { return tanh(x); }", distractors: [], indent: 0, "explanation": "The Hyperbolic Tangent activation function." },
            { correct: "// --- Layer Structure ---", distractors: [], indent: 0, "explanation": "A struct to represent one dense layer of the network." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "Begin DenseLayer definition." },
            { correct: "  Matrix weights;", distractors: [], indent: 1, "explanation": "The weight matrix for this layer." },
            { correct: "  Matrix biases;", distractors: [], indent: 1, "explanation": "The bias vector (represented as a matrix) for this layer." },
            { correct: "  float (*activation)(float);", distractors: [], indent: 1, "explanation": "A function pointer to this layer's activation function." },
            { correct: "} DenseLayer;", distractors: [], indent: 0, "explanation": "Close the DenseLayer typedef." },
            { correct: "// --- Forward Pass Function ---", distractors: [], indent: 0, "explanation": "This function performs the core logic of inference." },
            { correct: "Matrix layer_forward(DenseLayer layer, Matrix input) {", distractors: [], indent: 0, "explanation": "Function to compute the output of one layer." },
            { correct: "  // 1. Multiply input by the layer's weights.", distractors: [], indent: 1, "explanation": "First step of a dense layer." },
            { correct: "  Matrix weighted_sum = matrix_multiply(layer.weights, input);", distractors: [], indent: 1, "explanation": "Perform the matrix multiplication." },
            { correct: "  // 2. Add the biases.", distractors: [], indent: 1, "explanation": "Second step of a dense layer." },
            { correct: "  Matrix with_bias = matrix_add(weighted_sum, layer.biases);", distractors: [], indent: 1, "explanation": "Perform the matrix addition." },
            { correct: "  // 3. Apply the activation function.", distractors: [], indent: 1, "explanation": "Third step of a dense layer." },
            { correct: "  matrix_apply_func(with_bias, layer.activation);", distractors: [], indent: 1, "explanation": "Apply the layer's activation function to every element." },
            { correct: "  // Cleanup intermediate matrices to prevent memory leaks.", distractors: [], indent: 1, "explanation": "Important memory management step." },
            { correct: "  matrix_destroy(weighted_sum);", distractors: [], indent: 1, "explanation": "Free the temporary matrix from the multiplication." },
            { correct: "  return with_bias;", distractors: [], indent: 1, "explanation": "Return the final output of the layer." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `layer_forward`." },
            { correct: "// === Stage 3: Building and Running the Network ===", distractors: [], indent: 0, "explanation": "Now we'll define a simple pre-trained network and pass data through it." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  printf(\"--- Neural Network Forward Pass Demo ---\\n\");", distractors: [], indent: 1, "explanation": "Header." },
            { correct: "  // Define a 2-layer network: 2 inputs -> 4 hidden neurons -> 1 output neuron", distractors: [], indent: 1, "explanation": "Describe the network architecture." },
            { correct: "  // --- Create Layer 1 (Hidden Layer) ---", distractors: [], indent: 1, "explanation": "Setup for the first layer." },
            { correct: "  DenseLayer layer1;", distractors: [], indent: 1, "explanation": "Declare the first layer." },
            { correct: "  layer1.weights = matrix_create(4, 2); // 4 neurons, 2 inputs", distractors: [], indent: 1, "explanation": "Create the weight matrix (4x2)." },
            { correct: "  layer1.biases = matrix_create(4, 1);  // 4 neurons, 1 bias each", distractors: [], indent: 1, "explanation": "Create the bias vector (4x1)." },
            { correct: "  layer1.activation = activation_relu;", distractors: [], indent: 1, "explanation": "Set the activation function to ReLU." },
            { correct: "  // Load pre-trained weights and biases (hardcoded for this demo)", distractors: [], indent: 1, "explanation": "Comment on loading weights." },
            { correct: "  float l1_w[] = {0.1, 0.2, -0.3, 0.4, 0.5, -0.6, -0.7, 0.8};", distractors: [], indent: 1, "explanation": "Define the weight data for layer 1." },
            { correct: "  memcpy(layer1.weights.data, l1_w, sizeof(l1_w));", distractors: [], indent: 1, "explanation": "Copy the data into the matrix." },
            { correct: "  float l1_b[] = {0.1, 0.1, -0.2, -0.2};", distractors: [], indent: 1, "explanation": "Define the bias data for layer 1." },
            { correct: "  memcpy(layer1.biases.data, l1_b, sizeof(l1_b));", distractors: [], indent: 1, "explanation": "Copy the data into the bias matrix." },
            { correct: "  // --- Create Layer 2 (Output Layer) ---", distractors: [], indent: 1, "explanation": "Setup for the second layer." },
            { correct: "  DenseLayer layer2;", distractors: [], indent: 1, "explanation": "Declare the second layer." },
            { correct: "  layer2.weights = matrix_create(1, 4); // 1 neuron, 4 inputs from prev layer", distractors: [], indent: 1, "explanation": "Create the weight matrix (1x4)." },
            { correct: "  layer2.biases = matrix_create(1, 1);  // 1 neuron, 1 bias", distractors: [], indent: 1, "explanation": "Create the bias vector (1x1)." },
            { correct: "  layer2.activation = activation_tanh;", distractors: [], indent: 1, "explanation": "Use tanh for the output layer to get a value between -1 and 1." },
            { correct: "  // Load pre-trained weights and biases", distractors: [], indent: 1, "explanation": "Comment on loading weights." },
            { correct: "  float l2_w[] = {0.9, -0.8, 0.7, -0.6};", distractors: [], indent: 1, "explanation": "Define the weight data for layer 2." },
            { correct: "  memcpy(layer2.weights.data, l2_w, sizeof(l2_w));", distractors: [], indent: 1, "explanation": "Copy the data." },
            { correct: "  float l2_b[] = {0.3};", distractors: [], indent: 1, "explanation": "Define the bias data for layer 2." },
            { correct: "  memcpy(layer2.biases.data, l2_b, sizeof(l2_b));", distractors: [], indent: 1, "explanation": "Copy the data." },
            { correct: "  // --- Create Input Data ---", distractors: [], indent: 1, "explanation": "Create the input vector to be fed into the network." },
            { correct: "  Matrix input = matrix_create(2, 1);", distractors: [], indent: 1, "explanation": "Create a 2x1 input vector." },
            { correct: "  M_AT(input, 0, 0) = 0.5f;", distractors: [], indent: 1, "explanation": "Set the first input feature." },
            { correct: "  M_AT(input, 1, 0) = -0.5f;", distractors: [], indent: 1, "explanation": "Set the second input feature." },
            { correct: "  matrix_print(input, \"Input Vector\");", distractors: [], indent: 1, "explanation": "Print the input data." },
            { correct: "  // --- Run the Forward Pass ---", distractors: [], indent: 1, "explanation": "Perform the end-to-end inference." },
            { correct: "  printf(\"\\nProcessing through Layer 1...\\n\");", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  Matrix output1 = layer_forward(layer1, input);", distractors: [], indent: 1, "explanation": "Pass the input through the first layer." },
            { correct: "  matrix_print(output1, \"Output of Layer 1 (after ReLU)\");", distractors: [], indent: 1, "explanation": "Print the intermediate result." },
            { correct: "  printf(\"\\nProcessing through Layer 2...\\n\");", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  Matrix final_output = layer_forward(layer2, output1);", distractors: [], indent: 1, "explanation": "Pass the output of layer 1 into layer 2." },
            { correct: "  matrix_print(final_output, \"Final Output of Network (after Tanh)\");", distractors: [], indent: 1, "explanation": "Print the final prediction." },
            { correct: "  // --- Cleanup ---", distractors: [], indent: 1, "explanation": "Free all allocated memory." },
            { correct: "  matrix_destroy(input);", distractors: [], indent: 1, "explanation": "Free input matrix." },
            { correct: "  matrix_destroy(output1);", distractors: [], indent: 1, "explanation": "Free intermediate output matrix." },
            { correct: "  matrix_destroy(final_output);", distractors: [], indent: 1, "explanation": "Free final output matrix." },
            { correct: "  matrix_destroy(layer1.weights); matrix_destroy(layer1.biases);", distractors: [], indent: 1, "explanation": "Free layer 1 matrices." },
            { correct: "  matrix_destroy(layer2.weights); matrix_destroy(layer2.biases);", distractors: [], indent: 1, "explanation": "Free layer 2 matrices." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
    // Level 87: gradient descent algorithm
    {
        "goal": "Implement the gradient descent algorithm from scratch to find the minimum of a function.",
        concepts: "Function pointers, iterative algorithms, floating-point math, core ML optimization",
        sequence: [
            { correct: "// === Stage 1: Setup and Mathematical Foundation ===", distractors: [], indent: 0, "explanation": "Define includes and the mathematical functions we want to optimize." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O for printing our progress." },
            { correct: "#include <math.h>", distractors: [], indent: 0, "explanation": "For `fabs` to check for convergence." },
            { correct: "// Gradient descent is an iterative optimization algorithm for finding a local minimum of a function.", distractors: [], indent: 0, "explanation": "Explain the purpose of the algorithm." },
            { correct: "// The core idea is to take repeated steps in the opposite direction of the function's gradient.", distractors: [], indent: 0, "explanation": "Describe the core mechanic of gradient descent." },
            { correct: "// --- The Function to Minimize ---", distractors: [], indent: 0, "explanation": "We'll find the minimum of the simple quadratic function: f(x) = (x - 5)^2" },
            { correct: "double a_simple_function(double x) {", distractors: [], indent: 0, "explanation": "Define the function we want to minimize." },
            { correct: "  return (x - 5.0) * (x - 5.0);", distractors: [], indent: 1, "explanation": "The minimum value of this function is 0, which occurs when x = 5." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the function definition." },
            { correct: "// --- The Gradient (Derivative) of the Function ---", distractors: [], indent: 0, "explanation": "The gradient tells us the direction of steepest ascent. We want to move in the opposite direction." },
            { correct: "// The derivative of (x - 5)^2 is 2 * (x - 5).", distractors: [], indent: 0, "explanation": "State the derivative from calculus." },
            { correct: "double gradient_of_simple_function(double x) {", distractors: [], indent: 0, "explanation": "Define the function that calculates the gradient (derivative)." },
            { correct: "  return 2.0 * (x - 5.0);", distractors: [], indent: 1, "explanation": "This function tells us the slope at any given point x." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the gradient function." },
            { correct: "// --- Typedef for a generic gradient function pointer ---", distractors: [], indent: 0, "explanation": "To make our optimizer generic, we'll use a function pointer." },
            { correct: "typedef double (*GradientFunc)(double);", distractors: [], indent: 0, "explanation": "Create a type `GradientFunc` for any function that takes a double and returns a double." },
            { correct: "// === Stage 2: The Gradient Descent Optimizer Implementation ===", distractors: [], indent: 0, "explanation": "Implement the main optimization function." },
            { correct: "double gradient_descent(double initial_guess, double learning_rate, GradientFunc grad_func, int max_iterations) {", distractors: [], indent: 0, "explanation": "Define the optimizer function, taking an initial guess, learning rate, and a pointer to a gradient function." },
            { correct: "  printf(\"--- Starting Gradient Descent ---\\n\");", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  printf(\"Initial Guess: %.4f, Learning Rate: %.4f\\n\", initial_guess, learning_rate);", distractors: [], indent: 1, "explanation": "Print the starting parameters." },
            { correct: "  double current_x = initial_guess;", distractors: [], indent: 1, "explanation": "Initialize our current position with the initial guess." },
            { correct: "  for (int i = 0; i < max_iterations; i++) {", distractors: [], indent: 1, "explanation": "Start the main optimization loop, which runs for a fixed number of iterations (epochs)." },
            { correct: "    // 1. Calculate the gradient at the current position.", distractors: [], indent: 2, "explanation": "First step inside the loop." },
            { correct: "    double gradient = grad_func(current_x);", distractors: [], indent: 2, "explanation": "Call the provided gradient function to find the slope at our current x." },
            { correct: "    // 2. Calculate the 'step' to take.", distractors: [], indent: 2, "explanation": "Second step inside the loop." },
            { correct: "    double step = learning_rate * gradient;", distractors: [], indent: 2, "explanation": "The size of the step is the gradient multiplied by the learning rate." },
            { correct: "    // 3. Update our position by moving in the opposite direction of the gradient.", distractors: [], indent: 2, "explanation": "The core update rule of gradient descent." },
            { correct: "    current_x = current_x - step;", distractors: [], indent: 2, "explanation": "Update our guess for x." },
            { correct: "    if ((i + 1) % 10 == 0) { // Print progress every 10 iterations", distractors: [], indent: 2, "explanation": "A check to periodically print our progress." },
            { correct: "      printf(\"  Iter %3d: x = %.4f, f(x) = %.4f\\n\", i + 1, current_x, a_simple_function(current_x));", distractors: [], indent: 3, "explanation": "Print the current iteration, x value, and the value of the original function at x." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close the progress-printing block." },
            { correct: "    // Optional: Check for convergence to stop early.", distractors: [], indent: 2, "explanation": "A more advanced optimizer would stop if the value stops changing." },
            { correct: "    if (fabs(step) < 1e-6) {", distractors: [], indent: 2, "explanation": "If the step we are taking is extremely small..." },
            { correct: "      printf(\"Converged early at iteration %d.\\n\", i + 1);", distractors: [], indent: 3, "explanation": "Announce that we've found the minimum." },
            { correct: "      break; // Exit the loop", distractors: [], indent: 3, "explanation": "Stop iterating." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close convergence check." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the main optimization loop." },
            { correct: "  printf(\"--- Gradient Descent Finished ---\\n\");", distractors: [], indent: 1, "explanation": "Completion message." },
            { correct: "  return current_x;", distractors: [], indent: 1, "explanation": "Return the final, optimized value of x." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the gradient descent function." },
            { correct: "// === Stage 3: Main Program to Run the Optimizer ===", distractors: [], indent: 0, "explanation": "A `main` function to test our optimizer." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  printf(\"Goal: Find the minimum of f(x) = (x - 5)^2, which is at x = 5.\\n\");", distractors: [], indent: 1, "explanation": "State the problem we are solving." },
            { correct: "  // Set hyperparameters for the optimizer", distractors: [], indent: 1, "explanation": "Comment on hyperparameters." },
            { correct: "  double initial_x = 0.0;", distractors: [], indent: 1, "explanation": "Our initial random guess for x." },
            { correct: "  double learning_rate = 0.1;", distractors: [], indent: 1, "explanation": "The learning rate, which controls how big of a step we take." },
            { correct: "  int iterations = 100;", distractors: [], indent: 1, "explanation": "The maximum number of iterations to run." },
            { correct: "  // Run the optimizer", distractors: [], indent: 1, "explanation": "Comment on running the function." },
            { correct: "  double minimum_x = gradient_descent(initial_x, learning_rate, gradient_of_simple_function, iterations);", distractors: [], indent: 1, "explanation": "Call the optimizer, passing our specific gradient function as the callback." },
            { correct: "  printf(\"\\nFinal Result:\\n\");", distractors: [], indent: 1, "explanation": "Header for the final result." },
            { correct: "  printf(\"  The minimum of the function is at x = %.6f\\n\", minimum_x);", distractors: [], indent: 1, "explanation": "Print the final calculated minimum." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
    // Level 88: high-performance C function for python
    {
        "goal": "Write a high-performance C function, compile it into a shared library, and call it from Python.",
        concepts: "Shared libraries, `gcc -shared -fPIC`, extern \"C\", Python `ctypes`, Foreign Function Interface (FFI)",
        sequence: [
            { correct: "// === Stage 1, Part A: The C Library Source Code ('process.c') ===", distractors: [], indent: 0, "explanation": "First, we write the C code that we want to accelerate." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O for a simple message." },
            { correct: "#include <stdint.h>", distractors: [], indent: 0, "explanation": "Include for fixed-width types like `int64_t` for cross-language compatibility." },
            { correct: "// When compiling C for use by C++ (or other languages), `extern \"C\"`", distractors: [], indent: 0, "explanation": "Explain the purpose of `extern \"C\"`." },
            { correct: "// prevents the compiler from 'mangling' the function name.", distractors: [], indent: 0, "explanation": "This ensures Python can find the function by its exact C name." },
            { correct: "#ifdef __cplusplus", distractors: [], indent: 0, "explanation": "Check if being compiled by a C++ compiler." },
            { correct: "extern \"C\" {", distractors: [], indent: 0, "explanation": "Start the extern block." },
            { correct: "#endif", distractors: [], indent: 0, "explanation": "End the preprocessor check." },
            { correct: "// --- The C Function to be Exported ---", distractors: [], indent: 0, "explanation": "This is the function we will call from Python." },
            { correct: "long long sum_array(const long long* array, int size) {", distractors: [], indent: 0, "explanation": "A simple but computationally intensive function: summing a large array." },
            { correct: "  printf(\"[C] Hello from the C library! Processing array...\\n\");", distractors: [], indent: 1, "explanation": "A message to prove the C code is actually running." },
            { correct: "  long long sum = 0;", distractors: [], indent: 1, "explanation": "Initialize the accumulator." },
            { correct: "  for (int i = 0; i < size; i++) {", distractors: [], indent: 1, "explanation": "Loop through the array." },
            { correct: "    sum += array[i];", distractors: [], indent: 2, "explanation": "Add each element to the sum." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the loop." },
            { correct: "  printf(\"[C] Processing complete. Returning sum.\\n\");", distractors: [], indent: 1, "explanation": "Completion message from C." },
            { correct: "  return sum;", distractors: [], indent: 1, "explanation": "Return the final sum." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the C function." },
            { correct: "#ifdef __cplusplus", distractors: [], indent: 0, "explanation": "The matching end for the extern block." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close the extern block." },
            { correct: "// === Stage 1, Part B: Compiling the C Library ===", distractors: [], indent: 0, "explanation": "To call our C code, we must compile it into a shared library file." },
            { correct: "// On Linux or macOS, you would use a command like this in your terminal:", distractors: [], indent: 0, "explanation": "Provide the compilation command for Linux/macOS." },
            { correct: "// gcc -shared -o libprocess.so -fPIC process.c", distractors: [], indent: 0, "explanation": "`-shared` creates a shared library. `-fPIC` generates Position-Independent Code, which is required for shared libraries." },
            { correct: "// On Windows, the command would be slightly different and produce a .dll file:", distractors: [], indent: 0, "explanation": "Provide the compilation command for Windows." },
            { correct: "// gcc -shared -o process.dll process.c", distractors: [], indent: 0, "explanation": "This command creates a Dynamic-Link Library." },
            { correct: "// After running the command, you will have a `libprocess.so` or `process.dll` file.", distractors: [], indent: 0, "explanation": "Describe the output of the compilation." },
            { correct: "// === Stage 2: The Python Script ('main.py') ===", distractors: [], indent: 0, "explanation": "Now, we write the Python code to load and use our C library." },
            { correct: "import ctypes", distractors: [], indent: 0, "explanation": "Import the `ctypes` library, Python's built-in tool for calling C functions." },
            { correct: "import numpy as np", distractors: [], indent: 0, "explanation": "Import NumPy, the standard library for numerical data in Python." },
            { correct: "import platform", distractors: [], indent: 0, "explanation": "Import platform to handle differences between operating systems." },
            { correct: "# Load the shared library", distractors: [], indent: 0, "explanation": "Python comment for loading the library." },
            { correct: "lib_path = \"./libprocess.so\"", distractors: [], indent: 0, "explanation": "Define the path to the library on Linux/macOS." },
            { correct: "if platform.system() == \"Windows\":", distractors: [], indent: 0, "explanation": "Check if the operating system is Windows." },
            { correct: "    lib_path = \"./process.dll\"", distractors: [], indent: 1, "explanation": "If it is, change the library path to the .dll file." },
            { correct: "try:", distractors: [], indent: 0, "explanation": "Use a try/except block to handle potential errors when loading the library." },
            { correct: "    c_lib = ctypes.CDLL(lib_path)", distractors: [], indent: 1, "explanation": "Use `ctypes.CDLL` to load our shared library into memory." },
            { correct: "except OSError as e:", distractors: [], indent: 0, "explanation": "Catch the `OSError` if the file is not found." },
            { correct: "    print(f\"Error: Could not load shared library from {lib_path}\")", distractors: [], indent: 1, "explanation": "Print a helpful error message." },
            { correct: "    print(\"Please compile the C code first (see comments in the C file).\")", distractors: [], indent: 1, "explanation": "Instruct the user on how to fix the error." },
            { correct: "    exit()", distractors: [], indent: 1, "explanation": "Exit the Python script." },
            { correct: "# Define the function signature (argument types and return type)", distractors: [], indent: 0, "explanation": "This step is crucial for `ctypes` to work correctly." },
            { correct: "sum_array_func = c_lib.sum_array", distractors: [], indent: 0, "explanation": "Get a reference to our `sum_array` function from the loaded library." },
            { correct: "sum_array_func.argtypes = [np.ctypeslib.ndpointer(dtype=np.int64), ctypes.c_int]", distractors: [], indent: 0, "explanation": "Define the argument types: a pointer to a numpy array of 64-bit ints, and a C integer." },
            { correct: "sum_array_func.restype = ctypes.c_longlong", distractors: [], indent: 0, "explanation": "Define the return type as a C long long, which matches the `long long` in our C code." },
            { correct: "# Prepare data in Python", distractors: [], indent: 0, "explanation": "Python comment for data preparation." },
            { correct: "print(\"\\n[Python] Preparing data with NumPy...\")", distractors: [], indent: 0, "explanation": "Informational message from Python." },
            { correct: "python_array = np.arange(1, 1000001, dtype=np.int64)", distractors: [], indent: 0, "explanation": "Create a large NumPy array with numbers from 1 to 1,000,000." },
            { correct: "array_size = len(python_array)", distractors: [], indent: 0, "explanation": "Get the size of the array." },
            { correct: "# Call the C function", distractors: [], indent: 0, "explanation": "Python comment for calling the C function." },
            { correct: "print(\"[Python] Calling the C function to sum the array...\")", distractors: [], indent: 0, "explanation": "Informational message." },
            { correct: "c_result = sum_array_func(python_array, array_size)", distractors: [], indent: 0, "explanation": "Call our C function. `ctypes` handles the conversion of the NumPy array to a pointer that C can understand." },
            { correct: "print(f\"\\n[Python] C function returned: {c_result}\")", distractors: [], indent: 0, "explanation": "Print the result returned by the C function." },
            { correct: "# Verify the result in Python", distractors: [], indent: 0, "explanation": "Python comment for verification." },
            { correct: "print(\"[Python] Verifying result with NumPy's own sum()...\")", distractors: [], indent: 0, "explanation": "Informational message." },
            { correct: "python_sum = np.sum(python_array)", distractors: [], indent: 0, "explanation": "Calculate the sum using NumPy's highly optimized built-in function." },
            { correct: "print(f\"[Python] NumPy's sum is: {python_sum}\")", distractors: [], indent: 0, "explanation": "Print the NumPy result." },
            { correct: "if c_result == python_sum:", distractors: [], indent: 0, "explanation": "Compare the result from our C library with the result from NumPy." },
            { correct: "    print(\"\\nSUCCESS: The result from the C library matches the NumPy result!\")", distractors: [], indent: 1, "explanation": "Print a success message if they match." },
            { correct: "else:", distractors: [], indent: 0, "explanation": "If they don't match..." },
            { correct: "    print(\"\\nFAILURE: The results do not match.\")", distractors: [], indent: 1, "explanation": "Print a failure message." }
        ]
    },
    // Level 89: 24-bit BMP image filters
    {
        "goal": "Build a tool to read, apply filters to, and write 24-bit BMP image files.",
        concepts: "Binary I/O, structs, #pragma pack, fread, fwrite, pixel manipulation, data alignment",
        sequence: [
            { correct: "// === Stage 1: Setup and BMP File Format Structures ===", distractors: [], indent: 0, "explanation": "Define the necessary includes and the precise structures that match the BMP file format specification." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O for file operations." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "For memory management." },
            { correct: "#include <stdint.h>", distractors: [], indent: 0, "explanation": "For fixed-width integer types like `uint16_t`." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "For `strcmp`." },
            { correct: "// The BMP format has padding to ensure struct members are aligned.", distractors: [], indent: 0, "explanation": "Comment on data alignment in file formats." },
            { correct: "// We use `#pragma pack(push, 1)` to tell the compiler to pack these structs tightly, with no extra padding.", distractors: [], indent: 0, "explanation": "This ensures our `sizeof` matches the file format exactly." },
            { correct: "#pragma pack(push, 1)", distractors: [], indent: 0, "explanation": "Apply tight packing." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "The BMP File Header is the first 14 bytes of the file." },
            { correct: "  uint16_t type;      // Magic identifier: 0x4D42 ('BM')", distractors: [], indent: 1, "explanation": "The file type, must be 'BM' for a bitmap." },
            { correct: "  uint32_t size;      // Size of the BMP file in bytes", distractors: [], indent: 1, "explanation": "Total file size." },
            { correct: "  uint16_t reserved1, reserved2;", distractors: [], indent: 1, "explanation": "Reserved fields, must be zero." },
            { correct: "  uint32_t offset;    // Byte offset to the beginning of image data", distractors: [], indent: 1, "explanation": "Where the pixel data starts." },
            { correct: "} BMPFileHeader;", distractors: [], indent: 0, "explanation": "Close the File Header struct." },
            { correct: "typedef struct {", distractors: [], indent: 0, "explanation": "The DIB (Device-Independent Bitmap) Header follows the file header." },
            { correct: "  uint32_t header_size; // Size of this header (40 bytes)", distractors: [], indent: 1, "explanation": "Size of this DIB header." },
            { correct: "  int32_t  width;       // Image width in pixels", distractors: [], indent: 1, "explanation": "The width of the image." },
            { correct: "  int32_t  height;      // Image height in pixels", distractors: [], indent: 1, "explanation": "The height of the image." },
            { correct: "  uint16_t planes;      // Number of color planes (must be 1)", distractors: [], indent: 1, "explanation": "Must be 1." },
            { correct: "  uint16_t bit_count;   // Bits per pixel (e.g., 24 for true color)", distractors: [], indent: 1, "explanation": "We will only support 24-bit images." },
            { correct: "  uint32_t compression, size_image, x_pixels_per_m, y_pixels_per_m, colors_used, colors_important;", distractors: [], indent: 1, "explanation": "Other fields, which we can ignore for uncompressed 24-bit images." },
            { correct: "} BMPInfoHeader;", distractors: [], indent: 0, "explanation": "Close the Info Header struct." },
            { correct: "#pragma pack(pop)", distractors: [], indent: 0, "explanation": "Restore the default compiler packing behavior." },
            { correct: "// A struct to hold a single 24-bit pixel. Note the BGR order in BMP files.", distractors: [], indent: 0, "explanation": "Comment on pixel structure and color order." },
            { correct: "typedef struct { uint8_t b, g, r; } Pixel;", distractors: [], indent: 0, "explanation": "Represents a single Blue, Green, Red pixel." },
            { correct: "// A struct to hold our image data in memory.", distractors: [], indent: 0, "explanation": "Comment on the in-memory Image struct." },
            { correct: "typedef struct { int width, height; Pixel* data; } Image;", distractors: [], indent: 0, "explanation": "The main image container with dimensions and a dynamic pixel buffer." },
            { correct: "// --- Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare all our image processing functions." },
            { correct: "Image* bmp_load(const char* filename);", distractors: [], indent: 0, "explanation": "Prototype for the BMP loading function." },
            { correct: "int bmp_save(const Image* img, const char* filename);", distractors: [], indent: 0, "explanation": "Prototype for the BMP saving function." },
            { correct: "void image_apply_grayscale(Image* img);", distractors: [], indent: 0, "explanation": "Prototype for the grayscale filter." },
            { correct: "void image_apply_invert(Image* img);", distractors: [], indent: 0, "explanation": "Prototype for the color inversion filter." },
            { correct: "void image_destroy(Image* img);", distractors: [], indent: 0, "explanation": "Prototype for freeing image memory." },
            { correct: "// === Stage 2: Main Program and Argument Parsing ===", distractors: [], indent: 0, "explanation": "The main function will parse commands and orchestrate the process." },
            { correct: "int main(int argc, char* argv[]) {", distractors: [], indent: 0, "explanation": "Start main, accepting command-line arguments." },
            { correct: "if (argc != 4) {", distractors: [], indent: 1, "explanation": "Check for the correct number of arguments." },
            { correct: "  printf(\"Usage: %s <input.bmp> <grayscale|invert> <output.bmp>\\n\", argv[0]);", distractors: [], indent: 2, "explanation": "Print usage instructions if arguments are incorrect." },
            { correct: "  return 1;", distractors: [], indent: 2, "explanation": "Exit with an error." },
            { correct: "}", distractors: [], indent: 1, "explanation": "Close argument check." },
            { correct: "const char* input_file = argv[1];", distractors: [], indent: 1, "explanation": "Get the input filename from the arguments." },
            { correct: "const char* operation = argv[2];", distractors: [], indent: 1, "explanation": "Get the desired operation from the arguments." },
            { correct: "const char* output_file = argv[3];", distractors: [], indent: 1, "explanation": "Get the output filename from the arguments." },
            { correct: "printf(\"Loading image from %s...\\n\", input_file);", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "Image* img = bmp_load(input_file);", distractors: [], indent: 1, "explanation": "Call the function to load the BMP file into memory." },
            { correct: "if (!img) { printf(\"Failed to load image.\\n\"); return 1; }", distractors: [], indent: 1, "explanation": "If loading failed, print an error and exit." },
            { correct: "printf(\"Image loaded successfully (%d x %d pixels).\\n\", img->width, img->height);", distractors: [], indent: 1, "explanation": "Confirm successful loading." },
            { correct: "// Apply the requested filter", distractors: [], indent: 1, "explanation": "Comment on the filtering stage." },
            { correct: "if (strcmp(operation, \"grayscale\") == 0) {", distractors: [], indent: 1, "explanation": "Check if the requested operation is 'grayscale'." },
            { correct: "  printf(\"Applying grayscale filter...\\n\");", distractors: [], indent: 2, "explanation": "Informational message." },
            { correct: "  image_apply_grayscale(img);", distractors: [], indent: 2, "explanation": "Call the grayscale filter function." },
            { correct: "} else if (strcmp(operation, \"invert\") == 0) {", distractors: [], indent: 1, "explanation": "Check if the requested operation is 'invert'." },
            { correct: "  printf(\"Applying invert filter...\\n\");", distractors: [], indent: 2, "explanation": "Informational message." },
            { correct: "  image_apply_invert(img);", distractors: [], indent: 2, "explanation": "Call the invert filter function." },
            { correct: "} else {", distractors: [], indent: 1, "explanation": "Handle unknown operations." },
            { correct: "  printf(\"Error: Unknown operation '%s'.\\n\", operation);", distractors: [], indent: 2, "explanation": "Print an error for an invalid filter name." },
            { correct: "  image_destroy(img);", distractors: [], indent: 2, "explanation": "Clean up the loaded image before exiting." },
            { correct: "  return 1;", distractors: [], indent: 2, "explanation": "Exit with an error." },
            { correct: "}", distractors: [], indent: 1, "explanation": "Close the operation selection logic." },
            { correct: "printf(\"Saving image to %s...\\n\", output_file);", distractors: [], indent: 1, "explanation": "Informational message for saving." },
            { correct: "if (bmp_save(img, output_file) != 0) {", distractors: [], indent: 1, "explanation": "Call the save function and check for errors." },
            { correct: "  printf(\"Failed to save image.\\n\");", distractors: [], indent: 2, "explanation": "Print an error if saving failed." },
            { correct: "} else {", distractors: [], indent: 1, "explanation": "If saving was successful..." },
            { correct: "  printf(\"Image saved successfully.\\n\");", distractors: [], indent: 2, "explanation": "Print a success message." },
            { correct: "}", distractors: [], indent: 1, "explanation": "Close the save check." },
            { correct: "// Cleanup", distractors: [], indent: 1, "explanation": "Comment on the final cleanup." },
            { correct: "image_destroy(img);", distractors: [], indent: 1, "explanation": "Free all memory associated with the image." },
            { correct: "return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." },
            { correct: "// === Stage 3: BMP File I/O and Filter Implementations ===", distractors: [], indent: 0, "explanation": "Implement the core logic for loading, saving, and filtering." },
            { correct: "Image* bmp_load(const char* filename) {", distractors: [], indent: 0, "explanation": "Start the BMP loading function." },
            { correct: "  FILE* fp = fopen(filename, \"rb\");", distractors: [], indent: 1, "explanation": "Open the file in binary read mode ('rb')." },
            { correct: "  if (!fp) { perror(\"fopen\"); return NULL; }", distractors: [], indent: 1, "explanation": "Handle file open error." },
            { correct: "  BMPFileHeader file_header;", distractors: [], indent: 1, "explanation": "A struct to hold the file header." },
            { correct: "  fread(&file_header, sizeof(BMPFileHeader), 1, fp);", distractors: [], indent: 1, "explanation": "Read the 14-byte file header from the file." },
            { correct: "  if (file_header.type != 0x4D42) {", distractors: [], indent: 1, "explanation": "Check the magic number to confirm it's a BMP file. 'BM' is 0x4D42 in little-endian." },
            { correct: "    printf(\"Error: Not a BMP file.\\n\"); fclose(fp); return NULL;", distractors: [], indent: 2, "explanation": "Error if not a BMP." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close magic number check." },
            { correct: "  BMPInfoHeader info_header;", distractors: [], indent: 1, "explanation": "A struct to hold the DIB header." },
            { correct: "  fread(&info_header, sizeof(BMPInfoHeader), 1, fp);", distractors: [], indent: 1, "explanation": "Read the 40-byte info header." },
            { correct: "  if (info_header.bit_count != 24 || info_header.compression != 0) {", distractors: [], indent: 1, "explanation": "Check that the BMP is a 24-bit, uncompressed image, which is all our simple parser supports." },
            { correct: "    printf(\"Error: Only 24-bit uncompressed BMPs are supported.\\n\"); fclose(fp); return NULL;", distractors: [], indent: 2, "explanation": "Error if unsupported format." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close format check." },
            { correct: "  fseek(fp, file_header.offset, SEEK_SET);", distractors: [], indent: 1, "explanation": "Jump to the start of the pixel data, using the offset from the file header." },
            { correct: "  Image* img = malloc(sizeof(Image));", distractors: [], indent: 1, "explanation": "Allocate memory for our in-memory Image struct." },
            { correct: "  img->width = info_header.width;", distractors: [], indent: 1, "explanation": "Set the width from the header." },
            { correct: "  img->height = abs(info_header.height);", distractors: [], indent: 1, "explanation": "Set the height. A negative height means the image is stored top-to-bottom." },
            { correct: "  size_t data_size = img->width * img->height * sizeof(Pixel);", distractors: [], indent: 1, "explanation": "Calculate the size of the pixel buffer." },
            { correct: "  img->data = malloc(data_size);", distractors: [], indent: 1, "explanation": "Allocate memory for the pixel buffer." },
            { correct: "  fread(img->data, 1, data_size, fp);", distractors: [], indent: 1, "explanation": "Read the entire pixel data block from the file into our buffer." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the file." },
            { correct: "  return img;", distractors: [], indent: 1, "explanation": "Return the loaded image." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `bmp_load`." },
            { correct: "int bmp_save(const Image* img, const char* filename) {", distractors: [], indent: 0, "explanation": "Start the BMP saving function." },
            { correct: "  FILE* fp = fopen(filename, \"wb\");", distractors: [], indent: 1, "explanation": "Open the destination file in binary write mode." },
            { correct: "  if (!fp) { return -1; }", distractors: [], indent: 1, "explanation": "Handle file open error." },
            { correct: "  size_t data_size = img->width * img->height * sizeof(Pixel);", distractors: [], indent: 1, "explanation": "Calculate the size of the pixel data." },
            { correct: "  BMPFileHeader file_header = {0x4D42, sizeof(BMPFileHeader) + sizeof(BMPInfoHeader) + data_size, 0, 0, sizeof(BMPFileHeader) + sizeof(BMPInfoHeader)};", distractors: [], indent: 1, "explanation": "Construct the file header with correct values." },
            { correct: "  BMPInfoHeader info_header = {sizeof(BMPInfoHeader), img->width, img->height, 1, 24, 0, data_size, 0, 0, 0, 0};", distractors: [], indent: 1, "explanation": "Construct the info header." },
            { correct: "  fwrite(&file_header, sizeof(BMPFileHeader), 1, fp);", distractors: [], indent: 1, "explanation": "Write the file header to the file." },
            { correct: "  fwrite(&info_header, sizeof(BMPInfoHeader), 1, fp);", distractors: [], indent: 1, "explanation": "Write the info header to the file." },
            { correct: "  fwrite(img->data, 1, data_size, fp);", distractors: [], indent: 1, "explanation": "Write the raw pixel data to the file." },
            { correct: "  fclose(fp);", distractors: [], indent: 1, "explanation": "Close the file." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Return 0 on success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `bmp_save`." },
            { correct: "void image_destroy(Image* img) {", distractors: [], indent: 0, "explanation": "Implement the destructor." },
            { correct: "  if (img) { free(img->data); free(img); }", distractors: [], indent: 1, "explanation": "Free the pixel data first, then the main struct." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `image_destroy`." },
            { correct: "void image_apply_grayscale(Image* img) {", distractors: [], indent: 0, "explanation": "Implement the grayscale filter." },
            { correct: "  for (int i = 0; i < img->width * img->height; i++) {", distractors: [], indent: 1, "explanation": "Loop through every pixel in the image." },
            { correct: "    uint8_t gray = (uint8_t)(img->data[i].r * 0.299 + img->data[i].g * 0.587 + img->data[i].b * 0.114);", distractors: [], indent: 2, "explanation": "Calculate the weighted average of the R, G, and B components to get a grayscale value." },
            { correct: "    img->data[i].r = gray;", distractors: [], indent: 2, "explanation": "Set the Red component to the gray value." },
            { correct: "    img->data[i].g = gray;", distractors: [], indent: 2, "explanation": "Set the Green component to the gray value." },
            { correct: "    img->data[i].b = gray;", distractors: [], indent: 2, "explanation": "Set the Blue component to the gray value." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the pixel loop." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `image_apply_grayscale`." },
            { correct: "void image_apply_invert(Image* img) {", distractors: [], indent: 0, "explanation": "Implement the color inversion filter." },
            { correct: "  for (int i = 0; i < img->width * img->height; i++) {", distractors: [], indent: 1, "explanation": "Loop through every pixel." },
            { correct: "    img->data[i].r = 255 - img->data[i].r;", distractors: [], indent: 2, "explanation": "Invert the Red component." },
            { correct: "    img->data[i].g = 255 - img->data[i].g;", distractors: [], indent: 2, "explanation": "Invert the Green component." },
            { correct: "    img->data[i].b = 255 - img->data[i].b;", distractors: [], indent: 2, "explanation": "Invert the Blue component." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close the pixel loop." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `image_apply_invert`." }
        ]
    },
    // Level 90: convolutional kernels
    {
        "goal": "Apply convolutional kernels to an image for advanced filtering like sharpening and edge detection.",
        concepts: "Convolution, image kernels, nested loops, boundary handling, advanced image processing",
        sequence: [
            { correct: "// === Stage 1: Setup and Prerequisite Image Structs ===", distractors: [], indent: 0, "explanation": "Define the necessary includes and data structures. We will reuse some from the previous level." },
            { correct: "#include <stdio.h>", distractors: [], indent: 0, "explanation": "Standard I/O." },
            { correct: "#include <stdlib.h>", distractors: [], indent: 0, "explanation": "Memory management." },
            { correct: "#include <stdint.h>", distractors: [], indent: 0, "explanation": "Fixed-width integers." },
            { correct: "#include <string.h>", distractors: [], indent: 0, "explanation": "For `memcpy`." },
            { correct: "// A simplified Pixel struct for this example.", distractors: [], indent: 0, "explanation": "We will work with grayscale images for simplicity in convolution." },
            { correct: "typedef struct { uint8_t value; } PixelGray;", distractors: [], indent: 0, "explanation": "A struct for a single 8-bit grayscale pixel." },
            { correct: "typedef struct { int width, height; PixelGray* data; } ImageGray;", distractors: [], indent: 0, "explanation": "A struct to hold a grayscale image." },
            { correct: "// A struct to represent our convolutional kernel.", distractors: [], indent: 0, "explanation": "The kernel is a small matrix that we slide over the image." },
            { correct: "typedef struct { int size; float* data; } Kernel;", distractors: [], indent: 0, "explanation": "We will assume square kernels (e.g., 3x3), so we only need one size dimension." },
            { correct: "// --- Function Prototypes ---", distractors: [], indent: 0, "explanation": "Declare the functions for our convolution engine." },
            { correct: "ImageGray* image_create(int width, int height);", distractors: [], indent: 0, "explanation": "Creates an empty grayscale image." },
            { correct: "void image_destroy(ImageGray* img);", distractors: [], indent: 0, "explanation": "Frees an image." },
            { correct: "ImageGray* image_apply_convolution(const ImageGray* src, const Kernel* kernel);", distractors: [], indent: 0, "explanation": "The core function to apply a kernel to a source image." },
            { correct: "// --- Stage 2: Convolution Algorithm Implementation ===", distractors: [], indent: 0, "explanation": "Implement the core logic for applying the filter." },
            { correct: "ImageGray* image_create(int width, int height) {", distractors: [], indent: 0, "explanation": "Start the image constructor." },
            { correct: "  ImageGray* img = malloc(sizeof(ImageGray));", distractors: [], indent: 1, "explanation": "Allocate the main struct." },
            { correct: "  img->width = width; img->height = height;", distractors: [], indent: 1, "explanation": "Set dimensions." },
            { correct: "  img->data = malloc(width * height * sizeof(PixelGray));", distractors: [], indent: 1, "explanation": "Allocate the pixel buffer." },
            { correct: "  return img;", distractors: [], indent: 1, "explanation": "Return the new image." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `image_create`." },
            { correct: "void image_destroy(ImageGray* img) {", distractors: [], indent: 0, "explanation": "Implement the destructor." },
            { correct: "  if (img) { free(img->data); free(img); }", distractors: [], indent: 1, "explanation": "Free the pixel data and then the struct." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `image_destroy`." },
            { correct: "uint8_t clamp(float value) {", distractors: [], indent: 0, "explanation": "A helper function to ensure pixel values stay within the 0-255 range." },
            { correct: "  if (value > 255.0f) return 255;", distractors: [], indent: 1, "explanation": "Clamp high values to 255." },
            { correct: "  if (value < 0.0f) return 0;", distractors: [], indent: 1, "explanation": "Clamp low values to 0." },
            { correct: "  return (uint8_t)value;", distractors: [], indent: 1, "explanation": "Return the value as a valid byte." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `clamp`." },
            { correct: "ImageGray* image_apply_convolution(const ImageGray* src, const Kernel* kernel) {", distractors: [], indent: 0, "explanation": "The main convolution function." },
            { correct: "  printf(\"Applying %dx%d kernel...\\n\", kernel->size, kernel->size);", distractors: [], indent: 1, "explanation": "Informational message." },
            { correct: "  ImageGray* dest = image_create(src->width, src->height);", distractors: [], indent: 1, "explanation": "Create a new destination image to store the results. We cannot modify the image in-place." },
            { correct: "  int kernel_radius = kernel->size / 2;", distractors: [], indent: 1, "explanation": "Calculate the radius of the kernel (e.g., for a 3x3 kernel, the radius is 1)." },
            { correct: "  // Iterate over every pixel in the source image.", distractors: [], indent: 1, "explanation": "Comment on the main loop." },
            { correct: "  for (int y = 0; y < src->height; y++) {", distractors: [], indent: 1, "explanation": "Loop through each row." },
            { correct: "    for (int x = 0; x < src->width; x++) {", distractors: [], indent: 2, "explanation": "Loop through each column." },
            { correct: "      // For each pixel, apply the kernel.", distractors: [], indent: 3, "explanation": "Comment on applying the kernel." },
            { correct: "      float sum = 0.0f;", distractors: [], indent: 3, "explanation": "Initialize the accumulator for the weighted sum." },
            { correct: "      // Iterate over the kernel itself.", distractors: [], indent: 3, "explanation": "Comment on the kernel loop." },
            { correct: "      for (int ky = 0; ky < kernel->size; ky++) {", distractors: [], indent: 3, "explanation": "Loop through kernel rows." },
            { correct: "        for (int kx = 0; kx < kernel->size; kx++) {", distractors: [], indent: 4, "explanation": "Loop through kernel columns." },
            { correct: "          // Find the corresponding image pixel for this kernel point.", distractors: [], indent: 5, "explanation": "Comment on coordinate calculation." },
            { correct: "          int pixel_x = x + (kx - kernel_radius);", distractors: [], indent: 5, "explanation": "Calculate the x-coordinate of the image pixel under the kernel." },
            { correct: "          int pixel_y = y + (ky - kernel_radius);", distractors: [], indent: 5, "explanation": "Calculate the y-coordinate." },
            { correct: "          // Handle image boundaries (edge cases).", distractors: [], indent: 5, "explanation": "Comment on boundary handling." },
            { correct: "          if (pixel_x >= 0 && pixel_x < src->width && pixel_y >= 0 && pixel_y < src->height) {", distractors: [], indent: 5, "explanation": "Check if the calculated pixel is within the image bounds." },
            { correct: "            float image_val = src->data[pixel_y * src->width + pixel_x].value;", distractors: [], indent: 6, "explanation": "Get the value of the source image pixel." },
            { correct: "            float kernel_val = kernel->data[ky * kernel->size + kx];", distractors: [], indent: 6, "explanation": "Get the corresponding value from the kernel." },
            { correct: "            sum += image_val * kernel_val;", distractors: [], indent: 6, "explanation": "Multiply them and add to the sum." },
            { correct: "          }", distractors: [], indent: 5, "explanation": "Close the boundary check." },
            { correct: "        }", distractors: [], indent: 4, "explanation": "Close kernel column loop." },
            { correct: "      }", distractors: [], indent: 3, "explanation": "Close kernel row loop." },
            { correct: "      // Set the destination pixel's value to the calculated sum.", distractors: [], indent: 3, "explanation": "Comment on setting the destination pixel." },
            { correct: "      dest->data[y * dest->width + x].value = clamp(sum);", distractors: [], indent: 3, "explanation": "Assign the final sum to the destination image, clamping it to the 0-255 range." },
            { correct: "    }", distractors: [], indent: 2, "explanation": "Close image column loop." },
            { correct: "  }", distractors: [], indent: 1, "explanation": "Close image row loop." },
            { correct: "  return dest;", distractors: [], indent: 1, "explanation": "Return the newly created, filtered image." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close `image_apply_convolution`." },
            { correct: "// === Stage 3: Main Program to Demonstrate Convolution ===", distractors: [], indent: 0, "explanation": "A `main` function to define kernels and apply them." },
            { correct: "int main() {", distractors: [], indent: 0, "explanation": "Start main." },
            { correct: "  // Create a simple source image (e.g., a white square on a black background).", distractors: [], indent: 1, "explanation": "Comment on creating a test image." },
            { correct: "  ImageGray* source_image = image_create(50, 50);", distractors: [], indent: 1, "explanation": "Create a 50x50 image." },
            { correct: "  for(int y=10; y<40; y++) { for(int x=10; x<40; x++) source_image->data[y*50+x].value = 255; }", distractors: [], indent: 1, "explanation": "Draw a white box in the middle of it." },
            { correct: "  printf(\"--- Convolution Demo ---\\n\");", distractors: [], indent: 1, "explanation": "Header." },
            { correct: "  // Define an Edge Detection Kernel (Sobel X).", distractors: [], indent: 1, "explanation": "Comment on the edge detection kernel." },
            { correct: "  float sobel_x_data[] = { -1, 0, 1, -2, 0, 2, -1, 0, 1 };", distractors: [], indent: 1, "explanation": "This kernel detects vertical edges." },
            { correct: "  Kernel sobel_kernel = { .size = 3, .data = sobel_x_data };", distractors: [], indent: 1, "explanation": "Create a Kernel struct for it." },
            { correct: "  // Apply the kernel.", distractors: [], indent: 1, "explanation": "Comment on applying the filter." },
            { correct: "  ImageGray* edge_image = image_apply_convolution(source_image, &sobel_kernel);", distractors: [], indent: 1, "explanation": "Call the convolution function." },
            { correct: "  printf(\"Edge detection filter applied.\\n\");", distractors: [], indent: 1, "explanation": "Confirmation message." },
            { correct: "  // In a real program, you would now save `edge_image` to a file to see the result.", distractors: [], indent: 1, "explanation": "Comment on what the next step would be." },
            { correct: "  printf(\"The resulting image would show bright lines on the vertical edges of the white square.\\n\");", distractors: [], indent: 1, "explanation": "Describe the expected output." },
            { correct: "  // Cleanup", distractors: [], indent: 1, "explanation": "Comment on cleanup." },
            { correct: "  image_destroy(source_image);", distractors: [], indent: 1, "explanation": "Free the source image." },
            { correct: "  image_destroy(edge_image);", distractors: [], indent: 1, "explanation": "Free the destination image." },
            { correct: "  return 0;", distractors: [], indent: 1, "explanation": "Indicate success." },
            { correct: "}", distractors: [], indent: 0, "explanation": "Close main." }
        ]
    },
    // Level 91: Prep for Samsung
    {
    "goal": "Implement a fixed-block-size memory pool allocator to manage memory efficiently, a common task in embedded and system-level programming.",
    "concepts": "Memory management, pointers, linked lists, bit manipulation, memory alignment, system programming",
    "sequence": [
        { "correct": "// === Stage 1: Data Structures and Core Declarations ===", "distractors": [], "indent": 0, "explanation": "Define the fundamental structures for our memory pool." },
        { "correct": "#include <stdio.h>", "distractors": [], "indent": 0, "explanation": "For standard input/output functions like printf." },
        { "correct": "#include <stdlib.h>", "distractors": [], "indent": 0, "explanation": "For standard memory allocation (`malloc`, `free`) to get the initial memory pool." },
        { "correct": "#include <stdint.h>", "distractors": [], "indent": 0, "explanation": "For using fixed-width integer types like `uintptr_t` and `size_t`." },
        { "correct": "#define BLOCK_SIZE 64", "distractors": [], "indent": 0, "explanation": "Define the size of each memory block we will manage. 64 bytes is a common size." },
        { "correct": "#define POOL_SIZE 1024", "distractors": [], "indent": 0, "explanation": "Define the total number of blocks in our memory pool." },
        { "correct": "// This node will be part of a free list, overlayed on the unused memory blocks.", "distractors": [], "indent": 0, "explanation": "A comment explaining the purpose of the FreeBlockNode struct." },
        { "correct": "typedef struct FreeBlockNode {", "distractors": [], "indent": 0, "explanation": "Start definition of the node for the free list." },
        { "correct": "  struct FreeBlockNode* next;", "distractors": [], "indent": 1, "explanation": "A pointer to the next free block in the list." },
        { "correct": "} FreeBlockNode;", "distractors": [], "indent": 0, "explanation": "Complete the typedef for FreeBlockNode." },
        { "correct": "// This is the main struct for our memory pool allocator.", "distractors": [], "indent": 0, "explanation": "A comment explaining the allocator's main control structure." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start definition of the MemoryPool struct." },
        { "correct": "  void* pool_start;", "distractors": [], "indent": 1, "explanation": "A pointer to the beginning of the large memory chunk we allocate from the OS." },
        { "correct": "  FreeBlockNode* free_list_head;", "distractors": [], "indent": 1, "explanation": "A pointer to the head of the linked list of available blocks." },
        { "correct": "} MemoryPool;", "distractors": [], "indent": 0, "explanation": "Complete the typedef for MemoryPool." },
        { "correct": "// --- Function Prototypes ---", "distractors": [], "indent": 0, "explanation": "Declare the public API for our memory allocator." },
        { "correct": "void pool_init(MemoryPool* pool);", "distractors": [], "indent": 0, "explanation": "Initializes the memory pool, setting up the free list." },
        { "correct": "void* pool_alloc(MemoryPool* pool);", "distractors": [], "indent": 0, "explanation": "Allocates one block of memory from the pool." },
        { "correct": "void pool_free(MemoryPool* pool, void* block);", "distractors": [], "indent": 0, "explanation": "Returns a block of memory to the pool's free list." },
        { "correct": "void pool_destroy(MemoryPool* pool);", "distractors": [], "indent": 0, "explanation": "Releases the entire memory pool back to the OS." },
        { "correct": "// === Stage 2: Memory Pool Initialization ===", "distractors": [], "indent": 0, "explanation": "Implement the logic to set up the memory pool and the free list." },
        { "correct": "void pool_init(MemoryPool* pool) {", "distractors": [], "indent": 0, "explanation": "Begin the implementation of `pool_init`." },
        { "correct": "  printf(\"Initializing memory pool with %d blocks of %d bytes...\\n\", POOL_SIZE, BLOCK_SIZE);", "distractors": [], "indent": 1, "explanation": "Print an informational message about the pool's capacity." },
        { "correct": "  size_t total_size = POOL_SIZE * BLOCK_SIZE;", "distractors": [], "indent": 1, "explanation": "Calculate the total number of bytes needed for the entire pool." },
        { "correct": "  pool->pool_start = malloc(total_size);", "distractors": [], "indent": 1, "explanation": "Request a single large chunk of memory from the operating system." },
        { "correct": "  if (pool->pool_start == NULL) {", "distractors": [], "indent": 1, "explanation": "Check if the system `malloc` failed." },
        { "correct": "    fprintf(stderr, \"Failed to allocate memory for the pool.\\n\");", "distractors": [], "indent": 2, "explanation": "Print an error message to standard error if allocation fails." },
        { "correct": "    exit(EXIT_FAILURE);", "distractors": [], "indent": 2, "explanation": "Terminate the program if we cannot create the memory pool." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "Close the failure check block." },
        { "correct": "  // Now, build the linked list of free blocks.", "distractors": [], "indent": 1, "explanation": "Comment explaining the next step: creating the free list." },
        { "correct": "  pool->free_list_head = NULL;", "distractors": [], "indent": 1, "explanation": "Initialize the head of the free list to NULL before building it." },
        { "correct": "  for (int i = 0; i < POOL_SIZE; ++i) {", "distractors": [], "indent": 1, "explanation": "Loop through each block in the pool to add it to the free list." },
        { "correct": "    // Calculate the address of the current block.", "distractors": [], "indent": 2, "explanation": "Comment on calculating block address." },
        { "correct": "    void* current_block_addr = (char*)pool->pool_start + (i * BLOCK_SIZE);", "distractors": [], "indent": 2, "explanation": "Get the address of the i-th block by offsetting from the start of the pool." },
        { "correct": "    // Cast this block to a FreeBlockNode to add it to the list.", "distractors": [], "indent": 2, "explanation": "Comment explaining the type cast." },
        { "correct": "    FreeBlockNode* new_node = (FreeBlockNode*)current_block_addr;", "distractors": [], "indent": 2, "explanation": "Treat the current block's memory as a FreeBlockNode." },
        { "correct": "    new_node->next = pool->free_list_head;", "distractors": [], "indent": 2, "explanation": "Set the new node's `next` to the current head of the free list." },
        { "correct": "    pool->free_list_head = new_node;", "distractors": [], "indent": 2, "explanation": "Update the head of the free list to be this new node." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of the for loop for initializing free list nodes." },
        { "correct": "  printf(\"Memory pool initialized successfully.\\n\");", "distractors": [], "indent": 1, "explanation": "Confirm successful initialization." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "Close the `pool_init` function." },
        { "correct": "// === Stage 3: Allocation and Deallocation Logic ===", "distractors": [], "indent": 0, "explanation": "Implement the core functions for getting and returning memory blocks." },
        { "correct": "void* pool_alloc(MemoryPool* pool) {", "distractors": [], "indent": 0, "explanation": "Begin the implementation of `pool_alloc`." },
        { "correct": "  // Check if there are any free blocks available.", "distractors": [], "indent": 1, "explanation": "Comment explaining the check for an empty free list." },
        { "correct": "  if (pool->free_list_head == NULL) {", "distractors": [], "indent": 1, "explanation": "If the free list head is NULL, the pool is full." },
        { "correct": "    printf(\"Allocation failed: Memory pool is empty.\\n\");", "distractors": [], "indent": 2, "explanation": "Inform the user that no blocks are available." },
        { "correct": "    return NULL; // Indicate failure", "distractors": [], "indent": 2, "explanation": "Return NULL to signal that the allocation failed." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "Close the empty check block." },
        { "correct": "  // Get the block from the head of the free list.", "distractors": [], "indent": 1, "explanation": "Comment explaining how a block is retrieved." },
        { "correct": "  FreeBlockNode* block_to_alloc = pool->free_list_head;", "distractors": [], "indent": 1, "explanation": "Get a pointer to the first available block." },
        { "correct": "  // Move the free list head to the next available block.", "distractors": [], "indent": 1, "explanation": "Comment on updating the free list." },
        { "correct": "  pool->free_list_head = block_to_alloc->next;", "distractors": [], "indent": 1, "explanation": "Advance the free list head to the next node." },
        { "correct": "  // Return the allocated block as a generic pointer.", "distractors": [], "indent": 1, "explanation": "Comment on the return value." },
        { "correct": "  return (void*)block_to_alloc;", "distractors": [], "indent": 1, "explanation": "Return the pointer to the allocated memory. The user can now use this block." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "Close the `pool_alloc` function." },
        { "correct": "void pool_free(MemoryPool* pool, void* block) {", "distractors": [], "indent": 0, "explanation": "Begin the implementation of `pool_free`." },
        { "correct": "  if (block == NULL) {", "distractors": [], "indent": 1, "explanation": "Check for an attempt to free a NULL pointer." },
        { "correct": "    printf(\"Warning: Attempt to free a NULL pointer.\\n\");", "distractors": [], "indent": 2, "explanation": "It's good practice to handle this case." },
        { "correct": "    return;", "distractors": [], "indent": 2, "explanation": "Exit the function if the block is NULL." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "Close the NULL check." },
        { "correct": "  // Boundary check: ensure the pointer is within our pool.", "distractors": [], "indent": 1, "explanation": "A crucial security and stability check." },
        { "correct": "  uintptr_t block_addr = (uintptr_t)block;", "distractors": [], "indent": 1, "explanation": "Cast the block pointer to an integer for address arithmetic." },
        { "correct": "  uintptr_t pool_start_addr = (uintptr_t)pool->pool_start;", "distractors": [], "indent": 1, "explanation": "Get the starting address of the pool as an integer." },
        { "correct": "  uintptr_t pool_end_addr = pool_start_addr + (POOL_SIZE * BLOCK_SIZE);", "distractors": [], "indent": 1, "explanation": "Calculate the end address of the pool." },
        { "correct": "  if (block_addr < pool_start_addr || block_addr >= pool_end_addr) {", "distractors": [], "indent": 1, "explanation": "Check if the block address is outside the valid range." },
        { "correct": "    fprintf(stderr, \"Error: Attempt to free memory not managed by this pool.\\n\");", "distractors": [], "indent": 2, "explanation": "Report a critical error." },
        { "correct": "    return;", "distractors": [], "indent": 2, "explanation": "Exit if the pointer is invalid." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "Close the boundary check." },
        { "correct": "  // Alignment check: ensure it's a valid block boundary.", "distractors": [], "indent": 1, "explanation": "Another important validation step." },
        { "correct": "  if ((block_addr - pool_start_addr) % BLOCK_SIZE != 0) {", "distractors": [], "indent": 1, "explanation": "Check if the pointer corresponds to the start of a block." },
        { "correct": "    fprintf(stderr, \"Error: Attempt to free a pointer with invalid alignment.\\n\");", "distractors": [], "indent": 2, "explanation": "This indicates memory corruption or incorrect pointer usage." },
        { "correct": "    return;", "distractors": [], "indent": 2, "explanation": "Exit on alignment error." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "Close the alignment check." },
        { "correct": "  // Cast the block back to a FreeBlockNode.", "distractors": [], "indent": 1, "explanation": "Comment explaining the type cast for re-linking." },
        { "correct": "  FreeBlockNode* node_to_free = (FreeBlockNode*)block;", "distractors": [], "indent": 1, "explanation": "Overlay the FreeBlockNode structure onto the memory being freed." },
        { "correct": "  // Add the block back to the head of the free list.", "distractors": [], "indent": 1, "explanation": "Comment on the re-linking process." },
        { "correct": "  node_to_free->next = pool->free_list_head;", "distractors": [], "indent": 1, "explanation": "The freed block's `next` pointer now points to the old head." },
        { "correct": "  pool->free_list_head = node_to_free;", "distractors": [], "indent": 1, "explanation": "The head of the free list is now the block we just freed." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "Close the `pool_free` function." },
        { "correct": "// === Stage 4: Pool Destruction and Cleanup ===", "distractors": [], "indent": 0, "explanation": "Implement the function to release all resources." },
        { "correct": "void pool_destroy(MemoryPool* pool) {", "distractors": [], "indent": 0, "explanation": "Begin the implementation of `pool_destroy`." },
        { "correct": "  printf(\"Destroying memory pool...\\n\");", "distractors": [], "indent": 1, "explanation": "Informational message about cleanup." },
        { "correct": "  if (pool && pool->pool_start) {", "distractors": [], "indent": 1, "explanation": "Check if the pool and its memory exist before trying to free them." },
        { "correct": "    free(pool->pool_start);", "distractors": [], "indent": 2, "explanation": "Release the large chunk of memory back to the operating system." },
        { "correct": "    pool->pool_start = NULL;", "distractors": [], "indent": 2, "explanation": "Set the pointer to NULL to prevent dangling pointers." },
        { "correct": "    pool->free_list_head = NULL;", "distractors": [], "indent": 2, "explanation": "Also nullify the free list head." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "Close the check block." },
        { "correct": "  printf(\"Memory pool destroyed.\\n\");", "distractors": [], "indent": 1, "explanation": "Confirm successful destruction." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "Close the `pool_destroy` function." },
        { "correct": "// === Stage 5: Main Program for Demonstration ===", "distractors": [], "indent": 0, "explanation": "A `main` function to test the memory pool allocator." },
        { "correct": "int main() {", "distractors": [], "indent": 0, "explanation": "Start of the main function." },
        { "correct": "  printf(\"--- Custom Memory Allocator Demo ---\\n\");", "distractors": [], "indent": 1, "explanation": "Print a title for the demonstration." },
        { "correct": "  MemoryPool my_pool;", "distractors": [], "indent": 1, "explanation": "Declare an instance of our MemoryPool struct." },
        { "correct": "  pool_init(&my_pool);", "distractors": [], "indent": 1, "explanation": "Initialize the memory pool." },
        { "correct": "  // --- Test allocation ---", "distractors": [], "indent": 1, "explanation": "Comment indicating the start of the allocation test." },
        { "correct": "  void* ptr1 = pool_alloc(&my_pool);", "distractors": [], "indent": 1, "explanation": "Allocate the first block." },
        { "correct": "  printf(\"Allocated block 1 at address: %p\\n\", ptr1);", "distractors": [], "indent": 1, "explanation": "Print the address of the allocated block." },
        { "correct": "  void* ptr2 = pool_alloc(&my_pool);", "distractors": [], "indent": 1, "explanation": "Allocate the second block." },
        { "correct": "  printf(\"Allocated block 2 at address: %p\\n\", ptr2);", "distractors": [], "indent": 1, "explanation": "Print its address." },
        { "correct": "  // Let's use the memory to store some data", "distractors": [], "indent": 1, "explanation": "Comment on actually using the allocated memory." },
        { "correct": "  if (ptr1) { *(int*)ptr1 = 12345; }", "distractors": [], "indent": 1, "explanation": "Store an integer in the first block." },
        { "correct": "  if (ptr2) { *(int*)ptr2 = 67890; }", "distractors": [], "indent": 1, "explanation": "Store an integer in the second block." },
        { "correct": "  printf(\"Stored data: ptr1 -> %d, ptr2 -> %d\\n\", *(int*)ptr1, *(int*)ptr2);", "distractors": [], "indent": 1, "explanation": "Retrieve and print the stored data to verify." },
        { "correct": "  // --- Test deallocation ---", "distractors": [], "indent": 1, "explanation": "Comment indicating the start of the deallocation test." },
        { "correct": "  printf(\"Freeing block 1...\\n\");", "distractors": [], "indent": 1, "explanation": "Informational message." },
        { "correct": "  pool_free(&my_pool, ptr1);", "distractors": [], "indent": 1, "explanation": "Return the first block to the pool." },
        { "correct": "  printf(\"Block 1 returned to the pool.\\n\");", "distractors": [], "indent": 1, "explanation": "Confirmation." },
        { "correct": "  // --- Test reallocation ---", "distractors": [], "indent": 1, "explanation": "Comment for reallocation test." },
        { "correct": "  void* ptr3 = pool_alloc(&my_pool);", "distractors": [], "indent": 1, "explanation": "Allocate another block. It should reuse the memory from ptr1." },
        { "correct": "  printf(\"Allocated block 3 at address: %p (should be same as ptr1)\\n\", ptr3);", "distractors": [], "indent": 1, "explanation": "Print the address of the new block to show it's the same as the freed one." },
        { "correct": "  // --- Test exhaustion ---", "distractors": [], "indent": 1, "explanation": "Comment for testing the pool's limit." },
        { "correct": "  printf(\"Attempting to exhaust the pool...\\n\");", "distractors": [], "indent": 1, "explanation": "Informational message." },
        { "correct": "  void* pointers[POOL_SIZE];", "distractors": [], "indent": 1, "explanation": "Create an array to hold pointers to all allocated blocks." },
        { "correct": "  int allocated_count = 0;", "distractors": [], "indent": 1, "explanation": "Initialize a counter for allocations." },
        { "correct": "  for(int i = 0; i < POOL_SIZE; ++i) {", "distractors": [], "indent": 1, "explanation": "Loop to try and allocate all available blocks." },
        { "correct": "    pointers[i] = pool_alloc(&my_pool);", "distractors": [], "indent": 2, "explanation": "Attempt to allocate a block." },
        { "correct": "    if (pointers[i] != NULL) {", "distractors": [], "indent": 2, "explanation": "Check if allocation was successful." },
        { "correct": "      allocated_count++;", "distractors": [], "indent": 3, "explanation": "Increment the counter if successful." },
        { "correct": "    } else {", "distractors": [], "indent": 2, "explanation": "If allocation fails..." },
        { "correct": "      break; // Stop when the pool is empty.", "distractors": [], "indent": 3, "explanation": "Break the loop." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "Close the if/else block." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of the allocation loop." },
        { "correct": "  printf(\"Successfully allocated %d blocks before exhaustion.\\n\", allocated_count);", "distractors": [], "indent": 1, "explanation": "Report how many blocks were allocated." },
        { "correct": "  void* extra_ptr = pool_alloc(&my_pool); // This should fail", "distractors": [], "indent": 1, "explanation": "Try to allocate one more block, expecting failure." },
        { "correct": "  if (extra_ptr == NULL) { printf(\"As expected, allocation failed after pool was exhausted.\\n\"); }", "distractors": [], "indent": 1, "explanation": "Confirm that the allocation failed as expected." },
        { "correct": "  // --- Test cleanup ---", "distractors": [], "indent": 1, "explanation": "Comment indicating the final cleanup test." },
        { "correct": "  pool_destroy(&my_pool);", "distractors": [], "indent": 1, "explanation": "Destroy the pool, releasing all its memory." },
        { "correct": "  printf(\"--- Demo Finished ---\\n\");", "distractors": [], "indent": 1, "explanation": "Final message." },
        { "correct": "  return 0;", "distractors": [], "indent": 1, "explanation": "Return 0 to indicate successful execution." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of the main function." }
    ]
},
// Level 92: Prep for Oracle
{
    "goal": "Implement a simplified in-memory B-Tree to store and search for integer keys, simulating a core component of a database index.",
    "concepts": "B-Tree, data structures, recursion, dynamic memory allocation, file I/O (for persistence simulation), database indexing concepts",
    "sequence": [
        { "correct": "// === Stage 1: B-Tree Node Structure and Constants ===", "distractors": [], "indent": 0, "explanation": "Define the constants and data structures that form the building blocks of our B-Tree." },
        { "correct": "#include <stdio.h>", "distractors": [], "indent": 0, "explanation": "For standard I/O operations like printf." },
        { "correct": "#include <stdlib.h>", "distractors": [], "indent": 0, "explanation": "For memory management functions like malloc and free." },
        { "correct": "#include <stdbool.h>", "distractors": [], "indent": 0, "explanation": "For using boolean types `true` and `false`." },
        { "correct": "#define T 3", "distractors": [], "indent": 0, "explanation": "Define the minimum degree (or order) of the B-Tree. T=3 means each node has at most 5 keys (2*T-1) and at most 6 children (2*T)." },
        { "correct": "// A structure to represent a node in the B-Tree", "distractors": [], "indent": 0, "explanation": "Comment explaining the B-Tree node." },
        { "correct": "typedef struct BTreeNode {", "distractors": [], "indent": 0, "explanation": "Start of the BTreeNode struct definition." },
        { "correct": "  int keys[2 * T - 1];", "distractors": [], "indent": 1, "explanation": "An array to store the keys within the node." },
        { "correct": "  struct BTreeNode *children[2 * T];", "distractors": [], "indent": 1, "explanation": "An array of pointers to child nodes." },
        { "correct": "  int n;", "distractors": [], "indent": 1, "explanation": "The current number of keys stored in the node." },
        { "correct": "  bool is_leaf;", "distractors": [], "indent": 1, "explanation": "A boolean flag that is true if the node is a leaf, and false otherwise." },
        { "correct": "} BTreeNode;", "distractors": [], "indent": 0, "explanation": "End of the BTreeNode typedef." },
        { "correct": "// A structure for the B-Tree itself", "distractors": [], "indent": 0, "explanation": "Comment for the main B-Tree control structure." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start of the BTree struct definition." },
        { "correct": "  BTreeNode *root;", "distractors": [], "indent": 1, "explanation": "A pointer to the root node of the tree." },
        { "correct": "} BTree;", "distractors": [], "indent": 0, "explanation": "End of the BTree typedef." },
        { "correct": "// --- Function Prototypes ---", "distractors": [], "indent": 0, "explanation": "Forward declarations of the functions we will implement." },
        { "correct": "BTree* btree_create();", "distractors": [], "indent": 0, "explanation": "Creates and initializes an empty B-Tree." },
        { "correct": "BTreeNode* btree_create_node(bool is_leaf);", "distractors": [], "indent": 0, "explanation": "Allocates and initializes a single B-Tree node." },
        { "correct": "void btree_insert(BTree* tree, int key);", "distractors": [], "indent": 0, "explanation": "Inserts a new key into the B-Tree." },
        { "correct": "void btree_insert_nonfull(BTreeNode* node, int key);", "distractors": [], "indent": 0, "explanation": "Helper function to insert a key into a non-full node." },
        { "correct": "void btree_split_child(BTreeNode* parent, int index, BTreeNode* child);", "distractors": [], "indent": 0, "explanation": "Splits a full child node of a given parent node." },
        { "correct": "BTreeNode* btree_search(BTreeNode* node, int key);", "distractors": [], "indent": 0, "explanation": "Searches for a key in the subtree rooted at a given node." },
        { "correct": "void btree_traverse(BTreeNode* node);", "distractors": [], "indent": 0, "explanation": "Traverses and prints all keys in the subtree rooted at a given node." },
        { "correct": "// === Stage 2: Node and Tree Creation ===", "distractors": [], "indent": 0, "explanation": "Implement the basic allocation and initialization functions." },
        { "correct": "BTreeNode* btree_create_node(bool is_leaf) {", "distractors": [], "indent": 0, "explanation": "Begin implementation of the node constructor." },
        { "correct": "  BTreeNode* new_node = (BTreeNode*)malloc(sizeof(BTreeNode));", "distractors": [], "indent": 1, "explanation": "Allocate memory for a new node." },
        { "correct": "  if (!new_node) { perror(\"Failed to allocate BTreeNode\"); exit(EXIT_FAILURE); }", "distractors": [], "indent": 1, "explanation": "Error handling for malloc failure." },
        { "correct": "  new_node->is_leaf = is_leaf;", "distractors": [], "indent": 1, "explanation": "Set the leaf property based on the parameter." },
        { "correct": "  new_node->n = 0;", "distractors": [], "indent": 1, "explanation": "Initialize the number of keys to 0." },
        { "correct": "  for (int i = 0; i < 2 * T; i++) { new_node->children[i] = NULL; }", "distractors": [], "indent": 1, "explanation": "Initialize all child pointers to NULL." },
        { "correct": "  return new_node;", "distractors": [], "indent": 1, "explanation": "Return the newly created node." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `btree_create_node`." },
        { "correct": "BTree* btree_create() {", "distractors": [], "indent": 0, "explanation": "Begin implementation of the B-Tree constructor." },
        { "correct": "  printf(\"Creating a new B-Tree with minimum degree T=%d\\n\", T);", "distractors": [], "indent": 1, "explanation": "Informational message about the tree's properties." },
        { "correct": "  BTree* new_tree = (BTree*)malloc(sizeof(BTree));", "distractors": [], "indent": 1, "explanation": "Allocate memory for the B-Tree control structure." },
        { "correct": "  if (!new_tree) { perror(\"Failed to allocate BTree\"); exit(EXIT_FAILURE); }", "distractors": [], "indent": 1, "explanation": "Error handling for malloc failure." },
        { "correct": "  BTreeNode* root = btree_create_node(true);", "distractors": [], "indent": 1, "explanation": "Create the root node, which is initially a leaf." },
        { "correct": "  new_tree->root = root;", "distractors": [], "indent": 1, "explanation": "Assign the new node as the root of the tree." },
        { "correct": "  return new_tree;", "distractors": [], "indent": 1, "explanation": "Return the pointer to the new B-Tree." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `btree_create`." },
        { "correct": "// === Stage 3: Core B-Tree Operations - Split and Insert ===", "distractors": [], "indent": 0, "explanation": "Implement the logic for splitting a full node and inserting a new key." },
        { "correct": "void btree_split_child(BTreeNode* parent, int index, BTreeNode* child_to_split) {", "distractors": [], "indent": 0, "explanation": "Begin implementation of `btree_split_child`." },
        { "correct": "  printf(\"Splitting child at index %d...\\n\", index);", "distractors": [], "indent": 1, "explanation": "Log the split operation." },
        { "correct": "  // Create a new node which will store (T-1) keys of child_to_split", "distractors": [], "indent": 1, "explanation": "Comment explaining the purpose of the new node." },
        { "correct": "  BTreeNode* new_sibling = btree_create_node(child_to_split->is_leaf);", "distractors": [], "indent": 1, "explanation": "The new node has the same leaf status as the node being split." },
        { "correct": "  new_sibling->n = T - 1;", "distractors": [], "indent": 1, "explanation": "The new sibling will have T-1 keys." },
        { "correct": "  // Copy the last (T-1) keys from child_to_split to new_sibling", "distractors": [], "indent": 1, "explanation": "Comment on the key transfer." },
        { "correct": "  for (int j = 0; j < T - 1; j++) {", "distractors": [], "indent": 1, "explanation": "Loop to copy the keys." },
        { "correct": "    new_sibling->keys[j] = child_to_split->keys[j + T];", "distractors": [], "indent": 2, "explanation": "Copy the second half of the keys from the full child." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End key copy loop." },
        { "correct": "  // If the split node was not a leaf, copy its last T children to the new sibling", "distractors": [], "indent": 1, "explanation": "Comment on child pointer transfer." },
        { "correct": "  if (!child_to_split->is_leaf) {", "distractors": [], "indent": 1, "explanation": "Check if the node to split is an internal node." },
        { "correct": "    for (int j = 0; j < T; j++) {", "distractors": [], "indent": 2, "explanation": "Loop to copy child pointers." },
        { "correct": "      new_sibling->children[j] = child_to_split->children[j + T];", "distractors": [], "indent": 3, "explanation": "Copy the second half of the child pointers." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End child pointer copy loop." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of child pointer copy block." },
        { "correct": "  // Reduce the number of keys in the original child", "distractors": [], "indent": 1, "explanation": "Comment on updating the original child node." },
        { "correct": "  child_to_split->n = T - 1;", "distractors": [], "indent": 1, "explanation": "The original child now only has T-1 keys." },
        { "correct": "  // Make space for the new child pointer in the parent node", "distractors": [], "indent": 1, "explanation": "Comment on modifying the parent node." },
        { "correct": "  for (int j = parent->n; j >= index + 1; j--) {", "distractors": [], "indent": 1, "explanation": "Loop to shift child pointers in the parent." },
        { "correct": "    parent->children[j + 1] = parent->children[j];", "distractors": [], "indent": 2, "explanation": "Shift child pointers one position to the right." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End child shifting loop." },
        { "correct": "  // Link the new sibling to the parent", "distractors": [], "indent": 1, "explanation": "Comment on linking the new node." },
        { "correct": "  parent->children[index + 1] = new_sibling;", "distractors": [], "indent": 1, "explanation": "Insert the new sibling into the parent's children array." },
        { "correct": "  // Make space for the median key in the parent node", "distractors": [], "indent": 1, "explanation": "Comment on shifting keys in the parent." },
        { "correct": "  for (int j = parent->n - 1; j >= index; j--) {", "distractors": [], "indent": 1, "explanation": "Loop to shift keys in the parent." },
        { "correct": "    parent->keys[j + 1] = parent->keys[j];", "distractors": [], "indent": 2, "explanation": "Shift keys one position to the right." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End key shifting loop." },
        { "correct": "  // Move the median key from the child to the parent", "distractors": [], "indent": 1, "explanation": "Comment on promoting the median key." },
        { "correct": "  parent->keys[index] = child_to_split->keys[T - 1];", "distractors": [], "indent": 1, "explanation": "The median key is promoted to the parent." },
        { "correct": "  // Increment the count of keys in the parent", "distractors": [], "indent": 1, "explanation": "Comment on updating the parent's key count." },
        { "correct": "  parent->n = parent->n + 1;", "distractors": [], "indent": 1, "explanation": "The parent now has one more key." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `btree_split_child`." },
        { "correct": "void btree_insert_nonfull(BTreeNode* node, int key) {", "distractors": [], "indent": 0, "explanation": "Begin implementation of `btree_insert_nonfull`." },
        { "correct": "  int i = node->n - 1;", "distractors": [], "indent": 1, "explanation": "Initialize index as the rightmost key." },
        { "correct": "  if (node->is_leaf) {", "distractors": [], "indent": 1, "explanation": "Case 1: The node is a leaf." },
        { "correct": "    // Find location for new key and move all greater keys one space ahead", "distractors": [], "indent": 2, "explanation": "Comment on finding insertion point." },
        { "correct": "    while (i >= 0 && node->keys[i] > key) {", "distractors": [], "indent": 2, "explanation": "Loop to shift keys." },
        { "correct": "      node->keys[i + 1] = node->keys[i];", "distractors": [], "indent": 3, "explanation": "Shift the key to the right." },
        { "correct": "      i--;", "distractors": [], "indent": 3, "explanation": "Decrement the index." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End key shifting loop." },
        { "correct": "    // Insert the new key at the found location", "distractors": [], "indent": 2, "explanation": "Comment on insertion." },
        { "correct": "    node->keys[i + 1] = key;", "distractors": [], "indent": 2, "explanation": "Place the new key." },
        { "correct": "    node->n = node->n + 1;", "distractors": [], "indent": 2, "explanation": "Increment the key count for the node." },
        { "correct": "    printf(\"Inserted key %d into leaf node.\\n\", key);", "distractors": [], "indent": 2, "explanation": "Log the insertion." },
        { "correct": "  } else {", "distractors": [], "indent": 1, "explanation": "Case 2: The node is not a leaf." },
        { "correct": "    // Find the child which is going to have the new key", "distractors": [], "indent": 2, "explanation": "Comment on finding the correct child." },
        { "correct": "    while (i >= 0 && node->keys[i] > key) { i--; }", "distractors": [], "indent": 2, "explanation": "Find the correct child index to descend into." },
        { "correct": "    i++; // Move to the correct child index.", "distractors": [], "indent": 2, "explanation": "Increment i to point to the correct child." },
        { "correct": "    // Check if the found child is full", "distractors": [], "indent": 2, "explanation": "Comment on the fullness check." },
        { "correct": "    if (node->children[i]->n == 2 * T - 1) {", "distractors": [], "indent": 2, "explanation": "If the child is full, we must split it." },
        { "correct": "      btree_split_child(node, i, node->children[i]);", "distractors": [], "indent": 3, "explanation": "Call the split function." },
        { "correct": "      // After split, the middle key of children[i] goes up and children[i] is split into two.", "distractors": [], "indent": 3, "explanation": "Comment on the result of the split." },
        { "correct": "      // Decide which of the two children is going to have the new key", "distractors": [], "indent": 3, "explanation": "Comment on choosing the correct path after splitting." },
        { "correct": "      if (node->keys[i] < key) { i++; }", "distractors": [], "indent": 3, "explanation": "If the new key is greater than the promoted median, go to the right sibling." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of fullness check block." },
        { "correct": "    btree_insert_nonfull(node->children[i], key);", "distractors": [], "indent": 2, "explanation": "Recursively call to insert the key in the appropriate child." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of leaf/non-leaf block." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `btree_insert_nonfull`." },
        { "correct": "void btree_insert(BTree* tree, int key) {", "distractors": [], "indent": 0, "explanation": "Begin implementation of the main `btree_insert` function." },
        { "correct": "  BTreeNode *root = tree->root;", "distractors": [], "indent": 1, "explanation": "Get a pointer to the root of the tree." },
        { "correct": "  // If root is full, the tree grows in height", "distractors": [], "indent": 1, "explanation": "Comment explaining the special case for a full root." },
        { "correct": "  if (root->n == 2 * T - 1) {", "distractors": [], "indent": 1, "explanation": "Check if the root node is full." },
        { "correct": "    printf(\"Root is full. Creating new root.\\n\");", "distractors": [], "indent": 2, "explanation": "Log the tree height growth." },
        { "correct": "    BTreeNode *new_root = btree_create_node(false);", "distractors": [], "indent": 2, "explanation": "Create a new root, which will be an internal node." },
        { "correct": "    tree->root = new_root;", "distractors": [], "indent": 2, "explanation": "Update the tree's root pointer." },
        { "correct": "    new_root->children[0] = root;", "distractors": [], "indent": 2, "explanation": "The old root becomes a child of the new root." },
        { "correct": "    btree_split_child(new_root, 0, root);", "distractors": [], "indent": 2, "explanation": "Split the old root and move a key to the new root." },
        { "correct": "    btree_insert_nonfull(new_root, key);", "distractors": [], "indent": 2, "explanation": "Insert the new key into the (now non-full) new root's structure." },
        { "correct": "  } else {", "distractors": [], "indent": 1, "explanation": "If the root is not full..." },
        { "correct": "    btree_insert_nonfull(root, key);", "distractors": [], "indent": 2, "explanation": "Call the helper function to insert into the root." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of root fullness check." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `btree_insert`." },
        { "correct": "// === Stage 4: Traversal and Search ===", "distractors": [], "indent": 0, "explanation": "Implement functions to find keys and display the tree's contents." },
        { "correct": "void btree_traverse(BTreeNode* node) {", "distractors": [], "indent": 0, "explanation": "Begin implementation of `btree_traverse`." },
        { "correct": "  if (node != NULL) {", "distractors": [], "indent": 1, "explanation": "Proceed only if the node is not NULL." },
        { "correct": "    int i;", "distractors": [], "indent": 1, "explanation": "Declare loop variable." },
        { "correct": "    for (i = 0; i < node->n; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through keys and children." },
        { "correct": "      // If this is not a leaf, then before printing key[i], traverse the subtree rooted with child children[i].", "distractors": [], "indent": 2, "explanation": "Comment explaining the recursive call." },
        { "correct": "      if (!node->is_leaf) { btree_traverse(node->children[i]); }", "distractors": [], "indent": 2, "explanation": "Recursively traverse the left child." },
        { "correct": "      printf(\" %d\", node->keys[i]);", "distractors": [], "indent": 2, "explanation": "Print the key at the current index." },
        { "correct": "    }", "distractors": [], "indent": 1, "explanation": "End of the main traversal loop." },
        { "correct": "    // Print the subtree rooted with the last child", "distractors": [], "indent": 1, "explanation": "Comment on traversing the rightmost child." },
        { "correct": "    if (!node->is_leaf) { btree_traverse(node->children[i]); }", "distractors": [], "indent": 1, "explanation": "Traverse the subtree of the last child." },
        { "correct": "  }", "distractors": [], "indent": 0, "explanation": "End of NULL check." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `btree_traverse`." },
        { "correct": "BTreeNode* btree_search(BTreeNode* node, int key) {", "distractors": [], "indent": 0, "explanation": "Begin implementation of `btree_search`." },
        { "correct": "  if (node == NULL) return NULL;", "distractors": [], "indent": 1, "explanation": "Base case: If the node is NULL, the key is not found." },
        { "correct": "  int i = 0;", "distractors": [], "indent": 1, "explanation": "Initialize index for searching keys." },
        { "correct": "  while (i < node->n && key > node->keys[i]) { i++; }", "distractors": [], "indent": 1, "explanation": "Find the first key greater than or equal to the target key." },
        { "correct": "  if (i < node->n && key == node->keys[i]) {", "distractors": [], "indent": 1, "explanation": "Check if the key is found at the current position." },
        { "correct": "    printf(\"Key %d found.\\n\", key);", "distractors": [], "indent": 2, "explanation": "Log that the key was found." },
        { "correct": "    return node;", "distractors": [], "indent": 2, "explanation": "Return the node containing the key." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of found-key check." },
        { "correct": "  if (node->is_leaf) {", "distractors": [], "indent": 1, "explanation": "If the node is a leaf and the key wasn't found, it doesn't exist." },
        { "correct": "    printf(\"Key %d not found.\\n\", key);", "distractors": [], "indent": 2, "explanation": "Log that the key was not found." },
        { "correct": "    return NULL;", "distractors": [], "indent": 2, "explanation": "Return NULL." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of leaf check." },
        { "correct": "  // Go to the appropriate child", "distractors": [], "indent": 1, "explanation": "Comment on the recursive step." },
        { "correct": "  return btree_search(node->children[i], key);", "distractors": [], "indent": 1, "explanation": "Recursively search in the appropriate child node." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `btree_search`." },
        { "correct": "// === Stage 5: Main Program for Demonstration ===", "distractors": [], "indent": 0, "explanation": "A `main` function to test the B-Tree implementation." },
        { "correct": "int main() {", "distractors": [], "indent": 0, "explanation": "Start of the main function." },
        { "correct": "  printf(\"--- B-Tree Index Simulation ---\\n\");", "distractors": [], "indent": 1, "explanation": "Print a title for the demo." },
        { "correct": "  BTree* t = btree_create();", "distractors": [], "indent": 1, "explanation": "Create a new B-Tree." },
        { "correct": "  int keys_to_insert[] = {10, 20, 5, 6, 12, 30, 7, 17, 3, 1, 4, 15, 18, 22, 25};", "distractors": [], "indent": 1, "explanation": "Define a set of keys to be inserted." },
        { "correct": "  int num_keys = sizeof(keys_to_insert)/sizeof(keys_to_insert[0]);", "distractors": [], "indent": 1, "explanation": "Calculate the number of keys in the array." },
        { "correct": "  for (int i = 0; i < num_keys; i++) {", "distractors": [], "indent": 1, "explanation": "Loop to insert all keys." },
        { "correct": "    printf(\"\\nInserting key: %d\\n\", keys_to_insert[i]);", "distractors": [], "indent": 2, "explanation": "Log which key is being inserted." },
        { "correct": "    btree_insert(t, keys_to_insert[i]);", "distractors": [], "indent": 2, "explanation": "Call the insert function." },
        { "correct": "    printf(\"Current Tree: \"); btree_traverse(t->root); printf(\"\\n\");", "distractors": [], "indent": 2, "explanation": "Print the state of the tree after each insertion." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of insertion loop." },
        { "correct": "  printf(\"\\n--- Final B-Tree Structure ---\\n\");", "distractors": [], "indent": 1, "explanation": "Header for the final tree traversal." },
        { "correct": "  printf(\"Traversal of the constructed tree is: \");", "distractors": [], "indent": 1, "explanation": "Informational message." },
        { "correct": "  btree_traverse(t->root);", "distractors": [], "indent": 1, "explanation": "Display all keys in sorted order." },
        { "correct": "  printf(\"\\n\");", "distractors": [], "indent": 1, "explanation": "Print a newline for formatting." },
        { "correct": "  printf(\"\\n--- Searching for keys ---\\n\");", "distractors": [], "indent": 1, "explanation": "Header for the search test." },
        { "correct": "  btree_search(t->root, 6);", "distractors": [], "indent": 1, "explanation": "Search for a key that exists." },
        { "correct": "  btree_search(t->root, 15);", "distractors": [], "indent": 1, "explanation": "Search for another key that exists." },
        { "correct": "  btree_search(t->root, 99);", "distractors": [], "indent": 1, "explanation": "Search for a key that does not exist." },
        { "correct": "  // Cleanup would involve a recursive free of all nodes, not implemented here for brevity.", "distractors": [], "indent": 1, "explanation": "A note on the importance of cleanup in a real application." },
        { "correct": "  printf(\"\\n--- Demo Finished ---\\n\");", "distractors": [], "indent": 1, "explanation": "Final message." },
        { "correct": "  // free(t); // In a real scenario, you'd free the tree and all its nodes.", "distractors": [], "indent": 1, "explanation": "Commented out cleanup code." },
        { "correct": "  return 0;", "distractors": [], "indent": 1, "explanation": "Indicate successful execution." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of the main function." }
    ]
},
// Level 93: Prep for Tesla
{
    "goal": "Implement a basic real-time, fixed-priority, preemptive task scheduler to manage and execute tasks based on their priority and timing constraints.",
    "concepts": "Real-time systems, scheduling algorithms, data structures (priority queue), function pointers, state machines, embedded systems programming",
    "sequence": [
        { "correct": "// === Stage 1: Core Data Structures and Definitions ===", "distractors": [], "indent": 0, "explanation": "Define the structures for tasks, the scheduler, and system-wide constants." },
        { "correct": "#include <stdio.h>", "distractors": [], "indent": 0, "explanation": "For standard I/O." },
        { "correct": "#include <stdlib.h>", "distractors": [], "indent": 0, "explanation": "For memory allocation." },
        { "correct": "#include <stdint.h>", "distractors": [], "indent": 0, "explanation": "For fixed-width integers like `uint32_t`." },
        { "correct": "#include <stdbool.h>", "distractors": [], "indent": 0, "explanation": "For boolean types." },
        { "correct": "#include <string.h>", "distractors": [], "indent": 0, "explanation": "For string manipulation, e.g., `strcpy`." },
        { "correct": "#define MAX_TASKS 10", "distractors": [], "indent": 0, "explanation": "The maximum number of tasks our scheduler can handle." },
        { "correct": "#define MAX_TASK_NAME 32", "distractors": [], "indent": 0, "explanation": "Maximum length for a task's name." },
        { "correct": "// Represents the state of a task.", "distractors": [], "indent": 0, "explanation": "Comment on the TaskState enum." },
        { "correct": "typedef enum { READY, RUNNING, WAITING, FINISHED } TaskState;", "distractors": [], "indent": 0, "explanation": "Defines the possible states a task can be in." },
        { "correct": "// The Task Control Block (TCB).", "distractors": [], "indent": 0, "explanation": "Comment explaining the TCB struct." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start of the TCB struct." },
        { "correct": "  char name[MAX_TASK_NAME];", "distractors": [], "indent": 1, "explanation": "A human-readable name for the task." },
        { "correct": "  void (*task_func)(void*);", "distractors": [], "indent": 1, "explanation": "A function pointer to the code the task will execute." },
        { "correct": "  void* arg;", "distractors": [], "indent": 1, "explanation": "An argument to be passed to the task function." },
        { "correct": "  uint32_t priority;", "distractors": [], "indent": 1, "explanation": "Task priority (lower number = higher priority)." },
        { "correct": "  TaskState state;", "distractors": [], "indent": 1, "explanation": "The current state of the task." },
        { "correct": "  uint32_t ticks_to_wait;", "distractors": [], "indent": 1, "explanation": "If waiting, how many system ticks to wait for." },
        { "correct": "} TCB;", "distractors": [], "indent": 0, "explanation": "End of the TCB typedef." },
        { "correct": "// The main scheduler control structure.", "distractors": [], "indent": 0, "explanation": "Comment for the Scheduler struct." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start of the Scheduler struct." },
        { "correct": "  TCB task_list[MAX_TASKS];", "distractors": [], "indent": 1, "explanation": "An array to hold all the tasks managed by the scheduler." },
        { "correct": "  uint32_t task_count;", "distractors": [], "indent": 1, "explanation": "The current number of tasks registered." },
        { "correct": "  uint32_t current_tick;", "distractors": [], "indent": 1, "explanation": "A counter simulating the system clock." },
        { "correct": "  int currently_running_task_index;", "distractors": [], "indent": 1, "explanation": "Index of the task that is currently in the RUNNING state (-1 if none)." },
        { "correct": "} Scheduler;", "distractors": [], "indent": 0, "explanation": "End of the Scheduler typedef." },
        { "correct": "// --- Function Prototypes ---", "distractors": [], "indent": 0, "explanation": "Declarations for scheduler functions." },
        { "correct": "void scheduler_init(Scheduler* sched);", "distractors": [], "indent": 0, "explanation": "Initializes the scheduler." },
        { "correct": "bool scheduler_add_task(Scheduler* sched, const char* name, uint32_t priority, void (*func)(void*), void* arg);", "distractors": [], "indent": 0, "explanation": "Adds a new task to the scheduler." },
        { "correct": "void scheduler_run(Scheduler* sched);", "distractors": [], "indent": 0, "explanation": "Starts the main scheduling loop." },
        { "correct": "void scheduler_tick(Scheduler* sched);", "distractors": [], "indent": 0, "explanation": "Advances the system clock and re-evaluates task states." },
        { "correct": "void task_wait(Scheduler* sched, uint32_t ticks);", "distractors": [], "indent": 0, "explanation": "API for a running task to put itself into a WAITING state." },
        { "correct": "void print_task_states(const Scheduler* sched);", "distractors": [], "indent": 0, "explanation": "A helper to visualize the state of all tasks." },
        { "correct": "// === Stage 2: Scheduler Initialization and Task Registration ===", "distractors": [], "indent": 0, "explanation": "Implement the basic setup functions." },
        { "correct": "void scheduler_init(Scheduler* sched) {", "distractors": [], "indent": 0, "explanation": "Begin `scheduler_init` implementation." },
        { "correct": "  printf(\"Initializing the Real-Time Scheduler...\\n\");", "distractors": [], "indent": 1, "explanation": "Informational message." },
        { "correct": "  sched->task_count = 0;", "distractors": [], "indent": 1, "explanation": "Start with zero tasks." },
        { "correct": "  sched->current_tick = 0;", "distractors": [], "indent": 1, "explanation": "Initialize system clock to zero." },
        { "correct": "  sched->currently_running_task_index = -1;", "distractors": [], "indent": 1, "explanation": "No task is running initially." },
        { "correct": "  for (int i = 0; i < MAX_TASKS; i++) { sched->task_list[i].state = FINISHED; }", "distractors": [], "indent": 1, "explanation": "Mark all task slots as available by setting state to FINISHED." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `scheduler_init`." },
        { "correct": "bool scheduler_add_task(Scheduler* sched, const char* name, uint32_t priority, void (*func)(void*), void* arg) {", "distractors": [], "indent": 0, "explanation": "Begin `scheduler_add_task` implementation." },
        { "correct": "  if (sched->task_count >= MAX_TASKS) {", "distractors": [], "indent": 1, "explanation": "Check if the task list is full." },
        { "correct": "    fprintf(stderr, \"Cannot add task '%s': Scheduler is full.\\n\", name);", "distractors": [], "indent": 2, "explanation": "Report an error if no more tasks can be added." },
        { "correct": "    return false;", "distractors": [], "indent": 2, "explanation": "Return false to indicate failure." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of fullness check." },
        { "correct": "  printf(\"Adding task '%s' with priority %u.\\n\", name, priority);", "distractors": [], "indent": 1, "explanation": "Log the addition of the new task." },
        { "correct": "  TCB* new_task = &sched->task_list[sched->task_count];", "distractors": [], "indent": 1, "explanation": "Get a pointer to the next available TCB slot." },
        { "correct": "  strncpy(new_task->name, name, MAX_TASK_NAME - 1);", "distractors": [], "indent": 1, "explanation": "Copy the task name securely." },
        { "correct": "  new_task->name[MAX_TASK_NAME - 1] = '\\0';", "distractors": [], "indent": 1, "explanation": "Ensure null-termination of the task name." },
        { "correct": "  new_task->priority = priority;", "distractors": [], "indent": 1, "explanation": "Set the task's priority." },
        { "correct": "  new_task->task_func = func;", "distractors": [], "indent": 1, "explanation": "Set the task's function pointer." },
        { "correct": "  new_task->arg = arg;", "distractors": [], "indent": 1, "explanation": "Set the task's argument." },
        { "correct": "  new_task->state = READY;", "distractors": [], "indent": 1, "explanation": "The new task is ready to run." },
        { "correct": "  new_task->ticks_to_wait = 0;", "distractors": [], "indent": 1, "explanation": "Initialize wait time to zero." },
        { "correct": "  sched->task_count++;", "distractors": [], "indent": 1, "explanation": "Increment the total number of tasks." },
        { "correct": "  return true;", "distractors": [], "indent": 1, "explanation": "Return true to indicate success." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `scheduler_add_task`." },
        { "correct": "// === Stage 3: The Scheduler Tick and Preemption Logic ===", "distractors": [], "indent": 0, "explanation": "Implement the core logic that drives the scheduler." },
        { "correct": "void scheduler_tick(Scheduler* sched) {", "distractors": [], "indent": 0, "explanation": "Begin `scheduler_tick` implementation. This simulates a timer interrupt." },
        { "correct": "  sched->current_tick++;", "distractors": [], "indent": 1, "explanation": "Increment the global system tick." },
        { "correct": "  printf(\"\\n--- Tick %u ---\\n\", sched->current_tick);", "distractors": [], "indent": 1, "explanation": "Print the current tick number for logging." },
        { "correct": "  // First, update the state of any waiting tasks.", "distractors": [], "indent": 1, "explanation": "Comment on the first phase of the tick: updating waiting tasks." },
        { "correct": "  for (uint32_t i = 0; i < sched->task_count; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through all registered tasks." },
        { "correct": "    if (sched->task_list[i].state == WAITING) {", "distractors": [], "indent": 2, "explanation": "Check if a task is in the WAITING state." },
        { "correct": "      sched->task_list[i].ticks_to_wait--;", "distractors": [], "indent": 3, "explanation": "Decrement its wait counter." },
        { "correct": "      if (sched->task_list[i].ticks_to_wait == 0) {", "distractors": [], "indent": 3, "explanation": "If the wait time is over..." },
        { "correct": "        sched->task_list[i].state = READY;", "distractors": [], "indent": 4, "explanation": "Transition the task back to the READY state." },
        { "correct": "        printf(\"Task '%s' is now READY.\\n\", sched->task_list[i].name);", "distractors": [], "indent": 4, "explanation": "Log the state change." },
        { "correct": "      }", "distractors": [], "indent": 3, "explanation": "End of wait-time-over check." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of WAITING state check." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of task loop." },
        { "correct": "  // Now, find the highest priority task that is READY.", "distractors": [], "indent": 1, "explanation": "Comment on the second phase: finding the next task to run." },
        { "correct": "  int highest_priority_ready_task = -1;", "distractors": [], "indent": 1, "explanation": "Initialize index to -1 (no task found yet)." },
        { "correct": "  uint32_t best_priority = -1; // -1 is max uint, so it's the lowest possible priority", "distractors": [], "indent": 1, "explanation": "Initialize best priority to the lowest possible value." },
        { "correct": "  for (uint32_t i = 0; i < sched->task_count; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through all tasks to find the best candidate." },
        { "correct": "    if (sched->task_list[i].state == READY) {", "distractors": [], "indent": 2, "explanation": "Consider only tasks that are in the READY state." },
        { "correct": "      if (sched->task_list[i].priority < best_priority) {", "distractors": [], "indent": 3, "explanation": "If this task has a higher priority (lower number) than the best found so far..." },
        { "correct": "        best_priority = sched->task_list[i].priority;", "distractors": [], "indent": 4, "explanation": "Update the best priority." },
        { "correct": "        highest_priority_ready_task = i;", "distractors": [], "indent": 4, "explanation": "Update the index of the best candidate." },
        { "correct": "      }", "distractors": [], "indent": 3, "explanation": "End of priority comparison." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of READY state check." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of candidate search loop." },
        { "correct": "  // Preemption Logic: Decide if we need to switch tasks.", "distractors": [], "indent": 1, "explanation": "Comment on the third phase: context switching." },
        { "correct": "  int current_task_idx = sched->currently_running_task_index;", "distractors": [], "indent": 1, "explanation": "Get the index of the currently running task." },
        { "correct": "  if (highest_priority_ready_task != -1) { // If a ready task exists", "distractors": [], "indent": 1, "explanation": "Check if we found any ready task." },
        { "correct": "    if (current_task_idx == -1 || sched->task_list[highest_priority_ready_task].priority < sched->task_list[current_task_idx].priority) {", "distractors": [], "indent": 2, "explanation": "Switch if no task is running OR if the new task has higher priority." },
        { "correct": "      if (current_task_idx != -1) {", "distractors": [], "indent": 3, "explanation": "If a task was running..." },
        { "correct": "        sched->task_list[current_task_idx].state = READY;", "distractors": [], "indent": 4, "explanation": "Set the preempted task's state back to READY." },
        { "correct": "        printf(\"PREEMPTING task '%s'.\\n\", sched->task_list[current_task_idx].name);", "distractors": [], "indent": 4, "explanation": "Log the preemption." },
        { "correct": "      }", "distractors": [], "indent": 3, "explanation": "End of preemption check." },
        { "correct": "      sched->currently_running_task_index = highest_priority_ready_task;", "distractors": [], "indent": 3, "explanation": "Update the index of the running task." },
        { "correct": "      sched->task_list[highest_priority_ready_task].state = RUNNING;", "distractors": [], "indent": 3, "explanation": "Set the new task's state to RUNNING." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of switch condition." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of ready task check." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `scheduler_tick`." },
        { "correct": "// === Stage 4: Scheduler Execution and Task API ===", "distractors": [], "indent": 0, "explanation": "Implement the main loop and functions for tasks to use." },
        { "correct": "void scheduler_run(Scheduler* sched) {", "distractors": [], "indent": 0, "explanation": "Begin `scheduler_run` implementation." },
        { "correct": "  printf(\"\\n--- Starting Scheduler Main Loop ---\\n\");", "distractors": [], "indent": 1, "explanation": "Header for the main loop." },
        { "correct": "  while (true) {", "distractors": [], "indent": 1, "explanation": "The main loop of the scheduler. In a real system, this would be the idle loop." },
        { "correct": "    scheduler_tick(sched);", "distractors": [], "indent": 2, "explanation": "Process one tick of the scheduler clock." },
        { "correct": "    print_task_states(sched);", "distractors": [], "indent": 2, "explanation": "Print the current state of all tasks for visualization." },
        { "correct": "    int running_idx = sched->currently_running_task_index;", "distractors": [], "indent": 2, "explanation": "Get the index of the task to execute." },
        { "correct": "    if (running_idx != -1) {", "distractors": [], "indent": 2, "explanation": "If there is a task to run..." },
        { "correct": "      TCB* current_task = &sched->task_list[running_idx];", "distractors": [], "indent": 3, "explanation": "Get a pointer to its TCB." },
        { "correct": "      printf(\"Executing task '%s'...\\n\", current_task->name);", "distractors": [], "indent": 3, "explanation": "Log the execution." },
        { "correct": "      current_task->task_func(sched); // Pass scheduler for API calls like task_wait", "distractors": [], "indent": 3, "explanation": "Call the task's function. We pass the scheduler as an argument." },
        { "correct": "    } else {", "distractors": [], "indent": 2, "explanation": "If no task is running..." },
        { "correct": "      printf(\"CPU is idle.\\n\");", "distractors": [], "indent": 3, "explanation": "Log that the system is idle." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of task execution block." },
        { "correct": "    // Check for termination condition (all tasks are finished).", "distractors": [], "indent": 2, "explanation": "Comment on the loop termination condition." },
        { "correct": "    bool all_finished = true;", "distractors": [], "indent": 2, "explanation": "Assume all tasks are finished." },
        { "correct": "    for (uint32_t i = 0; i < sched->task_count; i++) {", "distractors": [], "indent": 2, "explanation": "Loop through all tasks." },
        { "correct": "      if (sched->task_list[i].state != FINISHED) { all_finished = false; break; }", "distractors": [], "indent": 3, "explanation": "If any task is not finished, clear the flag and break." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of termination check loop." },
        { "correct": "    if (all_finished) { break; }", "distractors": [], "indent": 2, "explanation": "If all tasks are done, exit the main loop." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of `while(true)`." },
        { "correct": "  printf(\"\\n--- All Tasks Finished. Scheduler Halting. ---\\n\");", "distractors": [], "indent": 1, "explanation": "Final message." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `scheduler_run`." },
        { "correct": "void task_wait(Scheduler* sched, uint32_t ticks) {", "distractors": [], "indent": 0, "explanation": "Begin `task_wait` implementation. This is an API for tasks." },
        { "correct": "  int current_idx = sched->currently_running_task_index;", "distractors": [], "indent": 1, "explanation": "Get the index of the currently running task." },
        { "correct": "  if (current_idx != -1) {", "distractors": [], "indent": 1, "explanation": "This function should only be called by a running task." },
        { "correct": "    TCB* task = &sched->task_list[current_idx];", "distractors": [], "indent": 2, "explanation": "Get the TCB of the calling task." },
        { "correct": "    printf(\"Task '%s' is entering WAITING state for %u ticks.\\n\", task->name, ticks);", "distractors": [], "indent": 2, "explanation": "Log the state change." },
        { "correct": "    task->state = WAITING;", "distractors": [], "indent": 2, "explanation": "Change the task's state to WAITING." },
        { "correct": "    task->ticks_to_wait = ticks;", "distractors": [], "indent": 2, "explanation": "Set the number of ticks to wait." },
        { "correct": "    sched->currently_running_task_index = -1; // Yield the CPU", "distractors": [], "indent": 2, "explanation": "The CPU is now available for other tasks." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of current task check." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `task_wait`." },
        { "correct": "// === Stage 5: Helper Functions and Demo Tasks ===", "distractors": [], "indent": 0, "explanation": "Implement utility functions and the actual tasks for the demo." },
        { "correct": "void print_task_states(const Scheduler* sched) {", "distractors": [], "indent": 0, "explanation": "Begin `print_task_states` implementation." },
        { "correct": "  printf(\"Task States: | \");", "distractors": [], "indent": 1, "explanation": "Print a header." },
        { "correct": "  for (uint32_t i = 0; i < sched->task_count; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through all tasks." },
        { "correct": "    const char* state_str;", "distractors": [], "indent": 2, "explanation": "Declare a string for the state." },
        { "correct": "    switch(sched->task_list[i].state) {", "distractors": [], "indent": 2, "explanation": "Switch on the task's state enum." },
        { "correct": "      case READY: state_str = \"Ready\"; break;", "distractors": [], "indent": 3, "explanation": "Case for READY." },
        { "correct": "      case RUNNING: state_str = \"Running\"; break;", "distractors": [], "indent": 3, "explanation": "Case for RUNNING." },
        { "correct": "      case WAITING: state_str = \"Waiting\"; break;", "distractors": [], "indent": 3, "explanation": "Case for WAITING." },
        { "correct": "      case FINISHED: state_str = \"Finished\"; break;", "distractors": [], "indent": 3, "explanation": "Case for FINISHED." },
        { "correct": "      default: state_str = \"Unknown\"; break;", "distractors": [], "indent": 3, "explanation": "Default case." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of switch." },
        { "correct": "    printf(\"%s: %s | \", sched->task_list[i].name, state_str);", "distractors": [], "indent": 2, "explanation": "Print the name and state of the task." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of task loop." },
        { "correct": "  printf(\"\\n\");", "distractors": [], "indent": 1, "explanation": "Print a newline for formatting." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `print_task_states`." },
        { "correct": "// --- Demo Task Definitions ---", "distractors": [], "indent": 0, "explanation": "Define the functions that our tasks will execute." },
        { "correct": "void high_priority_task(void* arg) {", "distractors": [], "indent": 0, "explanation": "A high-priority task (e.g., brake monitoring)." },
        { "correct": "  Scheduler* sched = (Scheduler*)arg;", "distractors": [], "indent": 1, "explanation": "Cast the argument back to a Scheduler pointer." },
        { "correct": "  printf(\"  [HP Task] Running. Checking critical systems.\\n\");", "distractors": [], "indent": 1, "explanation": "Task-specific log." },
        { "correct": "  task_wait(sched, 3); // This task runs, then waits for 3 ticks.", "distractors": [], "indent": 1, "explanation": "The task puts itself to sleep, allowing lower priority tasks to run." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of high priority task." },
        { "correct": "void medium_priority_task(void* arg) {", "distractors": [], "indent": 0, "explanation": "A medium-priority task (e.g., navigation update)." },
        { "correct": "  Scheduler* sched = (Scheduler*)arg;", "distractors": [], "indent": 1, "explanation": "Get scheduler pointer." },
        { "correct": "  printf(\"  [MP Task] Running. Updating GPS coordinates.\\n\");", "distractors": [], "indent": 1, "explanation": "Task-specific log." },
        { "correct": "  task_wait(sched, 5); // This task runs, then waits for 5 ticks.", "distractors": [], "indent": 1, "explanation": "This task has a longer periodic wait." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of medium priority task." },
        { "correct": "void low_priority_task(void* arg) {", "distractors": [], "indent": 0, "explanation": "A low-priority task (e.g., music player)." },
        { "correct": "  Scheduler* sched = (Scheduler*)arg;", "distractors": [], "indent": 1, "explanation": "Get scheduler pointer." },
        { "correct": "  printf(\"  [LP Task] Running. Decoding audio buffer.\\n\");", "distractors": [], "indent": 1, "explanation": "Task-specific log." },
        { "correct": "  // This task will run whenever nothing else is ready. Let's make it 'finish' after one run.", "distractors": [], "indent": 1, "explanation": "Comment on this task's behavior." },
        { "correct": "  sched->task_list[sched->currently_running_task_index].state = FINISHED;", "distractors": [], "indent": 1, "explanation": "Mark itself as finished." },
        { "correct": "  sched->currently_running_task_index = -1;", "distractors": [], "indent": 1, "explanation": "Yield the CPU." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of low priority task." },
        { "correct": "// === Stage 6: Main Program to Run the Simulation ===", "distractors": [], "indent": 0, "explanation": "The main entry point to set up and run the scheduler simulation." },
        { "correct": "int main() {", "distractors": [], "indent": 0, "explanation": "Start of the main function." },
        { "correct": "  Scheduler my_scheduler;", "distractors": [], "indent": 1, "explanation": "Declare the scheduler instance." },
        { "correct": "  scheduler_init(&my_scheduler);", "distractors": [], "indent": 1, "explanation": "Initialize the scheduler." },
        { "correct": "  // Add tasks in an order that is different from their priority.", "distractors": [], "indent": 1, "explanation": "Comment explaining task registration order." },
        { "correct": "  scheduler_add_task(&my_scheduler, \"Music Player\", 10, low_priority_task, &my_scheduler);", "distractors": [], "indent": 1, "explanation": "Add the low priority task first." },
        { "correct": "  scheduler_add_task(&my_scheduler, \"Brake Monitor\", 1, high_priority_task, &my_scheduler);", "distractors": [], "indent": 1, "explanation": "Add the high priority task second." },
        { "correct": "  scheduler_add_task(&my_scheduler, \"Navigation\", 5, medium_priority_task, &my_scheduler);", "distractors": [], "indent": 1, "explanation": "Add the medium priority task last." },
        { "correct": "  // The scheduler should pick the highest priority task first, regardless of add order.", "distractors": [], "indent": 1, "explanation": "Comment on expected scheduler behavior." },
        { "correct": "  // For this demo, we'll manually limit the simulation ticks.", "distractors": [], "indent": 1, "explanation": "Comment on the simulation loop." },
        { "correct": "  printf(\"\\n--- Starting Scheduler Simulation for 10 Ticks ---\\n\");", "distractors": [], "indent": 1, "explanation": "Header for the simulation." },
        { "correct": "  for (int i = 0; i < 10; i++) {", "distractors": [], "indent": 1, "explanation": "A simplified main loop for the demo." },
        { "correct": "    scheduler_tick(&my_scheduler);", "distractors": [], "indent": 2, "explanation": "Advance the scheduler tick." },
        { "correct": "    print_task_states(&my_scheduler);", "distractors": [], "indent": 2, "explanation": "Print current state." },
        { "correct": "    int running_idx = my_scheduler.currently_running_task_index;", "distractors": [], "indent": 2, "explanation": "Find out which task should run." },
        { "correct": "    if (running_idx != -1) {", "distractors": [], "indent": 2, "explanation": "If a task is scheduled to run..." },
        { "correct": "      printf(\"Executing task '%s'.\\n\", my_scheduler.task_list[running_idx].name);", "distractors": [], "indent": 3, "explanation": "Log its execution." },
        { "correct": "      my_scheduler.task_list[running_idx].task_func(&my_scheduler);", "distractors": [], "indent": 3, "explanation": "Execute the task's function." },
        { "correct": "    } else {", "distractors": [], "indent": 2, "explanation": "If no task is ready..." },
        { "correct": "      printf(\"CPU is idle.\\n\");", "distractors": [], "indent": 3, "explanation": "Log idle state." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of execution block." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of simulation loop." },
        { "correct": "  printf(\"\\n--- Demo Finished ---\\n\");", "distractors": [], "indent": 1, "explanation": "Final message." },
        { "correct": "  return 0;", "distractors": [], "indent": 1, "explanation": "Indicate success." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of main." }
    ]
},
// Level 94: Prep for Amazon
{
    "goal": "Implement a hash table that automatically resizes and rehashes its elements when the load factor becomes too high, ensuring efficient lookups, insertions, and deletions.",
    "concepts": "Hash tables, hash functions, collision resolution (chaining), dynamic memory allocation, load factor, rehashing, pointers",
    "sequence": [
        { "correct": "// === Stage 1: Data Structures and Core Declarations ===", "distractors": [], "indent": 0, "explanation": "Define the structures for key-value pairs, hash table entries, and the main hash table." },
        { "correct": "#include <stdio.h>", "distractors": [], "indent": 0, "explanation": "For standard input/output." },
        { "correct": "#include <stdlib.h>", "distractors": [], "indent": 0, "explanation": "For dynamic memory management (`malloc`, `free`)." },
        { "correct": "#include <string.h>", "distractors": [], "indent": 0, "explanation": "For string operations like `strcpy` and `strcmp`." },
        { "correct": "#include <stdint.h>", "distractors": [], "indent": 0, "explanation": "For fixed-width integer types." },
        { "correct": "#define INITIAL_CAPACITY 8", "distractors": [], "indent": 0, "explanation": "The initial number of buckets in our hash table." },
        { "correct": "#define MAX_LOAD_FACTOR 0.75", "distractors": [], "indent": 0, "explanation": "The threshold at which we will trigger a resize and rehash." },
        { "correct": "// A single entry in a hash table bucket (using chaining for collisions).", "distractors": [], "indent": 0, "explanation": "Comment explaining the EntryNode struct." },
        { "correct": "typedef struct EntryNode {", "distractors": [], "indent": 0, "explanation": "Start definition of an entry node." },
        { "correct": "  char* key;", "distractors": [], "indent": 1, "explanation": "The key for the entry (we will use strings)." },
        { "correct": "  int value;", "distractors": [], "indent": 1, "explanation": "The value associated with the key." },
        { "correct": "  struct EntryNode* next;", "distractors": [], "indent": 1, "explanation": "Pointer to the next entry in the same bucket (for chaining)." },
        { "correct": "} EntryNode;", "distractors": [], "indent": 0, "explanation": "End of EntryNode typedef." },
        { "correct": "// The main Hash Table structure.", "distractors": [], "indent": 0, "explanation": "Comment for the HashTable struct." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start definition of the HashTable struct." },
        { "correct": "  EntryNode** buckets;", "distractors": [], "indent": 1, "explanation": "An array of pointers to EntryNodes. This is our bucket array." },
        { "correct": "  size_t capacity;", "distractors": [], "indent": 1, "explanation": "The current number of buckets in the `buckets` array." },
        { "correct": "  size_t size;", "distractors": [], "indent": 1, "explanation": "The current number of key-value pairs stored in the table." },
        { "correct": "} HashTable;", "distractors": [], "indent": 0, "explanation": "End of HashTable typedef." },
        { "correct": "// --- Function Prototypes ---", "distractors": [], "indent": 0, "explanation": "Declare the public API for our hash table." },
        { "correct": "HashTable* ht_create();", "distractors": [], "indent": 0, "explanation": "Creates and initializes a new hash table." },
        { "correct": "void ht_destroy(HashTable* table);", "distractors": [], "indent": 0, "explanation": "Frees all memory associated with the hash table." },
        { "correct": "unsigned long hash_function(const char* str, size_t capacity);", "distractors": [], "indent": 0, "explanation": "Computes the hash of a string key." },
        { "correct": "void ht_insert(HashTable* table, const char* key, int value);", "distractors": [], "indent": 0, "explanation": "Inserts or updates a key-value pair." },
        { "correct": "int* ht_get(HashTable* table, const char* key);", "distractors": [], "indent": 0, "explanation": "Retrieves the value for a given key." },
        { "correct": "void ht_delete(HashTable* table, const char* key);", "distractors": [], "indent": 0, "explanation": "Deletes a key-value pair." },
        { "correct": "static void ht_resize_and_rehash(HashTable* table);", "distractors": [], "indent": 0, "explanation": "The internal function to grow the table and rehash elements." },
        { "correct": "// === Stage 2: Hash Function and Table Creation/Destruction ===", "distractors": [], "indent": 0, "explanation": "Implement the foundational components." },
        { "correct": "unsigned long hash_function(const char* str, size_t capacity) {", "distractors": [], "indent": 0, "explanation": "Begin hash function (djb2 algorithm)." },
        { "correct": "  unsigned long hash = 5381;", "distractors": [], "indent": 1, "explanation": "Start with a magic prime number." },
        { "correct": "  int c;", "distractors": [], "indent": 1, "explanation": "Variable to hold each character." },
        { "correct": "  while ((c = *str++)) {", "distractors": [], "indent": 1, "explanation": "Iterate through the string." },
        { "correct": "    hash = ((hash << 5) + hash) + c; /* hash * 33 + c */", "distractors": [], "indent": 2, "explanation": "Incorporate each character into the hash value." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of loop." },
        { "correct": "  return hash % capacity;", "distractors": [], "indent": 1, "explanation": "Return the hash modulo the table capacity to get a bucket index." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `hash_function`." },
        { "correct": "HashTable* ht_create() {", "distractors": [], "indent": 0, "explanation": "Begin `ht_create`." },
        { "correct": "  printf(\"Creating hash table with initial capacity %d.\\n\", INITIAL_CAPACITY);", "distractors": [], "indent": 1, "explanation": "Log the creation event." },
        { "correct": "  HashTable* table = malloc(sizeof(HashTable));", "distractors": [], "indent": 1, "explanation": "Allocate the main HashTable struct." },
        { "correct": "  if (!table) { return NULL; }", "distractors": [], "indent": 1, "explanation": "Handle allocation failure." },
        { "correct": "  table->capacity = INITIAL_CAPACITY;", "distractors": [], "indent": 1, "explanation": "Set the initial capacity." },
        { "correct": "  table->size = 0;", "distractors": [], "indent": 1, "explanation": "Initialize the size to zero." },
        { "correct": "  table->buckets = calloc(table->capacity, sizeof(EntryNode*));", "distractors": [], "indent": 1, "explanation": "Allocate the bucket array and initialize all bucket pointers to NULL using calloc." },
        { "correct": "  if (!table->buckets) { free(table); return NULL; }", "distractors": [], "indent": 1, "explanation": "Handle bucket allocation failure." },
        { "correct": "  return table;", "distractors": [], "indent": 1, "explanation": "Return the newly created table." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `ht_create`." },
        { "correct": "void ht_destroy(HashTable* table) {", "distractors": [], "indent": 0, "explanation": "Begin `ht_destroy`." },
        { "correct": "  if (!table) return;", "distractors": [], "indent": 1, "explanation": "Do nothing if the table is already NULL." },
        { "correct": "  printf(\"Destroying hash table...\\n\");", "distractors": [], "indent": 1, "explanation": "Log the destruction." },
        { "correct": "  for (size_t i = 0; i < table->capacity; i++) {", "distractors": [], "indent": 1, "explanation": "Iterate through each bucket." },
        { "correct": "    EntryNode* entry = table->buckets[i];", "distractors": [], "indent": 2, "explanation": "Get the head of the linked list for the current bucket." },
        { "correct": "    while (entry) {", "distractors": [], "indent": 2, "explanation": "Iterate through the linked list (chain)." },
        { "correct": "      EntryNode* next = entry->next;", "distractors": [], "indent": 3, "explanation": "Save the pointer to the next node." },
        { "correct": "      free(entry->key);", "distractors": [], "indent": 3, "explanation": "Free the string key." },
        { "correct": "      free(entry);", "distractors": [], "indent": 3, "explanation": "Free the node itself." },
        { "correct": "      entry = next;", "distractors": [], "indent": 3, "explanation": "Move to the next node in the chain." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of linked list traversal." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of bucket iteration." },
        { "correct": "  free(table->buckets);", "distractors": [], "indent": 1, "explanation": "Free the bucket array itself." },
        { "correct": "  free(table);", "distractors": [], "indent": 1, "explanation": "Free the main HashTable struct." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `ht_destroy`." },
        { "correct": "// === Stage 3: Core Logic - Insertion with Rehashing ===", "distractors": [], "indent": 0, "explanation": "Implement the insertion logic, including the critical rehashing step." },
        { "correct": "static void ht_resize_and_rehash(HashTable* table) {", "distractors": [], "indent": 0, "explanation": "Begin the internal rehashing function." },
        { "correct": "  size_t old_capacity = table->capacity;", "distractors": [], "indent": 1, "explanation": "Store the old capacity." },
        { "correct": "  EntryNode** old_buckets = table->buckets;", "distractors": [], "indent": 1, "explanation": "Store a pointer to the old bucket array." },
        { "correct": "  size_t new_capacity = old_capacity * 2;", "distractors": [], "indent": 1, "explanation": "Double the capacity of the hash table." },
        { "correct": "  printf(\"--- Rehashing: capacity %zu -> %zu ---\\n\", old_capacity, new_capacity);", "distractors": [], "indent": 1, "explanation": "Log the resize event." },
        { "correct": "  // Create a new, larger bucket array", "distractors": [], "indent": 1, "explanation": "Comment on creating the new storage." },
        { "correct": "  table->buckets = calloc(new_capacity, sizeof(EntryNode*));", "distractors": [], "indent": 1, "explanation": "Allocate the new, larger bucket array." },
        { "correct": "  if (!table->buckets) {", "distractors": [], "indent": 1, "explanation": "Handle allocation failure (critical)." },
        { "correct": "    fprintf(stderr, \"Critical: Failed to allocate memory for rehashing.\\n\");", "distractors": [], "indent": 2, "explanation": "Print an error." },
        { "correct": "    table->buckets = old_buckets; // Restore old state", "distractors": [], "indent": 2, "explanation": "Attempt to restore the table to a usable (though full) state." },
        { "correct": "    return; // Abort rehash", "distractors": [], "indent": 2, "explanation": "Exit the function." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End failure check." },
        { "correct": "  table->capacity = new_capacity;", "distractors": [], "indent": 1, "explanation": "Update the capacity in the table struct." },
        { "correct": "  table->size = 0; // Size will be recounted as we re-insert", "distractors": [], "indent": 1, "explanation": "Reset the size before re-inserting." },
        { "correct": "  // Iterate over the old buckets and re-insert every entry into the new buckets", "distractors": [], "indent": 1, "explanation": "Comment on the re-insertion process." },
        { "correct": "  for (size_t i = 0; i < old_capacity; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through all the old buckets." },
        { "correct": "    EntryNode* entry = old_buckets[i];", "distractors": [], "indent": 2, "explanation": "Get the head of the chain in the old bucket." },
        { "correct": "    while (entry) {", "distractors": [], "indent": 2, "explanation": "Iterate through the chain." },
        { "correct": "      EntryNode* next = entry->next;", "distractors": [], "indent": 3, "explanation": "Save the next pointer." },
        { "correct": "      // Re-insert the entry into the new, larger table", "distractors": [], "indent": 3, "explanation": "Comment on the re-insertion call." },
        { "correct": "      ht_insert(table, entry->key, entry->value);", "distractors": [], "indent": 3, "explanation": "Call the main insert function, which will use the new capacity for hashing." },
        { "correct": "      // Free the old entry's memory", "distractors": [], "indent": 3, "explanation": "Comment on cleanup." },
        { "correct": "      free(entry->key);", "distractors": [], "indent": 3, "explanation": "Free the key from the old entry." },
        { "correct": "      free(entry);", "distractors": [], "indent": 3, "explanation": "Free the old entry node itself." },
        { "correct": "      entry = next;", "distractors": [], "indent": 3, "explanation": "Move to the next entry in the old chain." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End chain traversal." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End old bucket traversal." },
        { "correct": "  free(old_buckets);", "distractors": [], "indent": 1, "explanation": "Free the old bucket array itself." },
        { "correct": "  printf(\"--- Rehash complete ---\\n\");", "distractors": [], "indent": 1, "explanation": "Log completion." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `ht_resize_and_rehash`." },
        { "correct": "void ht_insert(HashTable* table, const char* key, int value) {", "distractors": [], "indent": 0, "explanation": "Begin `ht_insert`." },
        { "correct": "  if (!table || !key) return;", "distractors": [], "indent": 1, "explanation": "Guard against NULL inputs." },
        { "correct": "  // Check load factor and resize if necessary", "distractors": [], "indent": 1, "explanation": "Comment on the load factor check." },
        { "correct": "  if ((float)table->size / table->capacity >= MAX_LOAD_FACTOR) {", "distractors": [], "indent": 1, "explanation": "Calculate the current load factor and compare to the max." },
        { "correct": "    ht_resize_and_rehash(table);", "distractors": [], "indent": 2, "explanation": "Trigger the resize and rehash operation." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End load factor check." },
        { "correct": "  size_t index = hash_function(key, table->capacity);", "distractors": [], "indent": 1, "explanation": "Calculate the bucket index for the key." },
        { "correct": "  EntryNode* entry = table->buckets[index];", "distractors": [], "indent": 1, "explanation": "Get the head of the chain for this bucket." },
        { "correct": "  // Traverse the chain to see if the key already exists", "distractors": [], "indent": 1, "explanation": "Comment on checking for existing keys." },
        { "correct": "  while (entry) {", "distractors": [], "indent": 1, "explanation": "Loop through the chain." },
        { "correct": "    if (strcmp(entry->key, key) == 0) {", "distractors": [], "indent": 2, "explanation": "If the key already exists..." },
        { "correct": "      entry->value = value; // Update the value", "distractors": [], "indent": 3, "explanation": "Update the value for the existing key." },
        { "correct": "      printf(\"Updated key '%s' to value %d.\\n\", key, value);", "distractors": [], "indent": 3, "explanation": "Log the update." },
        { "correct": "      return;", "distractors": [], "indent": 3, "explanation": "Exit the function." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End key comparison." },
        { "correct": "    entry = entry->next;", "distractors": [], "indent": 2, "explanation": "Move to the next node." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End chain traversal." },
        { "correct": "  // If key not found, create a new entry and add it to the front of the chain.", "distractors": [], "indent": 1, "explanation": "Comment on creating a new entry." },
        { "correct": "  EntryNode* new_entry = malloc(sizeof(EntryNode));", "distractors": [], "indent": 1, "explanation": "Allocate memory for the new node." },
        { "correct": "  new_entry->key = strdup(key); // Duplicate the key string", "distractors": [], "indent": 1, "explanation": "Allocate memory for and copy the key string." },
        { "correct": "  new_entry->value = value;", "distractors": [], "indent": 1, "explanation": "Set the value." },
        { "correct": "  new_entry->next = table->buckets[index];", "distractors": [], "indent": 1, "explanation": "The new entry's `next` points to the old head of the chain." },
        { "correct": "  table->buckets[index] = new_entry;", "distractors": [], "indent": 1, "explanation": "The new entry becomes the new head of the chain." },
        { "correct": "  table->size++;", "distractors": [], "indent": 1, "explanation": "Increment the total size of the hash table." },
        { "correct": "  printf(\"Inserted key '%s' with value %d.\\n\", key, value);", "distractors": [], "indent": 1, "explanation": "Log the insertion." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `ht_insert`." },
        { "correct": "// === Stage 4: Retrieval and Deletion ===", "distractors": [], "indent": 0, "explanation": "Implement the get and delete operations." },
        { "correct": "int* ht_get(HashTable* table, const char* key) {", "distractors": [], "indent": 0, "explanation": "Begin `ht_get`." },
        { "correct": "  if (!table || !key) return NULL;", "distractors": [], "indent": 1, "explanation": "Guard against NULL inputs." },
        { "correct": "  size_t index = hash_function(key, table->capacity);", "distractors": [], "indent": 1, "explanation": "Calculate the bucket index for the key." },
        { "correct": "  EntryNode* entry = table->buckets[index];", "distractors": [], "indent": 1, "explanation": "Get the head of the chain." },
        { "correct": "  while (entry) {", "distractors": [], "indent": 1, "explanation": "Traverse the chain." },
        { "correct": "    if (strcmp(entry->key, key) == 0) {", "distractors": [], "indent": 2, "explanation": "If the key is found..." },
        { "correct": "      printf(\"Key '%s' found with value %d.\\n\", key, entry->value);", "distractors": [], "indent": 3, "explanation": "Log the find." },
        { "correct": "      return &entry->value; // Return a pointer to the value", "distractors": [], "indent": 3, "explanation": "Return a pointer to the value to allow modification." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End key comparison." },
        { "correct": "    entry = entry->next;", "distractors": [], "indent": 2, "explanation": "Move to the next node." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End chain traversal." },
        { "correct": "  printf(\"Key '%s' not found.\\n\", key);", "distractors": [], "indent": 1, "explanation": "Log that the key was not found." },
        { "correct": "  return NULL;", "distractors": [], "indent": 1, "explanation": "Return NULL if the key is not in the table." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `ht_get`." },
        { "correct": "void ht_delete(HashTable* table, const char* key) {", "distractors": [], "indent": 0, "explanation": "Begin `ht_delete`." },
        { "correct": "  if (!table || !key) return;", "distractors": [], "indent": 1, "explanation": "Guard against NULL inputs." },
        { "correct": "  size_t index = hash_function(key, table->capacity);", "distractors": [], "indent": 1, "explanation": "Calculate the bucket index." },
        { "correct": "  EntryNode* entry = table->buckets[index];", "distractors": [], "indent": 1, "explanation": "Get the head of the chain." },
        { "correct": "  EntryNode* prev = NULL;", "distractors": [], "indent": 1, "explanation": "Keep track of the previous node to relink the chain." },
        { "correct": "  while (entry) {", "distractors": [], "indent": 1, "explanation": "Traverse the chain." },
        { "correct": "    if (strcmp(entry->key, key) == 0) {", "distractors": [], "indent": 2, "explanation": "If the key is found..." },
        { "correct": "      if (prev == NULL) { // The node to delete is the head of the chain", "distractors": [], "indent": 3, "explanation": "Check if the target node is the first one." },
        { "correct": "        table->buckets[index] = entry->next;", "distractors": [], "indent": 4, "explanation": "Update the bucket to point to the next node." },
        { "correct": "      } else { // The node to delete is in the middle or end of the chain", "distractors": [], "indent": 3, "explanation": "If it's not the head." },
        { "correct": "        prev->next = entry->next;", "distractors": [], "indent": 4, "explanation": "Unlink the node by connecting the previous to the next." },
        { "correct": "      }", "distractors": [], "indent": 3, "explanation": "End of relinking logic." },
        { "correct": "      printf(\"Deleted key '%s'.\\n\", key);", "distractors": [], "indent": 3, "explanation": "Log the deletion." },
        { "correct": "      free(entry->key);", "distractors": [], "indent": 3, "explanation": "Free the key's memory." },
        { "correct": "      free(entry);", "distractors": [], "indent": 3, "explanation": "Free the node's memory." },
        { "correct": "      table->size--;", "distractors": [], "indent": 3, "explanation": "Decrement the table size." },
        { "correct": "      return;", "distractors": [], "indent": 3, "explanation": "Exit the function." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End key comparison." },
        { "correct": "    prev = entry;", "distractors": [], "indent": 2, "explanation": "Advance the previous pointer." },
        { "correct": "    entry = entry->next;", "distractors": [], "indent": 2, "explanation": "Advance the current pointer." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End chain traversal." },
        { "correct": "  printf(\"Key '%s' not found for deletion.\\n\", key);", "distractors": [], "indent": 1, "explanation": "Log if the key to delete was not found." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `ht_delete`." },
        { "correct": "// === Stage 5: Main Program for Demonstration ===", "distractors": [], "indent": 0, "explanation": "A `main` function to test the dynamic hash table." },
        { "correct": "int main() {", "distractors": [], "indent": 0, "explanation": "Start of the main function." },
        { "correct": "  printf(\"--- Dynamic Hash Table Demo ---\\n\");", "distractors": [], "indent": 1, "explanation": "Print a title." },
        { "correct": "  HashTable* my_ht = ht_create();", "distractors": [], "indent": 1, "explanation": "Create the hash table." },
        { "correct": "  // Insert items to trigger a rehash", "distractors": [], "indent": 1, "explanation": "Comment on the insertion phase." },
        { "correct": "  ht_insert(my_ht, \"apple\", 10);", "distractors": [], "indent": 1, "explanation": "Insert item 1." },
        { "correct": "  ht_insert(my_ht, \"banana\", 20);", "distractors": [], "indent": 1, "explanation": "Insert item 2." },
        { "correct": "  ht_insert(my_ht, \"cherry\", 30);", "distractors": [], "indent": 1, "explanation": "Insert item 3." },
        { "correct": "  ht_insert(my_ht, \"date\", 40);", "distractors": [], "indent": 1, "explanation": "Insert item 4." },
        { "correct": "  ht_insert(my_ht, \"elderberry\", 50);", "distractors": [], "indent": 1, "explanation": "Insert item 5." },
        { "correct": "  // (0.75 * 8 = 6). The next insertion should trigger a rehash.", "distractors": [], "indent": 1, "explanation": "Explain when the rehash will happen." },
        { "correct": "  ht_insert(my_ht, \"fig\", 60);", "distractors": [], "indent": 1, "explanation": "Insert item 6. This should trigger rehash." },
        { "correct": "  ht_insert(my_ht, \"grape\", 70);", "distractors": [], "indent": 1, "explanation": "Insert another item into the resized table." },
        { "correct": "  printf(\"Current table size: %zu, capacity: %zu\\n\", my_ht->size, my_ht->capacity);", "distractors": [], "indent": 1, "explanation": "Print the state after rehashing." },
        { "correct": "  // --- Test retrieval ---", "distractors": [], "indent": 1, "explanation": "Comment on the retrieval test." },
        { "correct": "  int* val = ht_get(my_ht, \"apple\");", "distractors": [], "indent": 1, "explanation": "Get an existing key." },
        { "correct": "  if(val) printf(\"Value for 'apple' is %d\\n\", *val);", "distractors": [], "indent": 1, "explanation": "Print the found value." },
        { "correct": "  ht_get(my_ht, \"zucchini\"); // Get a non-existent key", "distractors": [], "indent": 1, "explanation": "Try to get a key that isn't there." },
        { "correct": "  // --- Test update ---", "distractors": [], "indent": 1, "explanation": "Comment on the update test." },
        { "correct": "  ht_insert(my_ht, \"banana\", 25);", "distractors": [], "indent": 1, "explanation": "Update an existing key." },
        { "correct": "  val = ht_get(my_ht, \"banana\");", "distractors": [], "indent": 1, "explanation": "Get the updated key." },
        { "correct": "  if(val) printf(\"New value for 'banana' is %d\\n\", *val);", "distractors": [], "indent": 1, "explanation": "Print the new value." },
        { "correct": "  // --- Test deletion ---", "distractors": [], "indent": 1, "explanation": "Comment on the deletion test." },
        { "correct": "  ht_delete(my_ht, \"cherry\");", "distractors": [], "indent": 1, "explanation": "Delete a key." },
        { "correct": "  ht_get(my_ht, \"cherry\"); // Verify it's gone", "distractors": [], "indent": 1, "explanation": "Try to get the deleted key." },
        { "correct": "  printf(\"Current table size after deletion: %zu\\n\", my_ht->size);", "distractors": [], "indent": 1, "explanation": "Check the size after deletion." },
        { "correct": "  // --- Cleanup ---", "distractors": [], "indent": 1, "explanation": "Comment on cleanup." },
        { "correct": "  ht_destroy(my_ht);", "distractors": [], "indent": 1, "explanation": "Free all allocated memory." },
        { "correct": "  printf(\"--- Demo Finished ---\\n\");", "distractors": [], "indent": 1, "explanation": "Final message." },
        { "correct": "  return 0;", "distractors": [], "indent": 1, "explanation": "Indicate success." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of main." }
    ]
},
// Level 95: Prep for Meta
{
    "goal": "Implement a graph data structure using an adjacency list to model a social network, with features to add users, create friendships, and find mutual friends.",
    "concepts": "Graphs, adjacency lists, nodes, edges, dynamic memory allocation, data structures, searching algorithms",
    "sequence": [
        { "correct": "// === Stage 1: Core Data Structures for the Graph ===", "distractors": [], "indent": 0, "explanation": "Define the structures for graph nodes, the adjacency list, and the main graph container." },
        { "correct": "#include <stdio.h>", "distractors": [], "indent": 0, "explanation": "For standard I/O like printf." },
        { "correct": "#include <stdlib.h>", "distractors": [], "indent": 0, "explanation": "For memory management (malloc, free)." },
        { "correct": "#include <string.h>", "distractors": [], "indent": 0, "explanation": "For string manipulation like strdup." },
        { "correct": "#define MAX_USERS 50", "distractors": [], "indent": 0, "explanation": "Set a maximum number of users our social network can hold." },
        { "correct": "// Represents a node in the adjacency list, i.e., a friend of a user.", "distractors": [], "indent": 0, "explanation": "Comment explaining the purpose of AdjListNode." },
        { "correct": "typedef struct AdjListNode {", "distractors": [], "indent": 0, "explanation": "Start of the adjacency list node struct." },
        { "correct": "  int user_id;", "distractors": [], "indent": 1, "explanation": "The ID of the user this node points to. This ID is the index in the main user array." },
        { "correct": "  struct AdjListNode* next;", "distractors": [], "indent": 1, "explanation": "Pointer to the next friend in the list." },
        { "correct": "} AdjListNode;", "distractors": [], "indent": 0, "explanation": "End of AdjListNode typedef." },
        { "correct": "// Represents a user in the social network.", "distractors": [], "indent": 0, "explanation": "Comment explaining the UserNode struct." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start of the UserNode struct." },
        { "correct": "  char* name;", "distractors": [], "indent": 1, "explanation": "The name of the user." },
        { "correct": "  AdjListNode* friends_head;", "distractors": [], "indent": 1, "explanation": "The head of the linked list of this user's friends." },
        { "correct": "} UserNode;", "distractors": [], "indent": 0, "explanation": "End of UserNode typedef." },
        { "correct": "// Represents the entire social network graph.", "distractors": [], "indent": 0, "explanation": "Comment for the main Graph struct." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start of the Graph struct." },
        { "correct": "  UserNode users[MAX_USERS];", "distractors": [], "indent": 1, "explanation": "An array to store all user data. The index is the user's ID." },
        { "correct": "  int user_count;", "distractors": [], "indent": 1, "explanation": "The current number of users registered in the network." },
        { "correct": "} Graph;", "distractors": [], "indent": 0, "explanation": "End of Graph typedef." },
        { "correct": "// --- Function Prototypes ---", "distractors": [], "indent": 0, "explanation": "Forward declarations for our graph functions." },
        { "correct": "Graph* create_graph();", "distractors": [], "indent": 0, "explanation": "Creates and initializes an empty graph." },
        { "correct": "void destroy_graph(Graph* graph);", "distractors": [], "indent": 0, "explanation": "Frees all memory used by the graph." },
        { "correct": "int add_user(Graph* graph, const char* name);", "distractors": [], "indent": 0, "explanation": "Adds a new user to the network and returns their ID." },
        { "correct": "void add_friendship(Graph* graph, int user_id1, int user_id2);", "distractors": [], "indent": 0, "explanation": "Creates a bidirectional friendship between two users." },
        { "correct": "void find_mutual_friends(Graph* graph, int user_id1, int user_id2);", "distractors": [], "indent": 0, "explanation": "Finds and prints all mutual friends between two users." },
        { "correct": "void print_graph(const Graph* graph);", "distractors": [], "indent": 0, "explanation": "Prints the entire social network structure." },
        { "correct": "// === Stage 2: Graph Initialization and Destruction ===", "distractors": [], "indent": 0, "explanation": "Implement functions to manage the graph's lifecycle." },
        { "correct": "Graph* create_graph() {", "distractors": [], "indent": 0, "explanation": "Begin `create_graph` implementation." },
        { "correct": "  printf(\"Creating a new social network graph...\\n\");", "distractors": [], "indent": 1, "explanation": "Log the creation event." },
        { "correct": "  Graph* graph = (Graph*)malloc(sizeof(Graph));", "distractors": [], "indent": 1, "explanation": "Allocate memory for the main graph structure." },
        { "correct": "  if (!graph) { perror(\"Failed to create graph\"); exit(EXIT_FAILURE); }", "distractors": [], "indent": 1, "explanation": "Handle memory allocation failure." },
        { "correct": "  graph->user_count = 0;", "distractors": [], "indent": 1, "explanation": "Initialize the user count to zero." },
        { "correct": "  for (int i = 0; i < MAX_USERS; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through the user array for initialization." },
        { "correct": "    graph->users[i].name = NULL;", "distractors": [], "indent": 2, "explanation": "Initialize user name to NULL." },
        { "correct": "    graph->users[i].friends_head = NULL;", "distractors": [], "indent": 2, "explanation": "Initialize the friends list head to NULL." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End initialization loop." },
        { "correct": "  return graph;", "distractors": [], "indent": 1, "explanation": "Return the newly created graph." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `create_graph`." },
        { "correct": "void destroy_graph(Graph* graph) {", "distractors": [], "indent": 0, "explanation": "Begin `destroy_graph` implementation." },
        { "correct": "  if (!graph) return;", "distractors": [], "indent": 1, "explanation": "Guard against NULL graph pointer." },
        { "correct": "  printf(\"\\nDestroying the graph and freeing all memory...\\n\");", "distractors": [], "indent": 1, "explanation": "Log the destruction event." },
        { "correct": "  for (int i = 0; i < graph->user_count; i++) {", "distractors": [], "indent": 1, "explanation": "Iterate through each user to free their data." },
        { "correct": "    free(graph->users[i].name);", "distractors": [], "indent": 2, "explanation": "Free the memory allocated for the user's name." },
        { "correct": "    AdjListNode* current_friend = graph->users[i].friends_head;", "distractors": [], "indent": 2, "explanation": "Get the head of the friends list for the current user." },
        { "correct": "    while (current_friend) {", "distractors": [], "indent": 2, "explanation": "Loop through the friends list." },
        { "correct": "      AdjListNode* next_friend = current_friend->next;", "distractors": [], "indent": 3, "explanation": "Store the pointer to the next friend node." },
        { "correct": "      free(current_friend);", "distractors": [], "indent": 3, "explanation": "Free the current friend node." },
        { "correct": "      current_friend = next_friend;", "distractors": [], "indent": 3, "explanation": "Move to the next friend in the list." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of friends list traversal." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of user iteration." },
        { "correct": "  free(graph);", "distractors": [], "indent": 1, "explanation": "Free the main graph structure itself." },
        { "correct": "  printf(\"Graph destroyed.\\n\");", "distractors": [], "indent": 1, "explanation": "Confirm destruction." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `destroy_graph`." },
        { "correct": "// === Stage 3: Core Operations - Adding Users and Friendships ===", "distractors": [], "indent": 0, "explanation": "Implement the functions to populate the social network." },
        { "correct": "int add_user(Graph* graph, const char* name) {", "distractors": [], "indent": 0, "explanation": "Begin `add_user` implementation." },
        { "correct": "  if (graph->user_count >= MAX_USERS) {", "distractors": [], "indent": 1, "explanation": "Check if the user limit has been reached." },
        { "correct": "    fprintf(stderr, \"Error: Cannot add more users. Network is full.\\n\");", "distractors": [], "indent": 2, "explanation": "Print an error message if the network is full." },
        { "correct": "    return -1; // Indicate failure", "distractors": [], "indent": 2, "explanation": "Return -1 to signal an error." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of capacity check." },
        { "correct": "  int new_user_id = graph->user_count;", "distractors": [], "indent": 1, "explanation": "The new user's ID will be the current user count." },
        { "correct": "  graph->users[new_user_id].name = strdup(name);", "distractors": [], "indent": 1, "explanation": "Allocate memory for and copy the user's name." },
        { "correct": "  graph->users[new_user_id].friends_head = NULL;", "distractors": [], "indent": 1, "explanation": "The new user starts with no friends." },
        { "correct": "  graph->user_count++;", "distractors": [], "indent": 1, "explanation": "Increment the total number of users in the graph." },
        { "correct": "  printf(\"Added user '%s' with ID %d.\\n\", name, new_user_id);", "distractors": [], "indent": 1, "explanation": "Log the addition of the new user." },
        { "correct": "  return new_user_id;", "distractors": [], "indent": 1, "explanation": "Return the ID assigned to the new user." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `add_user`." },
        { "correct": "void add_friendship(Graph* graph, int user_id1, int user_id2) {", "distractors": [], "indent": 0, "explanation": "Begin `add_friendship` implementation." },
        { "correct": "  if (user_id1 >= graph->user_count || user_id2 >= graph->user_count || user_id1 < 0 || user_id2 < 0) {", "distractors": [], "indent": 1, "explanation": "Check if the provided user IDs are valid." },
        { "correct": "    fprintf(stderr, \"Error: Invalid user ID for friendship.\\n\");", "distractors": [], "indent": 2, "explanation": "Print an error for invalid IDs." },
        { "correct": "    return;", "distractors": [], "indent": 2, "explanation": "Exit the function." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of ID validation." },
        { "correct": "  printf(\"Creating friendship between '%s' and '%s'.\\n\", graph->users[user_id1].name, graph->users[user_id2].name);", "distractors": [], "indent": 1, "explanation": "Log the friendship creation." },
        { "correct": "  // Add edge from user1 to user2", "distractors": [], "indent": 1, "explanation": "Comment on the first direction of the edge." },
        { "correct": "  AdjListNode* node1 = (AdjListNode*)malloc(sizeof(AdjListNode));", "distractors": [], "indent": 1, "explanation": "Allocate a new node for user1's friend list." },
        { "correct": "  node1->user_id = user_id2;", "distractors": [], "indent": 1, "explanation": "Set the destination ID." },
        { "correct": "  node1->next = graph->users[user_id1].friends_head;", "distractors": [], "indent": 1, "explanation": "Link the new node to the front of the list." },
        { "correct": "  graph->users[user_id1].friends_head = node1;", "distractors": [], "indent": 1, "explanation": "Update the head of user1's friend list." },
        { "correct": "  // Add edge from user2 to user1 (since friendship is mutual)", "distractors": [], "indent": 1, "explanation": "Comment on the second, bidirectional edge." },
        { "correct": "  AdjListNode* node2 = (AdjListNode*)malloc(sizeof(AdjListNode));", "distractors": [], "indent": 1, "explanation": "Allocate a new node for user2's friend list." },
        { "correct": "  node2->user_id = user_id1;", "distractors": [], "indent": 1, "explanation": "Set the destination ID." },
        { "correct": "  node2->next = graph->users[user_id2].friends_head;", "distractors": [], "indent": 1, "explanation": "Link the new node to the front of the list." },
        { "correct": "  graph->users[user_id2].friends_head = node2;", "distractors": [], "indent": 1, "explanation": "Update the head of user2's friend list." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `add_friendship`." },
        { "correct": "// === Stage 4: Social Network Algorithm - Finding Mutuals ===", "distractors": [], "indent": 0, "explanation": "Implement the logic to find common connections between two users." },
        { "correct": "void find_mutual_friends(Graph* graph, int user_id1, int user_id2) {", "distractors": [], "indent": 0, "explanation": "Begin `find_mutual_friends` implementation." },
        { "correct": "  if (user_id1 >= graph->user_count || user_id2 >= graph->user_count || user_id1 < 0 || user_id2 < 0) {", "distractors": [], "indent": 1, "explanation": "Perform validity check on user IDs." },
        { "correct": "    fprintf(stderr, \"Error: Invalid user ID for finding mutuals.\\n\");", "distractors": [], "indent": 2, "explanation": "Report an error if IDs are out of bounds." },
        { "correct": "    return;", "distractors": [], "indent": 2, "explanation": "Exit the function." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of validity check." },
        { "correct": "  printf(\"\\nFinding mutual friends between '%s' and '%s':\\n\", graph->users[user_id1].name, graph->users[user_id2].name);", "distractors": [], "indent": 1, "explanation": "Print a header for the output." },
        { "correct": "  // To do this efficiently, we can load one user's friends into a temporary lookup array.", "distractors": [], "indent": 1, "explanation": "Comment on the chosen algorithm." },
        { "correct": "  int friends1_lookup[MAX_USERS] = {0}; // Initialize a boolean-like lookup table.", "distractors": [], "indent": 1, "explanation": "Create a lookup table, initialized to all zeros (false)." },
        { "correct": "  AdjListNode* friend1_iter = graph->users[user_id1].friends_head;", "distractors": [], "indent": 1, "explanation": "Get the head of the first user's friend list." },
        { "correct": "  while (friend1_iter) {", "distractors": [], "indent": 1, "explanation": "Iterate through the friends of the first user." },
        { "correct": "    friends1_lookup[friend1_iter->user_id] = 1; // Mark this ID as a friend of user 1.", "distractors": [], "indent": 2, "explanation": "Set the value at the friend's ID index to 1 (true)." },
        { "correct": "    friend1_iter = friend1_iter->next;", "distractors": [], "indent": 2, "explanation": "Move to the next friend." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of populating the lookup table." },
        { "correct": "  // Now, iterate through the second user's friends and check against the lookup table.", "distractors": [], "indent": 1, "explanation": "Comment on the second phase of the algorithm." },
        { "correct": "  int mutual_count = 0;", "distractors": [], "indent": 1, "explanation": "Initialize a counter for mutual friends." },
        { "correct": "  AdjListNode* friend2_iter = graph->users[user_id2].friends_head;", "distractors": [], "indent": 1, "explanation": "Get the head of the second user's friend list." },
        { "correct": "  while (friend2_iter) {", "distractors": [], "indent": 1, "explanation": "Iterate through the friends of the second user." },
        { "correct": "    if (friends1_lookup[friend2_iter->user_id] == 1) {", "distractors": [], "indent": 2, "explanation": "Check if this friend is also in user1's friend lookup table." },
        { "correct": "      printf(\"  - %s\\n\", graph->users[friend2_iter->user_id].name);", "distractors": [], "indent": 3, "explanation": "If it is, print the name of the mutual friend." },
        { "correct": "      mutual_count++;", "distractors": [], "indent": 3, "explanation": "Increment the mutual friend counter." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of lookup check." },
        { "correct": "    friend2_iter = friend2_iter->next;", "distractors": [], "indent": 2, "explanation": "Move to the next friend of user 2." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of the second iteration." },
        { "correct": "  if (mutual_count == 0) {", "distractors": [], "indent": 1, "explanation": "Check if no mutual friends were found." },
        { "correct": "    printf(\"  No mutual friends found.\\n\");", "distractors": [], "indent": 2, "explanation": "Print a message indicating no mutuals." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of zero-count check." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `find_mutual_friends`." },
        { "correct": "// === Stage 5: Utility and Display Functions ===", "distractors": [], "indent": 0, "explanation": "Implement a helper function to visualize the graph's structure." },
        { "correct": "void print_graph(const Graph* graph) {", "distractors": [], "indent": 0, "explanation": "Begin `print_graph` implementation." },
        { "correct": "  printf(\"\\n--- Social Network Overview ---\\n\");", "distractors": [], "indent": 1, "explanation": "Print a title for the output." },
        { "correct": "  for (int i = 0; i < graph->user_count; i++) {", "distractors": [], "indent": 1, "explanation": "Iterate through each user in the network." },
        { "correct": "    printf(\"User %d: %s -> Friends: \", i, graph->users[i].name);", "distractors": [], "indent": 2, "explanation": "Print the current user's name and ID." },
        { "correct": "    AdjListNode* friend_iter = graph->users[i].friends_head;", "distractors": [], "indent": 2, "explanation": "Get the head of the current user's friend list." },
        { "correct": "    if (!friend_iter) {", "distractors": [], "indent": 2, "explanation": "Check if the user has any friends." },
        { "correct": "      printf(\"None\");", "distractors": [], "indent": 3, "explanation": "Print 'None' if the friend list is empty." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of no-friend check." },
        { "correct": "    while (friend_iter) {", "distractors": [], "indent": 2, "explanation": "Loop through the friend list." },
        { "correct": "      printf(\"%s\", graph->users[friend_iter->user_id].name);", "distractors": [], "indent": 3, "explanation": "Print the name of the friend." },
        { "correct": "      if (friend_iter->next) { printf(\", \"); }", "distractors": [], "indent": 3, "explanation": "Print a comma if it's not the last friend." },
        { "correct": "      friend_iter = friend_iter->next;", "distractors": [], "indent": 3, "explanation": "Move to the next friend." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of friend list loop." },
        { "correct": "    printf(\"\\n\");", "distractors": [], "indent": 2, "explanation": "Print a newline for the next user." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of user loop." },
        { "correct": "  printf(\"--- End of Overview ---\\n\");", "distractors": [], "indent": 1, "explanation": "Print a footer." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `print_graph`." },
        { "correct": "// === Stage 6: Main Program for Demonstration ===", "distractors": [], "indent": 0, "explanation": "The main function to create and test our social network graph." },
        { "correct": "int main() {", "distractors": [], "indent": 0, "explanation": "Start of the main function." },
        { "correct": "  printf(\"--- Social Network Graph Demo ---\\n\");", "distractors": [], "indent": 1, "explanation": "Print a demo title." },
        { "correct": "  Graph* social_network = create_graph();", "distractors": [], "indent": 1, "explanation": "Create the graph instance." },
        { "correct": "  // Add users to the network", "distractors": [], "indent": 1, "explanation": "Comment on the user creation phase." },
        { "correct": "  int alice_id = add_user(social_network, \"Alice\");", "distractors": [], "indent": 1, "explanation": "Add user Alice." },
        { "correct": "  int bob_id = add_user(social_network, \"Bob\");", "distractors": [], "indent": 1, "explanation": "Add user Bob." },
        { "correct": "  int charlie_id = add_user(social_network, \"Charlie\");", "distractors": [], "indent": 1, "explanation": "Add user Charlie." },
        { "correct": "  int diana_id = add_user(social_network, \"Diana\");", "distractors": [], "indent": 1, "explanation": "Add user Diana." },
        { "correct": "  int eve_id = add_user(social_network, \"Eve\");", "distractors": [], "indent": 1, "explanation": "Add user Eve." },
        { "correct": "  // Create friendships", "distractors": [], "indent": 1, "explanation": "Comment on the friendship creation phase." },
        { "correct": "  add_friendship(social_network, alice_id, bob_id);", "distractors": [], "indent": 1, "explanation": "Alice and Bob are friends." },
        { "correct": "  add_friendship(social_network, alice_id, charlie_id);", "distractors": [], "indent": 1, "explanation": "Alice and Charlie are friends." },
        { "correct": "  add_friendship(social_network, bob_id, charlie_id);", "distractors": [], "indent": 1, "explanation": "Bob and Charlie are friends." },
        { "correct": "  add_friendship(social_network, bob_id, diana_id);", "distractors": [], "indent": 1, "explanation": "Bob and Diana are friends." },
        { "correct": "  add_friendship(social_network, charlie_id, diana_id);", "distractors": [], "indent": 1, "explanation": "Charlie and Diana are friends." },
        { "correct": "  add_friendship(social_network, diana_id, eve_id);", "distractors": [], "indent": 1, "explanation": "Diana and Eve are friends." },
        { "correct": "  // Display the final state of the network", "distractors": [], "indent": 1, "explanation": "Comment on printing the graph." },
        { "correct": "  print_graph(social_network);", "distractors": [], "indent": 1, "explanation": "Call the print function." },
        { "correct": "  // Test the mutual friends feature", "distractors": [], "indent": 1, "explanation": "Comment on testing the core algorithm." },
        { "correct": "  find_mutual_friends(social_network, alice_id, diana_id);", "distractors": [], "indent": 1, "explanation": "Find mutuals between Alice and Diana (should be Bob and Charlie)." },
        { "correct": "  find_mutual_friends(social_network, alice_id, eve_id);", "distractors": [], "indent": 1, "explanation": "Find mutuals between Alice and Eve (should be none)." },
        { "correct": "  // Clean up all allocated memory", "distractors": [], "indent": 1, "explanation": "Comment on the cleanup phase." },
        { "correct": "  destroy_graph(social_network);", "distractors": [], "indent": 1, "explanation": "Call the destructor function." },
        { "correct": "  printf(\"\\n--- Demo Finished ---\\n\");", "distractors": [], "indent": 1, "explanation": "Final message." },
        { "correct": "  return 0;", "distractors": [], "indent": 1, "explanation": "Indicate successful execution." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of main." }
    ]
},
// Level 96: Prep for Netflix
{
    "goal": "Implement a parser for a custom binary data protocol to deserialize and validate packets from a raw byte buffer, simulating the processing of streaming data.",
    "concepts": "Bit manipulation, data serialization, structs, pointers, buffer management, checksums, network programming concepts",
    "sequence": [
        { "correct": "// === Stage 1: Protocol Definition and Data Structures ===", "distractors": [], "indent": 0, "explanation": "Define the structure of our binary packet and any necessary constants." },
        { "correct": "#include <stdio.h>", "distractors": [], "indent": 0, "explanation": "For standard I/O (printf)." },
        { "correct": "#include <stdlib.h>", "distractors": [], "indent": 0, "explanation": "For memory allocation." },
        { "correct": "#include <stdint.h>", "distractors": [], "indent": 0, "explanation": "For fixed-width integers like uint32_t, uint16_t, etc." },
        { "correct": "#include <string.h>", "distractors": [], "indent": 0, "explanation": "For memcpy and other memory operations." },
        { "correct": "// This pragma ensures the compiler doesn't add padding bytes to our struct.", "distractors": [], "indent": 0, "explanation": "Crucial for mapping the struct directly onto a byte buffer." },
        { "correct": "#pragma pack(1)", "distractors": [], "indent": 0, "explanation": "Set structure packing to 1 byte." },
        { "correct": "#define SYNC_WORD 0xDEADBEEF", "distractors": [], "indent": 0, "explanation": "A magic number to identify the start of a valid packet." },
        { "correct": "// Define the types of packets our protocol supports.", "distractors": [], "indent": 0, "explanation": "Comment on the PacketType enum." },
        { "correct": "typedef enum { VIDEO_DATA = 1, AUDIO_DATA = 2, KEEPALIVE = 3, METADATA = 4 } PacketType;", "distractors": [], "indent": 0, "explanation": "Enum for different packet content types." },
        { "correct": "// The header structure for every packet in our stream.", "distractors": [], "indent": 0, "explanation": "Comment explaining the PacketHeader struct." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start of PacketHeader struct definition." },
        { "correct": "  uint32_t sync_word;", "distractors": [], "indent": 1, "explanation": "Should always be 0xDEADBEEF." },
        { "correct": "  uint16_t payload_len;", "distractors": [], "indent": 1, "explanation": "The length of the data payload that follows this header." },
        { "correct": "  uint8_t packet_type;", "distractors": [], "indent": 1, "explanation": "The type of the packet (VIDEO_DATA, AUDIO_DATA, etc.)." },
        { "correct": "  uint8_t checksum;", "distractors": [], "indent": 1, "explanation": "A simple checksum to verify payload integrity." },
        { "correct": "} PacketHeader;", "distractors": [], "indent": 0, "explanation": "End of PacketHeader typedef." },
        { "correct": "// --- Function Prototypes ---", "distractors": [], "indent": 0, "explanation": "Declarations of our protocol handling functions." },
        { "correct": "uint8_t calculate_checksum(const uint8_t* payload, uint16_t len);", "distractors": [], "indent": 0, "explanation": "Calculates a simple XOR checksum for a data payload." },
        { "correct": "void* create_packet(PacketType type, const uint8_t* payload, uint16_t len, uint32_t* out_total_size);", "distractors": [], "indent": 0, "explanation": "Serializes a packet (header + payload) into a single byte buffer." },
        { "correct": "void process_stream(const uint8_t* stream_buffer, uint32_t stream_size);", "distractors": [], "indent": 0, "explanation": "The main function to parse a buffer containing multiple packets." },
        { "correct": "void handle_video_packet(const uint8_t* payload, uint16_t len);", "distractors": [], "indent": 0, "explanation": "Handler function for video data." },
        { "correct": "void handle_audio_packet(const uint8_t* payload, uint16_t len);", "distractors": [], "indent": 0, "explanation": "Handler function for audio data." },
        { "correct": "void handle_keepalive_packet();", "distractors": [], "indent": 0, "explanation": "Handler for keepalive messages." },
        { "correct": "// === Stage 2: Checksum and Packet Serialization ===", "distractors": [], "indent": 0, "explanation": "Implement functions to build our packets." },
        { "correct": "uint8_t calculate_checksum(const uint8_t* payload, uint16_t len) {", "distractors": [], "indent": 0, "explanation": "Begin `calculate_checksum` implementation." },
        { "correct": "  uint8_t chk = 0;", "distractors": [], "indent": 1, "explanation": "Initialize the checksum accumulator to 0." },
        { "correct": "  for (uint16_t i = 0; i < len; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through each byte of the payload." },
        { "correct": "    chk ^= payload[i];", "distractors": [], "indent": 2, "explanation": "XOR the current byte with the accumulator." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of payload loop." },
        { "correct": "  return chk;", "distractors": [], "indent": 1, "explanation": "Return the final checksum value." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `calculate_checksum`." },
        { "correct": "void* create_packet(PacketType type, const uint8_t* payload, uint16_t len, uint32_t* out_total_size) {", "distractors": [], "indent": 0, "explanation": "Begin `create_packet` implementation." },
        { "correct": "  *out_total_size = sizeof(PacketHeader) + len;", "distractors": [], "indent": 1, "explanation": "Calculate the total size of the packet." },
        { "correct": "  uint8_t* packet_buffer = (uint8_t*)malloc(*out_total_size);", "distractors": [], "indent": 1, "explanation": "Allocate a buffer of the required size." },
        { "correct": "  if (!packet_buffer) { return NULL; }", "distractors": [], "indent": 1, "explanation": "Handle memory allocation failure." },
        { "correct": "  PacketHeader* header = (PacketHeader*)packet_buffer;", "distractors": [], "indent": 1, "explanation": "Map the header struct onto the beginning of the buffer." },
        { "correct": "  printf(\"Creating packet: type=%d, payload_len=%u...\\n\", type, len);", "distractors": [], "indent": 1, "explanation": "Log the packet creation." },
        { "correct": "  // Populate the header fields.", "distractors": [], "indent": 1, "explanation": "Comment on populating the header." },
        { "correct": "  header->sync_word = SYNC_WORD;", "distractors": [], "indent": 1, "explanation": "Set the sync word." },
        { "correct": "  header->packet_type = type;", "distractors": [], "indent": 1, "explanation": "Set the packet type from the enum." },
        { "correct": "  header->payload_len = len;", "distractors": [], "indent": 1, "explanation": "Set the payload length." },
        { "correct": "  // Copy the payload data into the buffer right after the header.", "distractors": [], "indent": 1, "explanation": "Comment on copying the payload." },
        { "correct": "  if (payload && len > 0) {", "distractors": [], "indent": 1, "explanation": "Check if there is a payload to copy." },
        { "correct": "    memcpy(packet_buffer + sizeof(PacketHeader), payload, len);", "distractors": [], "indent": 2, "explanation": "Copy the payload data." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End payload copy check." },
        { "correct": "  // Calculate and set the checksum based on the payload.", "distractors": [], "indent": 1, "explanation": "Comment on the checksum calculation." },
        { "correct": "  header->checksum = calculate_checksum(payload, len);", "distractors": [], "indent": 1, "explanation": "Calculate and store the checksum in the header." },
        { "correct": "  return packet_buffer;", "distractors": [], "indent": 1, "explanation": "Return the pointer to the complete, serialized packet buffer." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `create_packet`." },
        { "correct": "// === Stage 3: Stream Processing and Packet Deserialization ===", "distractors": [], "indent": 0, "explanation": "Implement the core logic to read and validate packets from a buffer." },
        { "correct": "void process_stream(const uint8_t* stream_buffer, uint32_t stream_size) {", "distractors": [], "indent": 0, "explanation": "Begin `process_stream` implementation." },
        { "correct": "  printf(\"\\n--- Processing Stream (Total Size: %u bytes) ---\\n\", stream_size);", "distractors": [], "indent": 1, "explanation": "Print a header for the processing log." },
        { "correct": "  const uint8_t* current_pos = stream_buffer;", "distractors": [], "indent": 1, "explanation": "Initialize a pointer to the current position in the stream." },
        { "correct": "  uint32_t bytes_processed = 0;", "distractors": [], "indent": 1, "explanation": "Initialize a counter for bytes processed." },
        { "correct": "  while (bytes_processed < stream_size) {", "distractors": [], "indent": 1, "explanation": "Loop as long as there are bytes left to process." },
        { "correct": "    printf(\"\\nProcessing at offset %u...\\n\", bytes_processed);", "distractors": [], "indent": 2, "explanation": "Log the current position in the stream." },
        { "correct": "    if (stream_size - bytes_processed < sizeof(PacketHeader)) {", "distractors": [], "indent": 2, "explanation": "Check if there's enough data left for at least a header." },
        { "correct": "      printf(\"  -> Incomplete data, not enough for a header. Stopping.\\n\");", "distractors": [], "indent": 3, "explanation": "Log the reason for stopping." },
        { "correct": "      break;", "distractors": [], "indent": 3, "explanation": "Exit the loop if data is truncated." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of size check." },
        { "correct": "    // Map the header struct onto the current position in the buffer.", "distractors": [], "indent": 2, "explanation": "Comment on deserialization." },
        { "correct": "    const PacketHeader* header = (const PacketHeader*)current_pos;", "distractors": [], "indent": 2, "explanation": "Create a header pointer to the current buffer position." },
        { "correct": "    // --- Validation Step 1: Check Sync Word ---", "distractors": [], "indent": 2, "explanation": "Comment on the first validation step." },
        { "correct": "    if (header->sync_word != SYNC_WORD) {", "distractors": [], "indent": 2, "explanation": "Check if the sync word matches our protocol's magic number." },
        { "correct": "      printf(\"  -> ERROR: Invalid sync word (Expected 0x%X, Got 0x%X). Skipping 1 byte.\\n\", SYNC_WORD, header->sync_word);", "distractors": [], "indent": 3, "explanation": "Log a sync error." },
        { "correct": "      current_pos++;", "distractors": [], "indent": 3, "explanation": "Advance the buffer by one byte to search for the next sync word." },
        { "correct": "      bytes_processed++;", "distractors": [], "indent": 3, "explanation": "Increment the processed counter." },
        { "correct": "      continue; // Continue to the next iteration of the loop.", "distractors": [], "indent": 3, "explanation": "Skip the rest of the processing for this position." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of sync word check." },
        { "correct": "    printf(\"  -> Found valid sync word.\\n\");", "distractors": [], "indent": 2, "explanation": "Log successful sync." },
        { "correct": "    // --- Validation Step 2: Check if payload fits in the stream ---", "distractors": [], "indent": 2, "explanation": "Comment on checking payload boundary." },
        { "correct": "    uint32_t total_packet_size = sizeof(PacketHeader) + header->payload_len;", "distractors": [], "indent": 2, "explanation": "Calculate the expected full packet size." },
        { "correct": "    if (bytes_processed + total_packet_size > stream_size) {", "distractors": [], "indent": 2, "explanation": "Check if the declared payload length would read past the end of the buffer." },
        { "correct": "      printf(\"  -> ERROR: Declared payload length (%u) exceeds buffer size. Stopping.\\n\", header->payload_len);", "distractors": [], "indent": 3, "explanation": "Log a truncated packet error." },
        { "correct": "      break;", "distractors": [], "indent": 3, "explanation": "Exit the loop." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of payload boundary check." },
        { "correct": "    const uint8_t* payload = current_pos + sizeof(PacketHeader);", "distractors": [], "indent": 2, "explanation": "Get a pointer to the start of the payload data." },
        { "correct": "    // --- Validation Step 3: Checksum Verification ---", "distractors": [], "indent": 2, "explanation": "Comment on the checksum validation." },
        { "correct": "    uint8_t calculated_checksum = calculate_checksum(payload, header->payload_len);", "distractors": [], "indent": 2, "explanation": "Calculate the checksum of the received payload." },
        { "correct": "    if (calculated_checksum != header->checksum) {", "distractors": [], "indent": 2, "explanation": "Compare calculated checksum with the one in the header." },
        { "correct": "      printf(\"  -> ERROR: Checksum mismatch (Expected %u, Calculated %u). Discarding packet.\\n\", header->checksum, calculated_checksum);", "distractors": [], "indent": 3, "explanation": "Log a checksum error." },
        { "correct": "    } else {", "distractors": [], "indent": 2, "explanation": "If the checksum is valid..." },
        { "correct": "      printf(\"  -> Checksum OK. Packet Type: %d.\\n\", header->packet_type);", "distractors": [], "indent": 3, "explanation": "Log successful validation." },
        { "correct": "      // --- Packet Handling ---", "distractors": [], "indent": 3, "explanation": "Comment on dispatching to the correct handler." },
        { "correct": "      switch ((PacketType)header->packet_type) {", "distractors": [], "indent": 3, "explanation": "Use a switch statement to call the appropriate handler." },
        { "correct": "        case VIDEO_DATA: handle_video_packet(payload, header->payload_len); break;", "distractors": [], "indent": 4, "explanation": "Call the video handler." },
        { "correct": "        case AUDIO_DATA: handle_audio_packet(payload, header->payload_len); break;", "distractors": [], "indent": 4, "explanation": "Call the audio handler." },
        { "correct": "        case KEEPALIVE: handle_keepalive_packet(); break;", "distractors": [], "indent": 4, "explanation": "Call the keepalive handler." },
        { "correct": "        default: printf(\"  -> WARNING: Unknown packet type %d. Discarding.\\n\", header->packet_type); break;", "distractors": [], "indent": 4, "explanation": "Handle unknown packet types." },
        { "correct": "      }", "distractors": [], "indent": 3, "explanation": "End of switch statement." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of checksum validation block." },
        { "correct": "    // Move to the next packet in the stream", "distractors": [], "indent": 2, "explanation": "Comment on advancing the buffer pointer." },
        { "correct": "    current_pos += total_packet_size;", "distractors": [], "indent": 2, "explanation": "Advance the position by the full size of the packet we just processed." },
        { "correct": "    bytes_processed += total_packet_size;", "distractors": [], "indent": 2, "explanation": "Update the total bytes processed counter." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of main processing loop." },
        { "correct": "  printf(\"\\n--- End of Stream Processing ---\\n\");", "distractors": [], "indent": 1, "explanation": "Print a footer." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `process_stream`." },
        { "correct": "// === Stage 4: Packet Handler Implementations ===", "distractors": [], "indent": 0, "explanation": "Implement the functions that do something with the validated packet data." },
        { "correct": "void handle_video_packet(const uint8_t* payload, uint16_t len) {", "distractors": [], "indent": 0, "explanation": "Begin video handler." },
        { "correct": "  printf(\"    [Handler] Processing %u bytes of video data. First byte: 0x%02X\\n\", len, payload[0]);", "distractors": [], "indent": 1, "explanation": "Log video packet details." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End video handler." },
        { "correct": "void handle_audio_packet(const uint8_t* payload, uint16_t len) {", "distractors": [], "indent": 0, "explanation": "Begin audio handler." },
        { "correct": "  printf(\"    [Handler] Processing %u bytes of audio data. First byte: 0x%02X\\n\", len, payload[0]);", "distractors": [], "indent": 1, "explanation": "Log audio packet details." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End audio handler." },
        { "correct": "void handle_keepalive_packet() {", "distractors": [], "indent": 0, "explanation": "Begin keepalive handler." },
        { "correct": "  printf(\"    [Handler] Received Keepalive. Connection is active.\\n\");", "distractors": [], "indent": 1, "explanation": "Log keepalive packet." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End keepalive handler." },
        { "correct": "// === Stage 5: Main Program for Demonstration ===", "distractors": [], "indent": 0, "explanation": "Create a simulated stream buffer and test the parser." },
        { "correct": "int main() {", "distractors": [], "indent": 0, "explanation": "Start of main." },
        { "correct": "  printf(\"--- Custom Protocol Parser Demo ---\\n\");", "distractors": [], "indent": 1, "explanation": "Demo title." },
        { "correct": "  // Create some sample payloads", "distractors": [], "indent": 1, "explanation": "Comment on payload creation." },
        { "correct": "  uint8_t video_payload[] = { 0xDE, 0xC0, 0xAD, 0xED };", "distractors": [], "indent": 1, "explanation": "A small payload for a video packet." },
        { "correct": "  uint8_t audio_payload[] = { 0xC0, 0xCA, 0xC0, 0x1A };", "distractors": [], "indent": 1, "explanation": "A small payload for an audio packet." },
        { "correct": "  // Create serialized packets from the payloads", "distractors": [], "indent": 1, "explanation": "Comment on packet serialization." },
        { "correct": "  uint32_t packet1_size, packet2_size, packet3_size, packet4_size;", "distractors": [], "indent": 1, "explanation": "Variables to hold the size of each created packet." },
        { "correct": "  void* packet1 = create_packet(VIDEO_DATA, video_payload, sizeof(video_payload), &packet1_size);", "distractors": [], "indent": 1, "explanation": "Create the first (valid) packet." },
        { "correct": "  void* packet2 = create_packet(AUDIO_DATA, audio_payload, sizeof(audio_payload), &packet2_size);", "distractors": [], "indent": 1, "explanation": "Create the second (valid) packet." },
        { "correct": "  void* packet3 = create_packet(KEEPALIVE, NULL, 0, &packet3_size);", "distractors": [], "indent": 1, "explanation": "Create a keepalive packet (no payload)." },
        { "correct": "  void* packet4_corrupt = create_packet(VIDEO_DATA, video_payload, sizeof(video_payload), &packet4_size);", "distractors": [], "indent": 1, "explanation": "Create a packet that we will manually corrupt." },
        { "correct": "  ((PacketHeader*)packet4_corrupt)->checksum++; // Corrupt the checksum", "distractors": [], "indent": 1, "explanation": "Manually alter the checksum to test validation." },
        { "correct": "  // Assemble the final stream buffer", "distractors": [], "indent": 1, "explanation": "Comment on assembling the stream." },
        { "correct": "  uint32_t stream_size = packet1_size + packet2_size + packet3_size + packet4_size + 3; // Add junk bytes", "distractors": [], "indent": 1, "explanation": "Calculate the total size of the stream buffer, including junk data." },
        { "correct": "  uint8_t* stream_buffer = malloc(stream_size);", "distractors": [], "indent": 1, "explanation": "Allocate memory for the stream buffer." },
        { "correct": "  uint32_t offset = 0;", "distractors": [], "indent": 1, "explanation": "Initialize an offset for copying data." },
        { "correct": "  stream_buffer[offset++] = 0xAA; // Junk byte at the start", "distractors": [], "indent": 1, "explanation": "Add junk byte to test sync word search. NOTE: This will fail the first read, which is intended." },
        { "correct": "  memcpy(stream_buffer + offset, packet1, packet1_size); offset += packet1_size;", "distractors": [], "indent": 1, "explanation": "Copy the first valid packet into the stream." },
        { "correct": "  stream_buffer[offset++] = 0xBB; // More junk", "distractors": [], "indent": 1, "explanation": "This will fail because it's not a valid sync word." },
        { "correct": "  stream_buffer[offset++] = 0xCC; // More junk", "distractors": [], "indent": 1, "explanation": "This will also fail." },
        { "correct": "  memcpy(stream_buffer + offset, packet2, packet2_size); offset += packet2_size;", "distractors": [], "indent": 1, "explanation": "Copy the second packet. NOTE: Sync will fail on BB and CC before finding this." },
        { "correct": "  memcpy(stream_buffer + offset, packet4_corrupt, packet4_size); offset += packet4_size;", "distractors": [], "indent": 1, "explanation": "Copy the corrupted packet." },
        { "correct": "  memcpy(stream_buffer + offset, packet3, packet3_size); offset += packet3_size;", "distractors": [], "indent": 1, "explanation": "Copy the keepalive packet." },
        { "correct": "  // Process the assembled stream", "distractors": [], "indent": 1, "explanation": "Comment on running the parser." },
        { "correct": "  process_stream(stream_buffer, stream_size);", "distractors": [], "indent": 1, "explanation": "Call the main processing function." },
        { "correct": "  // Cleanup", "distractors": [], "indent": 1, "explanation": "Comment on freeing memory." },
        { "correct": "  free(packet1); free(packet2); free(packet3); free(packet4_corrupt);", "distractors": [], "indent": 1, "explanation": "Free the individual packet buffers." },
        { "correct": "  free(stream_buffer);", "distractors": [], "indent": 1, "explanation": "Free the main stream buffer." },
        { "correct": "  printf(\"\\n--- Demo Finished ---\\n\");", "distractors": [], "indent": 1, "explanation": "Final message." },
        { "correct": "  return 0;", "distractors": [], "indent": 1, "explanation": "Indicate success." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of main." }
    ]
},
// Level 97: Prep for Nvidia
{
    "goal": "Simulate SIMD (Single Instruction, Multiple Data) processing by implementing vector arithmetic functions that operate on small blocks of data at a time, highlighting concepts relevant to GPU and high-performance computing.",
    "concepts": "Vectorization, SIMD, loop unrolling, pointer arithmetic, performance concepts, floating-point operations",
    "sequence": [
        { "correct": "// === Stage 1: Data Structures and Utility Declarations ===", "distractors": [], "indent": 0, "explanation": "Define the basic data structure for a vector and declare utility functions." },
        { "correct": "#include <stdio.h>", "distractors": [], "indent": 0, "explanation": "For standard I/O." },
        { "correct": "#include <stdlib.h>", "distractors": [], "indent": 0, "explanation": "For memory allocation." },
        { "correct": "#include <time.h>", "distractors": [], "indent": 0, "explanation": "To seed the random number generator." },
        { "correct": "#define VECTOR_SIZE 1027", "distractors": [], "indent": 0, "explanation": "A large, non-divisible-by-4 number to test handling of remainders." },
        { "correct": "#define SIMD_WIDTH 4", "distractors": [], "indent": 0, "explanation": "The 'width' of our simulated SIMD operation (i.e., process 4 floats at a time)." },
        { "correct": "// A simple struct to represent a vector of floats.", "distractors": [], "indent": 0, "explanation": "Comment for the FloatVector struct." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start of FloatVector struct definition." },
        { "correct": "  float* data;", "distractors": [], "indent": 1, "explanation": "A pointer to the dynamically allocated array of floats." },
        { "correct": "  size_t size;", "distractors": [], "indent": 1, "explanation": "The number of elements in the vector." },
        { "correct": "} FloatVector;", "distractors": [], "indent": 0, "explanation": "End of FloatVector typedef." },
        { "correct": "// --- Function Prototypes ---", "distractors": [], "indent": 0, "explanation": "Declarations for vector utilities and arithmetic functions." },
        { "correct": "FloatVector* vector_create(size_t size);", "distractors": [], "indent": 0, "explanation": "Allocates and initializes a new vector." },
        { "correct": "void vector_destroy(FloatVector* vec);", "distractors": [], "indent": 0, "explanation": "Frees the memory used by a vector." },
        { "correct": "void vector_fill_random(FloatVector* vec);", "distractors": [], "indent": 0, "explanation": "Fills a vector with random float values." },
        { "correct": "void vector_print(const FloatVector* vec, const char* name);", "distractors": [], "indent": 0, "explanation": "Prints the contents of a vector." },
        { "correct": "void vector_add_naive(const FloatVector* a, const FloatVector* b, FloatVector* result);", "distractors": [], "indent": 0, "explanation": "Adds two vectors element by element (scalar approach)." },
        { "correct": "void vector_add_simd(const FloatVector* a, const FloatVector* b, FloatVector* result);", "distractors": [], "indent": 0, "explanation": "Adds two vectors using a simulated SIMD approach." },
        { "correct": "void vector_fma_simd(const FloatVector* a, const FloatVector* b, const FloatVector* c, FloatVector* result);", "distractors": [], "indent": 0, "explanation": "Performs a fused multiply-add (a*b+c) using the SIMD approach." },
        { "correct": "// === Stage 2: Vector Utility Implementations ===", "distractors": [], "indent": 0, "explanation": "Implement the helper functions for creating, destroying, and populating vectors." },
        { "correct": "FloatVector* vector_create(size_t size) {", "distractors": [], "indent": 0, "explanation": "Begin `vector_create`." },
        { "correct": "  FloatVector* vec = malloc(sizeof(FloatVector));", "distractors": [], "indent": 1, "explanation": "Allocate the main struct." },
        { "correct": "  if (!vec) return NULL;", "distractors": [], "indent": 1, "explanation": "Handle allocation failure for the struct." },
        { "correct": "  vec->size = size;", "distractors": [], "indent": 1, "explanation": "Set the size." },
        { "correct": "  vec->data = malloc(size * sizeof(float));", "distractors": [], "indent": 1, "explanation": "Allocate the data array. On GPUs, this would be aligned memory." },
        { "correct": "  if (!vec->data) { free(vec); return NULL; }", "distractors": [], "indent": 1, "explanation": "Handle allocation failure for the data array." },
        { "correct": "  return vec;", "distractors": [], "indent": 1, "explanation": "Return the new vector." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vector_create`." },
        { "correct": "void vector_destroy(FloatVector* vec) {", "distractors": [], "indent": 0, "explanation": "Begin `vector_destroy`." },
        { "correct": "  if (vec) {", "distractors": [], "indent": 1, "explanation": "Check if the pointer is valid." },
        { "correct": "    free(vec->data);", "distractors": [], "indent": 2, "explanation": "Free the data array first." },
        { "correct": "    free(vec);", "distractors": [], "indent": 2, "explanation": "Then free the struct." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End validity check." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vector_destroy`." },
        { "correct": "void vector_fill_random(FloatVector* vec) {", "distractors": [], "indent": 0, "explanation": "Begin `vector_fill_random`." },
        { "correct": "  for (size_t i = 0; i < vec->size; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through each element." },
        { "correct": "    vec->data[i] = (float)rand() / (float)(RAND_MAX / 100.0);", "distractors": [], "indent": 2, "explanation": "Assign a random float value between 0 and 100." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End loop." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vector_fill_random`." },
        { "correct": "void vector_print(const FloatVector* vec, const char* name) {", "distractors": [], "indent": 0, "explanation": "Begin `vector_print`." },
        { "correct": "  printf(\"Vector '%s' (first 8 elements): [ \", name);", "distractors": [], "indent": 1, "explanation": "Print a header, indicating we only show a few elements." },
        { "correct": "  size_t limit = vec->size < 8 ? vec->size : 8;", "distractors": [], "indent": 1, "explanation": "Determine the print limit to avoid out-of-bounds access." },
        { "correct": "  for (size_t i = 0; i < limit; i++) {", "distractors": [], "indent": 1, "explanation": "Loop up to the limit." },
        { "correct": "    printf(\"%.2f \", vec->data[i]);", "distractors": [], "indent": 2, "explanation": "Print each float formatted to two decimal places." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End loop." },
        { "correct": "  printf(\"]\\n\");", "distractors": [], "indent": 1, "explanation": "Print the closing bracket and a newline." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vector_print`." },
        { "correct": "// === Stage 3: Naive Scalar Implementation ===", "distractors": [], "indent": 0, "explanation": "Implement the simple, one-element-at-a-time version for comparison." },
        { "correct": "void vector_add_naive(const FloatVector* a, const FloatVector* b, FloatVector* result) {", "distractors": [], "indent": 0, "explanation": "Begin `vector_add_naive`." },
        { "correct": "  if (a->size != b->size || a->size != result->size) return;", "distractors": [], "indent": 1, "explanation": "Ensure all vectors are the same size." },
        { "correct": "  for (size_t i = 0; i < a->size; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through each element from 0 to N-1." },
        { "correct": "    result->data[i] = a->data[i] + b->data[i];", "distractors": [], "indent": 2, "explanation": "Perform one addition per loop iteration." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End loop." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vector_add_naive`." },
        { "correct": "// === Stage 4: Simulated SIMD Implementation ===", "distractors": [], "indent": 0, "explanation": "Implement the core logic using block-based processing to simulate SIMD." },
        { "correct": "void vector_add_simd(const FloatVector* a, const FloatVector* b, FloatVector* result) {", "distractors": [], "indent": 0, "explanation": "Begin `vector_add_simd`." },
        { "correct": "  if (a->size != b->size || a->size != result->size) return;", "distractors": [], "indent": 1, "explanation": "Perform size validation." },
        { "correct": "  size_t n = a->size;", "distractors": [], "indent": 1, "explanation": "Get the total size for convenience." },
        { "correct": "  size_t i = 0;", "distractors": [], "indent": 1, "explanation": "Initialize the loop counter." },
        { "correct": "  // Process the bulk of the data in chunks of SIMD_WIDTH.", "distractors": [], "indent": 1, "explanation": "Comment on the main vectorized loop." },
        { "correct": "  for (; i + SIMD_WIDTH <= n; i += SIMD_WIDTH) {", "distractors": [], "indent": 1, "explanation": "Loop as long as there is at least one full SIMD block remaining." },
        { "correct": "    // This block simulates a single SIMD instruction.", "distractors": [], "indent": 2, "explanation": "Comment explaining the manual unrolling." },
        { "correct": "    result->data[i+0] = a->data[i+0] + b->data[i+0];", "distractors": [], "indent": 2, "explanation": "Process the first element in the block." },
        { "correct": "    result->data[i+1] = a->data[i+1] + b->data[i+1];", "distractors": [], "indent": 2, "explanation": "Process the second element in the block." },
        { "correct": "    result->data[i+2] = a->data[i+2] + b->data[i+2];", "distractors": [], "indent": 2, "explanation": "Process the third element in the block." },
        { "correct": "    result->data[i+3] = a->data[i+3] + b->data[i+3];", "distractors": [], "indent": 2, "explanation": "Process the fourth element in the block." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of the main SIMD loop." },
        { "correct": "  // Handle the remaining elements that didn't fit into a full SIMD block.", "distractors": [], "indent": 1, "explanation": "Comment on the scalar cleanup loop." },
        { "correct": "  for (; i < n; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through the remaining 0 to 3 elements." },
        { "correct": "    result->data[i] = a->data[i] + b->data[i];", "distractors": [], "indent": 2, "explanation": "Process the remaining elements one by one." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of the cleanup loop." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vector_add_simd`." },
        { "correct": "// === Stage 5: Fused Multiply-Add (FMA) SIMD Implementation ===", "distractors": [], "indent": 0, "explanation": "Implement a more complex FMA operation, common in graphics and HPC." },
        { "correct": "void vector_fma_simd(const FloatVector* a, const FloatVector* b, const FloatVector* c, FloatVector* result) {", "distractors": [], "indent": 0, "explanation": "Begin `vector_fma_simd`." },
        { "correct": "  if (a->size != b->size || a->size != c->size || a->size != result->size) return;", "distractors": [], "indent": 1, "explanation": "Validate that all four vectors have the same size." },
        { "correct": "  size_t n = a->size;", "distractors": [], "indent": 1, "explanation": "Get the size for convenience." },
        { "correct": "  size_t i = 0;", "distractors": [], "indent": 1, "explanation": "Initialize the loop counter." },
        { "correct": "  // Main SIMD loop for FMA.", "distractors": [], "indent": 1, "explanation": "Comment on the main FMA loop." },
        { "correct": "  for (; i + SIMD_WIDTH <= n; i += SIMD_WIDTH) {", "distractors": [], "indent": 1, "explanation": "Loop over full SIMD-width blocks." },
        { "correct": "    result->data[i+0] = a->data[i+0] * b->data[i+0] + c->data[i+0];", "distractors": [], "indent": 2, "explanation": "Perform FMA on the first element of the block." },
        { "correct": "    result->data[i+1] = a->data[i+1] * b->data[i+1] + c->data[i+1];", "distractors": [], "indent": 2, "explanation": "Perform FMA on the second element." },
        { "correct": "    result->data[i+2] = a->data[i+2] * b->data[i+2] + c->data[i+2];", "distractors": [], "indent": 2, "explanation": "Perform FMA on the third element." },
        { "correct": "    result->data[i+3] = a->data[i+3] * b->data[i+3] + c->data[i+3];", "distractors": [], "indent": 2, "explanation": "Perform FMA on the fourth element." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of the main FMA loop." },
        { "correct": "  // Scalar cleanup loop for the remainder.", "distractors": [], "indent": 1, "explanation": "Comment on the remainder handling for FMA." },
        { "correct": "  for (; i < n; i++) {", "distractors": [], "indent": 1, "explanation": "Loop over the remaining elements." },
        { "correct": "    result->data[i] = a->data[i] * b->data[i] + c->data[i];", "distractors": [], "indent": 2, "explanation": "Perform FMA on the remaining elements one by one." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of the FMA cleanup loop." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vector_fma_simd`." },
        { "correct": "// === Stage 6: Main Program for Demonstration ===", "distractors": [], "indent": 0, "explanation": "Set up vectors and demonstrate that both naive and SIMD methods produce the same results." },
        { "correct": "int main() {", "distractors": [], "indent": 0, "explanation": "Start of main." },
        { "correct": "  srand(time(NULL)); // Seed the random number generator.", "distractors": [], "indent": 1, "explanation": "Ensure we get different random numbers each time." },
        { "correct": "  printf(\"--- SIMD-like Vector Operations Demo (Vector Size: %d) ---\\n\", VECTOR_SIZE);", "distractors": [], "indent": 1, "explanation": "Demo title." },
        { "correct": "  // --- Vector Creation and Initialization ---", "distractors": [], "indent": 1, "explanation": "Comment on the setup phase." },
        { "correct": "  FloatVector* vec_a = vector_create(VECTOR_SIZE);", "distractors": [], "indent": 1, "explanation": "Create vector A." },
        { "correct": "  FloatVector* vec_b = vector_create(VECTOR_SIZE);", "distractors": [], "indent": 1, "explanation": "Create vector B." },
        { "correct": "  FloatVector* vec_c = vector_create(VECTOR_SIZE);", "distractors": [], "indent": 1, "explanation": "Create vector C (for FMA)." },
        { "correct": "  FloatVector* result_naive = vector_create(VECTOR_SIZE);", "distractors": [], "indent": 1, "explanation": "Create a vector to store the naive result." },
        { "correct": "  FloatVector* result_simd = vector_create(VECTOR_SIZE);", "distractors": [], "indent": 1, "explanation": "Create a vector to store the SIMD result." },
        { "correct": "  vector_fill_random(vec_a);", "distractors": [], "indent": 1, "explanation": "Fill vector A with random data." },
        { "correct": "  vector_fill_random(vec_b);", "distractors": [], "indent": 1, "explanation": "Fill vector B with random data." },
        { "correct": "  vector_fill_random(vec_c);", "distractors": [], "indent": 1, "explanation": "Fill vector C with random data." },
        { "correct": "  vector_print(vec_a, \"A\");", "distractors": [], "indent": 1, "explanation": "Print the first few elements of A." },
        { "correct": "  vector_print(vec_b, \"B\");", "distractors": [], "indent": 1, "explanation": "Print the first few elements of B." },
        { "correct": "  vector_print(vec_c, \"C\");", "distractors": [], "indent": 1, "explanation": "Print the first few elements of C." },
        { "correct": "  // --- Demonstrate Vector Addition ---", "distractors": [], "indent": 1, "explanation": "Comment on the addition demonstration." },
        { "correct": "  printf(\"\\n--- Testing Vector Addition ---\\n\");", "distractors": [], "indent": 1, "explanation": "Header for addition test." },
        { "correct": "  printf(\"Running naive version...\\n\");", "distractors": [], "indent": 1, "explanation": "Log naive execution." },
        { "correct": "  vector_add_naive(vec_a, vec_b, result_naive);", "distractors": [], "indent": 1, "explanation": "Call the naive add function." },
        { "correct": "  printf(\"Running SIMD version...\\n\");", "distractors": [], "indent": 1, "explanation": "Log SIMD execution." },
        { "correct": "  vector_add_simd(vec_a, vec_b, result_simd);", "distractors": [], "indent": 1, "explanation": "Call the SIMD add function." },
        { "correct": "  vector_print(result_naive, \"Result (Naive Add)\");", "distractors": [], "indent": 1, "explanation": "Print the naive result." },
        { "correct": "  vector_print(result_simd, \"Result (SIMD Add)\");", "distractors": [], "indent": 1, "explanation": "Print the SIMD result (should be identical)." },
        { "correct": "  // --- Demonstrate Fused Multiply-Add ---", "distractors": [], "indent": 1, "explanation": "Comment on the FMA demonstration." },
        { "correct": "  printf(\"\\n--- Testing Fused Multiply-Add (FMA) ---\\n\");", "distractors": [], "indent": 1, "explanation": "Header for FMA test." },
        { "correct": "  printf(\"Running SIMD FMA version...\\n\");", "distractors": [], "indent": 1, "explanation": "Log SIMD FMA execution." },
        { "correct": "  vector_fma_simd(vec_a, vec_b, vec_c, result_simd);", "distractors": [], "indent": 1, "explanation": "Call the SIMD FMA function." },
        { "correct": "  vector_print(result_simd, \"Result (SIMD FMA)\");", "distractors": [], "indent": 1, "explanation": "Print the FMA result." },
        { "correct": "  // --- Cleanup ---", "distractors": [], "indent": 1, "explanation": "Comment on the cleanup phase." },
        { "correct": "  printf(\"\\nCleaning up all vectors...\\n\");", "distractors": [], "indent": 1, "explanation": "Log cleanup." },
        { "correct": "  vector_destroy(vec_a);", "distractors": [], "indent": 1, "explanation": "Destroy vector A." },
        { "correct": "  vector_destroy(vec_b);", "distractors": [], "indent": 1, "explanation": "Destroy vector B." },
        { "correct": "  vector_destroy(vec_c);", "distractors": [], "indent": 1, "explanation": "Destroy vector C." },
        { "correct": "  vector_destroy(result_naive);", "distractors": [], "indent": 1, "explanation": "Destroy the naive result vector." },
        { "correct": "  vector_destroy(result_simd);", "distractors": [], "indent": 1, "explanation": "Destroy the SIMD result vector." },
        { "correct": "  printf(\"--- Demo Finished ---\\n\");", "distractors": [], "indent": 1, "explanation": "Final message." },
        { "correct": "  return 0;", "distractors": [], "indent": 1, "explanation": "Indicate success." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of main." }
    ]
},
// Level 98: Prep for Google
{
    "goal": "Implement a Trie data structure (prefix tree) to store a dictionary of words and then use it to find all words that start with a given prefix, simulating a search autocomplete feature.",
    "concepts": "Trie, prefix tree, recursion, tree traversal (DFS), dynamic memory allocation, string manipulation",
    "sequence": [
        { "correct": "// === Stage 1: Trie Data Structures and Constants ===", "distractors": [], "indent": 0, "explanation": "Define the structure for a trie node and constants for the alphabet size." },
        { "correct": "#include <stdio.h>", "distractors": [], "indent": 0, "explanation": "For standard I/O." },
        { "correct": "#include <stdlib.h>", "distractors": [], "indent": 0, "explanation": "For dynamic memory allocation." },
        { "correct": "#include <stdbool.h>", "distractors": [], "indent": 0, "explanation": "For using the `bool` type." },
        { "correct": "#include <string.h>", "distractors": [], "indent": 0, "explanation": "For string functions like `strlen`." },
        { "correct": "#define ALPHABET_SIZE 26", "distractors": [], "indent": 0, "explanation": "The number of possible characters (a-z) for our simple trie." },
        { "correct": "#define MAX_WORD_LENGTH 100", "distractors": [], "indent": 0, "explanation": "The maximum length of a word we can handle in our autocomplete buffer." },
        { "correct": "// A single node in the Trie data structure.", "distractors": [], "indent": 0, "explanation": "Comment for the TrieNode struct." },
        { "correct": "typedef struct TrieNode {", "distractors": [], "indent": 0, "explanation": "Start of TrieNode struct definition." },
        { "correct": "  struct TrieNode* children[ALPHABET_SIZE];", "distractors": [], "indent": 1, "explanation": "An array of pointers to child nodes, one for each letter." },
        { "correct": "  bool isEndOfWord;", "distractors": [], "indent": 1, "explanation": "A flag that is true if this node represents the end of a valid word." },
        { "correct": "} TrieNode;", "distractors": [], "indent": 0, "explanation": "End of TrieNode typedef." },
        { "correct": "// --- Function Prototypes ---", "distractors": [], "indent": 0, "explanation": "Forward declarations for our Trie functions." },
        { "correct": "TrieNode* trie_create_node();", "distractors": [], "indent": 0, "explanation": "Creates and initializes a single new Trie node." },
        { "correct": "void trie_insert(TrieNode* root, const char* word);", "distractors": [], "indent": 0, "explanation": "Inserts a word into the Trie." },
        { "correct": "bool trie_search(TrieNode* root, const char* word);", "distractors": [], "indent": 0, "explanation": "Searches for an exact word in the Trie." },
        { "correct": "void trie_autocomplete(TrieNode* root, const char* prefix);", "distractors": [], "indent": 0, "explanation": "Finds and prints all words with a given prefix." },
        { "correct": "static void autocomplete_recursive_helper(TrieNode* node, char* prefix, char* current_word_buffer);", "distractors": [], "indent": 0, "explanation": "The recursive helper function for the autocomplete feature." },
        { "correct": "void trie_destroy(TrieNode* root);", "distractors": [], "indent": 0, "explanation": "Frees all memory used by the Trie." },
        { "correct": "// === Stage 2: Trie Node Creation and Destruction ===", "distractors": [], "indent": 0, "explanation": "Implement the basic functions for managing node memory." },
        { "correct": "TrieNode* trie_create_node() {", "distractors": [], "indent": 0, "explanation": "Begin `trie_create_node` implementation." },
        { "correct": "  TrieNode* new_node = (TrieNode*)malloc(sizeof(TrieNode));", "distractors": [], "indent": 1, "explanation": "Allocate memory for a new node." },
        { "correct": "  if (new_node) {", "distractors": [], "indent": 1, "explanation": "Check if allocation was successful." },
        { "correct": "    new_node->isEndOfWord = false;", "distractors": [], "indent": 2, "explanation": "A new node is not the end of a word by default." },
        { "correct": "    for (int i = 0; i < ALPHABET_SIZE; i++) {", "distractors": [], "indent": 2, "explanation": "Loop through the children array." },
        { "correct": "      new_node->children[i] = NULL;", "distractors": [], "indent": 3, "explanation": "Initialize all child pointers to NULL." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End children initialization loop." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End successful allocation block." },
        { "correct": "  return new_node;", "distractors": [], "indent": 1, "explanation": "Return the newly created and initialized node." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `trie_create_node`." },
        { "correct": "void trie_destroy(TrieNode* root) {", "distractors": [], "indent": 0, "explanation": "Begin `trie_destroy` implementation." },
        { "correct": "  if (!root) return;", "distractors": [], "indent": 1, "explanation": "Base case for recursion: do nothing if the node is NULL." },
        { "correct": "  for (int i = 0; i < ALPHABET_SIZE; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through all possible children." },
        { "correct": "    if (root->children[i]) {", "distractors": [], "indent": 2, "explanation": "If a child exists..." },
        { "correct": "      trie_destroy(root->children[i]);", "distractors": [], "indent": 3, "explanation": "Recursively call destroy on that child." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End child check." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End child loop." },
        { "correct": "  free(root);", "distractors": [], "indent": 1, "explanation": "After all children are destroyed, free the current node." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `trie_destroy`." },
        { "correct": "// === Stage 3: Core Trie Operations - Insertion and Search ===", "distractors": [], "indent": 0, "explanation": "Implement the functions to add words and search for them." },
        { "correct": "void trie_insert(TrieNode* root, const char* word) {", "distractors": [], "indent": 0, "explanation": "Begin `trie_insert` implementation." },
        { "correct": "  TrieNode* current_node = root;", "distractors": [], "indent": 1, "explanation": "Start traversing from the root node." },
        { "correct": "  int len = strlen(word);", "distractors": [], "indent": 1, "explanation": "Get the length of the word to insert." },
        { "correct": "  for (int i = 0; i < len; i++) {", "distractors": [], "indent": 1, "explanation": "Iterate through each character of the word." },
        { "correct": "    int index = word[i] - 'a';", "distractors": [], "indent": 2, "explanation": "Calculate the character's index (0-25). Assumes lowercase 'a'-'z'." },
        { "correct": "    if (index < 0 || index >= ALPHABET_SIZE) continue; // Skip non-alphabetic chars", "distractors": [], "indent": 2, "explanation": "Basic validation for character range." },
        { "correct": "    if (!current_node->children[index]) {", "distractors": [], "indent": 2, "explanation": "If the path for this character does not exist..." },
        { "correct": "      current_node->children[index] = trie_create_node();", "distractors": [], "indent": 3, "explanation": "Create a new node for it." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End node creation check." },
        { "correct": "    current_node = current_node->children[index];", "distractors": [], "indent": 2, "explanation": "Move down to the next node in the path." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of word character loop." },
        { "correct": "  // Mark the last node as the end of a word.", "distractors": [], "indent": 1, "explanation": "Comment on marking the end of the word." },
        { "correct": "  current_node->isEndOfWord = true;", "distractors": [], "indent": 1, "explanation": "Set the flag on the final node." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `trie_insert`." },
        { "correct": "bool trie_search(TrieNode* root, const char* word) {", "distractors": [], "indent": 0, "explanation": "Begin `trie_search` implementation." },
        { "correct": "  TrieNode* current_node = root;", "distractors": [], "indent": 1, "explanation": "Start traversal from the root." },
        { "correct": "  int len = strlen(word);", "distractors": [], "indent": 1, "explanation": "Get the length of the word to search for." },
        { "correct": "  for (int i = 0; i < len; i++) {", "distractors": [], "indent": 1, "explanation": "Iterate through each character." },
        { "correct": "    int index = word[i] - 'a';", "distractors": [], "indent": 2, "explanation": "Calculate the character's index." },
        { "correct": "    if (index < 0 || index >= ALPHABET_SIZE || !current_node->children[index]) {", "distractors": [], "indent": 2, "explanation": "If the char is invalid or the path doesn't exist..." },
        { "correct": "      return false; // The word is not in the trie.", "distractors": [], "indent": 3, "explanation": "Return false immediately." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End path check." },
        { "correct": "    current_node = current_node->children[index];", "distractors": [], "indent": 2, "explanation": "Move down to the next node." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End character loop." },
        { "correct": "  // The word is found only if the final node exists and is marked as the end of a word.", "distractors": [], "indent": 1, "explanation": "Comment on the final condition." },
        { "correct": "  return (current_node != NULL && current_node->isEndOfWord);", "distractors": [], "indent": 1, "explanation": "Return true if the full path exists and is a valid word." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `trie_search`." },
        { "correct": "// === Stage 4: Autocomplete Implementation ===", "distractors": [], "indent": 0, "explanation": "Implement the main autocomplete logic and its recursive helper." },
        { "correct": "static void autocomplete_recursive_helper(TrieNode* node, char* prefix, char* current_word_buffer) {", "distractors": [], "indent": 0, "explanation": "Begin the recursive helper function." },
        { "correct": "  if (node->isEndOfWord) {", "distractors": [], "indent": 1, "explanation": "Check if the current node represents a complete word." },
        { "correct": "    printf(\"  -> %s%s\\n\", prefix, current_word_buffer);", "distractors": [], "indent": 2, "explanation": "If so, print the original prefix plus the suffix we've built." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of word check." },
        { "correct": "  // Recursively explore all children of the current node.", "distractors": [], "indent": 1, "explanation": "Comment on the recursive step (DFS)." },
        { "correct": "  for (int i = 0; i < ALPHABET_SIZE; i++) {", "distractors": [], "indent": 1, "explanation": "Iterate through all possible child characters." },
        { "correct": "    if (node->children[i]) {", "distractors": [], "indent": 2, "explanation": "If a child node exists for this character..." },
        { "correct": "      int len = strlen(current_word_buffer);", "distractors": [], "indent": 3, "explanation": "Get the length of the current suffix." },
        { "correct": "      current_word_buffer[len] = i + 'a';", "distractors": [], "indent": 3, "explanation": "Append the new character to the suffix buffer." },
        { "correct": "      current_word_buffer[len + 1] = '\\0';", "distractors": [], "indent": 3, "explanation": "Null-terminate the updated suffix." },
        { "correct": "      autocomplete_recursive_helper(node->children[i], prefix, current_word_buffer);", "distractors": [], "indent": 3, "explanation": "Make the recursive call on the child node." },
        { "correct": "      current_word_buffer[len] = '\\0';", "distractors": [], "indent": 3, "explanation": "Backtrack: remove the character we just added to explore other branches." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of child check." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of child loop." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of `autocomplete_recursive_helper`." },
        { "correct": "void trie_autocomplete(TrieNode* root, const char* prefix) {", "distractors": [], "indent": 0, "explanation": "Begin the main autocomplete function." },
        { "correct": "  printf(\"\\n--- Autocomplete results for prefix '%s' ---\\n\", prefix);", "distractors": [], "indent": 1, "explanation": "Print a header for the results." },
        { "correct": "  TrieNode* current_node = root;", "distractors": [], "indent": 1, "explanation": "Start traversal from the root." },
        { "correct": "  int len = strlen(prefix);", "distractors": [], "indent": 1, "explanation": "Get the length of the prefix." },
        { "correct": "  // Traverse the trie to the node corresponding to the end of the prefix.", "distractors": [], "indent": 1, "explanation": "Comment on the first phase: finding the prefix node." },
        { "correct": "  for (int i = 0; i < len; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through each character of the prefix." },
        { "correct": "    int index = prefix[i] - 'a';", "distractors": [], "indent": 2, "explanation": "Calculate the character's index." },
        { "correct": "    if (index < 0 || index >= ALPHABET_SIZE || !current_node->children[index]) {", "distractors": [], "indent": 2, "explanation": "If the prefix itself doesn't exist in the trie..." },
        { "correct": "      printf(\"  -> No words found with this prefix.\\n\");", "distractors": [], "indent": 3, "explanation": "Print a message and exit." },
        { "correct": "      return;", "distractors": [], "indent": 3, "explanation": "Return from the function." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of prefix path check." },
        { "correct": "    current_node = current_node->children[index];", "distractors": [], "indent": 2, "explanation": "Move down to the next node in the prefix path." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End prefix traversal loop." },
        { "correct": "  // Now, from this node, find all descendant words.", "distractors": [], "indent": 1, "explanation": "Comment on the second phase: collecting words." },
        { "correct": "  char word_buffer[MAX_WORD_LENGTH];", "distractors": [], "indent": 1, "explanation": "Create a buffer to build the word suffixes." },
        { "correct": "  word_buffer[0] = '\\0';", "distractors": [], "indent": 1, "explanation": "Initialize the buffer as an empty string." },
        { "correct": "  char prefix_copy[MAX_WORD_LENGTH];", "distractors": [], "indent": 1, "explanation": "Create a mutable copy of the prefix." },
        { "correct": "  strcpy(prefix_copy, prefix);", "distractors": [], "indent": 1, "explanation": "Copy the prefix into the mutable buffer." },
        { "correct": "  autocomplete_recursive_helper(current_node, prefix_copy, word_buffer);", "distractors": [], "indent": 1, "explanation": "Call the recursive helper to start the search." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `trie_autocomplete`." },
        { "correct": "// === Stage 5: Main Program for Demonstration ===", "distractors": [], "indent": 0, "explanation": "Set up a dictionary and test the autocomplete functionality." },
        { "correct": "int main() {", "distractors": [], "indent": 0, "explanation": "Start of main." },
        { "correct": "  printf(\"--- Trie Autocomplete Demo ---\\n\");", "distractors": [], "indent": 1, "explanation": "Demo title." },
        { "correct": "  TrieNode* root = trie_create_node();", "distractors": [], "indent": 1, "explanation": "Create the root of the Trie." },
        { "correct": "  // Insert a dictionary of words.", "distractors": [], "indent": 1, "explanation": "Comment on populating the trie." },
        { "correct": "  const char* dictionary[] = {\"apple\", \"apply\", \"apricot\", \"ape\", \"application\", \"banana\", \"bandana\", \"band\", \"car\", \"cat\", \"cart\"};", "distractors": [], "indent": 1, "explanation": "Define an array of strings for our dictionary." },
        { "correct": "  int dict_size = sizeof(dictionary) / sizeof(dictionary[0]);", "distractors": [], "indent": 1, "explanation": "Calculate the number of words in the dictionary." },
        { "correct": "  printf(\"Inserting %d words into the Trie...\\n\", dict_size);", "distractors": [], "indent": 1, "explanation": "Log the insertion process." },
        { "correct": "  for (int i = 0; i < dict_size; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through the dictionary." },
        { "correct": "    trie_insert(root, dictionary[i]);", "distractors": [], "indent": 2, "explanation": "Insert each word into the trie." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End insertion loop." },
        { "correct": "  // --- Test Search Functionality ---", "distractors": [], "indent": 1, "explanation": "Comment on testing exact search." },
        { "correct": "  printf(\"\\nSearching for 'apple': %s\\n\", trie_search(root, \"apple\") ? \"Found\" : \"Not Found\");", "distractors": [], "indent": 1, "explanation": "Search for a word that exists." },
        { "correct": "  printf(\"Searching for 'appl': %s\\n\", trie_search(root, \"appl\") ? \"Found\" : \"Not Found\");", "distractors": [], "indent": 1, "explanation": "Search for a prefix that is not a complete word." },
        { "correct": "  printf(\"Searching for 'banana': %s\\n\", trie_search(root, \"banana\") ? \"Found\" : \"Not Found\");", "distractors": [], "indent": 1, "explanation": "Search for another existing word." },
        { "correct": "  printf(\"Searching for 'banned': %s\\n\", trie_search(root, \"banned\") ? \"Found\" : \"Not Found\");", "distractors": [], "indent": 1, "explanation": "Search for a word that does not exist." },
        { "correct": "  // --- Test Autocomplete Functionality ---", "distractors": [], "indent": 1, "explanation": "Comment on testing the autocomplete feature." },
        { "correct": "  trie_autocomplete(root, \"ap\");", "distractors": [], "indent": 1, "explanation": "Test autocomplete with prefix 'ap'." },
        { "correct": "  trie_autocomplete(root, \"band\");", "distractors": [], "indent": 1, "explanation": "Test autocomplete with prefix 'band'." },
        { "correct": "  trie_autocomplete(root, \"ca\");", "distractors": [], "indent": 1, "explanation": "Test autocomplete with prefix 'ca'." },
        { "correct": "  trie_autocomplete(root, \"z\");", "distractors": [], "indent": 1, "explanation": "Test autocomplete with a prefix that has no matches." },
        { "correct": "  // --- Cleanup ---", "distractors": [], "indent": 1, "explanation": "Comment on memory cleanup." },
        { "correct": "  printf(\"\\nDestroying the Trie...\\n\");", "distractors": [], "indent": 1, "explanation": "Log the destruction." },
        { "correct": "  trie_destroy(root);", "distractors": [], "indent": 1, "explanation": "Call the recursive destroy function to free all memory." },
        { "correct": "  printf(\"--- Demo Finished ---\\n\");", "distractors": [], "indent": 1, "explanation": "Final message." },
        { "correct": "  return 0;", "distractors": [], "indent": 1, "explanation": "Indicate success." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of main." }
    ]
},
// Level 99: Prep for Microsoft
{
    "goal": "Implement a simplified in-memory virtual file system (VFS) that supports creating directories and files, writing/reading file content, and listing directory contents.",
    "concepts": "Tree data structures, file system concepts (inodes, paths), recursion, string parsing, dynamic memory allocation, pointers",
    "sequence": [
        { "correct": "// === Stage 1: VFS Data Structures and Enums ===", "distractors": [], "indent": 0, "explanation": "Define the fundamental structures for files, directories, and the file system itself." },
        { "correct": "#include <stdio.h>", "distractors": [], "indent": 0, "explanation": "For standard input/output functions." },
        { "correct": "#include <stdlib.h>", "distractors": [], "indent": 0, "explanation": "For memory management (malloc, free, realloc)." },
        { "correct": "#include <string.h>", "distractors": [], "indent": 0, "explanation": "For string manipulation (strcpy, strtok, strdup)." },
        { "correct": "#include <stdbool.h>", "distractors": [], "indent": 0, "explanation": "For the boolean type." },
        { "correct": "#include <time.h>", "distractors": [], "indent": 0, "explanation": "For managing file timestamps." },
        { "correct": "#define MAX_NAME_LEN 256", "distractors": [], "indent": 0, "explanation": "Maximum length for a file or directory name." },
        { "correct": "// Enum to distinguish between file and directory nodes.", "distractors": [], "indent": 0, "explanation": "Comment for the NodeType enum." },
        { "correct": "typedef enum { NODE_FILE, NODE_DIRECTORY } NodeType;", "distractors": [], "indent": 0, "explanation": "Defines the two types of nodes in our VFS." },
        { "correct": "// The core VFS node, acting like an 'inode'.", "distractors": [], "indent": 0, "explanation": "Comment for the VFSNode struct." },
        { "correct": "typedef struct VFSNode {", "distractors": [], "indent": 0, "explanation": "Start of the VFSNode definition." },
        { "correct": "  char name[MAX_NAME_LEN];", "distractors": [], "indent": 1, "explanation": "The name of this file or directory." },
        { "correct": "  NodeType type;", "distractors": [], "indent": 1, "explanation": "The type of this node." },
        { "correct": "  time_t creation_time;", "distractors": [], "indent": 1, "explanation": "Timestamp for when the node was created." },
        { "correct": "  struct VFSNode* parent;", "distractors": [], "indent": 1, "explanation": "Pointer to the parent directory node." },
        { "correct": "  // Directory-specific members", "distractors": [], "indent": 1, "explanation": "Comment for directory data." },
        { "correct": "  struct VFSNode* first_child;", "distractors": [], "indent": 1, "explanation": "Pointer to the first child in a linked list of children." },
        { "correct": "  // File-specific members", "distractors": [], "indent": 1, "explanation": "Comment for file data." },
        { "correct": "  char* content;", "distractors": [], "indent": 1, "explanation": "Pointer to the file's content buffer." },
        { "correct": "  size_t content_size;", "distractors": [], "indent": 1, "explanation": "The size of the content buffer." },
        { "correct": "  // Sibling pointer for the linked list", "distractors": [], "indent": 1, "explanation": "Comment for the sibling pointer." },
        { "correct": "  struct VFSNode* next_sibling;", "distractors": [], "indent": 1, "explanation": "Pointer to the next node in the same directory." },
        { "correct": "} VFSNode;", "distractors": [], "indent": 0, "explanation": "End of VFSNode definition." },
        { "correct": "// Main VFS control structure.", "distractors": [], "indent": 0, "explanation": "Comment for the VFS struct." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start of VFS struct definition." },
        { "correct": "  VFSNode* root;", "distractors": [], "indent": 1, "explanation": "Pointer to the root directory ('/') of the file system." },
        { "correct": "} VFS;", "distractors": [], "indent": 0, "explanation": "End of VFS struct definition." },
        { "correct": "// --- Function Prototypes ---", "distractors": [], "indent": 0, "explanation": "Forward declarations for our VFS API." },
        { "correct": "VFS* vfs_init();", "distractors": [], "indent": 0, "explanation": "Initializes the entire VFS." },
        { "correct": "void vfs_shutdown(VFS* vfs);", "distractors": [], "indent": 0, "explanation": "Frees all memory used by the VFS." },
        { "correct": "VFSNode* vfs_get_node(VFS* vfs, const char* path);", "distractors": [], "indent": 0, "explanation": "Finds a node given its absolute path." },
        { "correct": "bool vfs_mkdir(VFS* vfs, const char* path);", "distractors": [], "indent": 0, "explanation": "Creates a new directory." },
        { "correct": "bool vfs_create_file(VFS* vfs, const char* path);", "distractors": [], "indent": 0, "explanation": "Creates a new empty file." },
        { "correct": "bool vfs_write(VFS* vfs, const char* path, const char* data);", "distractors": [], "indent": 0, "explanation": "Writes data to a file, overwriting existing content." },
        { "correct": "char* vfs_read(VFS* vfs, const char* path);", "distractors": [], "indent": 0, "explanation": "Reads the content of a file." },
        { "correct": "void vfs_ls(VFS* vfs, const char* path);", "distractors": [], "indent": 0, "explanation": "Lists the contents of a directory." },
        { "correct": "static void vfs_free_node_recursive(VFSNode* node);", "distractors": [], "indent": 0, "explanation": "Internal helper to recursively free nodes." },
        { "correct": "// === Stage 2: Initialization and Shutdown Logic ===", "distractors": [], "indent": 0, "explanation": "Implement the main setup and teardown functions for the VFS." },
        { "correct": "VFS* vfs_init() {", "distractors": [], "indent": 0, "explanation": "Begin `vfs_init`." },
        { "correct": "  printf(\"Initializing Virtual File System...\\n\");", "distractors": [], "indent": 1, "explanation": "Log the initialization event." },
        { "correct": "  VFS* vfs = malloc(sizeof(VFS));", "distractors": [], "indent": 1, "explanation": "Allocate the main VFS control struct." },
        { "correct": "  if (!vfs) return NULL;", "distractors": [], "indent": 1, "explanation": "Handle allocation failure." },
        { "correct": "  // Create the root directory node.", "distractors": [], "indent": 1, "explanation": "Comment on creating the root." },
        { "correct": "  vfs->root = malloc(sizeof(VFSNode));", "distractors": [], "indent": 1, "explanation": "Allocate memory for the root node." },
        { "correct": "  if (!vfs->root) { free(vfs); return NULL; }", "distractors": [], "indent": 1, "explanation": "Handle root allocation failure." },
        { "correct": "  strcpy(vfs->root->name, \"/\");", "distractors": [], "indent": 1, "explanation": "The root directory is named '/'." },
        { "correct": "  vfs->root->type = NODE_DIRECTORY;", "distractors": [], "indent": 1, "explanation": "Set the node type to directory." },
        { "correct": "  vfs->root->creation_time = time(NULL);", "distractors": [], "indent": 1, "explanation": "Set the creation timestamp." },
        { "correct": "  vfs->root->parent = NULL; // Root has no parent", "distractors": [], "indent": 1, "explanation": "The parent of the root is NULL." },
        { "correct": "  vfs->root->first_child = NULL;", "distractors": [], "indent": 1, "explanation": "Root starts with no children." },
        { "correct": "  vfs->root->content = NULL;", "distractors": [], "indent": 1, "explanation": "Directories have no content buffer." },
        { "correct": "  vfs->root->content_size = 0;", "distractors": [], "indent": 1, "explanation": "Content size is zero for directories." },
        { "correct": "  vfs->root->next_sibling = NULL;", "distractors": [], "indent": 1, "explanation": "Root has no siblings." },
        { "correct": "  printf(\"VFS Initialized. Root directory '/' created.\\n\");", "distractors": [], "indent": 1, "explanation": "Confirm initialization." },
        { "correct": "  return vfs;", "distractors": [], "indent": 1, "explanation": "Return the new VFS instance." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vfs_init`." },
        { "correct": "void vfs_shutdown(VFS* vfs) {", "distractors": [], "indent": 0, "explanation": "Begin `vfs_shutdown`." },
        { "correct": "  if (!vfs) return;", "distractors": [], "indent": 1, "explanation": "Guard against NULL VFS pointer." },
        { "correct": "  printf(\"\\nShutting down VFS and freeing all nodes...\\n\");", "distractors": [], "indent": 1, "explanation": "Log the shutdown process." },
        { "correct": "  vfs_free_node_recursive(vfs->root);", "distractors": [], "indent": 1, "explanation": "Start the recursive free from the root." },
        { "correct": "  free(vfs);", "distractors": [], "indent": 1, "explanation": "Free the main VFS control struct." },
        { "correct": "  printf(\"VFS Shutdown complete.\\n\");", "distractors": [], "indent": 1, "explanation": "Confirm shutdown." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vfs_shutdown`." },
        { "correct": "static void vfs_free_node_recursive(VFSNode* node) {", "distractors": [], "indent": 0, "explanation": "Begin recursive free helper." },
        { "correct": "  if (!node) return;", "distractors": [], "indent": 1, "explanation": "Base case: if node is NULL, do nothing." },
        { "correct": "  // Recursively free all children (if it's a directory)", "distractors": [], "indent": 1, "explanation": "Comment on freeing children." },
        { "correct": "  if (node->type == NODE_DIRECTORY) {", "distractors": [], "indent": 1, "explanation": "Check if the node is a directory." },
        { "correct": "    VFSNode* child = node->first_child;", "distractors": [], "indent": 2, "explanation": "Get the first child." },
        { "correct": "    while (child) {", "distractors": [], "indent": 2, "explanation": "Iterate through the children list." },
        { "correct": "      VFSNode* next = child->next_sibling;", "distractors": [], "indent": 3, "explanation": "Store the next sibling before freeing the current one." },
        { "correct": "      vfs_free_node_recursive(child);", "distractors": [], "indent": 3, "explanation": "Make the recursive call on the child." },
        { "correct": "      child = next;", "distractors": [], "indent": 3, "explanation": "Move to the next sibling." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End of child loop." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End directory check." },
        { "correct": "  // Free the node's own content (if it's a file)", "distractors": [], "indent": 1, "explanation": "Comment on freeing file content." },
        { "correct": "  if (node->type == NODE_FILE) {", "distractors": [], "indent": 1, "explanation": "Check if the node is a file." },
        { "correct": "    free(node->content);", "distractors": [], "indent": 2, "explanation": "Free the file's content buffer." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End file check." },
        { "correct": "  // Finally, free the node struct itself", "distractors": [], "indent": 1, "explanation": "Comment on freeing the node." },
        { "correct": "  free(node);", "distractors": [], "indent": 1, "explanation": "Free the VFSNode." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vfs_free_node_recursive`." },
        { "correct": "// === Stage 3: Path Traversal and Node Creation ===", "distractors": [], "indent": 0, "explanation": "Implement the core logic for navigating the VFS tree." },
        { "correct": "VFSNode* vfs_get_node(VFS* vfs, const char* path) {", "distractors": [], "indent": 0, "explanation": "Begin `vfs_get_node`." },
        { "correct": "  if (strcmp(path, \"/\") == 0) return vfs->root;", "distractors": [], "indent": 1, "explanation": "Handle the special case for the root path." },
        { "correct": "  char path_copy[1024];", "distractors": [], "indent": 1, "explanation": "Create a mutable copy of the path for tokenizing." },
        { "correct": "  strncpy(path_copy, path, sizeof(path_copy) - 1);", "distractors": [], "indent": 1, "explanation": "Copy the path." },
        { "correct": "  path_copy[sizeof(path_copy)-1] = '\\0';", "distractors": [], "indent": 1, "explanation": "Ensure null termination." },
        { "correct": "  VFSNode* current_node = vfs->root;", "distractors": [], "indent": 1, "explanation": "Start traversal from the root." },
        { "correct": "  char* token = strtok(path_copy, \"/\");", "distractors": [], "indent": 1, "explanation": "Get the first token (directory/file name) from the path." },
        { "correct": "  while (token != NULL) {", "distractors": [], "indent": 1, "explanation": "Loop through all tokens in the path." },
        { "correct": "    VFSNode* child = current_node->first_child;", "distractors": [], "indent": 2, "explanation": "Get the first child of the current directory." },
        { "correct": "    bool found = false;", "distractors": [], "indent": 2, "explanation": "Flag to indicate if we found the next node in the path." },
        { "correct": "    while (child) {", "distractors": [], "indent": 2, "explanation": "Iterate through the children to find a name match." },
        { "correct": "      if (strcmp(child->name, token) == 0) {", "distractors": [], "indent": 3, "explanation": "If a child's name matches the token..." },
        { "correct": "        current_node = child;", "distractors": [], "indent": 4, "explanation": "Move to that child node." },
        { "correct": "        found = true;", "distractors": [], "indent": 4, "explanation": "Set the found flag." },
        { "correct": "        break;", "distractors": [], "indent": 4, "explanation": "Break the inner while loop." },
        { "correct": "      }", "distractors": [], "indent": 3, "explanation": "End name comparison." },
        { "correct": "      child = child->next_sibling;", "distractors": [], "indent": 3, "explanation": "Move to the next sibling." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End child search loop." },
        { "correct": "    if (!found) return NULL; // Path component not found", "distractors": [], "indent": 2, "explanation": "If any part of the path doesn't exist, return NULL." },
        { "correct": "    token = strtok(NULL, \"/\");", "distractors": [], "indent": 2, "explanation": "Get the next token in the path." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End token loop." },
        { "correct": "  return current_node;", "distractors": [], "indent": 1, "explanation": "Return the final node found at the end of the path." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vfs_get_node`." },
        { "correct": "// === Stage 4: Core VFS API Implementations ===", "distractors": [], "indent": 0, "explanation": "Implement the user-facing file system operations." },
        { "correct": "bool vfs_mkdir(VFS* vfs, const char* path) {", "distractors": [], "indent": 0, "explanation": "Begin `vfs_mkdir`." },
        { "correct": "  // Find parent directory and the new directory's name.", "distractors": [], "indent": 1, "explanation": "Comment on path parsing." },
        { "correct": "  char path_copy[1024]; strncpy(path_copy, path, 1023);", "distractors": [], "indent": 1, "explanation": "Make a copy of the path string." },
        { "correct": "  char* last_slash = strrchr(path_copy, '/');", "distractors": [], "indent": 1, "explanation": "Find the last slash to separate parent path from new directory name." },
        { "correct": "  if (!last_slash) return false; // Invalid path format", "distractors": [], "indent": 1, "explanation": "Handle invalid path." },
        { "correct": "  char* new_dir_name = last_slash + 1;", "distractors": [], "indent": 1, "explanation": "The new directory name is what comes after the last slash." },
        { "correct": "  if (last_slash == path_copy) *(last_slash + 1) = '\\0'; else *last_slash = '\\0';", "distractors": [], "indent": 1, "explanation": "Terminate the parent path string. Handle root case." },
        { "correct": "  const char* parent_path = (strlen(path_copy) == 0) ? \"/\" : path_copy;", "distractors": [], "indent": 1, "explanation": "Determine the parent path string." },
        { "correct": "  VFSNode* parent = vfs_get_node(vfs, parent_path);", "distractors": [], "indent": 1, "explanation": "Get the node for the parent directory." },
        { "correct": "  if (!parent || parent->type != NODE_DIRECTORY) return false;", "distractors": [], "indent": 1, "explanation": "Check if parent exists and is a directory." },
        { "correct": "  // Create the new directory node", "distractors": [], "indent": 1, "explanation": "Comment on creating the new node." },
        { "correct": "  VFSNode* new_node = malloc(sizeof(VFSNode));", "distractors": [], "indent": 1, "explanation": "Allocate memory for the new directory node." },
        { "correct": "  strcpy(new_node->name, new_dir_name);", "distractors": [], "indent": 1, "explanation": "Copy the name." },
        { "correct": "  new_node->type = NODE_DIRECTORY; new_node->creation_time = time(NULL);", "distractors": [], "indent": 1, "explanation": "Set type and timestamp." },
        { "correct": "  new_node->parent = parent; new_node->first_child = NULL; new_node->content = NULL; new_node->content_size = 0;", "distractors": [], "indent": 1, "explanation": "Initialize other fields." },
        { "correct": "  // Add new node to parent's children list", "distractors": [], "indent": 1, "explanation": "Comment on linking the node." },
        { "correct": "  new_node->next_sibling = parent->first_child;", "distractors": [], "indent": 1, "explanation": "New node points to the old first child." },
        { "correct": "  parent->first_child = new_node;", "distractors": [], "indent": 1, "explanation": "New node becomes the new first child." },
        { "correct": "  printf(\"Created directory: %s\\n\", path);", "distractors": [], "indent": 1, "explanation": "Log the creation." },
        { "correct": "  return true;", "distractors": [], "indent": 1, "explanation": "Return success." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vfs_mkdir`." },
        { "correct": "bool vfs_write(VFS* vfs, const char* path, const char* data) {", "distractors": [], "indent": 0, "explanation": "Begin `vfs_write`." },
        { "correct": "  VFSNode* node = vfs_get_node(vfs, path);", "distractors": [], "indent": 1, "explanation": "Find the node for the given path." },
        { "correct": "  if (!node) { /* For simplicity, we create the file if it doesn't exist */", "distractors": [], "indent": 1, "explanation": "If file doesn't exist, create it." },
        { "correct": "    char path_copy[1024]; strncpy(path_copy, path, 1023);", "distractors": [], "indent": 2, "explanation": "Copy path to parse out parent." },
        { "correct": "    char* last_slash = strrchr(path_copy, '/');", "distractors": [], "indent": 2, "explanation": "Find last slash." },
        { "correct": "    if(!last_slash) return false;", "distractors": [], "indent": 2, "explanation": "Invalid path." },
        { "correct": "    char* new_file_name = last_slash + 1;", "distractors": [], "indent": 2, "explanation": "Get new file name." },
        { "correct": "    if (last_slash == path_copy) *(last_slash + 1) = '\\0'; else *last_slash = '\\0';", "distractors": [], "indent": 2, "explanation": "Separate parent path." },
        { "correct": "    const char* parent_path = (strlen(path_copy) == 0) ? \"/\" : path_copy;", "distractors": [], "indent": 2, "explanation": "Determine parent path string." },
        { "correct": "    VFSNode* parent = vfs_get_node(vfs, parent_path);", "distractors": [], "indent": 2, "explanation": "Get parent node." },
        { "correct": "    if (!parent || parent->type != NODE_DIRECTORY) return false;", "distractors": [], "indent": 2, "explanation": "Check parent validity." },
        { "correct": "    node = malloc(sizeof(VFSNode));", "distractors": [], "indent": 2, "explanation": "Allocate new file node." },
        { "correct": "    strcpy(node->name, new_file_name);", "distractors": [], "indent": 2, "explanation": "Set its name." },
        { "correct": "    node->type = NODE_FILE; node->creation_time = time(NULL); node->parent = parent;", "distractors": [], "indent": 2, "explanation": "Set its properties." },
        { "correct": "    node->first_child = NULL; node->content=NULL; node->content_size=0;", "distractors": [], "indent": 2, "explanation": "Initialize file-specific fields." },
        { "correct": "    node->next_sibling = parent->first_child;", "distractors": [], "indent": 2, "explanation": "Link into parent's children list." },
        { "correct": "    parent->first_child = node;", "distractors": [], "indent": 2, "explanation": "Update parent's first child." },
        { "correct": "    printf(\"Created file: %s\\n\", path);", "distractors": [], "indent": 2, "explanation": "Log creation." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of file creation block." },
        { "correct": "  if (node->type != NODE_FILE) return false; // Can't write to a directory", "distractors": [], "indent": 1, "explanation": "Ensure we are writing to a file." },
        { "correct": "  free(node->content); // Free old content if any", "distractors": [], "indent": 1, "explanation": "Free any pre-existing content." },
        { "correct": "  node->content_size = strlen(data) + 1;", "distractors": [], "indent": 1, "explanation": "Calculate size of new data." },
        { "correct": "  node->content = malloc(node->content_size);", "distractors": [], "indent": 1, "explanation": "Allocate memory for the new content." },
        { "correct": "  strcpy(node->content, data);", "distractors": [], "indent": 1, "explanation": "Copy the data into the node's content buffer." },
        { "correct": "  printf(\"Wrote %zu bytes to %s\\n\", node->content_size, path);", "distractors": [], "indent": 1, "explanation": "Log the write operation." },
        { "correct": "  return true;", "distractors": [], "indent": 1, "explanation": "Return success." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vfs_write`." },
        { "correct": "char* vfs_read(VFS* vfs, const char* path) {", "distractors": [], "indent": 0, "explanation": "Begin `vfs_read`." },
        { "correct": "  VFSNode* node = vfs_get_node(vfs, path);", "distractors": [], "indent": 1, "explanation": "Get the node for the path." },
        { "correct": "  if (!node || node->type != NODE_FILE) return NULL;", "distractors": [], "indent": 1, "explanation": "Return NULL if path is not a valid file." },
        { "correct": "  printf(\"Read from %s\\n\", path);", "distractors": [], "indent": 1, "explanation": "Log the read operation." },
        { "correct": "  return node->content;", "distractors": [], "indent": 1, "explanation": "Return a pointer to the content." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vfs_read`." },
        { "correct": "void vfs_ls(VFS* vfs, const char* path) {", "distractors": [], "indent": 0, "explanation": "Begin `vfs_ls`." },
        { "correct": "  VFSNode* dir_node = vfs_get_node(vfs, path);", "distractors": [], "indent": 1, "explanation": "Get the node for the directory path." },
        { "correct": "  if (!dir_node || dir_node->type != NODE_DIRECTORY) {", "distractors": [], "indent": 1, "explanation": "Check if the path is a valid directory." },
        { "correct": "    printf(\"ls: cannot access '%s': Not a directory\\n\", path);", "distractors": [], "indent": 2, "explanation": "Print an error if not a directory." },
        { "correct": "    return;", "distractors": [], "indent": 2, "explanation": "Exit the function." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End validity check." },
        { "correct": "  printf(\"Listing for %s:\\n\", path);", "distractors": [], "indent": 1, "explanation": "Print a header for the listing." },
        { "correct": "  VFSNode* child = dir_node->first_child;", "distractors": [], "indent": 1, "explanation": "Get the first child of the directory." },
        { "correct": "  while (child) {", "distractors": [], "indent": 1, "explanation": "Loop through all children." },
        { "correct": "    printf(\"  %s%s\\n\", child->name, (child->type == NODE_DIRECTORY) ? \"/\" : \"\");", "distractors": [], "indent": 2, "explanation": "Print the child's name, adding a slash if it's a directory." },
        { "correct": "    child = child->next_sibling;", "distractors": [], "indent": 2, "explanation": "Move to the next child." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End of child loop." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `vfs_ls`." },
        { "correct": "// === Stage 5: Main Program for Demonstration ===", "distractors": [], "indent": 0, "explanation": "The main function to test the VFS API." },
        { "correct": "int main() {", "distractors": [], "indent": 0, "explanation": "Start of main." },
        { "correct": "  printf(\"--- Virtual File System Demo ---\\n\");", "distractors": [], "indent": 1, "explanation": "Demo title." },
        { "correct": "  VFS* my_vfs = vfs_init();", "distractors": [], "indent": 1, "explanation": "Initialize the VFS." },
        { "correct": "  // Create directory structure", "distractors": [], "indent": 1, "explanation": "Comment on creating directories." },
        { "correct": "  vfs_mkdir(my_vfs, \"/home\");", "distractors": [], "indent": 1, "explanation": "Create /home." },
        { "correct": "  vfs_mkdir(my_vfs, \"/home/user\");", "distractors": [], "indent": 1, "explanation": "Create /home/user." },
        { "correct": "  vfs_mkdir(my_vfs, \"/etc\");", "distractors": [], "indent": 1, "explanation": "Create /etc." },
        { "correct": "  // List root directory contents", "distractors": [], "indent": 1, "explanation": "Comment on listing root." },
        { "correct": "  vfs_ls(my_vfs, \"/\");", "distractors": [], "indent": 1, "explanation": "List contents of /." },
        { "correct": "  // Create and write to files", "distractors": [], "indent": 1, "explanation": "Comment on file operations." },
        { "correct": "  vfs_write(my_vfs, \"/home/user/profile.txt\", \"Name: Satya\\nCompany: Microsoft\");", "distractors": [], "indent": 1, "explanation": "Write to the first file." },
        { "correct": "  vfs_write(my_vfs, \"/etc/config.conf\", \"TIMEOUT=30\");", "distractors": [], "indent": 1, "explanation": "Write to a second file." },
        { "correct": "  // List subdirectory contents", "distractors": [], "indent": 1, "explanation": "Comment on listing a subdirectory." },
        { "correct": "  vfs_ls(my_vfs, \"/home/user\");", "distractors": [], "indent": 1, "explanation": "List the contents of /home/user." },
        { "correct": "  // Read from a file and print its content", "distractors": [], "indent": 1, "explanation": "Comment on reading a file." },
        { "correct": "  char* content = vfs_read(my_vfs, \"/home/user/profile.txt\");", "distractors": [], "indent": 1, "explanation": "Read the profile file." },
        { "correct": "  if (content) { printf(\"\\nContent of /home/user/profile.txt:\\n%s\\n\", content); }", "distractors": [], "indent": 1, "explanation": "Print its content if read was successful." },
        { "correct": "  // Cleanup", "distractors": [], "indent": 1, "explanation": "Comment on shutdown." },
        { "correct": "  vfs_shutdown(my_vfs);", "distractors": [], "indent": 1, "explanation": "Free all memory used by the VFS." },
        { "correct": "  printf(\"--- Demo Finished ---\\n\");", "distractors": [], "indent": 1, "explanation": "Final message." },
        { "correct": "  return 0;", "distractors": [], "indent": 1, "explanation": "Indicate success." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of main." }
    ]
},
// Level 100: Prep for Apple
{
    "goal": "Implement a reference counting system for managing the lifecycle of different types of objects, preventing memory leaks by automatically freeing objects when they are no longer referenced.",
    "concepts": "Reference counting, automatic memory management (ARC), object-oriented C, structs, function pointers (vtables), polymorphism",
    "sequence": [
        { "correct": "// === Stage 1: Base Object and VTable Definitions ===", "distractors": [], "indent": 0, "explanation": "Define the core structures for all objects and their 'virtual tables'." },
        { "correct": "#include <stdio.h>", "distractors": [], "indent": 0, "explanation": "For standard I/O." },
        { "correct": "#include <stdlib.h>", "distractors": [], "indent": 0, "explanation": "For memory management." },
        { "correct": "#include <string.h>", "distractors": [], "indent": 0, "explanation": "For string duplication." },
        { "correct": "// The base struct for all reference-counted objects.", "distractors": [], "indent": 0, "explanation": "Comment for BaseObject struct." },
        { "correct": "struct BaseObject;", "distractors": [], "indent": 0, "explanation": "Forward declaration of BaseObject." },
        { "correct": "// The 'virtual table' for polymorphic destruction.", "distractors": [], "indent": 0, "explanation": "Comment for the VTable struct." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start VTable definition." },
        { "correct": "  void (*destroy)(struct BaseObject* obj);", "distractors": [], "indent": 1, "explanation": "A function pointer to the type-specific destructor." },
        { "correct": "} VTable;", "distractors": [], "indent": 0, "explanation": "End VTable definition." },
        { "correct": "typedef struct BaseObject {", "distractors": [], "indent": 0, "explanation": "Start BaseObject definition." },
        { "correct": "  int ref_count;", "distractors": [], "indent": 1, "explanation": "The number of references to this object." },
        { "correct": "  const VTable* vtable;", "distractors": [], "indent": 1, "explanation": "Pointer to the vtable for this object's type." },
        { "correct": "} BaseObject;", "distractors": [], "indent": 0, "explanation": "End BaseObject definition." },
        { "correct": "// --- Core API Prototypes ---", "distractors": [], "indent": 0, "explanation": "Declare the retain/release API." },
        { "correct": "void object_retain(BaseObject* obj);", "distractors": [], "indent": 0, "explanation": "Increments an object's reference count." },
        { "correct": "void object_release(BaseObject* obj);", "distractors": [], "indent": 0, "explanation": "Decrements an object's reference count and destroys it if the count reaches zero." },
        { "correct": "// === Stage 2: Retain and Release API Implementation ===", "distractors": [], "indent": 0, "explanation": "Implement the core memory management functions." },
        { "correct": "void object_retain(BaseObject* obj) {", "distractors": [], "indent": 0, "explanation": "Begin `object_retain`." },
        { "correct": "  if (obj) {", "distractors": [], "indent": 1, "explanation": "Ensure the object pointer is not NULL." },
        { "correct": "    obj->ref_count++;", "distractors": [], "indent": 2, "explanation": "Increment the reference count." },
        { "correct": "    printf(\"[RC] Retain: obj at %p, new ref_count = %d\\n\", obj, obj->ref_count);", "distractors": [], "indent": 2, "explanation": "Log the retain operation." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End NULL check." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `object_retain`." },
        { "correct": "void object_release(BaseObject* obj) {", "distractors": [], "indent": 0, "explanation": "Begin `object_release`." },
        { "correct": "  if (obj) {", "distractors": [], "indent": 1, "explanation": "Ensure the object pointer is not NULL." },
        { "correct": "    obj->ref_count--;", "distractors": [], "indent": 2, "explanation": "Decrement the reference count." },
        { "correct": "    printf(\"[RC] Release: obj at %p, new ref_count = %d\\n\", obj, obj->ref_count);", "distractors": [], "indent": 2, "explanation": "Log the release operation." },
        { "correct": "    if (obj->ref_count == 0) {", "distractors": [], "indent": 2, "explanation": "Check if the reference count has dropped to zero." },
        { "correct": "      printf(\"[RC] Destroying obj at %p...\\n\", obj);", "distractors": [], "indent": 3, "explanation": "Log the impending destruction." },
        { "correct": "      // Use the vtable to call the type-specific destructor", "distractors": [], "indent": 3, "explanation": "Comment on using the vtable." },
        { "correct": "      obj->vtable->destroy(obj);", "distractors": [], "indent": 3, "explanation": "Call the appropriate destructor via function pointer." },
        { "correct": "      free(obj);", "distractors": [], "indent": 3, "explanation": "Free the memory for the BaseObject itself." },
        { "correct": "    }", "distractors": [], "indent": 2, "explanation": "End zero-count check." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End NULL check." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `object_release`." },
        { "correct": "// === Stage 3: Concrete Object Type - StringObject ===", "distractors": [], "indent": 0, "explanation": "Define and implement a reference-counted string object." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start StringObject definition." },
        { "correct": "  BaseObject base;", "distractors": [], "indent": 1, "explanation": "Must be the first member to allow casting." },
        { "correct": "  char* value;", "distractors": [], "indent": 1, "explanation": "The string data this object holds." },
        { "correct": "} StringObject;", "distractors": [], "indent": 0, "explanation": "End StringObject definition." },
        { "correct": "// Function prototypes for StringObject", "distractors": [], "indent": 0, "explanation": "Forward declarations for string functions." },
        { "correct": "void string_destroy(BaseObject* obj);", "distractors": [], "indent": 0, "explanation": "Destructor for StringObject." },
        { "correct": "StringObject* string_create(const char* value);", "distractors": [], "indent": 0, "explanation": "Constructor for StringObject." },
        { "correct": "static const VTable STRING_VTABLE = { .destroy = string_destroy };", "distractors": [], "indent": 0, "explanation": "Define the vtable for StringObjects." },
        { "correct": "void string_destroy(BaseObject* obj) {", "distractors": [], "indent": 0, "explanation": "Begin `string_destroy`." },
        { "correct": "  StringObject* self = (StringObject*)obj;", "distractors": [], "indent": 1, "explanation": "Cast the base object pointer back to a StringObject pointer." },
        { "correct": "  printf(\"  -> string_destroy: freeing value '%s'\\n\", self->value);", "distractors": [], "indent": 1, "explanation": "Log the specific destruction action." },
        { "correct": "  free(self->value);", "distractors": [], "indent": 1, "explanation": "Free the character data." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `string_destroy`." },
        { "correct": "StringObject* string_create(const char* value) {", "distractors": [], "indent": 0, "explanation": "Begin `string_create`." },
        { "correct": "  StringObject* obj = malloc(sizeof(StringObject));", "distractors": [], "indent": 1, "explanation": "Allocate memory for the new StringObject." },
        { "correct": "  obj->base.ref_count = 1;", "distractors": [], "indent": 1, "explanation": "Initialize reference count to 1 for the new reference." },
        { "correct": "  obj->base.vtable = &STRING_VTABLE;", "distractors": [], "indent": 1, "explanation": "Point the vtable to our string vtable." },
        { "correct": "  obj->value = strdup(value);", "distractors": [], "indent": 1, "explanation": "Duplicate the provided string." },
        { "correct": "  printf(\"[RC] Create: StringObject at %p with value '%s', ref_count = 1\\n\", obj, obj->value);", "distractors": [], "indent": 1, "explanation": "Log the creation event." },
        { "correct": "  return obj;", "distractors": [], "indent": 1, "explanation": "Return the newly created object." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `string_create`." },
        { "correct": "// === Stage 4: Concrete Object Type - ListObject ===", "distractors": [], "indent": 0, "explanation": "Define and implement a reference-counted list object that can hold other objects." },
        { "correct": "#define LIST_INITIAL_CAPACITY 4", "distractors": [], "indent": 0, "explanation": "Initial capacity for our list." },
        { "correct": "typedef struct {", "distractors": [], "indent": 0, "explanation": "Start ListObject definition." },
        { "correct": "  BaseObject base;", "distractors": [], "indent": 1, "explanation": "Base object header." },
        { "correct": "  BaseObject** items;", "distractors": [], "indent": 1, "explanation": "A dynamic array of pointers to other reference-counted objects." },
        { "correct": "  size_t size;", "distractors": [], "indent": 1, "explanation": "Current number of items in the list." },
        { "correct": "  size_t capacity;", "distractors": [], "indent": 1, "explanation": "Current allocated capacity of the items array." },
        { "correct": "} ListObject;", "distractors": [], "indent": 0, "explanation": "End ListObject definition." },
        { "correct": "// Function prototypes for ListObject", "distractors": [], "indent": 0, "explanation": "Forward declarations for list functions." },
        { "correct": "void list_destroy(BaseObject* obj);", "distractors": [], "indent": 0, "explanation": "Destructor for ListObject." },
        { "correct": "ListObject* list_create();", "distractors": [], "indent": 0, "explanation": "Constructor for ListObject." },
        { "correct": "void list_append(ListObject* list, BaseObject* item);", "distractors": [], "indent": 0, "explanation": "Appends an item to the list." },
        { "correct": "static const VTable LIST_VTABLE = { .destroy = list_destroy };", "distractors": [], "indent": 0, "explanation": "Define the vtable for ListObjects." },
        { "correct": "void list_destroy(BaseObject* obj) {", "distractors": [], "indent": 0, "explanation": "Begin `list_destroy`." },
        { "correct": "  ListObject* self = (ListObject*)obj;", "distractors": [], "indent": 1, "explanation": "Cast the base object pointer." },
        { "correct": "  printf(\"  -> list_destroy: releasing %zu items\\n\", self->size);", "distractors": [], "indent": 1, "explanation": "Log the list destruction." },
        { "correct": "  // Release every object this list holds a reference to", "distractors": [], "indent": 1, "explanation": "Comment on the crucial cascade release." },
        { "correct": "  for (size_t i = 0; i < self->size; i++) {", "distractors": [], "indent": 1, "explanation": "Loop through all items in the list." },
        { "correct": "    object_release(self->items[i]);", "distractors": [], "indent": 2, "explanation": "Release the list's reference to the item." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End item loop." },
        { "correct": "  free(self->items);", "distractors": [], "indent": 1, "explanation": "Free the array of pointers itself." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `list_destroy`." },
        { "correct": "ListObject* list_create() {", "distractors": [], "indent": 0, "explanation": "Begin `list_create`." },
        { "correct": "  ListObject* obj = malloc(sizeof(ListObject));", "distractors": [], "indent": 1, "explanation": "Allocate memory for the ListObject." },
        { "correct": "  obj->base.ref_count = 1;", "distractors": [], "indent": 1, "explanation": "Initialize ref count to 1." },
        { "correct": "  obj->base.vtable = &LIST_VTABLE;", "distractors": [], "indent": 1, "explanation": "Set the vtable pointer." },
        { "correct": "  obj->size = 0;", "distractors": [], "indent": 1, "explanation": "List starts empty." },
        { "correct": "  obj->capacity = LIST_INITIAL_CAPACITY;", "distractors": [], "indent": 1, "explanation": "Set initial capacity." },
        { "correct": "  obj->items = malloc(obj->capacity * sizeof(BaseObject*));", "distractors": [], "indent": 1, "explanation": "Allocate the initial items array." },
        { "correct": "  printf(\"[RC] Create: ListObject at %p, ref_count = 1\\n\", obj);", "distractors": [], "indent": 1, "explanation": "Log creation." },
        { "correct": "  return obj;", "distractors": [], "indent": 1, "explanation": "Return the new list." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `list_create`." },
        { "correct": "void list_append(ListObject* list, BaseObject* item) {", "distractors": [], "indent": 0, "explanation": "Begin `list_append`." },
        { "correct": "  if (list->size >= list->capacity) { /* Simple resize logic, not production-ready */", "distractors": [], "indent": 1, "explanation": "Check if resize is needed." },
        { "correct": "    list->capacity *= 2;", "distractors": [], "indent": 2, "explanation": "Double the capacity." },
        { "correct": "    list->items = realloc(list->items, list->capacity * sizeof(BaseObject*));", "distractors": [], "indent": 2, "explanation": "Reallocate the items array." },
        { "correct": "  }", "distractors": [], "indent": 1, "explanation": "End resize block." },
        { "correct": "  // The list is taking ownership of a reference, so we must retain.", "distractors": [], "indent": 1, "explanation": "Comment on the required retain call." },
        { "correct": "  object_retain(item);", "distractors": [], "indent": 1, "explanation": "Increment the item's ref count because the list now points to it." },
        { "correct": "  list->items[list->size] = item;", "distractors": [], "indent": 1, "explanation": "Add the item to the list." },
        { "correct": "  list->size++;", "distractors": [], "indent": 1, "explanation": "Increment the list size." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End `list_append`." },
        { "correct": "// === Stage 5: Main Program for Demonstration ===", "distractors": [], "indent": 0, "explanation": "The main function to demonstrate the reference counting system." },
        { "correct": "int main() {", "distractors": [], "indent": 0, "explanation": "Start of main." },
        { "correct": "  printf(\"--- Reference Counting Demo ---\\n\");", "distractors": [], "indent": 1, "explanation": "Demo title." },
        { "correct": "  // Create a list object. It is now owned by the 'my_list' variable.", "distractors": [], "indent": 1, "explanation": "Comment on creating the list." },
        { "correct": "  ListObject* my_list = list_create();", "distractors": [], "indent": 1, "explanation": "Create a list. ref_count=1." },
        { "correct": "  printf(\"\\n--- Populating List ---\\n\");", "distractors": [], "indent": 1, "explanation": "Header for population." },
        { "correct": "  // Create a string object. It is now owned by the 'str1' variable.", "distractors": [], "indent": 1, "explanation": "Comment on creating the first string." },
        { "correct": "  StringObject* str1 = string_create(\"Hello, Apple\");", "distractors": [], "indent": 1, "explanation": "Create string 1. ref_count=1." },
        { "correct": "  // Add the string to the list. The list now also owns a reference.", "distractors": [], "indent": 1, "explanation": "Comment on appending." },
        { "correct": "  list_append(my_list, (BaseObject*)str1);", "distractors": [], "indent": 1, "explanation": "Append str1. retain is called, str1->ref_count becomes 2." },
        { "correct": "  // We can release our original reference. The object will live on in the list.", "distractors": [], "indent": 1, "explanation": "Comment on releasing local variable's reference." },
        { "correct": "  object_release((BaseObject*)str1);", "distractors": [], "indent": 1, "explanation": "Release str1. ref_count drops to 1. It is not destroyed." },
        { "correct": "  // Append two more strings directly.", "distractors": [], "indent": 1, "explanation": "Comment on creating and appending in one go." },
        { "correct": "  list_append(my_list, (BaseObject*)string_create(\"Cupertino\"));", "distractors": [], "indent": 1, "explanation": "Create string 2 (ref_count=1), then append calls retain (ref_count=2)." },
        { "correct": "  list_append(my_list, (BaseObject*)string_create(\"Think Different\"));", "distractors": [], "indent": 1, "explanation": "Create string 3 (ref_count=1), then append calls retain (ref_count=2)." },
        { "correct": "  // We don't have local variables for the last two strings, but the list holds them.", "distractors": [], "indent": 1, "explanation": "Explanation for why we don't release the last two strings here." },
        { "correct": "  // Note: a better API would return the created object, which we would then release.", "distractors": [], "indent": 1, "explanation": "This shows a subtle memory leak in the demo code itself if not handled carefully." },
        { "correct": "  // For this demo, let's fix the above 'leaks' by releasing the temporary references.", "distractors": [], "indent": 1, "explanation": "Let's be explicit for the demo." },
        { "correct": "  object_release(my_list->items[1]);", "distractors": [], "indent": 1, "explanation": "Release the 'Cupertino' reference created by string_create. Its ref_count is now 1 (held by list)." },
        { "correct": "  object_release(my_list->items[2]);", "distractors": [], "indent": 1, "explanation": "Release the 'Think Different' reference. Its ref_count is now 1." },
        { "correct": "  printf(\"\\n--- Triggering Cascade Release ---\\n\");", "distractors": [], "indent": 1, "explanation": "Header for cascade test." },
        { "correct": "  // Now, we release our only reference to the list.", "distractors": [], "indent": 1, "explanation": "Comment on the final release." },
        { "correct": "  // This should trigger the list's destruction, which in turn will release all its items.", "distractors": [], "indent": 1, "explanation": "Explain the expected cascade." },
        { "correct": "  object_release((BaseObject*)my_list);", "distractors": [], "indent": 1, "explanation": "Release the list. Its ref_count drops to 0, and the cascade begins." },
        { "correct": "  printf(\"--- Demo Finished ---\\n\");", "distractors": [], "indent": 1, "explanation": "Final message." },
        { "correct": "  return 0;", "distractors": [], "indent": 1, "explanation": "Indicate success." },
        { "correct": "}", "distractors": [], "indent": 0, "explanation": "End of main." }
    ]
}
]