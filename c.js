const challengesData = [
    // Level 1: Simple For Loop
    {
        goal: "Print numbers 0 to 4 using a for loop.",
        concepts: "Includes, main function, for loop, printf",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`stdlib.h` contains general utility functions (like memory allocation, random numbers), but `printf` requires the Standard Input/Output library, which is `stdio.h`.'}, {text: '#import <stdio.h>', reason: 'Standard C uses the `#include` preprocessor directive. `#import` is a similar concept but specific to Objective-C and not part of standard C.'}], indent: 0, explanation: "Includes the Standard Input/Output library for functions like printf." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'The C standard (like C99, C11) specifies that `main` must return `int` to signal the program\'s exit status to the OS (0 for success). `void main()` is non-standard, though some compilers might allow it.'}, {text: 'function main() {', reason: 'The keyword `function` is used in languages like JavaScript to define functions, but in C, you define a function by specifying its return type (e.g., `int`), name, parameters, and body `{}`.'}], indent: 0, explanation: "The main function where program execution begins. It returns an integer." },
            { correct: 'for(int i = 0; i < 5; i++) {', distractors: [{text: 'while(int i < 5) {', reason: 'A `while` loop only checks a condition. Variable declaration (`int i`) is not allowed inside the `while` condition parentheses, and initialization/increment must happen separately before/inside the loop body.'}, {text: 'if(i < 5) {', reason: 'An `if` statement executes its block only *once* if the condition is true. A `for` loop is needed to *repeat* the block multiple times based on initialization, condition, and increment steps.'}], indent: 1, explanation: "A for loop: initializes i=0, continues while i<5, increments i after each loop." },
            { correct: 'printf("Count: %d\\n", i);', distractors: [{text: 'print("Count: %d", i);', reason: 'The standard C library function for formatted output is `printf` (print formatted). There is no standard function named `print`.'}, {text: 'console.log(i);', reason: '`console.log` is the function used for printing output in JavaScript environments (like browsers or Node.js), not in standard C.'}], indent: 2, explanation: "Prints formatted text. %d is a placeholder for an integer (i), \\n is a newline." },
            { correct: '}', distractors: [{text: 'end for;', reason: 'C uses matching curly braces `{` and `}` to define the start and end of code blocks (like loops, functions, if-statements). Keywords like `end` are not used for this.'}, {text: 'break;', reason: 'The `break;` statement is used to exit *early* from a loop (for, while, do-while) or switch statement. It does not define the normal end of the loop block.'}], indent: 1, explanation: "Closes the for loop block." },
            { correct: 'return 0;', distractors: [{text: 'exit(0);', reason: '`exit(0)` (from `stdlib.h`) forces immediate program termination from anywhere. `return 0;` specifically indicates the successful completion *of the `main` function* and allows normal program cleanup.'}, {text: 'return;', reason: 'The `main` function is declared as `int main()`, meaning it must return an integer value. `return;` is only valid for functions declared with a `void` return type.'}], indent: 1, explanation: "Indicates successful program execution by returning 0 from main." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'C uses curly braces `{}` to define code blocks. Keywords like `end` are not part of the C syntax for ending functions.'}, {text: '};', reason: 'A semicolon `;` is used to terminate statements in C, but it is *not* placed after the closing curly brace `}` that defines the end of a function body.'}], indent: 0, explanation: "Closes the main function block." }
        ]
    },
    // Level 2: Simple If Statement
    {
        goal: "Check if a variable is positive and print a message.",
        concepts: "Variables, if statement, comparison operators",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <math.h>', reason: 'The `math.h` header provides mathematical functions (like `sqrt`, `pow`, `sin`). It is not needed for basic comparison (`>`) or printing (`printf`).'}, {text: 'using namespace std;', reason: '`using namespace std;` is a C++ directive to avoid prefixing standard library elements with `std::`. It is not used or needed in standard C.'}], indent: 0, explanation: "Include the library needed for printing output."},
            { correct: 'int main() {', distractors: [{text: 'int start() {', reason: 'By convention and standard, the execution of a C program begins in the function named `main`. Other names like `start` won\'t be automatically recognized as the entry point.'}, {text: 'void main() {', reason: 'Standard C (like C99, C11) requires `main` to return an `int` value to indicate the program\'s exit status to the operating system. `void main()` is non-standard.'}], indent: 0, explanation: "Start the main execution block."},
            { correct: 'int number = 10;', distractors: [{text: 'float number = 10.0;', reason: 'While `float` can store 10.0, the task involves a simple positive/non-positive check. Using `int` (integer) is more direct and common for such whole number operations.'}, {text: 'char number = \'A\';', reason: 'A `char` variable stores a character value (like \'A\'). Comparing it with `> 0` might yield unexpected results based on its ASCII value, and it doesn\'t fit the goal of checking a numerical value.'}], indent: 1, explanation: "Declare an integer variable 'number' and give it a value." },
            { correct: 'if (number > 0) {', distractors: [{text: 'if number > 0:', reason: 'In C, the conditional expression following the `if` keyword *must* be enclosed within parentheses `()`. The colon `:` is used in languages like Python, not C.'}, {text: 'while (number > 0) {', reason: 'A `while` loop repeatedly executes the code block as long as the condition is true. An `if` statement executes the block only *once* if the condition is true, which is needed here.'}], indent: 1, explanation: "Check if the value of 'number' is greater than zero." },
            { correct: 'printf("Number is positive.\\n");', distractors: [{text: 'printf(number);', reason: '`printf` requires a "format string" as the first argument to specify *how* to print the following arguments. To print an integer, you need `printf("%d\\n", number);`.'}, {text: 'echo "Positive";', reason: '`echo` is a command typically used in shell environments (like Bash or Command Prompt) to display text, not a function available within standard C.'}], indent: 2, explanation: "If the condition was true, print this message." },
            { correct: '}', distractors: [{text: 'end if;', reason: 'C uses curly braces `{}` to define the beginning and end of code blocks associated with control structures like `if`. Keywords are not used to end blocks.'}, {text: 'stop;', reason: '`stop` is not a recognized keyword or command in the standard C language.'}], indent: 1, explanation: "Closes the if statement block." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Conventionally, returning `0` from `main` indicates success, while returning a non-zero value (like `1`) signals an error or abnormal termination to the operating system.'}, {text: 'end;', reason: '`end` is not a C keyword. Use `return` followed by a value (for non-void functions) to exit a function.'}], indent: 1, explanation: "Signal that the program finished successfully."},
            { correct: '}', distractors: [{text: 'finish', reason: '`finish` is not a C keyword used for ending code blocks or functions.'}, {text: 'end main', reason: 'C uses the closing curly brace `}` to signify the end of the `main` function\'s code block.'}], indent: 0, explanation: "Closes the main function block." }
        ]
    },
    // Level 3: Basic Function Call
    {
        goal: "Define and call a simple function to add two numbers.",
        concepts: "Function declaration (prototype), function definition, function call, return value",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text:'#include <functions.h>', reason:'There is no standard C header file named `functions.h`. Header files typically group related declarations (like `stdio.h` for I/O).'}, {text:'#include <iostream>', reason:'`<iostream>` is the standard input/output header file for C++, used with `cout` and `cin`. C uses `<stdio.h>` for `printf` and `scanf`.'}], indent: 0, explanation: "Include necessary library for input/output."},
            { correct: '// Function declaration (prototype)', distractors: [{text:'// Variable declaration', reason:'This comment is misleading; the next line declares a function, not a variable.'}, {text:'// Loop setup', reason:'This comment is inaccurate; the next line is about a function, not setting up a loop.'}], indent: 0, explanation: "Add a comment explaining the next line's purpose."},
            { correct: 'int add(int a, int b);', distractors: [{text:'void add(int a, int b);', reason:'The function is intended to calculate and *return* the sum, which is an integer. Declaring it as `void` means it wouldn\'t return any value, contradicting the goal.'}, {text:'function add(a, b);', reason:'C requires explicit type declarations. You must specify the return type (`int`) and the type of each parameter (`int a`, `int b`). The keyword `function` is not used.'}], indent: 0, explanation: "Declare the 'add' function: specify return type (int) and parameter types (int, int)."},
            { correct: 'int main() {', distractors: [{text:'void main() {', reason:'Standard C requires `main` to return `int` to signal success (0) or failure (non-zero) to the OS.'}, {text:'program start {', reason:'C program execution starts in `int main() { ... }`. Other syntax is incorrect.'}], indent: 0, explanation: "Begin the main function."},
            { correct: 'int result = add(5, 3);', distractors: [{text:'int result = 5 + 3;', reason:'This performs the addition directly within `main`. The goal is to demonstrate defining and *calling* a separate `add` function.'}, {text:'call add(5, 3);', reason:'In C, you call a function simply by using its name followed by arguments in parentheses `()`. The keyword `call` is not used for function invocation.'}], indent: 1, explanation: "Call the 'add' function, pass 5 and 3 as arguments, and store the returned value in 'result'."},
            { correct: 'printf("Result: %d\\n", result);', distractors: [{text:'printf(result);', reason:'`printf` needs a format specifier (like `%d` for integers) within the format string (first argument) to know how to interpret and print the variable `result`.'}, {text:'print result;', reason:'`print` is not a standard C function. You must use `printf` for formatted output.'}], indent: 1, explanation: "Print the calculated result."},
            { correct: 'return 0;', distractors: [{text:'return result;', reason:'The `main` function should return `0` to indicate successful execution to the operating system, not the calculated value from the `add` function.'}, {text:'exit main;', reason:'Keywords like `exit` are not used to end `main` normally; use `return 0;`.'}], indent: 1, explanation: "Exit the main function successfully."},
            { correct: '}', distractors: [{text:'end program;', reason:'C uses the closing curly brace `}` to mark the end of the `main` function block.'}, {text:'stop;', reason:'`stop` is not a C keyword.'}], indent: 0, explanation: "Closes the main function block." },
            { correct: '// Function definition', distractors: [{text:'// Main loop', reason:'This comment is incorrect; the following code defines the `add` function, not a loop within `main`.'}, {text:'// Variable setup', reason:'This comment is inaccurate; the following code is the implementation of the `add` function.'}], indent: 0, explanation: "Add a comment indicating the start of the function's code."},
            { correct: 'int add(int a, int b) {', distractors: [{text:'void add(int a, int b) {', reason:'The function *definition* must match the *declaration* (prototype). Since it was declared to return `int`, the definition must also specify `int`.'}, {text:'define add(a, b) {', reason:'`#define` is a preprocessor directive for macros, not for defining functions. Function definitions require specifying return and parameter types.'}], indent: 0, explanation: "Define the 'add' function, matching the declaration."},
            { correct: 'return a + b;', distractors: [{text:'print a + b;', reason:'The purpose of this function, as declared, is to *return* the calculated sum, not to print it directly. Printing should happen in `main` using the returned value.'}, {text:'result = a + b;', reason:'This assigns the sum to a variable named `result`, but `result` hasn\'t been declared within this function scope, and more importantly, the value isn\'t being *returned* to the caller.'}], indent: 1, explanation: "Perform the addition and return the sum."},
            { correct: '}', distractors: [{text:'end function;', reason:'C uses the closing curly brace `}` to mark the end of the function\'s definition block.'}, {text:'end add;', reason:'C uses the closing curly brace `}` to mark the end of the function\'s definition block, not keywords.'}], indent: 0, explanation: "Closes the add function block." }
        ]
    },
    // Level 4: Basic Input with scanf
    {
        goal: "Read an integer from the user and print it.",
        concepts: "scanf, printf, variables, address-of operator (&)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <input.h>', reason: 'There is no standard C header named `input.h`. Input/output functions like `scanf` and `printf` are in `stdio.h`.'}, {text: '#include <iostream>', reason: '`<iostream>` is the C++ header for input/output using `cin` and `cout`. C uses `<stdio.h>`.'}], indent: 0, explanation: "Include the standard input/output library." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return an integer (`int`) to indicate exit status.'}, {text: 'main function {', reason: 'C function definition requires a return type before the name and parentheses `()`. '}], indent: 0, explanation: "Start the main function." },
            { correct: 'int userInput;', distractors: [{text: 'var userInput;', reason: 'C is statically typed; you must declare the type explicitly (like `int`, `float`, `char`). `var` is used in languages like JavaScript.'}, {text: 'integer userInput;', reason: 'The keyword for the integer data type in C is `int`, not `integer`.'}], indent: 1, explanation: "Declare an integer variable to store the user's input." },
            { correct: 'printf("Enter an integer: ");', distractors: [{text: 'print("Enter an integer: ");', reason: 'The standard C function for formatted output is `printf`.'}, {text: 'scanf("Enter an integer: ");', reason: '`scanf` is used for *reading* formatted input, not for *printing* prompts.'}], indent: 1, explanation: "Prompt the user to enter a number." },
            { correct: 'scanf("%d", &userInput);', distractors: [{text: 'scanf("%d", userInput);', reason: '`scanf` needs the memory *address* where it should store the input. The address-of operator `&` is required before the variable name (`&userInput`).'}, {text: 'scanf(userInput);', reason: '`scanf` requires a format string (like `"%d"`) to specify the type of input expected and the address (`&variable`) to store it.'}], indent: 1, explanation: "Read an integer (%d) from input and store it at the address of 'userInput'." },
            { correct: 'printf("You entered: %d\\n", userInput);', distractors: [{text: 'printf("You entered: %d\\n", &userInput);', reason: '`printf` needs the *value* of the variable to print it. Passing the address (`&userInput`) would print the memory address, not the stored integer.'}, {text: 'printf(userInput);', reason: '`printf` requires a format string as the first argument to specify how to print the subsequent arguments.'}], indent: 1, explanation: "Print the value stored in the 'userInput' variable." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Returning 0 from `main` conventionally indicates successful execution. Non-zero often indicates an error.'}, {text: 'return userInput;', reason: '`main` should return an exit status (0 for success), not a variable\'s value unless intended as an exit code.'}], indent: 1, explanation: "Indicate successful program execution." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'C uses `}` to close function blocks.'}, {text: '};', reason: 'A semicolon `;` is used after `struct` definitions, but not after the closing brace `}` of a function.'}], indent: 0, explanation: "Close the main function block." }
        ]
    },
    // Level 5: Floating-Point Arithmetic
    {
        goal: "Calculate the area of a circle given its radius (using float).",
        concepts: "float data type, arithmetic operators, constants (#define), math.h",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason:'`stdlib.h` is for general utilities, not core I/O or math constants like M_PI.'}, {text:'#include <maths.h>', reason:'The standard math header is `<math.h>`, not `<maths.h>`.'}], indent: 0, explanation: "Include standard input/output for printing." },
            { correct: '#include <math.h>', distractors: [{text: '#include "math.h"', reason:'While sometimes permissible, standard library headers are conventionally included using angle brackets `< >`.'}, {text:'#include <float.h>', reason:'`<float.h>` defines properties of floating-point types, but not the `M_PI` constant or math functions like `pow()`.'}], indent: 0, explanation: "Include math library for constants like M_PI and functions like pow()." },
            { correct: '#define PI 3.14159f', distractors: [{text: '#define PI = 3.14159f;', reason:'`#define` is a preprocessor directive; it does not use `=` for assignment or usually end with a semicolon (the semicolon would become part of the replacement).'}, {text:'const float PI = 3.14159f;', reason:'Using `const float` is a more type-safe way to define constants in modern C, but `#define` is also common and widely used, especially in older codebases.'}], indent: 0, explanation: "Define a constant for PI (using 'f' suffix for float literal)." },
            { correct: 'int main() {', distractors: [{text:'float main() {', reason:'The C standard requires `main` to return `int`.'}, {text:'void main() {', reason:'Standard C requires `main` to return `int`. `void main` is non-standard.'}], indent: 0, explanation: "Start the main function." },
            { correct: 'float radius = 5.0f;', distractors: [{text: 'int radius = 5;', reason:'For calculations potentially involving decimals (like area with PI), using `float` or `double` provides more accurate results.'}, {text:'float radius = 5.0;', reason:'Appending `f` (e.g., `5.0f`) explicitly marks the literal as a `float`, avoiding potential implicit conversions from `double` if `5.0` were treated as `double` by default.'}], indent: 1, explanation: "Declare a float variable 'radius' and initialize it." },
            { correct: 'float area;', distractors: [{text: 'area = 0.0f;', reason:'Declaring the variable (`float area;`) must happen before assigning a value to it.'}, {text:'float area()', reason:'This syntax resembles a function declaration (`float area() { ... }`), not a variable declaration.'}], indent: 1, explanation: "Declare a float variable 'area' to store the result." },
            { correct: 'area = PI * radius * radius;', distractors: [{text: 'area = PI * (radius^2);', reason:'The `^` operator in C is the bitwise XOR operator, not exponentiation. Use `radius * radius` or `pow(radius, 2.0f)` from `<math.h>`.'}, {text:'area = PI * pow(radius, 2);', reason:'Using `pow()` from `<math.h>` is also correct (though `pow` typically takes `double` arguments, `radius` would be promoted). `radius * radius` is simpler for squaring.'}], indent: 1, explanation: "Calculate the area using the formula (PI * r^2)." },
            { correct: 'printf("Area: %.2f\\n", area);', distractors: [{text: 'printf("Area: %d\\n", area);', reason:'`%d` is the format specifier for integers. For floats, use `%f`. `%.2f` specifically formats it to 2 decimal places.'}, {text: 'printf("Area: %f.2\\n", area);', reason:'Format specifiers for precision come *before* the type character, like `%.2f`, not after (`%f.2`).'}], indent: 1, explanation: "Print the calculated area, formatted to 2 decimal places (%.2f)." },
            { correct: 'return 0;', distractors: [{text:'return area;', reason:'`main` should return 0 for success, not the calculated area value (unless intended as a specific exit code).'}, {text:'exit(0);', reason:'`return 0;` is the standard and preferred way to indicate success from `main`, allowing normal cleanup. `exit(0)` terminates immediately.'}], indent: 1, explanation: "Indicate successful execution." },
            { correct: '}', distractors: [{text:'end;', reason:'`end` is not a C keyword.'}, {text:'});', reason:'Parentheses and semicolons mark the end of statements or expressions, not code blocks.'}], indent: 0, explanation: "Close the main function." }
        ]
    },
    // Level 6: Character ASCII Value Even/Odd Check
    {
        goal: "Read a single character, get its integer ASCII value, and determine if that value is even or odd.",
        concepts: "char data type, getchar, printf, if-else statement, modulo operator (%)",
        sequence: [
            { correct: "#include <stdio.h>", distractors: [{text:"#include <stdlib.h>", reason:"`stdlib.h` is for general utilities. The functions for input/output like `printf` and `getchar` are in `stdio.h`."}, {text:"import stdio", reason:"`import` is not used in C; use `#include`."}], indent: 0, explanation: "Include the Standard Input/Output library for functions like `printf` and `getchar`." },
            { correct: "int main() {", distractors: [{text:"void main() {", reason:"Standard C requires `main` to return `int` to signal the program's exit status. `void main()` is non-standard."}, {text:"main() {", reason:"Missing return type for `main`. Should be `int main()`."}], indent: 0, explanation: "The main function where program execution begins." },
            { correct: "char inputChar;", distractors: [{text:"int inputChar;", reason:"While an `int` can store a character, using the `char` type is more idiomatic and clearly expresses the intent to store a character value."}, {text:"string inputChar;", reason:"`string` is not a built-in type in C."}], indent: 1, explanation: "Declare a variable of type `char` to store the user's input." },
            { correct: "printf(\"Enter a character: \");", distractors: [{text:"puts(\"Enter a character: \");", reason:"`puts` adds a newline automatically; `printf` provides better control."}, {text:"cout << \"Enter a character: \";", reason:"`cout` is a C++ feature, not C."}], indent: 1, explanation: "Prompt the user for input." },
            { correct: "inputChar = getchar();", distractors: [{text:"getchar(&inputChar);", reason:"`getchar()` returns a character; it doesn’t take a pointer argument."}, {text:"scanf(\"%c\", &inputChar);", reason:"`scanf(\"%c\", &inputChar)` works, but `getchar()` is simpler for reading a single character."}], indent: 1, explanation: "Read a single character from standard input." },
            { correct: "printf(\"Character: '%c'\\n\", inputChar);", distractors: [{text:"printf(\"Character: %s\\n\", &inputChar);", reason:"`%s` expects a null-terminated string; `%c` is for single characters."}, {text:"printf(inputChar);", reason:"`printf` requires a format string as the first argument to prevent security vulnerabilities."}], indent: 1, explanation: "Print the character that was entered." },
            { correct: "printf(\"ASCII Value: %d\\n\", inputChar);", distractors: [{text:"printf(\"ASCII Value: %c\\n\", inputChar);", reason:"`%c` would print the character itself again, not its numeric ASCII value. `%d` promotes the char to an int for printing."}, {text:"printf(\"ASCII Value: %u\\n\", inputChar);", reason:"`%d` is the standard choice for printing signed ASCII values, though `%u` would also work for standard characters."}], indent: 1, explanation: "Display the numeric ASCII value of the character." },
            { correct: "if (inputChar % 2 == 0) {", distractors: [{text:"if (inputChar % 2 = 0) {", reason:"The `=` operator is for assignment. The `==` operator is for comparison."}, {text:"if (inputChar / 2 * 2 == inputChar) {", reason:"While this logic is correct for positive integers, using the modulo operator `%` is the direct and idiomatic way to check for evenness."}], indent: 1, explanation: "Check if the ASCII value is an even number." },
            { correct: "printf(\"The ASCII value %d is EVEN.\\n\", inputChar);", distractors: [{text:"printf(\"Character is even.\\n\");", reason:"It's more informative to use `%d` to explicitly show the user which numeric value was checked."}, {text:"printf(\"%f is even.\\n\", inputChar);", reason:"`%f` is for floating-point numbers. A `char` is an integer type, so `%d` must be used."}], indent: 2, explanation: "Display that the ASCII value is even." },
            { correct: "} else {", distractors: [{text:"} if else {", reason:"The `else` keyword does not take a condition directly after it. Use `else if (condition)` or just `else`."}, {text:"} else (inputChar % 2 != 0) {", reason:"An `else` block does not take a condition in parentheses. It automatically handles all cases where the preceding `if` was false."}], indent: 1, explanation: "If the number was not even, this block executes." },
            { correct: "printf(\"The ASCII value %d is ODD.\\n\", inputChar);", distractors: [{text:"printf(\"Character is odd.\\n\");", reason:"It is better practice to print the actual numeric value with `%d` to provide full context."}, {text:"printf(\"It's odd!\\n\");", reason:"This is correct, but less informative than showing the value."}], indent: 2, explanation: "Display that the ASCII value is odd." },
            { correct: "}", distractors: [{text:"end if;", reason:"C uses curly braces `{}` to define code blocks, not keywords like `end`."}, {text:"};", reason:"A semicolon is not placed after the closing brace of a code block."}], indent: 1, explanation: "Close the else block." },
            { correct: "return 0;", distractors: [{text:"return inputChar;", reason:"Standard practice is to `return 0;` from `main` to indicate successful execution."}, {text:"end;", reason:"`end` is not a valid keyword in C."}], indent: 1, explanation: "Exit the program successfully." },
            { correct: "}", distractors: [{text:"finish;", reason:"`finish` is not a keyword in C."}, {text:"end main;", reason:"C uses a closing curly brace `}` to end a function block, not keywords."}], indent: 0, explanation: "Close the main function." }
        ]
    },
    // Level 7: Countdown with While Loop
    {
        goal: "Print numbers from 10 down to 1 using a while loop.",
        concepts: "while loop, decrement operator (--)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`stdlib.h` is for general utilities, not the `printf` function, which is in `stdio.h`.'}, {text: '#include "stdio.h"', reason: 'Using angle brackets `<>` is the convention for standard library headers, telling the compiler to look in standard system directories.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return `int`.'}, {text: 'int main(void) {', reason: 'This is also a correct way to declare main with no arguments, but `int main()` is more common.'}], indent: 0, explanation: "Start main function." },
            { correct: 'int counter = 10;', distractors: [{text:'int counter;', reason:'The counter needs an initial value (10) before the loop condition `counter >= 1` is checked.'}, {text:'int counter = 11;', reason:'Starting at 11 and using `--counter` inside the loop would work, but initializing directly to 10 is simpler.'}], indent: 1, explanation: "Initialize a counter variable to 10." },
            { correct: 'while (counter >= 1) {', distractors: [{text: 'while counter >= 1 {', reason:'The condition in a `while` loop must be enclosed in parentheses `()`. '}, {text:'while (counter > 0) {', reason:'Using `> 0` is equivalent to `>= 1` for integers and also correct.'}], indent: 1, explanation: "Start a loop that continues as long as 'counter' is greater than or equal to 1." },
            { correct: 'printf("%d ", counter);', distractors: [{text:'printf(counter);', reason:'`printf` requires a format string like `"%d "`.'}, {text:'printf("%d\\n", counter);', reason:'Using `\\n` prints each number on a new line. Using a space `" "` prints them on the same line as requested.'}], indent: 2, explanation: "Print the current value of the counter." },
            { correct: 'counter--;', distractors: [{text: 'counter ++;', reason:'`++` increments the counter. `--` is needed to decrement (count down).'}, {text:'--counter;', reason:'Both pre-decrement (`--counter`) and post-decrement (`counter--`) work here as standalone statements.'}], indent: 2, explanation: "Decrement the counter by 1." },
            { correct: '}', distractors: [{text:'end while;', reason:'C uses `}` to close loops.'}, {text:'break;', reason:'`break` would exit the loop prematurely after the first iteration.'}], indent: 1, explanation: "Close the while loop block." },
            { correct: 'printf("\\n"); // Print a final newline', distractors: [{text:'println();', reason:'`println` is not a standard C function.'}, {text: 'printf(\'\\n\');', reason: '`printf` expects a string literal (double quotes \" \") for the format string, not a character literal (single quotes \' \').'}], indent: 1, explanation: "Print a newline character for cleaner output after the loop." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to signal success. Non-zero values typically indicate an error.'}, {text: 'exit(0);', reason: '`exit(0)` is a valid way to terminate, but `return 0;` is the standard way to exit the `main` function.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: '`end` is not a C keyword.'}, {text: '};', reason: 'A semicolon is not placed after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 8: Input Validation with Do-While
    {
        goal: "Ask the user to enter a positive number, repeat until they do.",
        concepts: "do-while loop, scanf",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: 'include <stdio.h>;', reason: 'The preprocessor directive must start with `#` and should not end with a semicolon.'}, {text: '#include <iostream>', reason: '`<iostream>` is the C++ header for I/O. For `printf` and `scanf`, use `<stdio.h>`.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'The `main` function must be declared to return `int` in standard C.'}, {text: 'function main() {', reason: 'C does not use the `function` keyword. A function is defined by its return type, name, and parameters.'}], indent: 0, explanation: "Start main function." },
            { correct: 'int number;', distractors: [{text:'int number = 0;', reason:'Initializing is fine, but the loop guarantees execution at least once, so `scanf` will assign a value before the condition `number <= 0` is checked.'}, {text: 'let number;', reason: '`let` is not a C keyword for variable declaration. Use a type like `int`.'}], indent: 1, explanation: "Declare an integer variable to store user input." },
            { correct: 'do {', distractors: [{text: 'while (number <= 0) {', reason:'A `while` loop checks the condition *before* the first iteration. A `do-while` loop executes the body *at least once* before checking, which is needed here to get input first.'}, {text:'for (;;) { // Infinite loop', reason:'An infinite `for` loop would require an `if` and `break` inside, making `do-while` more suitable for this condition.'}], indent: 1, explanation: "Start a do-while loop, which executes the body at least once." },
            { correct: 'printf("Enter a positive number: ");', distractors: [{text: 'print("Enter a positive number: ");', reason: '`print` is not a standard C function; the correct function name is `printf`.'}, {text: 'scanf("Enter a positive number: ");', reason: '`scanf` is used for reading input from the user, not for displaying a message.'}], indent: 2, explanation: "Prompt the user for input inside the loop." },
            { correct: 'scanf("%d", &number);', distractors: [{text:'scanf("%d", number);', reason:'`scanf` requires the address (`&`) of the variable to store the input.'}, {text:'number = getchar();', reason:'`getchar` reads a single character, not a potentially multi-digit integer. Use `scanf` with `%d`.'}], indent: 2, explanation: "Read the integer input from the user." },
            { correct: '} while (number <= 0);', distractors: [{text: '} while number <= 0;', reason:'The condition must be enclosed in parentheses `()`. '}, {text:'} while (number < 1);', reason:'This condition is equivalent to `number <= 0` for integers and also correct.'}], indent: 1, explanation: "End the loop body and check the condition. Repeat if the number is not positive (<= 0)." },
            { correct: 'printf("Thank you! You entered: %d\\n", number);', distractors: [{text:'printf("Positive number entered.\\n");', reason:'Printing the actual number entered is more informative.'}, {text: 'printf("Thank you! You entered: %d", &number);', reason: '`printf` needs the variable\'s value, not its memory address (`&number`).'}], indent: 1, explanation: "Print the valid positive number entered." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Returning 1 indicates an error. The program completed successfully, so return 0.'}, {text: 'return number;', reason: '`main` should return an exit code, not the user\'s input.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'C uses `}` to close blocks, not the `end` keyword.'}, {text: '};', reason: 'Do not place a semicolon after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 9: Void Function
    {
        goal: "Define a function to print a greeting and call it from main.",
        concepts: "Function definition, function call, void return type",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: 'include <stdio.h>', reason: 'Preprocessor directives must begin with a `#` symbol.'}, {text: '#include <stdlib.h>', reason: '`printf` is in the standard I/O library (`stdio.h`), not the standard library (`stdlib.h`).'}], indent: 0, explanation: "Include standard I/O." },
            { correct: '// Function declaration (prototype)', distractors: [{text:'// Function definition', reason:'This is just the declaration (prototype), announcing the function\'s signature. The definition (implementation) comes later.'}, {text: '// Main function start', reason: 'This comment is inaccurate. The line below it declares a custom function, not `main`.'}], indent: 0, explanation: "Comment explaining the next line (prototype)." },
            { correct: 'void printGreeting(void);', distractors: [{text:'int printGreeting();', reason:'The function doesn\'t calculate or return a value, so `void` is the appropriate return type.'}, {text:'void printGreeting();', reason:'Specifying `(void)` for no parameters is explicit and preferred in C over empty parentheses `()` in declarations.'}], indent: 0, explanation: "Declare the function: returns nothing (void), takes no arguments (void)." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return an `int`.'}, {text: 'main function {', reason: 'This is not valid C syntax for a function definition.'}], indent: 0, explanation: "Start the main function." },
            { correct: 'printGreeting();', distractors: [{text: 'call printGreeting();', reason:'Function calls in C are done using just the function name followed by parentheses `()`. `call` is not a C keyword.'}, {text:'int result = printGreeting();', reason:'A `void` function doesn\'t return a value that can be assigned to `result`.'}], indent: 1, explanation: "Call the defined function to execute its code." },
            { correct: 'return 0;', distractors: [{text: 'return;', reason: 'The `main` function is defined to return `int`, so it must return an integer value.'}, {text: 'return "success";', reason: '`main` must return an integer exit code, not a string.'}], indent: 1, explanation: "Indicate successful execution of main." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'C uses `}` to close a function block, not keywords.'}, {text: 'stop;', reason: '`stop` is not a C keyword.'}], indent: 0, explanation: "Close the main function." },
            { correct: '// Function definition', distractors: [{text:'// Function call', reason:'This marks the implementation (definition) of the function.'}, {text: '// Comment block', reason: 'This is a comment, but "Function definition" is more specific and accurate for the code that follows.'}], indent: 0, explanation: "Comment indicating the function's implementation." },
            { correct: 'void printGreeting(void) {', distractors: [{text:'int printGreeting(void) {', reason:'The definition must match the return type (`void`) specified in the declaration.'}, {text:'void printGreeting() {', reason:'While sometimes allowed, matching the explicit `(void)` from the prototype in the definition is good practice.'}], indent: 0, explanation: "Define the function, matching the declaration." },
            { correct: 'printf("Hello from the function!\\n");', distractors: [{text:'puts("Hello from the function!");', reason:'`puts` works but adds its own newline. `printf` requires `\\n` explicitly.'}, {text: 'printf("Hello from the function!");', reason: 'Forgetting the `\\n` means the output might not have a line break, which can mess up terminal formatting.'}], indent: 1, explanation: "The action performed by the function: printing a message." },
            { correct: '}', distractors: [{text:'return;', reason:'Explicit `return;` is optional at the end of a `void` function; the closing brace `}` implies it.'}, {text:'};', reason:'Semicolon not needed after function closing brace.'}], indent: 0, explanation: "Close the printGreeting function block." }
        ]
    },
    // Level 10: Function Returning Value
    {
        goal: "Demonstrate the three fundamental types of functions: void (no parameters), with parameters, and returning a value.",
        concepts: "Function prototypes, function definitions, void functions, function parameters, return statement",
        sequence: [
            { "correct": "#include <stdio.h>", distractors: [{"text": "#include <functions.h>", reason: "There is no standard C header named `<functions.h>`. Core function capabilities are built into the language."}, {"text": "include <stdio.h>", reason: "Preprocessor directives like `#include` must always start with a '#' symbol to be recognized by the compiler."}], indent: 0, explanation: "Include the standard I/O library for printing." },
            { "correct": "// --- Function Prototypes ---", distractors: [{"text": "/* Function Declarations */", reason: "This is also a valid comment style (multi-line). Using `//` for single lines is often preferred for readability."}, {"text": "// --- Function Implementations ---", reason: "This comment is inaccurate. The code that follows only *declares* the functions (prototypes), it does not define their behavior (implementations)."}], indent: 0, explanation: "Declaring all functions before `main` allows us to call them from anywhere." },
            { "correct": "void print_intro_message(void);", distractors: [{"text": "int print_intro_message(void);", reason: "Since this function only prints a message and does not calculate or return any data, its return type should be `void`."}, {"text": "void print_intro_message();", reason: "While some compilers allow empty parentheses `()`, explicitly stating `(void)` is the correct and clearer way in C to declare a function takes no arguments."}], indent: 0, explanation: "Prototype 1: A `void` function that takes no arguments." },
            { "correct": "int add_two_numbers(int a, int b);", distractors: [{"text": "void add_two_numbers(int a, int b);", reason: "This function needs to return the calculated sum (an integer), so its return type must be `int`."}, {"text": "int add_two_numbers(int, int);", reason: "While omitting parameter names is allowed in prototypes, including them (`a`, `b`) makes the function's purpose much clearer to anyone reading the code."}], indent: 0, explanation: "Prototype 2: A function that takes two integers and returns an integer result." },
            { "correct": "void print_final_result(int result);", distractors: [{"text": "void print_final_result(int);", reason: "While omitting the parameter name is allowed in prototypes, including it (`result`) makes the function's purpose clearer."}, {"text": "int print_final_result(int result);", reason: "This function's only job is to print the value passed to it; it doesn't need to return anything, so `void` is the correct return type."}], indent: 0, explanation: "Prototype 3: A `void` function that accepts an integer argument to print." },
            { "correct": "// --- Main Function ---", distractors: [{"text": "// --- Function Calls ---", reason: "This is too specific. The `main` block contains more than just calls (like variable declarations), so 'Main Function' is a better description."}, {"text": "// --- Program Start ---", reason: "While true, 'Main Function' is the more technically accurate description for this specific block of code in a C program."}], indent: 0, explanation: "The main entry point where we will orchestrate our function calls." },
            { "correct": "int main() {", distractors: [{"text": "void main() {", reason: "The C standard requires `main` to return an integer to indicate its exit status to the operating system. `0` conventionally means success."}, {"text": "function main() {", reason: "`function` is not a keyword in C. A function definition starts with its return type, name, and parameters."}], indent: 0, explanation: "Start the main function." },
            { "correct": "print_intro_message();", distractors: [{"text": "call print_intro_message();", reason: "C does not use a `call` keyword. A function is called simply by using its name followed by parentheses `()`."}, {"text": "int intro = print_intro_message();", reason: "The function `print_intro_message` is a `void` function, meaning it doesn't return a value that can be assigned to a variable."}], indent: 1, explanation: "Call the first function to print a welcome message." },
            { "correct": "int num1 = 20;", distractors: [{"text": "num1 = 20;", reason: "In C, you must declare the type of a variable (e.g., `int`) when you first define it."}, {"text": "let num1 = 20;", reason: "`let` is a keyword for variable declaration in other languages like JavaScript, but not in C. You must use a type name like `int` or `float`."}], indent: 1, explanation: "Declare and initialize the first number." },
            { "correct": "int num2 = 22;", distractors: [{"text": "const int num2 = 22;", reason: "Using `const` would make `num2` a read-only variable. While not wrong, it's unnecessary here and a regular `int` is standard practice."}, {"text": "int num1 = 22;", reason: "Using the same variable name `num1` again would cause a redefinition error. Each variable must have a unique name within its scope."}], indent: 1, explanation: "Declare and initialize the second number." },
            { "correct": "int sum;", distractors: [{"text": "sum;", reason: "C is a statically-typed language, which means you must always specify the data type (like `int`) when first declaring a variable."}, {"text": "int sum = 0;", reason: "While initializing `sum` to 0 is excellent practice, it's not strictly required here since it will be assigned a new value on the very next line."}], indent: 1, explanation: "Declare a variable to hold the result of our calculation." },
            { "correct": "sum = add_two_numbers(num1, num2);", distractors: [{"text": "add_two_numbers(num1, num2);", reason: "The `add_two_numbers` function returns the calculated value. If you don't assign it to a variable (like `sum`), the result is lost and cannot be used later."}, {"text": "int sum = add_two_numbers(num1, num2);", reason: "This would be a redefinition error. The variable `sum` has already been declared in the previous step."}], indent: 1, explanation: "Call the addition function, passing `num1` and `num2` as arguments, and store the return value in `sum`." },
            { "correct": "print_final_result(sum);", distractors: [{"text": "print_final_result(int sum);", reason: "When calling a function, you pass the variable (the argument) directly, without its type declaration."}, {"text": "sum = print_final_result(sum);", reason: "The `print_final_result` function has a `void` return type, so it doesn't return a value that can be assigned to `sum`."}], indent: 1, explanation: "Call the final function, passing the calculated `sum` as its argument." },
            { "correct": "return 0;", distractors: [{"text": "return sum;", reason: "The return value of `main` is an exit code for the OS. It should be `0` to signal success, not the result of the program's calculation."}, {"text": "return(0);", reason: "While using parentheses `()` around the return value works, they are not necessary and it's more conventional to write `return 0;`."}], indent: 1, explanation: "Indicate that the program finished successfully." },
            { "correct": "}", distractors: [{"text": "end;", reason: "`end` is not a C keyword. A code block is always closed with a `}`."}, {"text": "};", reason: "A semicolon is not needed after the closing brace `}` of a function definition."}], indent: 0, explanation: "Close the main function." },
            { "correct": "// --- Function Definitions ---", distractors: [{"text": "// --- Function Prototypes ---", reason: "This is inaccurate. This section provides the full implementation (the 'body') of the functions, not just their declarations (prototypes)."}, {"text": "// --- Subroutines ---", reason: "While 'subroutine' is a general term for a function, 'Function Definitions' is the standard, precise terminology used in C programming."}], indent: 0, explanation: "Now we provide the implementation for each of our declared functions." },
            { "correct": "void print_intro_message(void) {", distractors: [{"text": "int print_intro_message(void) {", reason: "The function definition must match the prototype. Since it was declared to return `void`, the definition must also be `void`."}, {"text": "void print_intro_message(void); {", reason: "A semicolon here prematurely ends the function header, which is incorrect syntax for a function definition."}], indent: 0, explanation: "Implement the intro message function." },
            { "correct": "  printf(\"--- Function Demo: Starting calculation... ---\\n\");", distractors: [{"text": "  puts(\"--- Function Demo: Starting calculation... ---\");", reason: "`puts` is a valid way to print a string and automatically adds a newline. `printf` is used here for consistency with the final print statement."}, {"text": "  printf(\"--- Function Demo: Starting calculation... ---\");", reason: "Forgetting the newline character `\\n` means the program's next output would appear on the same line, which can look messy."}], indent: 1, explanation: "The body of the function simply prints a line of text." },
            { "correct": "}", distractors: [{"text": "return;", reason: "An explicit `return;` is valid but optional at the end of a `void` function; the closing brace `}` is sufficient and implies the return."}, {"text": "return 0;", reason: "A function with a `void` return type cannot return an integer value. It can only have an empty `return;` or no return at all."}], indent: 0, explanation: "Close the function block." },
            { "correct": "int add_two_numbers(int a, int b) {", distractors: [{"text": "void add_two_numbers(int a, int b) {", reason: "The definition's return type (`int`) must match the prototype's return type."}, {"text": "int add_two_numbers(int a; int b) {", reason: "Function parameters in C must be separated by commas, not semicolons."}], indent: 0, explanation: "Implement the addition function." },
            { "correct": "  int result = a + b;", distractors: [{"text": "  int result; result = a + b;", reason: "This is also correct, but combining the declaration and initialization into one statement is more concise and generally preferred."}, {"text": "  return a + b;", reason: "This is a more direct way to write the function. Using a local `result` variable is also perfectly fine and can make the code easier to debug."}], indent: 1, explanation: "Perform the addition and store it in a local variable." },
            { "correct": "  return result;", distractors: [{"text": "  printf(\"Sum is %d\", result);", reason: "This function's declared job is to *return* the calculated value, not print it. Printing is correctly handled by a different, dedicated function."}, {"text": "  return;", reason: "This function is declared to return an `int`, so it must return a value of that type. An empty `return;` is only valid for `void` functions."}], indent: 1, explanation: "Use the `return` keyword to send the calculated value back to the caller." },
            { "correct": "}", distractors: [{"text": "return;", reason: "A function declared to return `int` must explicitly return an integer value before it closes. The closing brace alone is not enough."}, {"text": "end function;", reason: "This is not valid C syntax. Function blocks are always closed with a `}`."}], indent: 0, explanation: "Close the function block." },
            { "correct": "void print_final_result(int result) {", distractors: [{"text": "void print_final_result(value) {", reason: "Function parameters in C require an explicit type declaration (e.g., `int result`). You cannot omit the type."}, {"text": "void print_final_result(int sum) {", reason: "While this would work, it's good practice to use a generic parameter name like `result` or `value`, as this function doesn't know or care that the data came from a variable named `sum`."}], indent: 0, explanation: "Implement the function that prints the final result." },
            { "correct": "  printf(\"--- The final result is: %d ---\\n\", result);", distractors: [{"text": "  printf(\"Result is %d\\n\", sum);", reason: "Inside this function, the passed value is known by the parameter name `result`. The variable `sum` only exists within the `main` function's scope."}, {"text": "  printf(\"--- The final result is: %d ---\\n\");", reason: "The `%d` format specifier tells `printf` to expect an integer variable. Forgetting to provide `result` will cause the program to print a garbage value."}], indent: 1, explanation: "Print the integer value that was passed into the function." },
            { "correct": "}", distractors: [{"text": "return 0;", reason: "A `void` function cannot return a value. The closing brace is all that's needed to end the function."}, {"text": "};", reason: "Semicolons are not written after the closing brace `}` of a function's definition."}], indent: 0, explanation: "Close the final function block." }
        ]
    },
    // Level 11: Array Basics
    {
        goal: "Create an integer array, initialize it, and print the third element.",
        concepts: "Array declaration, array initialization, array indexing (0-based)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <arrays.h>', reason: 'There is no standard C header `<arrays.h>`. Basic array functionality is built into the language.'}, {text: '#include <iostream>', reason: '`<iostream>` is the C++ header for I/O. Use `<stdio.h>` for `printf` in C.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires that `main` returns an `int`.'}, {text: 'int main(void) {', reason: 'This is also a correct signature for `main`, but `int main()` is more common and sufficient here.'}], indent: 0, explanation: "Start main function." },
            { correct: 'int scores[5] = {88, 92, 75, 100, 95};', distractors: [{text: 'int scores = {88, 92, 75, 100, 95};', reason:'You must specify the array size (e.g., `[5]`) or use empty brackets (`[]`) to let the compiler deduce it from the initializer list.'}, {text:'int scores(5) = {88, 92, 75, 100, 95};', reason:'Array size is specified using square brackets `[]`, not parentheses `()`.'}], indent: 1, explanation: "Declare an integer array named 'scores' of size 5 and initialize it with values." },
            { correct: 'int thirdScore;', distractors: [{text:'int scores[2];', reason:'This declares another array, not a variable to hold a single score.'}, {text: 'var thirdScore;', reason: 'C is a statically typed language and does not use the `var` keyword. You must specify the type, like `int`.'}], indent: 1, explanation: "Declare a variable to hold the specific score." },
            { correct: 'thirdScore = scores[2];', distractors: [{text: 'thirdScore = scores[3];', reason:'Array indexing in C is 0-based. The third element is at index 2 (0, 1, 2). Index 3 refers to the fourth element.'}, {text:'thirdScore = scores.get(2);', reason:'C arrays do not have methods like `.get()`. Access elements using square bracket notation `scores[index]`.'}], indent: 1, explanation: "Access the third element (at index 2) of the array and store it." },
            { correct: 'printf("The third score is: %d\\n", thirdScore);', distractors: [{text:'printf("The third score is: %d\\n", scores);', reason:'Passing the array name `scores` usually decays to a pointer to the first element. `printf` with `%d` expects an integer value, not an address.'}, {text:'printf(thirdScore);', reason:'`printf` requires a format string.'}], indent: 1, explanation: "Print the value retrieved from the array." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 for success. A non-zero return value from `main` conventionally indicates an error.'}, {text: 'exit(0);', reason: '`exit(0)` is another way to terminate, but `return 0;` is the standard way to exit from `main`.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: '`end` is not a C keyword. A closing brace `}` is used.'}, {text: '};', reason: 'A semicolon should not be placed after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 12: Array Iteration
    {
        goal: "Iterate through an array using a for loop and print all elements.",
        concepts: "Arrays, for loop, array indexing",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`printf` is in `<stdio.h>`, not `<stdlib.h>`.'}, {text: '#include "stdio.h"', reason: 'Angle brackets `<>` are the standard convention for including system library headers.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must be declared to return `int` in standard C.'}, {text: 'function main() {', reason: 'C does not use the `function` keyword.'}], indent: 0, explanation: "Start main function." },
            { correct: 'int values[4] = {10, 20, 30, 40};', distractors: [{text:'int values[]; values = {10, 20, 30, 40};', reason:'Assignment using `{}` after declaration is not allowed for arrays.'}, {text:'int values[4] = (10, 20, 30, 40);', reason:'Array initialization uses curly braces `{}`, not parentheses `()`.'}], indent: 1, explanation: "Declare and initialize an integer array." },
            { correct: 'int i;', distractors: [{text:'i = 0;', reason:'Declare the variable `int i;` before using it.'}, {text: 'var i;', reason: 'C requires an explicit type like `int`, not the `var` keyword.'}], indent: 1, explanation: "Declare a loop counter variable." },
            { correct: 'printf("Array elements: ");', distractors: [{text: 'puts("Array elements: ");', reason: '`puts` also prints the string, but automatically adds a newline. `printf` is used here to keep all numbers on one line.'}, {text: 'printf(Array elements: );', reason: 'The string argument to `printf` must be enclosed in double quotes.'}], indent: 1, explanation: "Print a label before the elements." },
            { correct: 'for (i = 0; i < 4; i++) {', distractors: [{text: 'for (i = 0; i <= 4; i++) {', reason:'Array indices for size 4 are 0, 1, 2, 3. Using `<=` would attempt to access `values[4]`, which is out of bounds.'}, {text:'for (i = 1; i <= 4; i++) {', reason:'Array indexing starts at 0, so the loop should start at 0 to include the first element.'}], indent: 1, explanation: "Start a for loop to iterate from index 0 up to (but not including) 4." },
            { correct: 'printf("%d ", values[i]);', distractors: [{text: 'printf("%d ", &values[i]);', reason:'`&values[i]` gives the address of the element. Pass `values[i]` directly to print the value.'}, {text:'printf(values[i]);', reason:'`printf` requires a format string like `"%d "`.'}], indent: 2, explanation: "Inside the loop, print the element at the current index 'i'." },
            { correct: '}', distractors: [{text: 'end for;', reason: 'C uses `}` to close loop blocks, not keywords.'}, {text: 'continue;', reason: '`continue` would skip to the next iteration of the loop, not end the loop block definition.'}], indent: 1, explanation: "Close the for loop block." },
            { correct: 'printf("\\n");', distractors: [{text:'puts("");', reason:'`puts("")` also prints a newline and is valid here.'}, {text:'return 1; // Error', reason:'This implies an error. The goal is just to print a newline for formatting before a successful exit.'}], indent: 1, explanation: "Print a final newline for formatting." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to signal success.'}, {text: 'end;', reason: '`end` is not a C keyword.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'C uses `}` to end function blocks.'}, {text: '};', reason: 'A semicolon is not used after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 13: Array Size with sizeof
    {
        goal: "Calculate the number of elements in an array using sizeof.",
        concepts: "sizeof operator, arrays, integer division",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: 'import <stdio.h>', reason: 'Use `#include` in C, not `import`.'}, {text: '#include <stdlib.h>', reason: '`printf` and `sizeof` do not require `stdlib.h`.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}, {text: 'main() {', reason: 'Explicitly defining the return type `int` for main is standard practice.'}], indent: 0, explanation: "Start main function." },
            { correct: 'int data[] = {5, 10, 15, 20, 25, 30}; // Size inferred', distractors: [{text:'int data[6] = {5, 10, 15, 20, 25, 30};', reason:'Explicit size is fine, but letting the compiler infer size `[]` from the initializer is also common and adaptable.'}, {text:'int data[]; data = {5, 10, 15, 20, 25, 30};', reason:'Array assignment after declaration isn\'t allowed this way.'}], indent: 1, explanation: "Declare and initialize an array, letting the compiler determine its size." },
            { correct: 'int size;', distractors: [{text:'float size;', reason:'The number of elements (size) should be an integer.'}, {text:'size_t size;', reason:'`size_t` is the type technically returned by `sizeof` and is appropriate for sizes, but `int` is often used for simplicity here.'}], indent: 1, explanation: "Declare a variable to store the array size." },
            { correct: 'size = sizeof(data) / sizeof(data[0]);', distractors: [{text: 'size = sizeof(data);', reason:'`sizeof(data)` gives the total size of the array in *bytes*, not the number of elements.'}, {text:'size = sizeof(data) / sizeof(int*);', reason:'`sizeof(int*)` gives the size of a pointer to an integer, not the size of an integer element itself. Use `sizeof(data[0])` or `sizeof(int)`.'}], indent: 1, explanation: "Calculate size: total bytes of array divided by bytes of one element." },
            { correct: 'printf("Number of elements: %d\\n", size);', distractors: [{text:'printf("Size in bytes: %d\\n", sizeof(data));', reason:'This would print the total byte size, not the element count.'}, {text: 'printf("Number of elements: %s\\n", size);', reason: '`%s` is the format specifier for strings. To print an integer like `size`, you must use `%d`.'}], indent: 1, explanation: "Print the calculated number of elements." },
            { correct: '// Now loop using the calculated size', distractors: [{text: '// This is a comment', reason: 'While true, a more descriptive comment explaining the intent of the next code block is better.'}, {text: '/* Loop time */', reason: 'Both `//` and `/**/` are valid comment styles, but this comment is less descriptive.'}], indent: 1, explanation: "Comment indicating the next step." },
            { correct: 'for (int i = 0; i < size; i++) {', distractors: [{text:'for (int i = 0; i < 6; i++) {', reason:'Using the calculated `size` variable makes the loop automatically adapt if the array initialization changes. Hardcoding `6` is less flexible.'}, {text:'for (int i = 0; i <= size; i++) {', reason:'Loop must be `< size` as indices go from 0 to size-1.'}], indent: 1, explanation: "Use the calculated 'size' in the loop condition." },
            { correct: 'printf("%d ", data[i]);', distractors: [{text:'printf("%d ", i);', reason:'This prints the index, not the array value.'}, {text: 'printf(data[i]);', reason: '`printf` requires a format string (like `"%d "`) as its first argument.'}], indent: 2, explanation: "Print each element." },
            { correct: '}', distractors: [{text: 'end loop;', reason: 'C uses `}` to close blocks.'}, {text: 'continue;', reason: '`continue` skips to the next iteration; it does not close the loop definition.'}], indent: 1, explanation: "Close the loop." },
            { correct: 'printf("\\n");', distractors: [{text: 'puts("");', reason: '`puts` also prints a newline and is valid, but `printf("\\n");` is also very common.'}, {text: 'printf("/n");', reason: 'The backslash `\\` is the correct escape character for a newline, not the forward slash `/`.'}], indent: 1, explanation: "Final newline." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate a successful run.'}, {text: 'return size;', reason: '`main` should return an exit code, not the size of the array.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Use `}` to close the `main` function.'}, {text: '};', reason: 'Semicolons are not used after a function\'s closing brace.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 14: Pointer Basics
    {
        goal: "Declare a pointer, initialize it to NULL, assign an address later, and check for NULL.",
        concepts: "Pointers, NULL, address-of operator (&), dereference operator (*), if statement",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <string.h>', reason: '`<string.h>` is for string functions. `printf` is in `<stdio.h>`.'}, {text: '#include <pointers.h>', reason: 'There is no standard C header `<pointers.h>`.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: '#include <stdlib.h> // For NULL (though often in stdio.h too)', distractors: [{text:'#include <pointers.h>', reason:'There is no standard `<pointers.h>`. NULL is typically defined in `<stdlib.h>`, `<stdio.h>`, `<stddef.h>` and others.'}, {text: '#define NULL 0', reason: 'While `NULL` is often defined as `0` or `(void*)0`, you should include a standard header like `<stdlib.h>` rather than defining it yourself.'}], indent: 0, explanation: "Include stdlib.h, commonly containing the NULL definition." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int` in standard C.'}, {text: 'int main(void) {', reason: 'This is also correct, but `int main()` is more common.'}], indent: 0, explanation: "Start main." },
            { correct: 'int number = 50;', distractors: [{text: 'int number == 50;', reason: 'Use `=` for assignment, `==` for comparison.'}, {text: 'const int number = 50;', reason: 'Using `const` would make the variable read-only, which is fine here but not necessary for the goal.'}], indent: 1, explanation: "Declare a regular integer variable." },
            { correct: 'int *ptr = NULL;', distractors: [{text:'int *ptr;', reason:'Initializing pointers to `NULL` when declared is good practice if they aren\'t immediately assigned a valid address.'}, {text:'int *ptr = 0;', reason:'Assigning `0` is often equivalent to assigning `NULL`, but using the `NULL` macro is more explicit and standard.'}], indent: 1, explanation: "Declare an integer pointer and initialize it to NULL." },
            { correct: 'printf("Initial ptr value: %p\\n", ptr);', distractors: [{text: 'printf("Initial ptr value: %d\\n", ptr);', reason: 'The `%p` format specifier is specifically for printing pointer addresses in a standard, implementation-defined way.'}, {text: 'printf("Initial ptr value: %p\\n", *ptr);', reason: 'This would attempt to dereference a `NULL` pointer, leading to a crash or undefined behavior. We want to print the pointer\'s value itself.'}], indent: 1, explanation: "Show that the pointer initially holds the NULL address (often printed as 0 or (nil))." },
            { correct: '// Assign address later', distractors: [{text: '/* Assign address later */', reason: 'Both comment styles are valid in C.'}, {text: '// Pointer assignment follows', reason: 'This is also a perfectly good comment.'}], indent: 1, explanation: "Comment indicating address assignment." },
            { correct: 'ptr = &number;', distractors: [{text: 'ptr = number;', reason: '`ptr` is a pointer and needs a memory address. `number` is an integer value (50). The address-of operator `&` is needed.'}, {text: '*ptr = &number;', reason: 'This is incorrect. It tries to assign an address to the location `ptr` points to (which is NULL), a guaranteed error.'}], indent: 1, explanation: "Assign the memory address of 'number' to the pointer 'ptr'." },
            { correct: 'printf("Ptr value after assignment: %p\\n", ptr);', distractors: [{text: 'printf("Number address: %d\\n", ptr);', reason: 'Use `%p` to print pointer addresses.'}, {text: 'printf("Number value: %d\\n", *ptr);', reason: 'This is valid and would print 50, but the goal here is to show the address the pointer now holds.'}], indent: 1, explanation: "Show the non-NULL address now stored in ptr." },
            { correct: 'if (ptr != NULL) {', distractors: [{text:'if (ptr)', reason:'While checking `if (ptr)` works because NULL evaluates to false in a boolean context, explicitly comparing `ptr != NULL` is clearer.'}, {text:'if (*ptr != NULL)', reason:'`*ptr` accesses the *value* (50). We want to check if the *pointer itself* (`ptr`) is NULL before dereferencing it.'}], indent: 1, explanation: "Check if the pointer is NOT NULL before trying to use it." },
            { correct: 'printf("Value via pointer: %d\\n", *ptr);', distractors: [{text: 'printf("Value via pointer: %d\\n", ptr);', reason: '`ptr` holds the address. The dereference operator `*` is needed to get the value (50) stored at that address.'}, {text: 'printf("Value via pointer: %p\\n", *ptr);', reason: '`%p` is for printing pointers/addresses. `%d` is for printing the integer value that `*ptr` resolves to.'}], indent: 2, explanation: "Safely print the value only if the pointer is not NULL." },
            { correct: '} else {', distractors: [{text: '} else if (ptr == NULL) {', reason: 'An `else` block does not take a condition; it executes if the preceding `if` condition was false.'}, {text: '} otherwise {', reason: 'C uses the keyword `else`, not `otherwise`.'}], indent: 1, explanation: "Block for when the pointer is NULL." },
            { correct: 'printf("Pointer is NULL, cannot dereference.\\n");', distractors: [{text: 'printf("Error!");', reason: 'This is too generic. The message should be specific about why the `else` block was entered.'}, {text: 'return 1;', reason: 'While you could exit, the goal here is just to print a message, not terminate the program.'}], indent: 2, explanation: "Message indicating the pointer is NULL." },
            { correct: '}', distractors: [{text: 'end if;', reason: 'C uses `}` to close blocks.'}, {text: '};', reason: 'A semicolon is not used here.'}], indent: 1, explanation: "Close the if/else block." },
            { correct: 'return 0;', distractors: [{text: 'return NULL;', reason: '`main` should return an integer exit code. `NULL` might work if it\'s defined as 0, but `return 0;` is explicit and correct.'}, {text: 'return (0);', reason: 'Parentheses are not required and this is just a stylistic difference.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Use `}` to close the function block.'}, {text: '});', reason: 'This syntax is incorrect for closing a block.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 15: Pointers and Arrays
    {
        goal: "Demonstrate accessing array elements using both array[index] and *(array + index) notation.",
        concepts: "Pointers, arrays, pointer arithmetic, dereference operator (*), equivalence",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: 'The `printf` function is declared in `stdio.h`.'}, {text: '#include "stdio.h"', reason: 'Angle brackets `<>` are preferred for standard library headers.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}, {text: 'int main(void) {', reason: 'This is also correct.'}], indent: 0, explanation: "Start main." },
            { correct: 'int nums[] = {11, 22, 33, 44};', distractors: [{text: 'int nums[4] = (11, 22, 33, 44);', reason: 'Array initialization lists must use curly braces `{}`.'}, {text: 'int nums[]; nums = {11, 22, 33, 44};', reason: 'You cannot assign to an array using an initializer list after it has been declared.'}], indent: 1, explanation: "Declare and initialize an integer array." },
            { correct: 'int *ptr = nums; // Point ptr to the start of the array', distractors: [{text: 'int *ptr = &nums;', reason: '`nums` by itself decays into a pointer to its first element. `&nums` is a pointer to the entire array, a different type (`int (*)[4]`).'}, {text: 'int ptr = nums;', reason: 'The pointer variable `ptr` must be declared with an asterisk `*` to indicate it is a pointer.'}], indent: 1, explanation: "Declare a pointer and make it point to the first element of nums." },
            { correct: 'printf("Accessing elements for nums[]:\\n");', distractors: [{text: 'puts("Accessing elements for nums[]:\\n");', reason: '`puts` is also valid here, as it prints a string and a newline.'}, {text: 'printf("Accessing elements for nums[]:");', reason: 'Adding the `\\n` newline character makes the output cleaner.'}], indent: 1, explanation: "Print a header." },
            { correct: 'printf("Element 0: nums[0]=%d, *(nums+0)=%d\\n", nums[0], *(nums + 0));', distractors: [{text:'printf("Element 0: nums[0]=%d, *nums+0=%d\\n", nums[0], *nums + 0);', reason:'Operator precedence matters. `*nums + 0` dereferences `nums` first (gets 11) then adds 0. `*(nums + 0)` calculates the address first, then dereferences.'}, {text: 'printf("Element 0: %d, %d\\n", nums[0], *nums);', reason: '`*nums` is equivalent to `*(nums + 0)`, so this is also correct, but the goal is to explicitly show the `+ 0` arithmetic.'}], indent: 1, explanation: "Show accessing the first element using both notations with the array name." },
            { correct: 'printf("Element 1: nums[1]=%d, *(nums+1)=%d\\n", nums[1], *(nums + 1));', distractors: [{text: 'printf("Element 1: %d\\n", nums[1]);', reason: 'This is correct but only shows one access method. The goal is to show both `[]` and `*()` notations are equivalent.'}, {text: 'printf("Element 1: %d, %d\\n", nums[1], *nums + 1);', reason: '`*nums + 1` would evaluate to `11 + 1 = 12`. `*(nums + 1)` correctly gets the second element, `22`.'}], indent: 1, explanation: "Show accessing the second element using both notations." },
            { correct: 'printf("\\nAccessing elements via ptr:\\n");', distractors: [{text: 'printf("Accessing elements via ptr:\\n");', reason: 'Adding the leading `\\n` creates a blank line, which helps separate the output sections for clarity.'}, {text: 'puts("\\nAccessing elements via ptr:");', reason: '`puts` would print two newlines (one from `\\n`, one from `puts` itself), creating too much space.'}], indent: 1, explanation: "Print another header for pointer access." },
            { correct: 'printf("Element 0: ptr[0]=%d, *(ptr+0)=%d\\n", ptr[0], *(ptr + 0));', distractors: [{text:'printf("Element 0: ptr[0]=%d, *ptr[0]=%d\\n", ptr[0], *ptr[0]);', reason:'`*ptr[0]` is parsed as `*(ptr[0])` which is invalid here. Use `ptr[0]` or `*(ptr+0)`.'}, {text: 'printf("Element 0: %d, %d\\n", *ptr, *(ptr));', reason: 'This is also correct, but the goal is to show the explicit equivalence of `ptr[0]` and `*(ptr + 0)`.'}], indent: 1, explanation: "Show accessing the first element using both notations via the pointer." },
            { correct: 'printf("Element 2: ptr[2]=%d, *(ptr+2)=%d\\n", ptr[2], *(ptr + 2));', distractors: [{text: 'printf("Element 2: %d, %d\\n", ptr[2], *ptr + 2);', reason: '`*ptr + 2` would evaluate to `11 + 2 = 13`. The correct pointer arithmetic is `*(ptr + 2)` to get the value `33`.'}, {text: 'printf("Element 2: %d, %d\\n", *(ptr+2), *(ptr+2));', reason: 'This is correct but doesn\'t show the `ptr[2]` notation, which is part of the goal.'}], indent: 1, explanation: "Show accessing the third element using both notations via the pointer." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate success.'}, {text: 'end;', reason: '`end` is not a C keyword.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'Use `}` to close function blocks.'}, {text: '};', reason: 'Semicolons are not used after a function closing brace.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 16: String Literal vs Char Array
    {
        goal: "Illustrate the difference between a string literal (often read-only) and a modifiable char array.",
        concepts: "String literals, char arrays, pointers, memory segments (conceptual)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <string.h>', reason: '`printf` is in `<stdio.h>`. `<string.h>` is needed for functions like `strcpy`, which are not used here.'}, {text: '#include <stdlib.h>', reason: 'This header is not needed for this program.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` should return `int`.'}, {text: 'program main() {', reason: 'This is not valid C syntax.'}], indent: 0, explanation: "Start main." },
            { correct: 'char *strLiteral = "Immutable"; // Pointer to string literal', distractors: [{text:'char strLiteral[] = "Immutable";', reason:'This creates a modifiable array initialized with the string. The goal here is to show a pointer to a literal.'}, {text: 'string strLiteral = "Immutable";', reason: 'C does not have a native `string` type. Use `char*` for string literals or `char[]` for string variables.'}], indent: 1, explanation: "Declare a pointer initialized to point to a string literal (often in read-only memory)." },
            { correct: 'char charArray[] = "Modifiable"; // Modifiable char array', distractors: [{text:'char *charArray = {"Modifiable"};', reason:'This syntax is incorrect for initializing a pointer to a character array content. You would need `char *charArray = "Modifiable";` for a pointer to a literal, or `char charArray[]` for a modifiable array.'}, {text: 'char charArray[10]; charArray = "Modifiable";', reason: 'You cannot assign a string literal to a char array after its declaration. You must use `strcpy` or initialize it at declaration.'}], indent: 1, explanation: "Declare a character array initialized with a string literal (creating a copy in writable memory)." },
            { correct: 'printf("String Literal: %s\\n", strLiteral);', distractors: [{text: 'printf("String Literal: %c\\n", *strLiteral);', reason: '`%c` prints a single character. `*strLiteral` would print just the first character, \'I\'. `%s` is needed to print the whole string.'}, {text: 'puts(strLiteral);', reason: '`puts` would work, but it adds its own newline. The goal is likely to practice with `printf`.'}], indent: 1, explanation: "Print the string literal." },
            { correct: 'printf("Character Array: %s\\n", charArray);', distractors: [{text: 'printf("Character Array: %s\\n", &charArray);', reason: '`printf` with `%s` expects a `char*`. The array name `charArray` already decays to a pointer to its first element, so `&charArray` is not correct here (it has type `char (*)[size]`).'}, {text: 'for(int i=0; charArray[i]!=\'\\0\'; i++){ putchar(charArray[i]); }', reason: 'This is a valid way to print a string, but using `printf` with `%s` is much simpler and more common.'}], indent: 1, explanation: "Print the character array." },
            { correct: '// Attempt to modify first character', distractors: [{text: '/* Modify char */', reason: 'This is also a valid comment.'}, {text: '# Modify first char', reason: '`#` is not the C syntax for single-line comments. Use `//`.'}], indent: 1, explanation: "Comment explaining the next actions." },
            { correct: 'charArray[0] = \'X\'; // OK - Modifying the array', distractors: [{text:'strLiteral[0] = \'X\';', reason:'Attempting to modify a string literal through a pointer results in undefined behavior (often a crash) because the literal may be stored in read-only memory.'}, {text: 'charArray[0] = "X";', reason: 'Single quotes `\'X\'` are for a single `char` literal. Double quotes `"X"` are for a string literal (which includes a null terminator `\\0`), which cannot be assigned to a single char.'}], indent: 1, explanation: "Modify the first character of the character array (this is allowed)." },
            { correct: 'printf("Modified Array: %s\\n", charArray);', distractors: [{text: 'printf("Modified Array: %c\\n", charArray[0]);', reason: 'This would print only the first character \'X\'. `%s` is needed to see the whole modified string "Xodifiable".'}, {text: 'puts(charArray);', reason: '`puts` would also work correctly here.'}], indent: 1, explanation: "Show the modification was successful." },
            { correct: '// strLiteral[0] = \'Y\'; // <-- This would likely cause a runtime error!', distractors: [{text:'strLiteral = "New"; // OK - Changing where pointer points', reason:'Assigning a new string literal changes the pointer, but doesn\'t modify the original "Immutable" literal.'}, {text: '// strcpy(strLiteral, "New"); // Also an error!', reason: 'This would also cause a runtime error, as `strcpy` would attempt to write to the read-only memory where "Immutable" is stored.'}], indent: 1, explanation: "Comment illustrating the danger of modifying a string literal." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate success.'}, {text: 'exit(0);', reason: '`return 0;` is the standard way to exit `main`.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Use `}` to close the block.'}, {text: '};', reason: 'Semicolons are not used after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 17: Struct Initialization
    {
        goal: "Initialize a struct variable using an initializer list.",
        concepts: "Structs, initialization lists",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <structs.h>', reason: 'There is no standard `<structs.h>`. The `struct` keyword is built into the C language.'}, {text: '#include <string.h>', reason: 'This header is not needed for basic struct operations or `printf`.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'struct Point { int x; int y; };', distractors: [{text: 'struct Point ( int x, int y );', reason: 'The members of a struct must be defined within curly braces `{}`.'}, {text: 'class Point { int x; int y; };', reason: '`class` is the keyword for defining classes in C++, not for structs in C.'}], indent: 0, explanation: "Define a simple Point structure." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return `int`.'}, {text: 'int main(void) {', reason: 'This is also a correct way to define `main`.'}], indent: 0, explanation: "Start main." },
            { correct: 'struct Point p1 = {15, 25};', distractors: [{text:'struct Point p1;', reason:'This only declares p1; the goal is to initialize during declaration.'}, {text:'struct Point p1 = (15, 25);', reason:'Struct initialization uses curly braces `{}`, not parentheses `()`.'}], indent: 1, explanation: "Declare and initialize struct variable p1 using an initializer list {value_for_x, value_for_y}." },
            { correct: 'printf("p1 coordinates: (%d, %d)\\n", p1.x, p1.y);', distractors: [{text: 'printf("p1 x: %d\\n", p1.x); printf("p1 y: %d\\n", p1.y);', reason: 'This also works, but the goal is to print both coordinates in a single formatted line.'}, {text: 'printf("p1 coordinates: %d, %d\\n", p1);', reason: 'You cannot pass an entire struct to `printf` and expect it to print the members. You must pass each member individually.'}], indent: 1, explanation: "Print the members of the initialized struct." },
            { correct: '// Designated initializers (C99 and later)', distractors: [{text: '// C99 feature', reason: 'This is true, but the current comment is more descriptive of what the feature is.'}, {text: '/* Named initializers */', reason: 'This is also a valid comment and descriptive name.'}], indent: 1, explanation: "Comment introducing designated initializers." },
            { correct: 'struct Point p2 = {.y = 50, .x = 30}; // Order doesn\'t matter', distractors: [{text:'struct Point p2 = {y: 50, x: 30};', reason:'Designated initializers use a dot (`.`) before the member name (`.y`, `.x`), not a colon.'}, {text:'struct Point p2 = {50, 30};', reason:'Without designated initializers, values are assigned in order (x=50, y=30). Designated initializers allow explicit assignment by name.'}], indent: 1, explanation: "Initialize p2 using designated initializers (explicitly naming members)." },
            { correct: 'printf("p2 coordinates: (%d, %d)\\n", p2.x, p2.y);', distractors: [{text: 'printf("p2 coordinates: (%d, %d)\\n", p2.y, p2.x);', reason: 'This would print "(50, 30)". The format string expects the x-coordinate first, so `p2.x` should be the first argument.'}, {text: 'printf(p2.x, p2.y);', reason: '`printf` always requires a format string as its first argument.'}], indent: 1, explanation: "Print the members of p2." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate success.'}, {text: 'end;', reason: '`end` is not a C keyword.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'Use `}` to close the function.'}, {text: '};', reason: 'A semicolon is not placed after the brace closing a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 18: Pass Struct by Value
    {
        goal: "Pass a struct to a function by value and print its members inside the function.",
        concepts: "Structs, functions, pass-by-value",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: 'This header is not needed for this program.'}, {text: '#include <string.h>', reason: 'This header is not needed for this program.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'struct Item { int id; float price; };', distractors: [{text: 'struct Item[int id, float price];', reason: 'Struct members are defined within curly braces `{}`.'}, {text: 'typedef struct { int id; float price; } Item;', reason: 'Using `typedef` is a common and excellent practice, but this level focuses on the basic `struct` keyword syntax.'}], indent: 0, explanation: "Define an Item structure." },
            { correct: 'void displayItem(struct Item it); // Function takes struct by value', distractors: [{text:'void displayItem(struct Item *it);', reason:'`struct Item *it` would mean passing a pointer (pass-by-reference effect). `struct Item it` means passing a copy (pass-by-value).'}, {text: 'int displayItem(struct Item it);', reason: 'The function only prints information, it does not calculate or return a value, so `void` is the correct return type.'}], indent: 0, explanation: "Declare function displayItem that takes a struct Item by value (a copy)." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}, {text: 'int main(void) {', reason: 'This is also correct.'}], indent: 0, explanation: "Start main." },
            { correct: 'struct Item item1 = {101, 19.99f};', distractors: [{text: 'struct Item item1 = {19.99f, 101};', reason: 'Without designated initializers, the values must be in the same order as the members are declared in the struct (`id` then `price`).'}, {text: 'struct Item item1; item1 = {101, 19.99f};', reason: 'In modern C (C99+), you can assign to a struct with a compound literal after declaration, but initialization is more direct.'}], indent: 1, explanation: "Declare and initialize an Item struct." },
            { correct: 'displayItem(item1);', distractors: [{text:'displayItem(&item1);', reason:'The function expects a `struct Item`, not a pointer `struct Item *`. Pass `item1` directly to send a copy.'}, {text: 'displayItem({101, 19.99f});', reason: 'Passing a compound literal like this is also valid C, but the goal is to pass the variable `item1`.'}], indent: 1, explanation: "Call displayItem, passing the item1 struct (a copy will be made)." },
            { correct: 'printf("item1 price in main after call: %.2f\\n", item1.price);', distractors: [{text: 'printf("item1 price in main: %.2f\\n", it.price);', reason: 'The variable `it` only exists inside the `displayItem` function. In `main`, you must use `item1`.'}, {text: 'printf("item1 price: %f\\n", item1.price);', reason: '`%.2f` is better for currency as it formats the float to two decimal places.'}], indent: 1, explanation: "Show that the original item1 in main is unaffected by changes inside the function (if any)." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 for success.'}, {text: 'exit(0);', reason: '`return 0;` is the standard way to exit `main`.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'Use `}` to close the function.'}, {text: '};', reason: 'Semicolons are not placed after function braces.'}], indent: 0, explanation: "Close main." },
            { correct: 'void displayItem(struct Item it) {', distractors: [{text: 'void displayItem(struct Item item1) {', reason: 'It is good practice to use a different parameter name (`it`) to make it clear you are working with a copy, not the original `item1` from `main`.'}, {text: 'void displayItem(Item it) {', reason: 'In C, you must use the `struct` keyword before the struct name in a parameter list (unless you use `typedef`).'}], indent: 0, explanation: "Define displayItem, taking a copy of the struct named 'it'." },
            { correct: 'printf("-- Inside Function --\\n");', distractors: [{text: 'puts("-- Inside Function --");', reason: '`puts` also works and is slightly more efficient for printing a simple string with a newline.'}, {text: 'printf("-- Inside Function --");', reason: 'Adding `\\n` ensures the output moves to the next line, which is cleaner.'}], indent: 1, explanation: "Indicate output is from within the function." },
            { correct: 'printf("Item ID: %d\\n", it.id);', distractors: [{text: 'printf("Item ID: %d\\n", it->id);', reason: 'The arrow operator `->` is used to access members via a pointer to a struct. Since `it` is a struct variable itself (a copy), you use the dot operator `.`.'}, {text: 'printf("Item ID: %d\\n", &it.id);', reason: 'Passing `&it.id` would print the memory address of the `id` member, not its value.'}], indent: 1, explanation: "Print the id member of the received struct copy 'it'." },
            { correct: 'printf("Item Price: %.2f\\n", it.price);', distractors: [{text: 'printf("Item Price: %d\\n", it.price);', reason: '`%d` is for integers. The `price` member is a `float`, so you must use `%f` (or `%.2f` for formatting).'}, {text: 'printf("Item Price: %.2f\\n", it . price);', reason: 'There should not be a space between the variable name and the dot operator.'}], indent: 1, explanation: "Print the price member of 'it'." },
            { correct: 'it.price = 0.0f; // Modify the copy', distractors: [{text: 'item1.price = 0.0f;', reason: 'The original `item1` from `main` is not in scope here. You can only modify the local copy, `it`.'}, {text: 'it.id = 0;', reason: 'This modifies the `id`, but the goal is to show how modifying the price of the copy does not affect the original.'}], indent: 1, explanation: "Modify the price of the local copy 'it' within the function." },
            { correct: 'printf("Price inside function modified to: %.2f\\n", it.price);', distractors: [{text: 'printf("Price is now 0.00\\n");', reason: 'While true, printing the variable itself (`it.price`) confirms the assignment worked.'}, {text: 'printf("Original price was: %.2f\\n", item1.price);', reason: '`item1` is not accessible from within this function.'}], indent: 1, explanation: "Show the modified price of the copy." },
            { correct: 'printf("-- Leaving Function --\\n");', distractors: [{text: 'puts("-- Leaving Function --");', reason: '`puts` is also a valid and good choice here.'}, {text: '// End of function', reason: 'A print statement is better here to explicitly show the flow of control in the program\'s output.'}], indent: 1, explanation: "Indicate end of function execution." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Use `}` to close the function block.'}, {text: 'return;', reason: 'An explicit `return;` is optional at the end of a `void` function. The closing `}` is sufficient.'}], indent: 0, explanation: "Close displayItem function. The copy 'it' is destroyed." }
        ]
    },
    // Level 19: Pass Struct by Pointer
    {
        goal: "Pass a pointer to a struct to a function to modify the original struct.",
        concepts: "Structs, pointers, functions, pass-by-reference (using pointers), arrow operator (->)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: 'This header is not needed for this program\'s functionality.'}, {text: '#include <string.h>', reason: 'This header is for string manipulation and is not needed here.'}], indent: 0, explanation: "Include standard I/O." },
            { correct: 'struct Config { int settingA; char mode; };', distractors: [{text: 'struct Config { int settingA, char mode };', reason: 'Members in a struct definition must be separated by semicolons, not commas.'}, {text: 'typedef struct { int settingA; char mode; };', reason: 'This is not a valid `typedef`. It should be `typedef struct { ... } Config;`.'}], indent: 0, explanation: "Define a Config structure." },
            { correct: 'void updateConfig(struct Config *confPtr); // Takes pointer', distractors: [{text:'void updateConfig(struct Config conf);', reason:'Passing by value (`struct Config conf`) sends a copy; modifications inside wouldn\'t affect the original.'}, {text: 'void updateConfig(struct Config &confPtr);', reason: 'Reference parameters using `&` are a C++ feature. To modify the original in C, you must pass a pointer (`*`).'}], indent: 0, explanation: "Declare function updateConfig taking a POINTER to a struct Config." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return an integer.'}, {text: 'int main(void) {', reason: 'This is also a correct way to declare `main`.'}], indent: 0, explanation: "Start main." },
            { correct: 'struct Config currentConfig = { 1, \'A\' };', distractors: [{text: 'struct Config currentConfig = { .settingA = 1, .mode = \'A\'};', reason: 'Using designated initializers is also correct and often clearer, but this level uses the simpler positional initialization.'}, {text: 'struct Config currentConfig;', reason: 'This just declares the struct variable but does not initialize its members, which would contain garbage values.'}], indent: 1, explanation: "Declare and initialize a Config struct." },
            { correct: 'printf("Before call: SettingA=%d, Mode=%c\\n", currentConfig.settingA, currentConfig.mode);', distractors: [{text: 'printf("Before: %d, %c\\n", currentConfig);', reason: 'You cannot pass an entire struct to `printf` this way. You must specify each member you want to print.'}, {text: 'puts("Config is initialized.");', reason: 'This is too vague. Printing the actual values is necessary to see the change later.'}], indent: 1, explanation: "Print initial values." },
            { correct: 'updateConfig(&currentConfig);', distractors: [{text:'updateConfig(currentConfig);', reason:'The function expects a pointer (`struct Config *`). Pass the address (`&`) of `currentConfig`.'}, {text: 'updateConfig(*currentConfig);', reason: 'This is invalid. `*` is the dereference operator, and you cannot dereference a non-pointer variable like `currentConfig`.'}], indent: 1, explanation: "Call updateConfig, passing the ADDRESS of currentConfig." },
            { correct: 'printf("After call: SettingA=%d, Mode=%c\\n", currentConfig.settingA, currentConfig.mode);', distractors: [{text: 'printf("After call: SettingA=%d, Mode=%c\\n", confPtr->settingA, confPtr->mode);', reason: 'The pointer `confPtr` only exists within the `updateConfig` function. In `main`, you must use the original variable `currentConfig`.'}, {text: 'puts("Config was updated.");', reason: 'Again, printing the actual values is the only way to prove the function worked as intended.'}], indent: 1, explanation: "Print values again to show they were modified by the function." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to signal that the program completed without errors.'}, {text: 'end;', reason: '`end` is not a keyword in C.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'Use `}` to close the function block.'}, {text: '};', reason: 'Do not put a semicolon after the function\'s closing brace.'}], indent: 0, explanation: "Close main." },
            { correct: 'void updateConfig(struct Config *confPtr) { // Receives pointer', distractors: [{text: 'void updateConfig(struct Config confPtr) {', reason: 'The function was declared to take a pointer (`struct Config *`), so the definition must match.'}, {text: 'void updateConfig(struct Config *config) {', reason: 'Using a different parameter name like `config` is perfectly fine and does not change the logic.'}], indent: 0, explanation: "Define updateConfig, receiving a pointer named 'confPtr'." },
            { correct: 'printf("-- Inside updateConfig --\\n");', distractors: [{text: 'puts("-- Inside updateConfig --");', reason: 'This is also a correct and efficient way to print this line.'}, {text: '// Now modifying the struct', reason: 'A comment is good, but a `printf` shows the program flow at runtime.'}], indent: 1, explanation: "Indicate execution within the function." },
            { correct: 'confPtr->settingA = 99;', distractors: [{text:'confPtr.settingA = 99;', reason:'`confPtr` is a pointer; use the arrow operator `->` to access members via the pointer.'}, {text:'*confPtr.settingA = 99;', reason:'Operator precedence is wrong; use `(*confPtr).settingA` or preferably `confPtr->settingA`.'}], indent: 1, explanation: "Modify the settingA member of the ORIGINAL struct via the pointer." },
            { correct: 'confPtr->mode = \'Z\';', distractors: [{text:'*confPtr->mode = \'Z\';', reason:'`confPtr->mode` already accesses the member value; no extra `*` is needed.'}, {text: '(*confPtr).mode = \'Z\';', reason: 'This syntax is also correct and equivalent to the arrow operator, but the arrow operator `->` is generally preferred for its readability with pointers.'}], indent: 1, explanation: "Modify the mode member of the ORIGINAL struct via the pointer." },
            { correct: 'printf("Config updated inside function.\\n");', distractors: [{text: 'printf("Updated to %d and %c\\n", confPtr->settingA, confPtr->mode);', reason: 'This is also a great option to be more explicit about what happened inside the function.'}, {text: 'return;', reason: 'A `return` is not necessary here; the goal is to print a confirmation.'}], indent: 1, explanation: "Confirmation message." },
            { correct: '}', distractors: [{text: 'end function;', reason: 'C uses `}` to close blocks.'}, {text: 'return;', reason: 'A `return;` is implied at the end of a `void` function by the closing brace.'}], indent: 0, explanation: "Close updateConfig function." }
        ]
    },
    // Level 20: File Read with fgets
    {
        goal: "Open an existing file ('output.txt'), read lines from it using fgets, and print them.",
        concepts: "File I/O, FILE pointer, fopen, fgets, fclose, file modes (\"r\"), char arrays (buffers)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: 'File operations are part of the standard I/O library, `<stdio.h>`.'}, {text: '#include <files.h>', reason: 'There is no standard C header named `<files.h>`.'}], indent: 0, explanation: "Include standard I/O for file operations and printf." },
            { correct: '// Assumes "output.txt" exists (e.g., from a previous write operation)', distractors: [{text: '/* File must exist */', reason: 'This is also a valid comment achieving the same goal.'}, {text: '// Create "output.txt"', reason: 'This comment is misleading. The code does not create the file; it assumes it\'s already there.'}], indent: 0, explanation: "Comment reminding prerequisite." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}, {text: 'int main(void) {', reason: 'This is also correct.'}], indent: 0, explanation: "Start main." },
            { correct: 'FILE *readFilePtr;', distractors: [{text: 'File *readFilePtr;', reason: 'The type for a file stream is `FILE`, in all capital letters.'}, {text: 'int *readFilePtr;', reason: 'A file stream requires a special `FILE` pointer, not a standard integer pointer.'}], indent: 1, explanation: "Declare a FILE pointer for reading." },
            { correct: 'char lineBuffer[100]; // Buffer to hold one line', distractors: [{text:'char *lineBuffer;', reason:'`fgets` needs a character array (buffer) allocated in memory to store the line it reads. A simple pointer isn\'t enough.'}, {text:'char lineBuffer;', reason:'A single char cannot hold a line of text.'}], indent: 1, explanation: "Declare a character array to act as a buffer for reading lines." },
            { correct: 'readFilePtr = fopen("output.txt", "r");', distractors: [{text:'readFilePtr = fopen("output.txt", "w");', reason:'Mode "w" is for writing (and truncates the file). Mode "r" is needed for reading.'}, {text:'readFilePtr = open("output.txt", "r");', reason:'`open` is a different, lower-level I/O function (from `<fcntl.h>`). The standard C library function is `fopen`.'}], indent: 1, explanation: "Open 'output.txt' in read mode ('r')." },
            { correct: 'if (readFilePtr == NULL) {', distractors: [{text: 'if (!readFilePtr) {', reason: 'This is also a correct and common way to check for a NULL pointer.'}, {text: 'if (readFilePtr == 0) {', reason: '`NULL` is the standard macro for a null pointer constant. While it may be defined as 0, using `NULL` is more explicit and portable.'}], indent: 1, explanation: "Check if the file failed to open (e.g., doesn't exist)." },
            { correct: 'perror("Error opening file for reading"); return 1;', distractors: [{text:'printf("Error opening file!\\n"); return 1;', reason:'`perror` is useful as it prints the system error message corresponding to why `fopen` failed.'}, {text: 'return 1;', reason: 'Exiting is correct, but you should always print an error message so the user knows what went wrong.'}], indent: 2, explanation: "Print a system error message using perror and exit if file couldn't be opened." },
            { correct: '}', distractors: [{text: 'end if;', reason: 'Use `}` to close a block.'}], indent: 1, explanation: "Close error check." },
            { correct: 'printf("Contents of output.txt:\\n---\n");', distractors: [{text: 'puts("Contents of output.txt:\\n---");', reason: '`puts` is fine, but it will add an extra newline at the end.'}], indent: 1, explanation: "Print a header before showing file content." },
            { correct: 'while (fgets(lineBuffer, sizeof(lineBuffer), readFilePtr) != NULL) {', distractors: [{text:'while (!feof(readFilePtr)) {', reason:'Checking `feof` *before* reading can lead to issues. The standard idiom is to check the return value of the read function (`fgets` or `fscanf`) itself. `fgets` returns NULL on end-of-file or error.'}, {text:'fgets(lineBuffer, 100, readFilePtr); while(1) { ... }', reason:'`fgets` should be *inside* the loop condition to read each line and check the return value.'}], indent: 1, explanation: "Loop while fgets successfully reads a line into lineBuffer (returns non-NULL)." },
            { correct: 'printf("%s", lineBuffer); // fgets includes newline', distractors: [{text:'printf("%s\\n", lineBuffer);', reason:'`fgets` reads and stores the newline character (`\\n`) if it fits in the buffer. Adding another `\\n` in `printf` would cause double spacing.'}, {text: 'puts(lineBuffer);', reason: '`puts` also prints the string but adds its own newline, which would also result in double spacing because `fgets` already captured one.'}], indent: 2, explanation: "Print the line read by fgets. It usually includes the newline." },
            { correct: '}', distractors: [{text: 'end while;', reason: 'Use `}` to close the loop block.'}], indent: 1, explanation: "Close the while loop." },
            { correct: 'printf("---\\nEnd of file.\\n");', distractors: [{text: 'puts("---\\nEnd of file.");', reason: 'This is also a perfectly valid way to print this.'}], indent: 1, explanation: "Print a footer after reading the file." },
            { correct: 'fclose(readFilePtr);', distractors: [{text:'fclose(lineBuffer);', reason:'`fclose` closes the `FILE` stream pointed to by `readFilePtr`.'}, {text: 'close(readFilePtr);', reason: '`close` is the corresponding function for `open`, not for `fopen`.'}], indent: 1, explanation: "Close the file stream." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate the program ran successfully.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Use `}` to close the main function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 21: Dynamic Memory with calloc
    {
        goal: "Allocate memory for an array of 3 integers using calloc() (initializes to zero) and print them.",
        concepts: "Dynamic memory allocation, calloc, free, sizeof, pointers, initialization to zero",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <string.h>', reason: 'This header is not needed.'}], indent: 0, explanation: "Include for printf." },
            { correct: '#include <stdlib.h>', distractors: [{text: '#include <memory.h>', reason: 'Dynamic memory functions like `calloc` and `free` are in the standard library header, `<stdlib.h>`.'}], indent: 0, explanation: "Include stdlib.h for calloc and free." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}], indent: 0, explanation: "Start main." },
            { correct: 'int *zeroArray;', distractors: [{text: 'int zeroArray[];', reason: 'This declares a static array of unknown size, which is not allowed. For dynamic memory, you need a pointer to hold the address.'}, {text: 'int *zeroArray = NULL;', reason: 'Initializing to NULL is excellent practice and also correct.'}], indent: 1, explanation: "Declare a pointer for the dynamically allocated array." },
            { correct: 'int count = 3;', distractors: [{text: 'const int count = 3;', reason: 'Using `const` is good practice for a value that won\'t change and is also correct here.'}, {text: '#define count 3', reason: 'Using a `#define` macro is another way to create a constant, but an `int` variable is often preferred in modern C.'}], indent: 1, explanation: "Define the number of elements needed." },
            { correct: 'zeroArray = (int *)calloc(count, sizeof(int));', distractors: [{text:'zeroArray = (int *)malloc(count * sizeof(int));', reason:'`malloc` allocates memory but doesn\'t initialize it (contains garbage values). `calloc` allocates *and* initializes the memory to zero.'}, {text:'zeroArray = (int *)calloc(sizeof(int), count);', reason:'The arguments for `calloc` are `(number_of_elements, size_of_each_element)`.'}], indent: 1, explanation: "Allocate memory for 'count' integers using calloc (initializes to zero) and cast." },
            { correct: 'if (zeroArray == NULL) {', distractors: [{text: 'if (!zeroArray) {', reason: 'This is another correct and common way to check for a NULL pointer.'}, {text: 'if (zeroArray != NULL) {', reason: 'This checks for a successful allocation. The block immediately following should handle the *failure* case.'}], indent: 1, explanation: "Check if calloc failed." },
            { correct: 'printf("Memory allocation failed!\\n"); return 1;', distractors: [{text: 'return 1;', reason: 'You should always print an error message to inform the user why the program is terminating.'}, {text: 'exit(1);', reason: '`exit(1)` from `<stdlib.h>` is also a valid way to terminate the program upon error.'}], indent: 2, explanation: "Handle allocation failure." },
            { correct: '}', distractors: [{text: 'end if;', reason: 'Use `}` to close the block.'}], indent: 1, explanation: "Close error check." },
            { correct: 'printf("Array elements after calloc (should be 0):\\n");', distractors: [{text: 'puts("Array elements are zero:");', reason: 'This also works, but the current message is slightly more descriptive about why they should be zero.'}], indent: 1, explanation: "Print a header." },
            { correct: 'for (int i = 0; i < count; i++) {', distractors: [{text: 'for (int i = 0; i <= count; i++) {', reason: 'This would cause a buffer overflow by trying to access `zeroArray[3]`, which is one element past the allocated memory.'}], indent: 1, explanation: "Loop through the allocated elements." },
            { correct: 'printf("zeroArray[%d] = %d\\n", i, zeroArray[i]);', distractors: [{text: 'printf("%d\\n", zeroArray[i]);', reason: 'Including the index `i` in the printout makes the output clearer and easier to verify.'}, {text: 'printf("Value is %d\\n", *(zeroArray + i));', reason: 'This is also a correct way to access and print the element using pointer arithmetic notation.'}], indent: 2, explanation: "Print the index and the value (should be 0)." },
            { correct: '}', distractors: [{text: 'end loop;', reason: 'Use `}` to close the loop.'}], indent: 1, explanation: "Close the loop." },
            { correct: 'free(zeroArray);', distractors: [{text:'free(&zeroArray);', reason:'`free` needs the pointer (`zeroArray`) that holds the address returned by `calloc`.'}, {text: 'delete(zeroArray);', reason: '`delete` is the C++ operator for freeing memory allocated with `new`. In C, you must use `free`.'}], indent: 1, explanation: "Free the memory allocated by calloc." },
            { correct: 'zeroArray = NULL;', distractors: [{text: '// Memory is now free', reason: 'This is a good comment, but setting the pointer to NULL is an important safety step to prevent dangling pointers.'}, {text: 'free(zeroArray); // Free again to be sure', reason: 'Freeing the same memory twice (a "double free") leads to undefined behavior and can crash your program.'}], indent: 1, explanation: "Set pointer to NULL after freeing (good practice)." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate success.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Use `}` to close `main`.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 22: Dynamic Memory with malloc
    {
        goal: "Allocate memory for an array of 5 floats dynamically using malloc, use it, and free it.",
        concepts: "Dynamic memory allocation, malloc, free, sizeof, pointers, pointer arithmetic/array notation",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: 'While `stdlib.h` is needed for this program, the `printf` function specifically requires `<stdio.h>`.'}, {text: 'import <stdio.h>', reason: 'C uses the `#include` preprocessor directive, not `import`.'}], indent: 0, explanation: "Include for printf." },
            { correct: '#include <stdlib.h>', distractors: [{text: '#include <memory.h>', reason: 'The standard C header for memory allocation functions like `malloc` and `free` is `<stdlib.h>`.'}, {text: '#include <string.h>', reason: 'The `<string.h>` header contains string manipulation functions, not memory allocation functions.'}], indent: 0, explanation: "Include stdlib.h for malloc and free." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'In standard C, the `main` function must be declared to return an `int` to signal its exit status.'}, {text: 'function main() {', reason: 'C does not use the `function` keyword; a function is defined by its return type, name, and parameters.'}], indent: 0, explanation: "Start main." },
            { correct: 'float *dynFloatArray;', distractors: [{text:'float dynFloatArray[5];', reason:'This declares a static array on the stack. We need a pointer for dynamically allocated memory from the heap.'}, {text: 'float *dynFloatArray = NULL;', reason: 'Initializing the pointer to NULL is excellent practice and is also a correct way to start.'}], indent: 1, explanation: "Declare a pointer to float for the dynamic array." },
            { correct: 'int numElements = 5;', distractors: [{text: '#define numElements 5', reason: 'Using a preprocessor macro is another valid way to define a constant like the size.'}, {text: 'const int numElements = 5;', reason: 'Using a `const` variable is also a great, type-safe way to define the size.'}], indent: 1, explanation: "Define the desired number of elements." },
            { correct: 'dynFloatArray = (float *)malloc(numElements * sizeof(float));', distractors: [{text:'dynFloatArray = (float *)malloc(numElements);', reason:'`malloc` needs the total number of *bytes*. You must multiply the number of elements by the size of *each* element (`sizeof(float)`).'}, {text:'dynFloatArray = (float *)malloc(sizeof(float[numElements]));', reason:'While this might work if `numElements` is a compile-time constant, the standard and most flexible way is `count * sizeof(type)`.'}], indent: 1, explanation: "Allocate memory for 'numElements' floats and cast the result to float*." },
            { correct: 'if (dynFloatArray == NULL) {', distractors: [{text: 'if (!dynFloatArray) {', reason: 'This is an equivalent and common way to check if a pointer is NULL, as NULL evaluates to false.'}, {text: 'if (dynFloatArray != NULL) {', reason: 'This checks for success. The `if` block here is intended to handle the *failure* case.'}], indent: 1, explanation: "Check if memory allocation failed." },
            { correct: 'printf("Memory allocation failed!\\n"); return 1;', distractors: [{text: 'return 1;', reason: 'It is crucial to print an error message to let the user know what went wrong before exiting.'}, {text: 'exit(1);', reason: '`exit(1)` from `<stdlib.h>` is also a valid and common way to terminate the program upon error.'}], indent: 2, explanation: "Handle allocation failure." },
            { correct: '}', distractors: [{text: 'end if;', reason: 'C uses a closing curly brace `}` to end a block, not keywords.'}], indent: 1, explanation: "Close error check." },
            { correct: '// Initialize the dynamic array', distractors: [{text: '/* Initialize array */', reason: 'This is another valid comment style in C.'}], indent: 1, explanation: "Comment indicating array initialization." },
            { correct: 'for (int i = 0; i < numElements; i++) {', distractors: [{text: 'for (int i=0; i < 5; i++) {', reason: 'Using the `numElements` variable is better practice than hard-coding the number 5, making the code easier to change.'}], indent: 1, explanation: "Loop through the allocated elements." },
            { correct: 'dynFloatArray[i] = (float)i * 1.1f;', distractors: [{text:'*(dynFloatArray + i) = (float)i * 1.1f;', reason:'Both array notation `dynFloatArray[i]` and pointer arithmetic `*(dynFloatArray + i)` are valid ways to access elements.'}, {text: 'dynFloatArray[i] = i * 1.1;', reason: 'Appending `f` (as in `1.1f`) makes the number a `float` literal, which is good practice for type consistency.'}], indent: 2, explanation: "Assign values using array notation (e.g., 0.0, 1.1, 2.2,...)." },
            { correct: '}', distractors: [{text: 'end for;', reason: 'C uses `}` to end loop blocks.'}], indent: 1, explanation: "Close initialization loop." },
            { correct: 'printf("Dynamic array elements: ");', distractors: [{text: 'puts("Dynamic array elements: ");', reason: '`puts` automatically adds a newline, which would cause the numbers to print on the next line, not after the label.'}], indent: 1, explanation: "Print a label." },
            { correct: 'for (int i = 0; i < numElements; i++) {', distractors: [{text: 'for (int i = 0; i <= numElements; i++) {', reason: 'Using `<=` would try to access an element at index 5, which is out of bounds for an array of 5 elements (indices 0-4).'}], indent: 1, explanation: "Loop again to print the elements." },
            { correct: 'printf("%.1f ", dynFloatArray[i]);', distractors: [{text: 'printf("%f ", dynFloatArray[i]);', reason: 'Using `%.1f` formats the output to one decimal place, which looks cleaner here.'}, {text: 'printf("%d ", dynFloatArray[i]);', reason: '`%d` is for printing integers. You must use `%f` for printing float values.'}], indent: 2, explanation: "Print each element, formatted to one decimal place." },
            { correct: '}', distractors: [{text: 'continue;', reason: '`continue` would just skip to the next loop iteration; it does not define the end of the loop\'s code block.'}], indent: 1, explanation: "Close printing loop." },
            { correct: 'printf("\\n");', distractors: [{text: 'puts("");', reason: 'This is another valid and common way to print just a newline character.'}], indent: 1, explanation: "Final newline." },
            { correct: 'free(dynFloatArray);', distractors: [{text: 'delete dynFloatArray;', reason: '`delete` is a C++ keyword for freeing memory. The C equivalent is `free`.'}, {text: 'free(dynFloatArray[0]);', reason: 'You must `free` the pointer to the start of the memory block that `malloc` returned, not a pointer to a single element.'}], indent: 1, explanation: "Free the entire allocated block of memory." },
            { correct: 'dynFloatArray = NULL;', distractors: [{text: '// Pointer is now invalid', reason: 'This comment is true, but actively setting the pointer to `NULL` is a crucial safety step to create a null pointer, not a dangling one.'}], indent: 1, explanation: "Set pointer to NULL after freeing." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Returning `1` (or any non-zero value) from `main` conventionally indicates that an error occurred.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: '`end` is not a C keyword. A closing brace `}` is used to end a function block.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 23: String Copy with strcpy
    {
        goal: "Copy one string to another using strcpy.",
        concepts: "strcpy, string.h, char arrays, null termination, buffer safety (conceptual)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: 'The header for `printf` is `<stdio.h>`.'}, {text: '#include "stdio.h"', reason: 'Using angle brackets `<>` is the standard convention for including system library headers.'}], indent: 0, explanation: "Include for printf." },
            { correct: '#include <string.h>', distractors: [{text: '#include <strings.h>', reason:'The standard C header for string manipulation is `<string.h>`, not `<strings.h>` (a non-standard POSIX header).'}, {text: '#include <stdlib.h>', reason: 'The `strcpy` function is declared in `<string.h>`, not `<stdlib.h>`.'}], indent: 0, explanation: "Include string.h for strcpy." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires that `main` returns an `int`.'}, {text: 'int main(void) {', reason: 'This is also a correct way to declare `main` with no arguments.'}], indent: 0, explanation: "Start main." },
            { correct: 'char source[] = "Hello C!";', distractors: [{text:'char *source = "Hello C!";', reason:'This creates a pointer to a string literal, which may be read-only. For demonstrating `strcpy`, using a mutable array is safe.'}, {text: 'char source[] = {\'H\',\'e\',\'l\',\'l\',\'o\',\' \',\'C\',\'!\'};', reason: 'This array is missing the required null terminator (`\\0`). `strcpy` would read past the end of it.'}], indent: 1, explanation: "Declare and initialize the source string." },
            { correct: 'char destination[20];', distractors: [{text:'char destination[];', reason:'When declaring an array that will be a destination, its size must be specified and be large enough to hold the source string.'}, {text:'char *destination;', reason:'This declares an uninitialized pointer. `strcpy` needs a valid memory location (like an array) to copy data into.'}], indent: 1, explanation: "Declare the destination string buffer (must be large enough)." },
            { correct: 'strcpy(destination, source);', distractors: [{text:'strcpy(source, destination);', reason:'The first argument to `strcpy` is the destination, and the second is the source. This would be a dangerous buffer overflow.'}, {text:'destination = source;', reason:'You cannot assign one array to another using the `=` operator in C. You must use a function like `strcpy` to copy the content.'}], indent: 1, explanation: "Copy the source string to the destination string." },
            { correct: 'printf("Source: %s\\n", source);', distractors: [{text: 'printf(source);', reason: 'This is insecure and considered bad practice (a format string vulnerability). Always use a format specifier like `%s`.'}, {text: 'puts(source);', reason: '`puts` is also a correct way to print the string, and it automatically adds a newline.'}], indent: 1, explanation: "Print the source string." },
            { correct: 'printf("Destination: %s\\n", destination);', distractors: [{text: 'puts(destination);', reason: '`puts` would also work correctly here.'}, {text: 'printf("Destination: %s\\n", &destination);', reason: 'The array name `destination` already decays to a pointer. `&destination` is a pointer to the whole array, which is the wrong type for `%s`.'}], indent: 1, explanation: "Print the copied string in destination." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to indicate a successful run.'}, {text: 'return destination;', reason: '`main` must return an `int` exit code, not a pointer to a string.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: '`end` is not a C keyword. Use `}`.'}, {text: '};', reason: 'A semicolon is not used after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 24: String Concatenation with strcat
    {
        goal: "Concatenate two strings using strcat.",
        concepts: "strcat, string.h, char arrays, buffer overflow risk (conceptual)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`printf` is in `<stdio.h>`.'}, {text: '#include "stdio.h"', reason: 'Use angle brackets `<>` for standard library headers.'}], indent: 0, explanation: "Include for printf." },
            { correct: '#include <string.h>', distractors: [{text: '#include <stdlib.h>', reason: 'String functions like `strcat` are declared in `<string.h>`.'}, {text: '#include <str.h>', reason: 'There is no standard C header named `<str.h>`. The correct header is `<string.h>`.'}], indent: 0, explanation: "Include string.h for strcat." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return type `int`.'}, {text: 'int main(void) {', reason: 'This is also correct.'}], indent: 0, explanation: "Start main." },
            { correct: 'char str1[50] = "Hello, ";', distractors: [{text:'char str1[] = "Hello, ";', reason:'While this initialization is valid, the destination array for `strcat` must be explicitly sized large enough to hold the final concatenated string.'}, {text: 'char *str1 = "Hello, ";', reason: 'You cannot use `strcat` to modify a string literal, as they are typically stored in read-only memory.'}], indent: 1, explanation: "Declare first string with enough space for concatenation." },
            { correct: 'char str2[] = "World!";', distractors: [{text: 'const char str2[] = "World!";', reason: 'Marking the source string `const` is good practice since `strcat` does not modify it. This would also work.'}, {text: 'char str2[6] = "World!";', reason: 'This is too small. It does not leave room for the null terminator `\\0`.'}], indent: 1, explanation: "Declare the second string to append." },
            { correct: 'strcat(str1, str2);', distractors: [{text:'strcat(str2, str1);', reason:'`strcat` appends the second string to the first. `str2` does not have enough space to hold the result, leading to a buffer overflow.'}, {text:'str1 = str1 + str2;', reason:'String concatenation with the `+` operator is not a feature of C char arrays; you must use a function like `strcat`.'}], indent: 1, explanation: "Append str2 to the end of str1." },
            { correct: 'printf("Concatenated string: %s\\n", str1);', distractors: [{text: 'printf(str1);', reason: 'This is insecure and can lead to a format string vulnerability. Always use `%s`.'}, {text: 'puts(str1);', reason: '`puts` is also a correct and safe way to print the final string.'}], indent: 1, explanation: "Print the resulting string in str1." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 for success.'}, {text: 'return strlen(str1);', reason: '`main` should return an exit code (0 for success), not a calculated value like the string length.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'Use `}` to close a function block.'}, {text: '};', reason: 'Do not place a semicolon after a function\'s closing brace.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 25: String Length with strlen
    {
        goal: "Find the length of a string using strlen.",
        concepts: "strlen, string.h, null termination (excluding)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`printf` is in `<stdio.h>`.'}, {text: 'import <stdio.h>', reason: 'C uses `#include`.'}], indent: 0, explanation: "Include for printf." },
            { correct: '#include <string.h>', distractors: [{text: '#include <stdlib.h>', reason: '`strlen` is declared in `<string.h>`.'}, {text: '#include <strings.h>', reason: 'The standard header is `<string.h>`. `<strings.h>` is a different, non-standard header.'}], indent: 0, explanation: "Include string.h for strlen." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}, {text: 'int main[] {', reason: 'Functions use parentheses `()` for their signature, not square brackets `[]`.'}], indent: 0, explanation: "Start main." },
            { correct: 'char myString[] = "Test"; // Length is 4', distractors: [{text: 'char *myString = "Test";', reason: 'This also works, as `strlen` correctly handles pointers to string literals.'}, {text: 'char myString[] = {\'T\', \'e\', \'s\', \'t\'};', reason: 'This array is NOT null-terminated. `strlen` would read past the end of the allocated memory, causing undefined behavior.'}], indent: 1, explanation: "Declare and initialize a string." },
            { correct: 'int length;', distractors: [{text:'size_t length;', reason:'`strlen` actually returns type `size_t`. Using `int` is common for simplicity, but `size_t` is the most correct type.'}, {text: 'int length = 0;', reason: 'Initializing to zero is fine and good practice, though it will be immediately overwritten by the `strlen` call.'}], indent: 1, explanation: "Declare a variable to store the length." },
            { correct: 'length = strlen(myString);', distractors: [{text:'length = sizeof(myString);', reason:'`sizeof(myString)` gives the size of the array in memory (5 bytes: 4 chars + 1 null terminator). `strlen` counts only the characters *before* the null terminator (4).'}, {text:'length = strlen(&myString);', reason:'`strlen` expects a `char*`. The array name `myString` decays to this type. `&myString` is a pointer to the whole array, which is the wrong type.'}], indent: 1, explanation: "Calculate the length of the string." },
            { correct: 'printf("The length of \\"%s\\" is %d.\\n", myString, length);', distractors: [{text: 'printf("Length is %d\\n", length);', reason: 'This works, but including the original string `myString` in the output makes it much more descriptive.'}, {text: 'printf("Length of %s is %f\\n", myString, length);', reason: '`%f` is the format specifier for floats. You must use `%d` to print an integer like `length`.'}], indent: 1, explanation: "Print the string and its calculated length." },
            { correct: 'return 0;', distractors: [{text: 'return length;', reason: '`main` should return the exit code `0` for success, not the calculated length of the string.'}, {text: 'exit(0);', reason: '`exit(0)` is another way to terminate successfully, but `return 0;` is the standard way to exit the `main` function.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'C uses `}` to close function blocks.'}, {text: '};', reason: 'A semicolon is not placed after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 26: String Comparison with strcmp
    {
        goal: "Compare two strings using strcmp.",
        concepts: "strcmp, string.h, return values (0, <0, >0)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <stdlib.h>', reason: '`printf` is in `<stdio.h>`.'}, {text: '#include <string.h>', reason: 'This is also needed, but this line is for `printf`.'}], indent: 0, explanation: "Include for printf." },
            { correct: '#include <string.h>', distractors: [{text: '#include <stdio.h>', reason: 'This is already included. This line is for `strcmp` which is in `<string.h>`.'}, {text: '#include <compare.h>', reason: 'There is no standard C header `<compare.h>`. String comparison is in `<string.h>`.'}], indent: 0, explanation: "Include string.h for strcmp." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: '`main` must return `int`.'}, {text: 'int main(void) {', reason: 'This is also correct.'}], indent: 0, explanation: "Start main." },
            { correct: 'char s1[] = "apple";', distractors: [{text: 'char s1 = "apple";', reason: 'You cannot assign a multi-character string literal to a single `char` variable.'}, {text: 'char s1[] = {\'a\',\'p\',\'p\',\'l\',\'e\'};', reason: 'This array is missing the essential null terminator (`\\0`), which would cause `strcmp` to read out of bounds.'}], indent: 1, explanation: "Declare first string." },
            { correct: 'char s2[] = "apply";', distractors: [{text: 'char s2[5] = "apply";', reason: 'This array is not large enough. It needs to be size 6 to hold the 5 characters plus the null terminator.'}, {text: 'char *s2 = "apply";', reason: 'This is also a valid way to create a string for comparison.'}], indent: 1, explanation: "Declare second string (different)." },
            { correct: 'char s3[] = "apple";', distractors: [{text: 'char s3[] = s1;', reason: 'You cannot initialize an array with another array in this manner.'}, {text: 'char *s3 = s1;', reason: 'This makes `s3` a pointer to `s1`. `strcmp(s1, s3)` would work, but the goal is to compare two separate but identical strings.'}], indent: 1, explanation: "Declare third string (same as s1)." },
            { correct: 'int result12 = strcmp(s1, s2);', distractors: [{text:'int result12 = s1 == s2;', reason:'Comparing char arrays with `==` compares their memory addresses, not their content. Use `strcmp` for content comparison.'}, {text: 'int result12 = str_cmp(s1, s2);', reason: 'The standard C library function is named `strcmp`, not `str_cmp`.'}], indent: 1, explanation: "Compare s1 and s2." },
            { correct: 'int result13 = strcmp(s1, s3);', distractors: [{text: 'int result13 = (s1 == s3);', reason: 'The `==` operator compares memory addresses. Since `s1` and `s3` are two different arrays, their addresses are different, and this would incorrectly result in 0 (false).'}], indent: 1, explanation: "Compare s1 and s3." },
            { correct: 'if (result12 < 0) { printf("%s comes before %s\\n", s1, s2); }', distractors: [{text:'if (result12 == 0) { printf("s1 and s2 are equal.\\n"); }', reason:'`strcmp` returns 0 only if strings are equal. "apple" and "apply" are not equal.'}, {text: 'if (result12 > 0) { printf("%s comes after %s\\n", s1, s2); }', reason: '`strcmp` returns a negative value because the first differing character, \'e\', comes before \'y\' alphabetically.'}], indent: 1, explanation: "Check if s1 is lexicographically less than s2." },
            { correct: 'if (result13 == 0) { printf("%s and %s are equal\\n", s1, s3); }', distractors: [{text:'if (result13 != 0) { printf("s1 and s3 are different.\\n"); }', reason:'`strcmp` returns 0 when strings *are* identical, so this condition is the opposite of what we want to check.'}, {text: 'if (result13) { printf("s1 and s3 are different.\\n"); }', reason: 'A return value of 0 is treated as `false` in a C `if` statement. This block would only execute if the strings were different.'}], indent: 1, explanation: "Check if s1 and s3 are equal." },
            { correct: 'return 0;', distractors: [{text: 'return result12;', reason: 'This would return a non-zero exit code to the OS, signaling an error, which is not the program\'s intent.'}, {text: 'return;', reason: '`main` is declared to return an `int`, so a value must be provided (`0` for success).'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: 'Not a C keyword. Use `}`.'}, {text: 'end if;', reason: 'Incorrect syntax. Use `}` to close the `main` function block.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 27: Function Pointer
    {
        goal: "Declare and use a simple function pointer.",
        concepts: "Function pointers (declaration, assignment, call)",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <functions.h>', reason: 'There is no standard C header `<functions.h>`. Functionality is built-in.'}, {text: 'import <stdio.h>', reason: 'C uses `#include`.'}], indent: 0, explanation: "Include for printf." },
            { correct: 'void sayHello() { printf("Hello!\\n"); }', distractors: [{text: 'int sayHello() { printf("Hello!\\n"); return 0; }', reason: 'This is a valid function, but a `void` return type is simpler for this first example.'}], indent: 0, explanation: "Define a simple function." },
            { correct: 'int add(int a, int b) { return a + b; }', distractors: [{text: 'void add(int a, int b) { printf("%d", a + b); }', reason: 'This function prints but does not *return* an integer value, so it would not match the function pointer we will declare.'}], indent: 0, explanation: "Define another function with parameters and return type." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return `int`.'}, {text: 'main() {', reason: 'Omitting the return type for functions is deprecated and bad practice. Always be explicit.'}], indent: 0, explanation: "Start main." },
            { correct: 'void (*helloPtr)();', distractors: [{text:'void *helloPtr();', reason:'This declares a function named `helloPtr` that returns a `void*` pointer. The parentheses `(*helloPtr)` are essential to declare a pointer to a function.'}, {text:'void helloPtr();', reason:'This declares a regular function named `helloPtr`, not a pointer to one.'}], indent: 1, explanation: "Declare a function pointer 'helloPtr' that can point to a void function with no arguments." },
            { correct: 'helloPtr = sayHello;', distractors: [{text:'helloPtr = sayHello();', reason:'Assign the function name directly. Adding `()` would *call* the function and try to assign its `void` result, which is invalid.'}, {text:'helloPtr = &sayHello;', reason:'Using the address-of operator `&` is also a valid and more explicit way to assign the function\'s address.'}], indent: 1, explanation: "Assign the address of 'sayHello' to 'helloPtr'." },
            { correct: 'helloPtr(); // Call function via pointer', distractors: [{text:'(*helloPtr)();', reason:'This is also a valid, older syntax for calling a function through a pointer. The simpler `helloPtr()` is more common today.'}, {text: 'sayHello();', reason: 'This calls the original function directly, not through the pointer, which defeats the purpose of this exercise.'}], indent: 1, explanation: "Call the function using the function pointer." },
            { correct: 'int (*mathOp)(int, int);', distractors: [{text:'int *mathOp(int, int);', reason:'This declares a function `mathOp` that returns a pointer-to-int. The parentheses `(*mathOp)` are required to specify a pointer-to-function.'}, {text: 'int mathOp(int, int);', reason: 'This declares a regular function, not a pointer.'}], indent: 1, explanation: "Declare a function pointer 'mathOp' for a function taking two ints and returning an int." },
            { correct: 'mathOp = add;', distractors: [{text: 'mathOp = add(5, 3);', reason: 'This would call the `add` function and try to assign its integer result (8) to the pointer, which is a type mismatch.'}, {text: '*mathOp = add;', reason: 'Assignment is done to the pointer variable `mathOp` itself, not by dereferencing it.'}], indent: 1, explanation: "Assign the address of 'add' to 'mathOp'." },
            { correct: 'printf("Sum: %d\\n", mathOp(5, 3));', distractors: [{text:'printf("Sum: %d\\n", (*mathOp)(5, 3));', reason:'This older syntax with the explicit dereference is also a valid way to call the function through the pointer.'}, {text: 'printf("Sum: %d\\n", add(5, 3));', reason: 'This calls the function directly, bypassing the function pointer.'}], indent: 1, explanation: "Call 'add' via 'mathOp' and print the result." },
            { correct: 'return 0;', distractors: [{text: 'return 1;', reason: 'Return 0 to signal success.'}, {text: 'return NULL;', reason: 'While `NULL` might be defined as 0, returning `0` explicitly is the standard and clearest way to signal success from `main`.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end main;', reason: 'Use `}` to close a block.'}, {text: '};', reason: 'Semicolons are not used after a function\'s closing brace.'}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 28: Enum Usage
    {
        goal: "Define an enum for days of the week and use it.",
        concepts: "enum keyword, enum values, using enum variables",
        sequence: [
            { correct: '#include <stdio.h>', distractors: [{text: '#include <enum.h>', reason: 'There is no standard `<enum.h>`. The `enum` keyword is a built-in part of the C language.'}, {text: '#include <stdlib.h>', reason: 'This header is not needed for this program.'}], indent: 0, explanation: "Include for printf." },
            { correct: 'enum Weekday { SUN, MON, TUE, WED, THU, FRI, SAT };', distractors: [{text:'enum Weekday [ SUN, MON, TUE ];', reason:'Enum members are listed inside curly braces `{}` and separated by commas, not square brackets.'}, {text:'struct Weekday { int SUN, MON, TUE; };', reason:'`struct` is used to group variables, not to define a set of named integer constants like `enum` does.'}], indent: 0, explanation: "Define an enumeration for days of the week (SUN=0, MON=1, etc.)." },
            { correct: 'int main() {', distractors: [{text: 'void main() {', reason: 'Standard C requires `main` to return `int`.'}, {text: 'int main(void) {', reason: 'This is also a correct way to declare `main`.'}], indent: 0, explanation: "Start main." },
            { correct: 'enum Weekday today;', distractors: [{text:'Weekday today;', reason:'In C (unlike C++), you must use the `enum` keyword when declaring a variable of an enum type, e.g., `enum Weekday`.'}, {text: 'int today;', reason: 'While an enum is compatible with `int`, declaring it as `enum Weekday` is more type-safe and clearly expresses your intent.'}], indent: 1, explanation: "Declare a variable 'today' of type 'enum Weekday'." },
            { correct: 'today = WED;', distractors: [{text:'today = "WED";', reason:'Enum values are named integer constants, not strings. You must use the enumerator `WED` directly, without quotes.'}, {text:'today = 3;', reason:'While `WED` is equal to 3 in this case, using the name `WED` is far more readable and self-documenting.'}], indent: 1, explanation: "Assign an enum value to 'today'." },
            { correct: 'if (today == WED) {', distractors: [{text:'if (today == "WED") {', reason:'You must compare enum variables with enum constants (`WED`), not with string literals (`"WED"`).'}, {text: 'if (strcmp(today, "WED") == 0)', reason: '`strcmp` is for comparing strings, not for comparing an enum value which acts like an integer.'}], indent: 1, explanation: "Check the value of the enum variable." },
            { correct: 'printf("Today is Wednesday!\\n");', distractors: [{text: 'printf("Today is %d\\n", today);', reason: 'This would print "Today is 3", which is not the goal. We want to print a specific message based on the `if` check.'}, {text: 'puts("Today is Wednesday!");', reason: 'This is also a perfectly correct way to print the desired output.'}], indent: 2, explanation: "Print a message based on the enum value." },
            { correct: '}', distractors: [{text: 'end if;', reason: 'C uses a closing brace `}` to end a block.'}, {text: 'break;', reason: '`break` is used to exit from a loop or a switch case, not an `if` statement.'}], indent: 1, explanation: "Close if block." },
            { correct: 'printf("Value of FRI: %d\\n", FRI);', distractors: [{text:'printf("Value of FRI: %s\\n", FRI);', reason:'Enum values are fundamentally integers. You must use the `%d` format specifier to print their numeric value, not `%s` for strings.'}, {text: 'printf("Value of FRI: %d\\n", "FRI");', reason: 'This passes a string literal to `printf` where it expects an integer, leading to incorrect output.'}], indent: 1, explanation: "Print the integer value of an enumerator." },
            { correct: 'return 0;', distractors: [{text: 'return today;', reason: '`main` should return a `0` for success, not the integer value of an enum variable.'}, {text: 'return 1;', reason: 'Returning `1` would signal that the program failed, which is not the case.'}], indent: 1, explanation: "Indicate success." },
            { correct: '}', distractors: [{text: 'end;', reason: '`end` is not a C keyword. Use `}`.'}, {text: '};', reason: 'A semicolon is not used after the closing brace of a function.'}], indent: 0, explanation: "Close main." }
        ]
    },
  // Level 29: 2D Arrays and Functions
  {
    goal: "Declare a 2D array, pass it to a function to calculate row sums, and print the results.",
    concepts: "2D arrays, nested loops, passing multidimensional arrays to functions, function prototypes",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "That’s a C++ header, not valid C." }, { text: "#import <stdio.h>", reason: "`#import` isn’t a standard directive in C." }], indent: 0, explanation: "Include standard I/O for printf." },
      { correct: "#define ROWS 3", distractors: [{ text: "#define ROWS = 3;", reason: "Macros don’t use `=` or semicolons." }, { text: "enum { ROWS = 3 };", reason: "Using an enum works but deviates from the `#define` convention here." }], indent: 0, explanation: "Define a constant for the number of rows." },
      { correct: "#define COLS 4", distractors: [{ text: "const int COLS = 4;", reason: "Also valid, but this level uses `#define` for dimensions." }, { text: "#define COLS = 4", reason: "Macros don’t use `=` sign." }], indent: 0, explanation: "Define a constant for the number of columns." },
      { correct: "// Prototype for the function that will process the array", distractors: [{ text: "/* Prototype to sum columns */", reason: "Mislabels the function’s purpose." }, { text: "// Declare sumCols prototype", reason: "Wrong function name/comment mismatch." }], indent: 0, explanation: "A comment explaining the function declaration." },
      { correct: "void sumRows(int arr[][COLS]);", distractors: [{ text: "void sumRows(int arr[][]);", reason: "Must specify all but the first dimension." }, { text: "void sumRows(int** arr);", reason: "A 2D array isn’t the same as an `int**` pointer." }], indent: 0, explanation: "Declare a function that accepts a 2D array, specifying all but the first dimension." },
      { correct: "int main(void) {", distractors: [{ text: "void main() {", reason: "Standard C requires `main` to return `int`." }, { text: "int main()", reason: "Missing parameter list—less explicit than `main(void)`." }], indent: 0, explanation: "Start the main function." },
      { correct: "// Initialize the 2D array", distractors: [{ text: "// Declare matrix size", reason: "Wrong comment for initialization." }, { text: "// Setup headers", reason: "Irrelevant comment." }], indent: 1, explanation: "Comment on array initialization." },
      { correct: "int matrix[ROWS][COLS] = {", distractors: [{ text: "int matrix[ROWS, COLS] = {", reason: "Dimensions must be in separate brackets." }, { text: "int matrix[3,4] = {", reason: "Comma operator yields a single dimension." }], indent: 1, explanation: "Begin declaring and initializing the 2D array." },
      { correct: "  { 10, 20, 30, 40 },", distractors: [{ text: "  (10, 20, 30, 40),", reason: "Parentheses aren’t valid for initializer lists." }, { text: "  {10,20,30}", reason: "Wrong number of elements." }], indent: 2, explanation: "Initialize the first row." },
      { correct: "  { 5, 15, 25, 35 },", distractors: [{ text: "  { 5, 15, 25, 35 }", reason: "Missing comma after row initializer." }, { text: "  {5 15 25 35},", reason: "Missing commas between values." }], indent: 2, explanation: "Initialize the second row." },
      { correct: "  { 11, 22, 33, 44 }", distractors: [{ text: "  { 11, 22, 33, 44, }", reason: "Trailing comma allowed but usually omitted here." }, { text: "  { 11; 22; 33; 44 }", reason: "Semicolons invalid in initializer lists." }], indent: 2, explanation: "Initialize the third row." },
      { correct: "};", distractors: [{ text: "}", reason: "Missing semicolon to end declaration." }, { text: "];", reason: "Wrong closing bracket." }], indent: 1, explanation: "Close the array initializer and the declaration statement." },
      { correct: "printf(\"Calculating row sums...\\n\");", distractors: [{ text: "puts(\"Calculating row sums...\");", reason: "`puts` adds a newline but differs from `printf` usage." }, { text: "print(\"Calculating row sums...\\n\");", reason: "`print` isn’t a C standard function." }], indent: 1, explanation: "Print an informational message." },
      { correct: "sumRows(matrix);", distractors: [{ text: "sumRows(matrix[ROWS][COLS]);", reason: "Passes a single element, not the array." }, { text: "sumRows(&matrix);", reason: "`&matrix` has the wrong pointer type." }], indent: 1, explanation: "Call the function, passing the 2D array." },
      { correct: "return 0;", distractors: [{ text: "return;", reason: "Missing return value for `main`." }, { text: "exit(0);", reason: "`exit` bypasses `main` return." }], indent: 1, explanation: "Indicate successful execution." },
      { correct: "}", distractors: [{ text: "end;", reason: "`end` is not C syntax." }, { text: "};", reason: "Extra semicolon is invalid." }], indent: 0, explanation: "Close the main function." },
      { correct: "void sumRows(int arr[][COLS]) {", distractors: [{ text: "void sumRows(int arr[ROWS][COLS]) {", reason: "Specifying both dims is valid but less flexible." }, { text: "void sumRows(int *arr) {", reason: "Loses 2D structure needed for `arr[r][c]`." }], indent: 0, explanation: "Define the function, matching the prototype's parameter type." },
      { correct: "for (int r = 0; r < ROWS; r++) {", distractors: [{ text: "for (r = 0; r < ROWS; r++) {", reason: "`r` must be declared." }, { text: "for (int r = 1; r <= ROWS; r++) {", reason: "Off-by-one and wrong bounds." }], indent: 1, explanation: "Start a loop to iterate through each row." },
      { correct: "int current_sum = 0;", distractors: [{ text: "int current_sum;", reason: "Uninitialized variable is undefined." }, { text: "int current_sum = arr[r][0];", reason: "Incorrect accumulation start." }], indent: 2, explanation: "Initialize a variable to hold the sum for the current row." },
      { correct: "for (int c = 0; c < COLS; c++) {", distractors: [{ text: "for (int c = 1; c < COLS; c++) {", reason: "Skips the first column." }, { text: "for (int c = 0; c <= COLS; c++) {", reason: "Off-by-one: iterates out of bounds." }], indent: 2, explanation: "Start a nested loop to iterate through each column in the current row." },
      { correct: "current_sum += arr[r][c];", distractors: [{ text: "current_sum = arr[r][c];", reason: "Overwrites the sum each time." }, { text: "current_sum += *(arr + r + c);", reason: "Pointer arithmetic is incorrect for 2D arrays." }], indent: 3, explanation: "Add the value of the current element to the row's sum." },
      { correct: "}", distractors: [{ text: ")", reason: "Loops close with `}`, not `)`." }, { text: "];", reason: "Invalid block closure." }], indent: 2, explanation: "Close the inner (column) loop." },
      { correct: "printf(\"Sum of row %d = %d\\n\", r, current_sum);", distractors: [{ text: "printf(\"Sum = %d\\n\", current_sum);", reason: "Doesn't show which row." }, { text: "printf(\"Row %d sum: %d\\n\");", reason: "Missing arguments for placeholders." }], indent: 2, explanation: "Print the calculated sum for the completed row." },
      { correct: "}", distractors: [{ text: ")", reason: "Loops close with `}`." }, { text: "];", reason: "Invalid block closure." }], indent: 1, explanation: "Close the outer (row) loop." },
      { correct: "}", distractors: [{ text: "];", reason: "Functions close with `}`." }, { text: "}}", reason: "Extra brace is a syntax error." }], indent: 0, explanation: "Close the function definition." }
    ]
  },

  // Level 30: Pointers to Pointers & Dynamic 2D Array
  {
    goal: "Dynamically allocate, fill, and free a 2D array using a pointer-to-a-pointer (int **).",
    concepts: "Pointers to pointers, dynamic memory allocation, malloc, free, loops",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "That’s C++ code, not C." }, { text: "#import <stdio.h>", reason: "`#import` isn’t used in C." }], indent: 0, explanation: "Include for standard I/O." },
      { correct: "#include <stdlib.h>", distractors: [{ text: "#include <malloc.h>", reason: "Non-standard header on some platforms." }, { text: "#include <string.h>", reason: "Not needed for malloc/free." }], indent: 0, explanation: "Include for malloc and free." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "`main` must return `int` in standard C." }, { text: "main() {", reason: "Missing return type altogether." }], indent: 0, explanation: "Start the main function." },
      { correct: "int rows = 3;", distractors: [{ text: "rows = 3;", reason: "Missing type declaration." }, { text: "const int rows;", reason: "Uninitialized constant—invalid." }], indent: 1, explanation: "Define the number of rows." },
      { correct: "int cols = 4;", distractors: [{ text: "cols = 4;", reason: "Missing type declaration." }, { text: "const cols = 4;", reason: "Missing type—invalid syntax." }], indent: 1, explanation: "Define the number of columns." },
      { correct: "int **dynamic_matrix;", distractors: [{ text: "int *dynamic_matrix;", reason: "A single pointer doesn’t represent a 2D array." }, { text: "int dynamic_matrix[rows][cols];", reason: "Declares a VLA on the stack, not heap memory." }], indent: 1, explanation: "Declare a pointer-to-a-pointer to manage the dynamic 2D array." },
      { correct: "// Allocate the array of row pointers", distractors: [{ text: "// Allocate the matrix", reason: "Too generic—needs separate pointer array step." }, { text: "// Setup rows", reason: "Doesn’t mention malloc." }], indent: 1, explanation: "Comment on the first allocation step." },
      { correct: "dynamic_matrix = (int **)malloc(rows * sizeof(int *));", distractors: [{ text: "dynamic_matrix = malloc(rows * sizeof(int));", reason: "Allocates space for ints, not pointers." }, { text: "dynamic_matrix = (int *)malloc(rows * sizeof(int *));", reason: "Wrong cast type." }], indent: 1, explanation: "Allocate memory for an array of pointers, one for each row." },
      { correct: "if (dynamic_matrix == NULL) { return 1; }", distractors: [{ text: "if (!dynamic_matrix) exit(1);", reason: "Exit abrupt but works; less explicit return." }, { text: "if (dynamic_matrix == 0) { return; }", reason: "Missing return value for `main`." }], indent: 1, explanation: "Always check if memory allocation was successful." },
      { correct: "// Allocate memory for each row", distractors: [{ text: "// Allocate heap memory", reason: "Too generic." }, { text: "// Setup columns", reason: "Doesn’t mention malloc." }], indent: 1, explanation: "Comment on the second allocation step." },
      { correct: "for (int i = 0; i < rows; i++) {", distractors: [{ text: "for (i = 0; i < rows; i++) {", reason: "`i` must be declared." }, { text: "for (int i = 1; i <= rows; i++) {", reason: "Off-by-one and wrong bounds." }], indent: 1, explanation: "Loop through each row to allocate its columns." },
      { correct: "dynamic_matrix[i] = (int *)malloc(cols * sizeof(int));", distractors: [{ text: "dynamic_matrix[i] = malloc(cols * sizeof(int *));", reason: "Allocates pointer-size chunks, not ints." }, { text: "dynamic_matrix[i] = (int **)malloc(cols * sizeof(int));", reason: "Wrong cast/pointer type." }], indent: 2, explanation: "For each row pointer, allocate enough memory for all the columns in that row." },
      { correct: "if (dynamic_matrix[i] == NULL) { return 1; }", distractors: [{ text: "if (!dynamic_matrix[i]) exit(1);", reason: "Works but less explicit." }, { text: "if (dynamic_matrix[i] == 0) return;", reason: "Missing return value." }], indent: 2, explanation: "Also check if each individual row allocation was successful." },
      { correct: "}", distractors: [{ text: "};", reason: "Extra semicolon." }, { text: ")", reason: "Wrong closing bracket." }], indent: 1, explanation: "Close the row allocation loop." },
      { correct: "// Fill and print the matrix", distractors: [{ text: "// Initialize matrix values", reason: "Too generic." }, { text: "// Display matrix", reason: "Misses filling step." }], indent: 1, explanation: "Comment explaining the next section." },
      { correct: "for (int i = 0; i < rows; i++) {", distractors: [{ text: "for (i = 0; i < rows; i++) {", reason: "`i` must be declared." }, { text: "while (i < rows) {", reason: "Wrong loop construct." }], indent: 1, explanation: "Start a loop to iterate through the rows." },
      { correct: "for (int j = 0; j < cols; j++) {", distractors: [{ text: "for (j = 0; j < cols; j++) {", reason: "`j` must be declared." }, { text: "for (int j = 1; j <= cols; j++) {", reason: "Off-by-one." }], indent: 2, explanation: "Start a nested loop for the columns." },
      { correct: "dynamic_matrix[i][j] = i * 10 + j;", distractors: [{ text: "*(*(dynamic_matrix + i) + j) = i*10+j;", reason: "Valid but not the syntax taught here." }, { text: "dynamic_matrix[j][i] = i+j;", reason: "Swaps indices—wrong mapping." }], indent: 3, explanation: "Assign a value to each element in the matrix." },
      { correct: "printf(\"%3d\", dynamic_matrix[i][j]);", distractors: [{ text: "printf(\"%d\", dynamic_matrix[i][j]);", reason: "No field width—less aligned." }, { text: "printf(\"%3d\\n\", dynamic_matrix[i][j]);", reason: "Prints newline after every element instead of row." }], indent: 3, explanation: "Print the newly assigned value." },
      { correct: "}", distractors: [{ text: ")", reason: "Wrong bracket." }, { text: "];", reason: "Invalid block closure." }], indent: 2, explanation: "Close the column loop." },
      { correct: "printf(\"\\n\");", distractors: [{ text: "printf(\"\\n\\n\");", reason: "Prints extra blank line." }, { text: "putchar('\\n');", reason: "Works but differs from `printf` usage." }], indent: 2, explanation: "Print a newline after each row." },
      { correct: "}", distractors: [{ text: "};", reason: "Extra semicolon." }, { text: ")", reason: "Wrong bracket." }], indent: 1, explanation: "Close the row loop." },
      { correct: "// Free the allocated memory in reverse order of allocation", distractors: [{ text: "// Deallocate matrix", reason: "Too generic." }, { text: "// Clean up rows", reason: "Misses pointer-array step." }], indent: 1, explanation: "A crucial comment on freeing memory." },
      { correct: "for (int i = 0; i < rows; i++) {", distractors: [{ text: "for (i = 0; i < rows; i++) {", reason: "`i` must be declared." }, { text: "while (i < rows) {", reason: "Wrong loop type." }], indent: 1, explanation: "First, loop through to free each individual row." },
      { correct: "free(dynamic_matrix[i]);", distractors: [{ text: "free(dynamic_matrix);", reason: "Frees pointer array too soon." }, { text: "dynamic_matrix[i] = NULL;", reason: "Does not actually free memory." }], indent: 2, explanation: "Free the memory allocated for each row's columns." },
      { correct: "}", distractors: [{ text: "};", reason: "Extra semicolon." }, { text: ")", reason: "Wrong bracket." }], indent: 1, explanation: "Close the row-freeing loop." },
      { correct: "free(dynamic_matrix);", distractors: [{ text: "dynamic_matrix = NULL;", reason: "Does not free memory." }, { text: "delete[] dynamic_matrix;", reason: "C++ syntax, not C." }], indent: 1, explanation: "Finally, free the memory that held the array of row pointers." },
      { correct: "return 0;", distractors: [{ text: "return;", reason: "Missing return value." }, { text: "exit(0);", reason: "Bypasses `main` return." }], indent: 1, explanation: "Indicate successful execution." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the main function." }
    ]
  },

  // Level 31: Creating a Simple Linked List
  {
    goal: "Create a simple 3-node linked list, traverse it, print the data, and free the memory.",
    concepts: "structs, pointers, dynamic memory allocation (malloc), linked lists, NULL",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "That’s C++ code." }, { text: "#import <stdio.h>", reason: "`#import` isn’t a C directive." }], indent: 0, explanation: "Include for printf." },
      { correct: "#include <stdlib.h>", distractors: [{ text: "#include <malloc.h>", reason: "Non-standard header." }, { text: "#include <string.h>", reason: "Not needed here." }], indent: 0, explanation: "Include for malloc and free." },
      { correct: "// Define the structure for a node in the list", distractors: [{ text: "/* Node struct declaration */", reason: "Generic comment missing clarity." }, { text: "// Structure: Node", reason: "Too vague." }], indent: 0, explanation: "Comment on the purpose of the struct." },
      { correct: "struct Node {", distractors: [{ text: "struct Node();", reason: "Syntax for function, not struct." }, { text: "class Node {", reason: "C++ keyword, not C." }], indent: 0, explanation: "Begin defining the Node struct." },
      { correct: "int data;", distractors: [{ text: "int *data;", reason: "Pointer instead of value." }, { text: "float data;", reason: "Wrong type." }], indent: 1, explanation: "Each node will hold an integer data value." },
      { correct: "struct Node *next;", distractors: [{ text: "struct Node next;", reason: "Embeds a struct instead of a pointer." }, { text: "Node *next;", reason: "`Node` isn’t typedef’d yet." }], indent: 1, explanation: "A pointer to the next node in the sequence." },
      { correct: "};", distractors: [{ text: "};;", reason: "Extra semicolon." }, { text: "}", reason: "Missing semicolon after struct." }], indent: 0, explanation: "End the struct definition." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "Standard C requires `int` return." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start main function." },
      { correct: "// Declare pointers for the head and other nodes", distractors: [{ text: "// Pointers", reason: "Too generic." }, { text: "// Node variables", reason: "Misses that they’re pointers." }], indent: 1, explanation: "Comment on pointer declarations." },
      { correct: "struct Node *head;", distractors: [{ text: "Node *head;", reason: "C requires `struct` keyword here." }, { text: "int *head;", reason: "Wrong type." }], indent: 1, explanation: "Declare the head pointer, which will point to the start of the list." },
      { correct: "struct Node *second;", distractors: [{ text: "struct Node second;", reason: "Declares a struct, not pointer." }, { text: "Node *second;", reason: "Missing `struct` keyword." }], indent: 1, explanation: "Declare a pointer for the second node." },
      { correct: "struct Node *third;", distractors: [{ text: "struct Node third;", reason: "Declares a struct instance, not pointer." }, { text: "Node third;", reason: "Missing pointer notation." }], indent: 1, explanation: "Declare a pointer for the third node." },
      { correct: "// Allocate memory for the three nodes on the heap", distractors: [{ text: "// New nodes", reason: "Doesn’t mention malloc." }, { text: "// Setup nodes", reason: "Too vague." }], indent: 1, explanation: "Comment on memory allocation." },
      { correct: "head = (struct Node*)malloc(sizeof(struct Node));", distractors: [{ text: "head = malloc(sizeof(int));", reason: "Allocates too little memory." }, { text: "head = &someNode;", reason: "Uses address of local, not heap." }], indent: 1, explanation: "Allocate memory for the first node." },
      { correct: "second = (struct Node*)malloc(sizeof(struct Node));", distractors: [{ text: "second = malloc(sizeof(Node));", reason: "Missing `struct` keyword in sizeof." }, { text: "second = NULL;", reason: "Doesn’t allocate memory." }], indent: 1, explanation: "Allocate memory for the second node." },
      { correct: "third = (struct Node*)malloc(sizeof(struct Node));", distractors: [{ text: "third = malloc(sizeof(*third));", reason: "Works but less explicit." }, { text: "third = second;", reason: "Points to the wrong node." }], indent: 1, explanation: "Allocate memory for the third node." },
      { correct: "// Assign data and link the head node", distractors: [{ text: "// Set head data", reason: "Missing link step." }, { text: "// Link nodes", reason: "Too generic." }], indent: 1, explanation: "Comment on setting up the first node." },
      { correct: "head->data = 10;", distractors: [{ text: "head.data = 10;", reason: "Must use `->` on a pointer." }, { text: "(*head).data = 10;", reason: "Valid but not the shorthand taught." }], indent: 1, explanation: "Set the data for the head node." },
      { correct: "head->next = second;", distractors: [{ text: "head->next = &second;", reason: "`second` is already a pointer." }, { text: "head->next = NULL;", reason: "Wrong link—terminates list too early." }], indent: 1, explanation: "Link the head node to the second node." },
      { correct: "// Assign data and link the second node", distractors: [{ text: "// Second node data", reason: "Misses linking." }, { text: "// Link head to third", reason: "Skips second node." }], indent: 1, explanation: "Comment on setting up the second node." },
      { correct: "second->data = 20;", distractors: [{ text: "second.data = 20;", reason: "Must use `->` on pointer." }, { text: "(*second).data = 20;", reason: "Valid but not taught shorthand." }], indent: 1, explanation: "Set the data for the second node." },
      { correct: "second->next = third;", distractors: [{ text: "second->next = head;", reason: "Creates a loop." }, { text: "second->next = NULL;", reason: "Terminates list too soon." }], indent: 1, explanation: "Link the second node to the third node." },
      { correct: "// Assign data and terminate the list at the third node", distractors: [{ text: "// Third node data", reason: "Misses termination." }, { text: "// End list", reason: "Too generic." }], indent: 1, explanation: "Comment on setting up the final node." },
      { correct: "third->data = 30;", distractors: [{ text: "third.data = 30;", reason: "Must use `->` on a pointer." }, { text: "(*third).data = 30;", reason: "Valid but not taught shorthand." }], indent: 1, explanation: "Set the data for the third node." },
      { correct: "third->next = NULL;", distractors: [{ text: "third->next = 0;", reason: "`NULL` is clearer than literal `0`." }, { text: "// third->next uninitialized", reason: "Unsafe and wrong." }], indent: 1, explanation: "Set the `next` pointer of the last node to NULL to signify the end of the list." },
      { correct: "// Traverse and print the list", distractors: [{ text: "// Print list", reason: "Misses traversal comment." }, { text: "// Walk nodes", reason: "Too vague." }], indent: 1, explanation: "Comment on list traversal." },
      { correct: "struct Node *current = head;", distractors: [{ text: "Node *current = head;", reason: "Missing `struct` keyword." }, { text: "struct Node current = head;", reason: "Wrong type—declares a struct, not pointer." }], indent: 1, explanation: "Create a temporary pointer to traverse the list, starting at the head." },
      { correct: "while (current != NULL) {", distractors: [{ text: "while (current)", reason: "Works but less explicit." }, { text: "for (; current; ) {", reason: "Different loop form, not taught here." }], indent: 2, explanation: "Loop as long as we have not reached the end of the list (the NULL pointer)." },
      { correct: "printf(\"%d -> \", current->data);", distractors: [{ text: "printf(\"%d\", current->data);", reason: "Missing arrow and separator." }, { text: "puts(current->data);", reason: "`puts` expects a string, not an int." }], indent: 3, explanation: "Print the data of the current node." },
      { correct: "current = current->next;", distractors: [{ text: "current = head;", reason: "Resets pointer—infinite loop." }, { text: "current->next = current;", reason: "Creates a self-loop." }], indent: 3, explanation: "Move the `current` pointer to the next node in the list." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not valid C syntax." }, { text: "];", reason: "Invalid block closure." }], indent: 2, explanation: "Close the traversal loop." },
      { correct: "printf(\"NULL\\n\");", distractors: [{ text: "puts(\"NULL\");", reason: "No newline escape." }, { text: "printf(\"%s\\n\", \"NULL\");", reason: "Valid but not the format shown." }], indent: 1, explanation: "Print NULL to show the end of the list visually." },
      { correct: "// Free the allocated memory to prevent memory leaks", distractors: [{ text: "// Delete nodes", reason: "C++ keyword, not C." }, { text: "// Clear nodes", reason: "Too generic." }], indent: 1, explanation: "Comment on freeing memory." },
      { correct: "free(head);", distractors: [{ text: "free(current);", reason: "`current` is NULL here." }, { text: "head = NULL;", reason: "Doesn’t free memory." }], indent: 1, explanation: "Free the first node." },
      { correct: "free(second);", distractors: [{ text: "free(head);", reason: "Duplicates previous free—incorrect order." }, { text: "second = NULL;", reason: "Doesn’t free memory." }], indent: 1, explanation: "Free the second node." },
      { correct: "free(third);", distractors: [{ text: "free(second);", reason: "Duplicates previous free." }, { text: "third = NULL;", reason: "Doesn’t free memory." }], indent: 1, explanation: "Free the third node." },
      { correct: "return 0;", distractors: [{ text: "return head;", reason: "Wrong return type." }, { text: "exit(0);", reason: "Bypasses `main` return." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not valid C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close main function." }
    ]
  },

  // Level 32: Advanced Linked List - Insertion Function
  {
    goal: "Create a function that inserts a new node at the head of a linked list using a pointer-to-a-pointer.",
    concepts: "Linked lists, pointers to pointers, functions modifying pointers, dynamic memory",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for standard I/O." },
      { correct: "#include <stdlib.h>", distractors: [{ text: "#include <malloc.h>", reason: "Non-standard." }, { text: "#include <string.h>", reason: "Not required here." }], indent: 0, explanation: "Include for malloc/free." },
      { correct: "typedef struct Node {", distractors: [{ text: "struct Node {", reason: "Missing typedef—requires `typedef` keyword." }, { text: "class Node {", reason: "C++ keyword." }], indent: 0, explanation: "Begin defining the Node struct using a typedef for convenience." },
      { correct: "  int data;", distractors: [{ text: "  int *data;", reason: "Pointer to int, not int." }, { text: "  float data;", reason: "Wrong type." }], indent: 1, explanation: "The data held by the node." },
      { correct: "  struct Node *next;", distractors: [{ text: "  Node *next;", reason: "`Node` alias not active until after typedef ends." }, { text: "  struct Node next;", reason: "Embeds node, not pointer." }], indent: 1, explanation: "A pointer to the next node." },
      { correct: "} Node;", distractors: [{ text: "} Node", reason: "Missing semicolon after typedef." }, { text: "} node_t;", reason: "Alias name differs from `Node`." }], indent: 0, explanation: "Create the alias `Node` for `struct Node`." },
      { correct: "// Function prototype to insert a node at the beginning", distractors: [{ text: "// Prototype: insert function", reason: "Too generic." }, { text: "// Insertion helper", reason: "Misses pointer-to-pointer detail." }], indent: 0, explanation: "Comment on the function prototype." },
      { correct: "void insertAtHead(Node **head_ref, int new_data);", distractors: [{ text: "void insertAtHead(Node *head, int new_data);", reason: "Passes head by value—can’t modify original." }, { text: "Node* insertAtHead(Node *head, int new_data);", reason: "Returns new head instead of modifying in place." }], indent: 0, explanation: "Declare a function that takes a pointer to the head pointer." },
      { correct: "void printList(Node *node);", distractors: [{ text: "void printList(Node **node);", reason: "Unnecessary double pointer." }, { text: "void print(Node *n);", reason: "Different name—less clear." }], indent: 0, explanation: "Prototype for a helper function to print the list." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "`main` must return `int`." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start main function." },
      { correct: "Node *head = NULL;", distractors: [{ text: "Node head = NULL;", reason: "Wrong type—should be pointer." }, { text: "Node *head;", reason: "Uninitialized pointer—undefined behavior." }], indent: 1, explanation: "Initialize the head of the list to NULL, indicating it's empty." },
      { correct: "printf(\"Inserting 30...\\n\");", distractors: [{ text: "puts(\"Inserting 30...\");", reason: "Valid but differs from `printf`." }, { text: "print(\"Inserting 30...\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Informational print." },
      { correct: "insertAtHead(&head, 30);", distractors: [{ text: "insertAtHead(head, 30);", reason: "Needs address-of for double pointer." }, { text: "insertAtHead(*head, 30);", reason: "Dereferences NULL—crash." }], indent: 1, explanation: "Call the insertion function, passing the address of the head pointer." },
      { correct: "printList(head);", distractors: [{ text: "printList(&head);", reason: "Wrong pointer type." }, { text: "printList(*head);", reason: "Dereferences head—wrong type." }], indent: 1, explanation: "Print the list to verify the insertion." },
      { correct: "printf(\"Inserting 20...\\n\");", distractors: [{ text: "puts(\"Inserting 20...\");", reason: "Valid but differs." }, { text: "print(\"Inserting 20...\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Informational print." },
      { correct: "insertAtHead(&head, 20);", distractors: [{ text: "insertAtHead(head, 20);", reason: "Wrong pointer level." }, { text: "insertAtHead(NULL, 20);", reason: "Passes NULL—no effect." }], indent: 1, explanation: "Insert another node. It should become the new head." },
      { correct: "printList(head);", distractors: [{ text: "printList(&head);", reason: "Wrong pointer type." }, { text: "printList(*head);", reason: "Dereferences head—wrong type." }], indent: 1, explanation: "Print the list again." },
      { correct: "printf(\"Inserting 10...\\n\");", distractors: [{ text: "puts(\"Inserting 10...\");", reason: "Valid but differs." }, { text: "print(\"Inserting 10...\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Informational print." },
      { correct: "insertAtHead(&head, 10);", distractors: [{ text: "insertAtHead(head, 10);", reason: "Wrong pointer level." }, { text: "insertAtHead(NULL, 10);", reason: "Passes NULL—no effect." }], indent: 1, explanation: "Insert a third node." },
      { correct: "printList(head);", distractors: [{ text: "printList(&head);", reason: "Wrong pointer type." }, { text: "printList(*head);", reason: "Dereferences head—wrong type." }], indent: 1, explanation: "Print the final list." },
      { correct: "return 0;", distractors: [{ text: "return head;", reason: "Wrong return type." }, { text: "exit(0);", reason: "Bypasses `main` return." }], indent: 1, explanation: "Indicate success. (Note: memory is not freed in this example to keep it focused on insertion)." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the main function." },
      { correct: "void insertAtHead(Node **head_ref, int new_data) {", distractors: [{ text: "void insertAtHead(Node *head, int new_data) {", reason: "Wrong pointer level." }, { text: "void insertAtHead(Node head_ref, int new_data) {", reason: "Passes struct by value." }], indent: 0, explanation: "Define the insertion function, accepting a double pointer." },
      { correct: "// 1. Allocate memory for the new node", distractors: [{ text: "// Create new node", reason: "Too generic—misses malloc detail." }, { text: "// Step 1: data", reason: "Wrong focus." }], indent: 1, explanation: "Step 1 of insertion." },
      { correct: "Node *new_node = (Node*)malloc(sizeof(Node));", distractors: [{ text: "Node *new_node = malloc(sizeof(Node));", reason: "Missing cast (though works in C, not explicit)." }, { text: "Node new_node = malloc(sizeof(Node));", reason: "Wrong type—declares struct, not pointer." }], indent: 1, explanation: "Create the new node on the heap." },
      { correct: "// 2. Put data in the new node", distractors: [{ text: "// Assign data", reason: "Too generic." }, { text: "// new_node->data", reason: "Missing assignment." }], indent: 1, explanation: "Step 2 of insertion." },
      { correct: "new_node->data = new_data;", distractors: [{ text: "new_node.data = new_data;", reason: "Must use `->` on pointer." }, { text: "(*new_node).data = new_data;", reason: "Valid but not taught shorthand." }], indent: 1, explanation: "Assign the provided data." },
      { correct: "// 3. Make the new node point to the old head", distractors: [{ text: "// Link new node", reason: "Too generic." }, { text: "// Set next", reason: "Missing pointer dereference detail." }], indent: 1, explanation: "Step 3 of insertion." },
      { correct: "new_node->next = (*head_ref);", distractors: [{ text: "new_node->next = head_ref;", reason: "`head_ref` is a double pointer." }, { text: "new_node->next = NULL;", reason: "Wrong link—terminates list early." }], indent: 1, explanation: "The new node's `next` should be the current start of the list." },
      { correct: "// 4. Move the head to point to the new node", distractors: [{ text: "// Update head", reason: "Too generic." }, { text: "// head_ref = new_node", reason: "Modifies pointer copy." }], indent: 1, explanation: "Step 4 of insertion." },
      { correct: "(*head_ref) = new_node;", distractors: [{ text: "head_ref = new_node;", reason: "Modifies local pointer, not original." }, { text: "head = new_node;", reason: "Doesn’t use `head_ref`—no effect." }], indent: 1, explanation: "Change the original head pointer in main to now point at our new node." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the insertion function." },
      { correct: "void printList(Node *node) {", distractors: [{ text: "void printList(Node **node) {", reason: "Wrong pointer level." }, { text: "void print(Node *node) {", reason: "Different name." }], indent: 0, explanation: "Define the list printing utility function." },
      { correct: "while (node != NULL) {", distractors: [{ text: "while (node) {", reason: "Works but less explicit." }, { text: "for (; node; ) {", reason: "Different form—not shown here." }], indent: 1, explanation: "Loop until the end of the list." },
      { correct: "printf(\" %d ->\", node->data);", distractors: [{ text: "puts(node->data);", reason: "`puts` expects a string." }, { text: "printf(\"%d->\", node->data);", reason: "Missing leading space." }], indent: 2, explanation: "Print the data for the current node." },
      { correct: "node = node->next;", distractors: [{ text: "node->next = node;", reason: "Creates a cycle." }, { text: "node = head;", reason: "Resets pointer—infinite loop." }], indent: 2, explanation: "Move to the next node." },
      { correct: "}", distractors: [{ text: "];", reason: "Wrong bracket." }, { text: "end;", reason: "Not C syntax." }], indent: 1, explanation: "Close the loop." },
      { correct: "printf(\" NULL\\n\");", distractors: [{ text: "puts(\"NULL\");", reason: "No leading space." }, { text: "printf(\"%s\\n\", \"NULL\");", reason: "Valid but not taught format." }], indent: 1, explanation: "Print NULL at the end for clarity." },
      { correct: "}", distractors: [{ text: "};", reason: "Extra semicolon." }, { text: "end;", reason: "Not C syntax." }], indent: 0, explanation: "Close the print function." }
    ]
  },

  // Level 33: Bitwise Operations for Flags
  {
    goal: "Manage a set of boolean options using a single integer and bitwise operations.",
    concepts: "Bitwise operators (&, |, ~, <<), enums, hexadecimal literals, masks",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for printf." },
      { correct: "// Define flags as distinct powers of 2", distractors: [{ text: "/* Flags definition */", reason: "Too generic." }, { text: "// Bit masks", reason: "Less descriptive." }], indent: 0, explanation: "Comment on flag definition." },
      { correct: "enum Options {", distractors: [{ text: "enum Flags {", reason: "Different name—less clear." }, { text: "typedef enum Options {", reason: "Extra `typedef` not used here." }], indent: 0, explanation: "Use an enum to give names to our bit flags." },
      { correct: "  OPTION_A = 1 << 0, // 00000001 (1)", distractors: [{ text: "  OPTION_A = 0x01,", reason: "Hex literal is valid but not the taught shift form." }, { text: "  OPTION_A = 1,", reason: "Valid but doesn’t show bit-shift intent." }], indent: 1, explanation: "Flag for option A is the 0th bit." },
      { correct: "  OPTION_B = 1 << 1, // 00000010 (2)", distractors: [{ text: "  OPTION_B = 2,", reason: "Valid but loses shift clarity." }, { text: "  OPTION_B = 1 << 0,", reason: "Duplicates OPTION_A value." }], indent: 1, explanation: "Flag for option B is the 1st bit." },
      { correct: "  OPTION_C = 1 << 2, // 00000100 (4)", distractors: [{ text: "  OPTION_C = 4,", reason: "Valid but no shift." }, { text: "  OPTION_C = 1 << 1,", reason: "Duplicates OPTION_B value." }], indent: 1, explanation: "Flag for option C is the 2nd bit." },
      { correct: "  OPTION_D = 1 << 3  // 00001000 (8)", distractors: [{ text: "  OPTION_D = 8,", reason: "Valid but less illustrative." }, { text: "  OPTION_D = 1 << 2,", reason: "Duplicates OPTION_C value." }], indent: 1, explanation: "Flag for option D is the 3rd bit." },
      { correct: "};", distractors: [{ text: "}", reason: "Missing semicolon." }, { text: "];", reason: "Wrong bracket." }], indent: 0, explanation: "Close the enum definition." },
      { correct: "void print_options(unsigned char settings);", distractors: [{ text: "void print_options(int settings);", reason: "Wrong type—should be `unsigned char`." }, { text: "print_options(unsigned char settings);", reason: "Missing return type." }], indent: 0, explanation: "Prototype for a function to display the current settings." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "Wrong return type." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start main function." },
      { correct: "unsigned char my_settings = 0;", distractors: [{ text: "int my_settings = 0;", reason: "Wrong type size." }, { text: "unsigned my_settings = 0;", reason: "Missing `char` qualifier." }], indent: 1, explanation: "Declare the variable to hold our flags, initialized to all off." },
      { correct: "printf(\"Initial settings:\\n\");", distractors: [{ text: "puts(\"Initial settings:\");", reason: "No newline escape." }, { text: "print(\"Initial settings:\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Print header." },
      { correct: "print_options(my_settings);", distractors: [{ text: "print_options(&my_settings);", reason: "Wrong pointer type." }, { text: "print(my_settings);", reason: "`print` not C." }], indent: 1, explanation: "Show initial state." },
      { correct: "// Turn ON option A and C", distractors: [{ text: "/* Enable bits */", reason: "Too generic." }, { text: "// Set flags", reason: "Less specific." }], indent: 1, explanation: "Comment on setting flags." },
      { correct: "my_settings = my_settings | OPTION_A | OPTION_C;", distractors: [{ text: "my_settings |= OPTION_A + OPTION_C;", reason: "Uses addition inside OR—confusing." }, { text: "my_settings = OPTION_A & OPTION_C;", reason: "AND clears bits, not sets." }], indent: 1, explanation: "Use the bitwise OR operator to set bits for options A and C." },
      { correct: "printf(\"\\nSettings after turning ON A and C:\\n\");", distractors: [{ text: "puts(\"Settings after turning ON A and C:\");", reason: "No newline escape." }, { text: "print(\"Settings after turning ON A and C:\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Print header." },
      { correct: "print_options(my_settings);", distractors: [{ text: "print_options(&my_settings);", reason: "Wrong pointer type." }, { text: "printf(\"%d\\n\", my_settings);", reason: "Prints raw number, not formatted flags." }], indent: 1, explanation: "Show new state." },
      { correct: "// Turn OFF option C", distractors: [{ text: "/* Clear bit C */", reason: "Less clear syntax." }, { text: "// Disable C", reason: "Too generic." }], indent: 1, explanation: "Comment on clearing a flag." },
      { correct: "my_settings = my_settings & ~OPTION_C;", distractors: [{ text: "my_settings -= OPTION_C;", reason: "Subtraction works only if bit set once." }, { text: "my_settings ^= OPTION_C;", reason: "XOR toggles bit, not guaranteed clear." }], indent: 1, explanation: "Use bitwise AND with the bitwise NOT of the flag to clear the bit." },
      { correct: "printf(\"\\nSettings after turning OFF C:\\n\");", distractors: [{ text: "puts(\"Settings after OFF C:\");", reason: "No newline escape." }, { text: "print(\"Settings after turning OFF C:\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Print header." },
      { correct: "print_options(my_settings);", distractors: [{ text: "print_options(&my_settings);", reason: "Wrong pointer type." }, { text: "printf(\"%d\\n\", my_settings);", reason: "Raw number only." }], indent: 1, explanation: "Show final state." },
      { correct: "return 0;", distractors: [{ text: "exit(0);", reason: "Bypasses `main` return." }, { text: "return;", reason: "Missing return value." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close main." },
      { correct: "void print_options(unsigned char settings) {", distractors: [{ text: "print_options(unsigned char settings) {", reason: "Missing return type." }, { text: "void print_options(char settings) {", reason: "Wrong type size." }], indent: 0, explanation: "Define the display function." },
      { correct: "printf(\"Binary: \");", distractors: [{ text: "puts(\"Binary: \");", reason: "No newline escape." }, { text: "print(\"Binary: \");", reason: "`print` isn’t C." }], indent: 1, explanation: "Print binary label." },
      { correct: "for (int i = 7; i >= 0; i--) {", distractors: [{ text: "for (i = 7; i >= 0; i--) {", reason: "`i` must be declared." }, { text: "while (i >= 0) {", reason: "Wrong loop type." }], indent: 1, explanation: "Loop to print each bit of the 8-bit char." },
      { correct: "putchar((settings >> i) & 1 ? '1' : '0');", distractors: [{ text: "printf(\"%d\", (settings >> i) & 1);", reason: "Prints 0/1, not '0'/'1'." }, { text: "putchar(settings & (1 << i));", reason: "Passes integer, not character." }], indent: 2, explanation: "Right-shift the bit to the 0th position, mask with 1, and print '1' or '0'." },
      { correct: "}", distractors: [{ text: ")", reason: "Wrong bracket." }, { text: "];", reason: "Invalid block closure." }], indent: 1, explanation: "Close bit-printing loop." },
      { correct: "printf(\"\\n\");", distractors: [{ text: "putchar('\\n');", reason: "Works but differs from `printf`." }, { text: "puts(\"\\n\");", reason: "Double newline." }], indent: 1, explanation: "Newline for formatting." },
      { correct: "// Check if a specific option is ON", distractors: [{ text: "// Test flags", reason: "Too generic." }, { text: "// Query bit", reason: "Less clear." }], indent: 1, explanation: "Comment on checking a flag." },
      { correct: "if ((settings & OPTION_A) != 0) {", distractors: [{ text: "if (settings == OPTION_A) {", reason: "Fails when multiple bits set." }, { text: "if (settings & ~OPTION_A) {", reason: "Checks opposite bit." }], indent: 1, explanation: "Use bitwise AND to check if the bit for Option A is set." },
      { correct: "printf(\"- Option A is ON\\n\");", distractors: [{ text: "puts(\"Option A ON\");", reason: "Missing dash and space." }, { text: "print(\"- Option A is ON\\n\");", reason: "`print` isn’t C." }], indent: 2, explanation: "Print status if on." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "];", reason: "Wrong bracket." }], indent: 1, explanation: "Close check for A." },
      { correct: "if (settings & OPTION_B) { printf(\"- Option B is ON\\n\"); }", distractors: [{ text: "if ((settings & OPTION_B) == OPTION_B) {", reason: "Also valid but verbose." }, { text: "if (settings | OPTION_B) {", reason: "Bitwise OR always true when bit set." }], indent: 1, explanation: "A more concise way to check Option B." },
      { correct: "if (settings & OPTION_C) { printf(\"- Option C is ON\\n\"); }", distractors: [{ text: "if (settings ^ OPTION_C) {", reason: "XOR toggles, not checks." }, { text: "if (settings == OPTION_C) {", reason: "Fails if other bits set." }], indent: 1, explanation: "Check Option C." },
      { correct: "if (settings & OPTION_D) { printf(\"- Option D is ON\\n\"); }", distractors: [{ text: "if (~settings & OPTION_D) {", reason: "Checks the opposite bit." }, { text: "if (settings & ~OPTION_D) {", reason: "Checks other bits." }], indent: 1, explanation: "Check Option D." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "];", reason: "Wrong closure." }], indent: 0, explanation: "Close the display function." }
    ]
  },

  // Level 34: Function Pointers as Callbacks
  {
    goal: "Create a generic array processing function that accepts a function pointer (callback) to perform an operation on each element.",
    concepts: "Function pointers, callbacks, typedef, generic programming",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for printf." },
      { correct: "#include <math.h>", distractors: [{ text: "#include <cmath>", reason: "C++ header." }, { text: "#include <stdlib.h>", reason: "Not needed for `pow`." }], indent: 0, explanation: "Include for pow() function." },
      { correct: "// Define a type for our function pointer for readability", distractors: [{ text: "/* Function pointer alias */", reason: "Less descriptive." }, { text: "// Typedef callback", reason: "Too generic." }], indent: 0, explanation: "Comment on using typedef." },
      { correct: "typedef void (*IntOperation)(int);", distractors: [{ text: "void (*IntOperation)(int);", reason: "Declares a variable, not a type." }, { text: "typedef void IntOperation(int);", reason: "Missing `*` in typedef syntax." }], indent: 0, explanation: "Create a type alias `IntOperation` for a pointer to a function that takes an int and returns void." },
      { correct: "// Callback function 1: Square a number", distractors: [{ text: "/* square callback */", reason: "Less descriptive." }, { text: "// First operation", reason: "Too generic." }], indent: 0, explanation: "Comment for first callback." },
      { correct: "void square(int num) {", distractors: [{ text: "int square(int num) {", reason: "Wrong return type." }, { text: "void square();", reason: "Missing parameter list." }], indent: 0, explanation: "Define the square function." },
      { correct: "printf(\"Square of %d is %d\\n\", num, num * num);", distractors: [{ text: "printf(\"%d^2 = %d\\n\", num, num*num);", reason: "Different format string." }, { text: "puts(\"Square computed\");", reason: "Doesn’t print the value." }], indent: 1, explanation: "Print the square." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close square function." },
      { correct: "// Callback function 2: Cube a number", distractors: [{ text: "/* cube callback */", reason: "Less descriptive." }, { text: "// Second operation", reason: "Too generic." }], indent: 0, explanation: "Comment for second callback." },
      { correct: "void cube(int num) {", distractors: [{ text: "int cube(int num) {", reason: "Wrong return type." }, { text: "void cube();", reason: "Missing parameter list." }], indent: 0, explanation: "Define the cube function." },
      { correct: "printf(\"Cube of %d is %.0f\\n\", num, pow(num, 3));", distractors: [{ text: "printf(\"%d^3=%.0f\\n\", num, pow(num,3));", reason: "Different format string." }, { text: "puts(\"Cube done\");", reason: "Doesn’t print the result." }], indent: 1, explanation: "Print the cube using the pow() function." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close cube function." },
      { correct: "// The generic processing function", distractors: [{ text: "/* Processor */", reason: "Less descriptive." }, { text: "// Generic callback", reason: "Too generic." }], indent: 0, explanation: "Comment for the main processing function." },
      { correct: "void processArray(int arr[], int size, IntOperation op) {", distractors: [{ text: "void processArray(int *arr, int size, IntOperation op) {", reason: "Works but less clear that it’s an array." }, { text: "void processArray(int arr[], size_t size, IntOperation op) {", reason: "Uses `size_t`, not taught here." }], indent: 0, explanation: "Define a function that takes an array, its size, and our function pointer type." },
      { correct: "for (int i = 0; i < size; i++) {", distractors: [{ text: "for (i = 0; i < size; i++) {", reason: "`i` must be declared." }, { text: "while (i < size) {", reason: "Wrong loop type." }], indent: 1, explanation: "Loop through each element of the array." },
      { correct: "op(arr[i]);", distractors: [{ text: "(*op)(arr[i]);", reason: "Valid but older syntax." }, { text: "arr[i] = op(arr[i]);", reason: "Assumes return value—wrong signature." }], indent: 2, explanation: "Call the provided callback function, passing the current array element." },
      { correct: "}", distractors: [{ text: ")", reason: "Wrong bracket." }, { text: "];", reason: "Invalid closure." }], indent: 1, explanation: "Close the loop." },
      { correct: "}", distractors: [{ text: "};", reason: "Extra semicolon." }, { text: "end;", reason: "Not C syntax." }], indent: 0, explanation: "Close the processing function." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "Wrong return type." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start the main function." },
      { correct: "int numbers[] = {1, 2, 3, 4, 5};", distractors: [{ text: "int numbers[5] = {1,2,3,4,5};", reason: "Valid but no spaces—less readable." }, { text: "int numbers[] = {1 2 3 4 5};", reason: "Missing commas." }], indent: 1, explanation: "Create an array of numbers to process." },
      { correct: "int size = sizeof(numbers) / sizeof(numbers[0]);", distractors: [{ text: "int size = sizeof(numbers);", reason: "Gives byte count, not element count." }, { text: "int size = 5;", reason: "Hard-codes length—less generic." }], indent: 1, explanation: "Calculate the number of elements in the array." },
      { correct: "printf(\"--- Processing with square() ---\\n\");", distractors: [{ text: "puts(\"--- Processing with square() ---\");", reason: "No newline escape." }, { text: "print(\"--- Processing with square() ---\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Print a header for the first operation." },
      { correct: "processArray(numbers, size, square);", distractors: [{ text: "processArray(&numbers, size, square);", reason: "Wrong pointer level." }, { text: "processArray(numbers, size, square());", reason: "Calls function instead of passing pointer." }], indent: 1, explanation: "Call the processor, passing the `square` function as the callback." },
      { correct: "printf(\"\\n--- Processing with cube() ---\\n\");", distractors: [{ text: "puts(\"--- Processing with cube() ---\");", reason: "No newline escape." }, { text: "print(\"--- Processing with cube() ---\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Print a header for the second operation." },
      { correct: "processArray(numbers, size, cube);", distractors: [{ text: "processArray(numbers, size, &cube);", reason: "Explicit `&` is redundant." }, { text: "processArray(numbers, size, cube());", reason: "Calls function, not pass pointer." }], indent: 1, explanation: "Call the processor again, this time passing the `cube` function." },
      { correct: "return 0;", distractors: [{ text: "exit(0);", reason: "Bypasses `main` return." }, { text: "return;", reason: "Missing return value." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the main function." }
    ]
  },

  // Level 35: Binary File I/O with Structs
  {
    goal: "Write an array of structs to a binary file using fwrite, then read it back with fread and verify the data.",
    concepts: "struct, binary file I/O, fopen, fwrite, fread, fclose, sizeof",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <fstream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for file I/O and printf." },
      { correct: "#include <stdlib.h>", distractors: [{ text: "#include <unistd.h>", reason: "POSIX, not needed here." }, { text: "#include <string.h>", reason: "Not required." }], indent: 0, explanation: "Include for exit()." },
      { correct: "typedef struct {", distractors: [{ text: "struct Player {", reason: "Missing `typedef` alias." }, { text: "typedef struct Player {", reason: "Alias name duplicated incorrectly." }], indent: 0, explanation: "Define a `Player` struct using typedef." },
      { correct: "  int id;", distractors: [{ text: "  char id;", reason: "Wrong type." }, { text: "  unsigned id;", reason: "Misses type width." }], indent: 1, explanation: "Player's unique ID." },
      { correct: "  char name[50];", distractors: [{ text: "  char *name;", reason: "Pointer requires allocation." }, { text: "  std::string name;", reason: "C++ type." }], indent: 1, explanation: "Player's name." },
      { correct: "  float score;", distractors: [{ text: "  double score;", reason: "Different precision." }, { text: "  int score;", reason: "Wrong type." }], indent: 1, explanation: "Player's score." },
      { correct: "} Player;", distractors: [{ text: "} player_t;", reason: "Alias name differs." }, { text: "} Player;", reason: "Duplicate correct alias (redundant)." }], indent: 0, explanation: "Create the alias `Player`." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "Wrong return type." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start main function." },
      { correct: "Player players_out[2] = {", distractors: [{ text: "Player players_out[] = {", reason: "Missing size—VLA not standard here." }, { text: "Player players_out[3] = {", reason: "Wrong array length." }], indent: 1, explanation: "Create an array of Player structs to write to the file." },
      { correct: "  {1, \"Alice\", 99.5f},", distractors: [{ text: "  {1, Alice, 99.5f},", reason: "String must be in quotes." }, { text: "  {1; \"Alice\"; 99.5f},", reason: "Semicolons invalid." }], indent: 2, explanation: "Initialize the first player." },
      { correct: "  {2, \"Bob\", 88.0f}", distractors: [{ text: "  {2, Bob, 88.0f}", reason: "Missing quotes around string." }, { text: "  {2, \"Bob\", 88.0}", reason: "Missing `f` suffix." }], indent: 2, explanation: "Initialize the second player." },
      { correct: "};", distractors: [{ text: "}", reason: "Missing semicolon." }, { text: "];", reason: "Wrong bracket." }], indent: 1, explanation: "Close the initializer list." },
      { correct: "FILE *file_ptr;", distractors: [{ text: "fstream file_ptr;", reason: "C++ type." }, { text: "FILE file_ptr;", reason: "Must be pointer." }], indent: 1, explanation: "Declare a file pointer." },
      { correct: "// --- WRITE TO FILE ---", distractors: [{ text: "/* WRITE */", reason: "Too generic." }, { text: "// Open for write", reason: "Misses binary mode detail." }], indent: 1, explanation: "Comment for the writing section." },
      { correct: "file_ptr = fopen(\"players.bin\", \"wb\");", distractors: [{ text: "file_ptr = fopen(\"players.bin\", \"w\");", reason: "Text mode corrupts binary data." }, { text: "file_ptr = fopen(\"players.txt\", \"wb\");", reason: "Wrong filename extension." }], indent: 1, explanation: "Open a file in binary write mode ('wb')." },
      { correct: "if (file_ptr == NULL) { perror(\"Error opening for write\"); exit(1); }", distractors: [{ text: "if (!file_ptr) return 1;", reason: "Works but less explicit." }, { text: "if (file_ptr == 0) exit(EXIT_FAILURE);", reason: "Uses macro differently." }], indent: 1, explanation: "Check for file open error." },
      { correct: "fwrite(players_out, sizeof(Player), 2, file_ptr);", distractors: [{ text: "fwrite(players_out, sizeof(Player), 1, file_ptr);", reason: "Writes only one element." }, { text: "fwrite(&players_out, sizeof(Player), 2, file_ptr);", reason: "Passes pointer-to-array, not element pointer." }], indent: 1, explanation: "Write the entire array of 2 players to the file." },
      { correct: "fclose(file_ptr);", distractors: [{ text: "close(file_ptr);", reason: "POSIX `close` on file descriptor, not `FILE*`." }, { text: "fclose(\"players.bin\");", reason: "Wrong argument type." }], indent: 1, explanation: "Always close the file after writing." },
      { correct: "printf(\"Data written to players.bin\\n\\n\");", distractors: [{ text: "puts(\"Data written!\");", reason: "Less informative." }, { text: "print(\"Data written to players.bin\\n\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Confirmation message." },
      { correct: "// --- READ FROM FILE ---", distractors: [{ text: "/* READ */", reason: "Too generic." }, { text: "// Reopen file", reason: "Misses binary mode detail." }], indent: 1, explanation: "Comment for the reading section." },
      { correct: "Player players_in[2];", distractors: [{ text: "Player players_in[];", reason: "Missing size." }, { text: "Player players_in[3];", reason: "Wrong size." }], indent: 1, explanation: "Create a new array to hold the data read from the file." },
      { correct: "file_ptr = fopen(\"players.bin\", \"rb\");", distractors: [{ text: "fopen(\"players.bin\",\"r\");", reason: "Text mode wrong." }, { text: "fopen(\"players.txt\",\"rb\");", reason: "Wrong extension." }], indent: 1, explanation: "Re-open the file in binary read mode ('rb')." },
      { correct: "if (file_ptr == NULL) { perror(\"Error opening for read\"); exit(1); }", distractors: [{ text: "if (!file_ptr) return 1;", reason: "Less explicit." }, { text: "if (file_ptr == 0) exit(EXIT_FAILURE);", reason: "Uses macro differently." }], indent: 1, explanation: "Check for file open error again." },
      { correct: "fread(players_in, sizeof(Player), 2, file_ptr);", distractors: [{ text: "fread(players_in, sizeof(Player*), 2, file_ptr);", reason: "Wrong size argument." }, { text: "fread(&players_in, sizeof(Player), 2, file_ptr);", reason: "Passes pointer-to-array." }], indent: 1, explanation: "Read exactly 2 Player-sized chunks of data from the file into the new array." },
      { correct: "fclose(file_ptr);", distractors: [{ text: "close(file_ptr);", reason: "POSIX call, not `FILE*`." }, { text: "fclose(\"players.bin\");", reason: "Wrong argument type." }], indent: 1, explanation: "Close the file after reading." },
      { correct: "printf(\"Verifying data read from file:\\n\");", distractors: [{ text: "puts(\"Verifying...\");", reason: "Less detailed." }, { text: "print(\"Verifying data read from file:\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "Header for verification." },
      { correct: "for (int i = 0; i < 2; i++) {", distractors: [{ text: "for (i = 0; i < 2; i++) {", reason: "`i` must be declared." }, { text: "while (i < 2) {", reason: "Wrong loop type." }], indent: 1, explanation: "Loop through the read-in data." },
      { correct: "printf(\"Player %d: ID=%d, Name=%s, Score=%.1f\\n\",", distractors: [{ text: "printf(\"Player %d: %d %s %.1f\\n\",", reason: "Wrong format fields." }, { text: "printf(\"%d %d %s %f\\n\",", reason: "Wrong format and missing labels." }], indent: 2, explanation: "Print the data for each player read from the file." },
      { correct: "  i + 1, players_in[i].id, players_in[i].name, players_in[i].score);", distractors: [{ text: "i, players_in[i].id, players_in[i].name, players_in[i].score);", reason: "Off-by-one index." }, { text: "i+1, &players_in[i].id, players_in[i].name, players_in[i].score);", reason: "Passing address of id, not value." }], indent: 3, explanation: "Access the members of the struct to print them." },
      { correct: "}", distractors: [{ text: "};", reason: "Extra semicolon." }, { text: "end;", reason: "Not C syntax." }], indent: 1, explanation: "Close the verification loop." },
      { correct: "return 0;", distractors: [{ text: "return 1;", reason: "Signals failure." }, { text: "exit(EXIT_SUCCESS);", reason: "Bypasses normal return." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the main function." }
    ]
  },

  // Level 36: `typedef` for Readability
  {
    goal: "Refactor complex type declarations using `typedef` to improve code readability.",
    concepts: "typedef, structs, function pointers, complex declarations",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for standard I/O." },
      { correct: "#include <string.h>", distractors: [{ text: "#include <cstring>", reason: "C++ header." }, { text: "#include <stdlib.h>", reason: "Not needed for strcpy." }], indent: 0, explanation: "Include for strcpy." },
      { correct: "// --- Without Typedef (Complex) ---", distractors: [{ text: "/* Complex types */", reason: "Less explicit." }, { text: "// No typedef section", reason: "Less structured." }], indent: 0, explanation: "Section demonstrating complex C types." },
      { correct: "struct user_profile {", distractors: [{ text: "struct user_profile();", reason: "Function, not struct." }, { text: "class user_profile {", reason: "C++ keyword." }], indent: 0, explanation: "Define a struct the long way." },
      { correct: "  unsigned long id;", distractors: [{ text: "  ulong id;", reason: "`ulong` not defined yet." }, { text: "  unsigned id;", reason: "Missing type width." }], indent: 1, explanation: "A member with a long type name." },
      { correct: "  char name[50];", distractors: [{ text: "  char *name;", reason: "Requires separate allocation." }, { text: "  std::string name;", reason: "C++ type." }], indent: 1, explanation: "A name member." },
      { correct: "};", distractors: [{ text: "}", reason: "Missing semicolon." }, { text: "};;", reason: "Extra semicolon." }], indent: 0, explanation: "End the struct definition." },
      { correct: "void print_user(struct user_profile u) {", distractors: [{ text: "void print_user(user_profile u) {", reason: "Missing `struct` keyword." }, { text: "int print_user(struct user_profile u) {", reason: "Wrong return type." }], indent: 0, explanation: "A function taking the struct, requiring the `struct` keyword." },
      { correct: "printf(\"ID: %lu, Name: %s\\n\", u.id, u.name);", distractors: [{ text: "printf(\"ID: %d, Name: %s\\n\", u.id, u.name);", reason: "Wrong format for `unsigned long`." }, { text: "puts(u.name);", reason: "Only prints name, not id." }], indent: 1, explanation: "Print user info. `%lu` is for `unsigned long`." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the print function." },
      { correct: "// --- With Typedef (Readable) ---", distractors: [{ text: "/* Typedef section */", reason: "Less explicit." }, { text: "// Readable types", reason: "Too generic." }], indent: 0, explanation: "Section demonstrating how typedef improves readability." },
      { correct: "typedef unsigned long ulong;", distractors: [{ text: "typedef ulong unsigned long;", reason: "Alias and type swapped." }, { text: "using ulong = unsigned long;", reason: "C++ syntax, not C." }], indent: 0, explanation: "Create a simple alias `ulong` for `unsigned long`." },
      { correct: "typedef struct {", distractors: [{ text: "typedef struct user_profile {", reason: "Naming conflicts." }, { text: "struct {", reason: "Missing typedef keyword." }], indent: 0, explanation: "Begin an anonymous struct definition for use in a typedef." },
      { correct: "  ulong id;", distractors: [{ text: "  unsigned long id;", reason: "Reverts to full type—misses benefit." }, { text: "  ulong id[50];", reason: "Wrong type shape." }], indent: 1, explanation: "Use the new `ulong` type for the ID." },
      { correct: "  char name[50];", distractors: [{ text: "  char *name;", reason: "Requires allocation." }, { text: "  string name;", reason: "C++ type." }], indent: 1, explanation: "The name member." },
      { correct: "} UserProfile;", distractors: [{ text: "} Profile;", reason: "Alias name differs." }, { text: "} UserProfile", reason: "Missing semicolon." }], indent: 0, explanation: "Complete the typedef, creating the alias `UserProfile` for the entire struct." },
      { correct: "typedef int (*MathFunc)(int, int);", distractors: [{ text: "typedef int MathFunc(int, int);", reason: "Defines a function type, not a pointer." }, { text: "int (*MathFunc)(int, int);", reason: "Declares variable, not typedef." }], indent: 0, explanation: "Create a `typedef` for a function pointer that takes two ints and returns an int." },
      { correct: "int add(int a, int b) { return a + b; }", distractors: [{ text: "int add(int a, int b) { return a - b; }", reason: "Implements subtract, not add." }, { text: "void add(int a, int b) { return a + b; }", reason: "Wrong return type." }], indent: 0, explanation: "Define a function that matches the `MathFunc` signature." },
      { correct: "int subtract(int a, int b) { return a - b; }", distractors: [{ text: "int subtract(int a, int b) { return a + b; }", reason: "Implements add, not subtract." }, { text: "void subtract(int a, int b) { return a - b; }", reason: "Wrong return type." }], indent: 0, explanation: "Define another function that matches." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "Wrong return type." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start the main function." },
      { correct: "// Using the cleaner, typedef'd versions", distractors: [{ text: "/* Using typedefs */", reason: "Less explicit." }, { text: "// Cleaner types", reason: "Too generic." }], indent: 1, explanation: "Comment on using the new types." },
      { correct: "UserProfile user1;", distractors: [{ text: "struct UserProfile user1;", reason: "Requires `typedef` to avoid `struct` keyword." }, { text: "UserProfile user1[1];", reason: "Declares an array, not variable." }], indent: 1, explanation: "Declare a `UserProfile` variable easily." },
      { correct: "user1.id = 12345UL;", distractors: [{ text: "user1.id = 12345;", reason: "Missing `UL` suffix—different type." }, { text: "user1.id = 0x3039;", reason: "Hex literal valid but less clear." }], indent: 1, explanation: "Assign an ID. `UL` suffix denotes an unsigned long." },
      { correct: "strcpy(user1.name, \"Charlie\");", distractors: [{ text: "strncpy(user1.name, \"Charlie\", 50);", reason: "Safe but not taught." }, { text: "user1.name = \"Charlie\";", reason: "Invalid assignment to array." }], indent: 1, explanation: "Assign a name using strcpy." },
      { correct: "print_user(user1); // Note: print_user was not typedef'd", distractors: [{ text: "UserProfile u = user1; print_user(u);", reason: "Unnecessary copy." }, { text: "print_user(&user1);", reason: "Wrong argument type." }], indent: 1, explanation: "Call the original print function (it's compatible)." },
      { correct: "MathFunc operation;", distractors: [{ text: "int (*operation)(int,int);", reason: "More verbose original syntax." }, { text: "MathFunc *operation;", reason: "Pointer-to-function-pointer—wrong." }], indent: 1, explanation: "Declare a function pointer variable using our new `MathFunc` type." },
      { correct: "operation = add;", distractors: [{ text: "operation = &add;", reason: "Explicit `&` redundant." }, { text: "operation = subtract;", reason: "Points to wrong function initially." }], indent: 1, explanation: "Point the `operation` pointer to the `add` function." },
      { correct: "printf(\"Result of add: %d\\n\", operation(10, 5));", distractors: [{ text: "printf(\"%d\\n\", operation(10,5));", reason: "Missing label." }, { text: "puts(\"Result of add computed\");", reason: "Doesn’t print value." }], indent: 1, explanation: "Use the function pointer." },
      { correct: "operation = subtract;", distractors: [{ text: "operation = add;", reason: "Remains pointing to add." }, { text: "operation = &subtract;", reason: "Redundant `&`." }], indent: 1, explanation: "Point the same pointer to the `subtract` function." },
      { correct: "printf(\"Result of subtract: %d\\n\", operation(10, 5));", distractors: [{ text: "printf(\"%d\\n\", operation(10,5));", reason: "Missing label." }, { text: "puts(\"Subtraction done\");", reason: "Doesn’t print result." }], indent: 1, explanation: "Use the function pointer again." },
      { correct: "return 0;", distractors: [{ text: "exit(0);", reason: "Bypasses `main` return." }, { text: "return;", reason: "Missing return value." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the main function." }
    ]
  },

  // Level 37: Command-Line Argument Parsing
  {
    goal: "Write a program that parses and uses command-line arguments `argc` and `argv`.",
    concepts: "main function arguments, argc, argv, string comparison, atoi",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for standard I/O." },
      { correct: "#include <stdlib.h>", distractors: [{ text: "#include <cstdlib>", reason: "C++ header." }, { text: "#include <string.h>", reason: "Not needed for `atoi`." }], indent: 0, explanation: "Include for `atoi` (convert string to integer)." },
      { correct: "#include <string.h>", distractors: [{ text: "#include <cstring>", reason: "C++ header." }, { text: "#include <strings.h>", reason: "POSIX header, not standard C." }], indent: 0, explanation: "Include for `strcmp` (string comparison)." },
      { correct: "// The main function signature for accepting command-line args", distractors: [{ text: "/* main signature */", reason: "Too generic." }, { text: "// Signature: int main()", reason: "Missing `argv` in comment." }], indent: 0, explanation: "Comment on main's signature." },
      { correct: "int main(int argc, char *argv[]) {", distractors: [{ text: "int main() {", reason: "Signature lacks arguments." }, { text: "int main(int argv, char *argc[]) {", reason: "Names swapped—wrong semantics." }], indent: 0, explanation: "Define `main` to accept argument count (`argc`) and argument vector (`argv`)." },
      { correct: "// argc is the number of strings in argv", distractors: [{ text: "/* argc count */", reason: "Less descriptive." }, { text: "// argv length", reason: "Confuses argc/argv roles." }], indent: 1, explanation: "Explain argc." },
      { correct: "// argv is an array of strings (char pointers)", distractors: [{ text: "// argv list", reason: "Less precise." }, { text: "/* argv pointers */", reason: "Generic comment." }], indent: 1, explanation: "Explain argv." },
      { correct: "// argv[0] is always the program's name", distractors: [{ text: "// argv[1] is first arg", reason: "Wrong index explanation." }, { text: "// argv[0] is first param", reason: "Imprecise wording." }], indent: 1, explanation: "Explain argv[0]." },
      { correct: "printf(\"Program name: %s\\n\", argv[0]);", distractors: [{ text: "puts(argv[0]);", reason: "No label or newline control." }, { text: "print(\"Program name: %s\\n\", argv[0]);", reason: "`print` isn’t C." }], indent: 1, explanation: "Print the name of the executable." },
      { correct: "printf(\"Number of arguments supplied: %d\\n\", argc);", distractors: [{ text: "printf(\"Args=%d\\n\");", reason: "Missing argument to print." }, { text: "puts(argc);", reason: "Wrong type passed." }], indent: 1, explanation: "Print the total argument count." },
      { correct: "if (argc < 2) {", distractors: [{ text: "if (argc == 0) {", reason: "Impossible condition." }, { text: "if (argc <= 1) {", reason: "Works but differs from taught check." }], indent: 1, explanation: "Check if the user failed to provide any arguments." },
      { correct: "printf(\"Usage: %s [-m <message>] [-n <number>]\\n\", argv[0]);", distractors: [{ text: "puts(\"Usage: program [-m <msg>] [-n <num>]\");", reason: "Less detailed and wrong call." }, { text: "print(\"Usage: %s...\\n\", argv[0]);", reason: "`print` isn’t C." }], indent: 2, explanation: "Print a usage message if no arguments are given." },
      { correct: "return 1;", distractors: [{ text: "exit(1);", reason: "Bypasses `main` return." }, { text: "return;", reason: "Missing return value." }], indent: 2, explanation: "Exit with an error code." },
      { correct: "}", distractors: [{ text: "end if;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 1, explanation: "Close the argument check." },
      { correct: "// Loop through all provided arguments (starting from 1)", distractors: [{ text: "/* Arg loop */", reason: "Less descriptive." }, { text: "// for each arg", reason: "Generic comment." }], indent: 1, explanation: "Comment on argument loop." },
      { correct: "for (int i = 1; i < argc; i++) {", distractors: [{ text: "for (i = 1; i < argc; i++) {", reason: "`i` must be declared." }, { text: "while (i < argc) {", reason: "Wrong loop type." }], indent: 1, explanation: "Start a loop from index 1 to skip the program name." },
      { correct: "printf(\"Argument %d: %s\\n\", i, argv[i]);", distractors: [{ text: "puts(argv[i]);", reason: "No index or label." }, { text: "printf(\"%s\\n\", argv[i]);", reason: "Missing position number." }], indent: 2, explanation: "Print each argument." },
      { correct: "// Check for a specific flag, e.g., \"-m\" for message", distractors: [{ text: "// Flag -m", reason: "Too generic." }, { text: "/* message flag */", reason: "Less clear." }], indent: 2, explanation: "Comment on flag checking." },
      { correct: "if (strcmp(argv[i], \"-m\") == 0) {", distractors: [{ text: "if (argv[i] == \"-m\") {", reason: "Cannot compare strings with `==`." }, { text: "if (!strcmp(argv[i], \"-m\")) {", reason: "Also valid but checks `!0`—less explicit." }], indent: 2, explanation: "Use `strcmp` to check if the current argument is the '-m' flag." },
      { correct: "printf(\"  -> Found message flag! Message: %s\\n\", argv[i+1]);", distractors: [{ text: "puts(argv[i+1]);", reason: "No label or control." }, { text: "printf(\"Message: %d\\n\", argv[i+1]);", reason: "Wrong format for string." }], indent: 3, explanation: "If found, print the *next* argument as the message." },
      { correct: "i++; // Increment i to skip the message argument in the next loop", distractors: [{ text: "i += 2; // Skip two args", reason: "Over-increments." }, { text: "continue; // Skip next iteration", reason: "Misuses `continue`." }], indent: 3, explanation: "Crucially, increment the counter to avoid re-processing the flag's value." },
      { correct: "}", distractors: [{ text: "end if;", reason: "Not C syntax." }, { text: "];", reason: "Invalid closure." }], indent: 2, explanation: "Close the '-m' flag check." },
      { correct: "// Check for a specific flag, e.g., \"-n\" for number", distractors: [{ text: "// Flag -n", reason: "Too generic." }, { text: "/* number flag */", reason: "Less clear." }], indent: 2, explanation: "Comment on another flag." },
      { correct: "else if (strcmp(argv[i], \"-n\") == 0) {", distractors: [{ text: "if (!strcmp(argv[i], \"-n\")) {", reason: "Valid but less explicit." }, { text: "if (argv[i][1] == 'n') {", reason: "Only checks char, not full string." }], indent: 2, explanation: "Check for the '-n' flag." },
      { correct: "int num = atoi(argv[i+1]);", distractors: [{ text: "int num = (int)argv[i+1];", reason: "Cannot cast string pointer to int." }, { text: "int num = strtol(argv[i+1], NULL, 10);", reason: "Valid but not taught here." }], indent: 3, explanation: "Use `atoi` to convert the next argument from a string to an integer." },
      { correct: "printf(\"  -> Found number flag! Value squared: %d\\n\", num * num);", distractors: [{ text: "printf(\"Number: %d\\n\", num);", reason: "Different calculation." }, { text: "puts(\"Number flag found\");", reason: "No numeric output." }], indent: 3, explanation: "Print a calculation based on the parsed number." },
      { correct: "i++; // Increment i to skip the number argument", distractors: [{ text: "i += 2; // Skip two args", reason: "Over-increments." }, { text: "continue;", reason: "Misuses `continue`." }], indent: 3, explanation: "Increment the counter again." },
      { correct: "}", distractors: [{ text: "end if;", reason: "Not C syntax." }, { text: "];", reason: "Invalid closure." }], indent: 2, explanation: "Close the '-n' flag check." },
      { correct: "}", distractors: [{ text: "end for;", reason: "Not C syntax." }, { text: "];", reason: "Invalid closure." }], indent: 1, explanation: "Close the argument processing loop." },
      { correct: "return 0;", distractors: [{ text: "exit(0);", reason: "Bypasses `main` return." }, { text: "return;", reason: "Missing return value." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close the main function." }
    ]
  },

  // Level 38: Error Handling with `errno` and `perror`
  {
    goal: "Demonstrate proper error handling by checking for a NULL return from fopen, then using `errno`, `perror`, and `strerror`.",
    concepts: "Error handling, errno, perror, strerror, FILE I/O",
    sequence: [
      { correct: "#include <stdio.h>", distractors: [{ text: "#include <iostream>", reason: "C++ header." }, { text: "#import <stdio.h>", reason: "`#import` isn’t C." }], indent: 0, explanation: "Include for I/O functions." },
      { correct: "#include <stdlib.h>", distractors: [{ text: "#include <stdlib>", reason: "Missing `.h`." }, { text: "#include <unistd.h>", reason: "Not needed here." }], indent: 0, explanation: "Include for exit()." },
      { correct: "#include <string.h>", distractors: [{ text: "#include <cstring>", reason: "C++ header." }, { text: "#include <strings.h>", reason: "POSIX header." }], indent: 0, explanation: "Include for `strerror`." },
      { correct: "#include <errno.h>", distractors: [{ text: "#include <error.h>", reason: "Wrong header." }, { text: "#include <err.h>", reason: "Non-standard." }], indent: 0, explanation: "Include to get the declaration of the `errno` variable." },
      { correct: "int main() {", distractors: [{ text: "void main() {", reason: "Wrong return type." }, { text: "main() {", reason: "Missing return type." }], indent: 0, explanation: "Start main function." },
      { correct: "FILE *fp;", distractors: [{ text: "int fp;", reason: "Wrong type." }, { text: "FILE fp;", reason: "Must be pointer." }], indent: 1, explanation: "Declare a file pointer." },
      { correct: "// Attempt to open a file that does not exist", distractors: [{ text: "/* Open file */", reason: "Too generic." }, { text: "// Try read mode", reason: "Less descriptive." }], indent: 1, explanation: "Comment on the intended failing operation." },
      { correct: "fp = fopen(\"non_existent_file.txt\", \"r\");", distractors: [{ text: "fopen(\"non_existent_file.txt\",\"w\");", reason: "Write mode creates file instead of failing." }, { text: "fopen(\"file.txt\",\"r\");", reason: "Different filename." }], indent: 1, explanation: "Try to open a non-existent file in read mode, which will fail." },
      { correct: "// Check if fopen() failed", distractors: [{ text: "/* Error check */", reason: "Less clear." }, { text: "// Verify file", reason: "Too generic." }], indent: 1, explanation: "Comment on the error check." },
      { correct: "if (fp == NULL) {", distractors: [{ text: "if (!fp) {", reason: "Equivalent but less explicit." }, { text: "if (fp = NULL) {", reason: "Assignment, not comparison." }], indent: 1, explanation: "A `NULL` return value from `fopen` indicates that an error occurred." },
      { correct: "// When a standard library function fails, it sets the global `errno` variable.", distractors: [{ text: "/* errno explained */", reason: "Less explicit." }, { text: "// errno holds error code", reason: "Less formal." }], indent: 2, explanation: "Explain `errno`." },
      { correct: "printf(\"fopen() failed. The error number is: %d\\n\", errno);", distractors: [{ text: "printf(\"Error: %s\\n\", errno);", reason: "Wrong format for integer." }, { text: "puts(errno);", reason: "Wrong function and type." }], indent: 2, explanation: "Print the raw integer error code stored in `errno`." },
      { correct: "// Method 1: Use perror() to print a descriptive error message", distractors: [{ text: "// Method 1: perror", reason: "Too short." }, { text: "/* perror usage */", reason: "Less instructional." }], indent: 2, explanation: "Explain perror." },
      { correct: "// perror() prints your custom message, followed by a colon,", distractors: [{ text: "// Prints error", reason: "Less detailed." }, { text: "/* Colon output */", reason: "Too vague." }], indent: 2, explanation: "Explain perror's output format." },
      { correct: "// and the string equivalent of the current errno value.", distractors: [{ text: "// Also uses strerror", reason: "Hints next method." }, { text: "/* strerror equivalent */", reason: "Less clear." }], indent: 2, explanation: "Continue explaining perror's output." },
      { correct: "perror(\"Error reported by perror\");", distractors: [{ text: "printf(\"Error: %s\\n\", perror);", reason: "`perror` doesn’t return a string." }, { text: "perror(errno);", reason: "`perror` takes string message, not int." }], indent: 2, explanation: "Call `perror` with a custom prefix for the error message." },
      { correct: "// Method 2: Use strerror() to get the error string yourself", distractors: [{ text: "// Method 2: strerror", reason: "Too brief." }, { text: "/* strerror usage */", reason: "Less explanatory." }], indent: 2, explanation: "Explain strerror." },
      { correct: "printf(\"Error reported by strerror: %s\\n\", strerror(errno));", distractors: [{ text: "printf(\"Error: %s\\n\", errno);", reason: "Prints integer as string." }, { text: "puts(strerror);", reason: "`strerror` is function, not string." }], indent: 2, explanation: "Use `strerror` to get the string for the current `errno` value and print it." },
      { correct: "exit(EXIT_FAILURE); // Use standard macro for failure exit code", distractors: [{ text: "exit(1);", reason: "Hard-coded rather than macro." }, { text: "return EXIT_FAILURE;", reason: "After perror, return is okay but bypasses exit." }], indent: 2, explanation: "Exit the program with a failure status." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "];", reason: "Wrong bracket." }], indent: 1, explanation: "Close the error handling block." },
      { correct: "// This part of the code will not be reached", distractors: [{ text: "// Success path", reason: "Misleading—won’t be reached here." }, { text: "/* Unreachable */", reason: "Less descriptive." }], indent: 1, explanation: "Comment on code flow." },
      { correct: "printf(\"File opened successfully!\\n\");", distractors: [{ text: "puts(\"File opened!\");", reason: "Less detailed." }, { text: "print(\"File opened successfully!\\n\");", reason: "`print` isn’t C." }], indent: 1, explanation: "A success message that won't print in this case." },
      { correct: "fclose(fp);", distractors: [{ text: "close(fp);", reason: "POSIX call, not `FILE*`." }, { text: "fclose(\"non_existent_file.txt\");", reason: "Wrong argument type." }], indent: 1, explanation: "Closing the file." },
      { correct: "return 0; // Or EXIT_SUCCESS", distractors: [{ text: "return;", reason: "Missing return value." }, { text: "exit(EXIT_SUCCESS);", reason: "Bypasses `main` return." }], indent: 1, explanation: "Indicate success." },
      { correct: "}", distractors: [{ text: "end;", reason: "Not C syntax." }, { text: "};", reason: "Extra semicolon." }], indent: 0, explanation: "Close main function." }
    ]
  },

  // Level 39: `const` Correctness with Pointers
  {
    goal: "Understand and demonstrate the three main uses of `const` with pointers to enforce code correctness.",
    concepts: "`const` keyword, pointers, pointer to const, const pointer, const pointer to const",
    sequence: [
        { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Including `<stdlib.h>` isn’t needed here; `<stdio.h>` is required for `printf`." }], indent: 0, explanation: "Include for standard I/O." },
        { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "C standard requires `int main()` for proper return type." }], indent: 0, explanation: "Start the main function." },
        { correct: "int val1 = 10;", distractors: [{ "text": "const int val1 = 10;", reason: "Using `const` here prevents modification, but we need `val1` modifiable later." }], indent: 1, explanation: "A modifiable integer value." },
        { correct: "int val2 = 20;", distractors: [{ "text": "int val2;", reason: "Uninitialized variable; could lead to undefined behavior when used." }], indent: 1, explanation: "Another modifiable integer value." },
        { correct: "// --- 1. Pointer to a `const` Integer ---", distractors: [{ "text": "// Pointer to a constant integer", reason: "Too vague and lacks proper formatting; comments should be clear." }], indent: 1, explanation: "The data pointed to is constant, but the pointer itself can change." },
        { correct: "const int* ptr_to_const;", distractors: [{ "text": "int* const ptr_to_const;", reason: "This declares a constant pointer to a modifiable integer, not a pointer to a constant integer." }, { "text": "const int ptr_to_const;", reason: "This declares a constant integer, not a pointer." }], indent: 1, explanation: "Declare a pointer that points to an integer that cannot be changed through this pointer." },
        { correct: "ptr_to_const = &val1;", distractors: [{ "text": "*ptr_to_const = val1;", reason: "Tries to modify the value through the pointer, which is illegal with `const int*`." }], indent: 1, explanation: "Point it to `val1`. This is allowed." },
        { correct: "printf(\"Value via ptr_to_const: %d\\n\", *ptr_to_const);", distractors: [{ "text": "printf(\"Value: %d\\n\", ptr_to_const);", reason: "Prints the pointer address instead of the value; needs dereference with `*`." }], indent: 1, explanation: "Reading the value is fine." },
        { correct: "// *ptr_to_const = 15; // COMPILE ERROR! Cannot change the value.", distractors: [{ "text": "*ptr_to_const = 15;", reason: "Uncommented, this would attempt an illegal modification through a `const` pointer." }], indent: 1, explanation: "This line is commented out because it would not compile. You cannot modify the data via this pointer." },
        { correct: "ptr_to_const = &val2;", distractors: [{ "text": "ptr_to_const = val2;", reason: "Assigns the value instead of the address; pointer needs `&`." }], indent: 1, explanation: "Pointing to a different address *is* allowed. The pointer itself is not constant." },
        { correct: "printf(\"Pointer was changed to point to val2: %d\\n\", *ptr_to_const);", distractors: [{ "text": "printf(\"Value: %d\\n\", &val2);", reason: "Prints the address of `val2` instead of the value via the pointer." }], indent: 1, explanation: "Show that the pointer was successfully reassigned." },
        { correct: "// --- 2. `const` Pointer to an Integer ---", distractors: [{ "text": "// Constant pointer", reason: "Incomplete and unclear; should specify it’s a pointer to a modifiable integer." }], indent: 1, explanation: "The pointer itself is constant, but the data it points to can be changed." },
        { correct: "int* const const_ptr = &val1;", distractors: [{ "text": "int* const const_ptr;", reason: "A constant pointer must be initialized at declaration." }, { "text": "const int* const_ptr = &val1;", reason: "Omits `const` on the pointer; this is a pointer to a `const int` instead." }], indent: 1, explanation: "Declare a constant pointer. It must be initialized immediately and can never be reassigned." },
        { correct: "printf(\"\\nValue via const_ptr: %d\\n\", *const_ptr);", distractors: [{ "text": "printf(\"Value: %d\\n\", const_ptr);", reason: "Prints the pointer address instead of the value." }], indent: 1, explanation: "Reading the value is fine." },
        { correct: "*const_ptr = 15; // Allowed! The data can be changed.", distractors: [{ "text": "const_ptr = &val2;", reason: "Tries to reassign the constant pointer, which is illegal." }], indent: 1, explanation: "Modifying the data *through* the pointer is allowed." },
        { correct: "printf(\"Value was changed via const_ptr: %d\\n\", *const_ptr);", distractors: [{ "text": "printf(\"Value: %d\\n\", val1);", reason: "Correct value but bypasses the pointer, missing the demonstration." }], indent: 1, explanation: "Show that the underlying `val1` was modified." },
        { correct: "// const_ptr = &val2; // COMPILE ERROR! Cannot change the pointer itself.", distractors: [{ "text": "const_ptr = &val2;", reason: "Uncommented, this would illegally reassign a constant pointer." }], indent: 1, explanation: "This line is commented out as it would fail. The pointer's address is fixed." },
        { correct: "// --- 3. `const` Pointer to a `const` Integer ---", distractors: [{ "text": "// Fully constant pointer", reason: "Ambiguous and less precise; should clarify both pointer and data are constant." }], indent: 1, explanation: "Neither the pointer nor the data it points to can be changed." },
        { correct: "const int* const fully_const_ptr = &val2;", distractors: [{ "text": "int* fully_const_ptr = &val2;", reason: "Missing both `const` qualifiers; neither pointer nor data is protected." }], indent: 1, explanation: "Declare a pointer where both the pointer and the data are constant." },
        { correct: "printf(\"\\nValue via fully_const_ptr: %d\\n\", *fully_const_ptr);", distractors: [{ "text": "printf(\"Value: %d\\n\", fully_const_ptr);", reason: "Prints the address instead of the value." }], indent: 1, explanation: "Reading is the only operation allowed." },
        { correct: "// *fully_const_ptr = 25; // COMPILE ERROR!", distractors: [{ "text": "*fully_const_ptr = 25;", reason: "Uncommented, this illegally tries to modify a `const` value." }], indent: 1, explanation: "Cannot modify the data." },
        { correct: "// fully_const_ptr = &val1; // COMPILE ERROR!", distractors: [{ "text": "fully_const_ptr = &val1;", reason: "Uncommented, this illegally tries to reassign a `const` pointer." }], indent: 1, explanation: "Cannot reassign the pointer." },
        { correct: "return 0;", distractors: [{ "text": "return;", reason: "Missing return value; `main` should return an `int`." }], indent: 1, explanation: "Indicate successful execution." },
        { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax; function blocks use `}` not `};`." }], indent: 0, explanation: "Close the main function." }
    ]
  },

  // Level 40: The `volatile` Keyword
  {
    goal: "Understand the purpose of the `volatile` keyword to prevent compiler optimizations on variables that can change unexpectedly.",
    concepts: "`volatile` keyword, pointers, compiler optimization (conceptual)",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "`<stdlib.h>` isn’t needed here; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for standard I/O." },
  { correct: "// `volatile` tells the compiler that a variable's value may change", distractors: [{ "text": "// volatile variable", reason: "Too brief; lacks explanation of its effect on the compiler." }], indent: 0, explanation: "Conceptual explanation of volatile." },
  { correct: "// at any time without any action being taken by the code the compiler sees.", distractors: [{ "text": "// at any time", reason: "Incomplete; misses the key point about compiler visibility." }], indent: 0, explanation: "Continuing the explanation." },
  { correct: "// For example, a hardware status register.", distractors: [{ "text": "// Like an integer", reason: "Misleading; doesn’t relate to the hardware context." }], indent: 0, explanation: "Providing a common use case." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Incorrect return type; `main` must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "// We simulate a hardware register using a global variable.", distractors: [{ "text": "// Global variable", reason: "Lacks context; doesn’t explain the simulation purpose." }], indent: 1, explanation: "Comment on the simulation setup." },
  { correct: "volatile int mock_hardware_register = 0;", distractors: [{ "text": "int mock_hardware_register = 0;", reason: "Without `volatile`, the compiler might optimize the loop, causing an infinite loop." }], indent: 1, explanation: "Declare a `volatile` integer to simulate a memory-mapped register." },
  { correct: "int non_volatile_var = 0;", distractors: [{ "text": "int non_volatile_var;", reason: "Uninitialized; could lead to unpredictable behavior." }], indent: 1, explanation: "Declare a normal variable for comparison." },
  { correct: "printf(\"Waiting for `volatile` register to become non-zero...\\n\");", distractors: [{ "text": "printf(\"Waiting...\\n\");", reason: "Less informative; doesn’t specify what’s being waited for." }], indent: 1, explanation: "Informational message." },
  { correct: "printf(\"(In a real program, an external event or hardware would change this.)\\n\");", distractors: [{ "text": "printf(\"(Hardware changes this)\\n\");", reason: "Too concise; lacks context about simulation." }], indent: 1, explanation: "Clarify the simulation." },
  { correct: "// This loop will reliably re-read the `volatile` variable from memory on each iteration.", distractors: [{ "text": "// Loop reads variable", reason: "Vague; misses the key role of `volatile`." }], indent: 1, explanation: "Explain the effect of `volatile` on the loop." },
  { correct: "while (mock_hardware_register == 0) {", distractors: [{ "text": "while(1) { if (mock_hardware_register != 0) break; }", reason: "Functionally similar but less clear and concise." }], indent: 1, explanation: "Start a loop that waits for the `volatile` variable to change." },
  { correct: "  // In this simulation, we change it ourselves after a delay.", distractors: [{ "text": "// Change variable", reason: "Too generic; doesn’t mention simulation or delay." }], indent: 2, explanation: "Comment on the manual change." },
  { correct: "  static int counter = 0;", distractors: [{ "text": "int counter = 0;", reason: "Non-static resets each iteration, breaking the delay logic." }], indent: 2, explanation: "Use a static counter to trigger the change only once." },
  { correct: "  if (counter == 50000000) { // Artificial delay", distractors: [{ "text": "if (counter = 50000000) {", reason: "Uses assignment (`=`) instead of comparison (`==`), always true." }], indent: 2, explanation: "Create an artificial delay before changing the value." },
  { correct: "    mock_hardware_register = 1;", distractors: [{ "text": "&mock_hardware_register = 1;", reason: "Cannot assign to an address; variable isn’t a pointer." }], indent: 3, explanation: "Simulate the external event changing the register's value." },
  { correct: "  }", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a block; uses struct style." }], indent: 2, explanation: "Close the if." },
  { correct: "  counter++;", distractors: [{ "text": "counter = counter + 1;", reason: "Works but `++` is simpler and more idiomatic." }], indent: 2, explanation: "Increment the delay counter." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect closing syntax for a loop block." }], indent: 1, explanation: "Close the `while` loop." },
  { correct: "printf(\"...`volatile` register changed! Loop exited.\\n\");", distractors: [{ "text": "printf(\"Loop exited\\n\");", reason: "Lacks detail about why the loop exited." }], indent: 1, explanation: "Confirm that the loop has been successfully exited." },
  { correct: "// A compiler might optimize `while(non_volatile_var == 0)` into an infinite loop", distractors: [{ "text": "// Loop might not work", reason: "Unclear; doesn’t explain optimization risk." }], indent: 1, explanation: "Explain the potential problem without volatile." },
  { correct: "// because it sees that nothing inside the loop changes `non_volatile_var`.", distractors: [{ "text": "// because of the variable", reason: "Incomplete and vague; misses the optimization point." }], indent: 1, explanation: "Continue the explanation of the optimization." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "Returns error code; 0 indicates success." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a function." }], indent: 0, explanation: "Close the main function." }
]
  },

  // Level 41: Unions for Type Punning
  {
    goal: "Use a `union` to store a value as one type and access its memory representation through another type (type punning).",
    concepts: "union, memory representation, type punning, hexadecimal",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed here; `<stdio.h>` suffices for I/O." }], indent: 0, explanation: "Include for standard I/O." },
  { correct: "// A union allows storing different data types in the same memory location.", distractors: [{ "text": "// Union for multiple types", reason: "Less precise; doesn’t explain memory sharing." }], indent: 0, explanation: "Explanation of a union." },
  { correct: "typedef union {", distractors: [{ "text": "union {", reason: "Missing `typedef` means no type alias is created." }], indent: 0, explanation: "Begin defining a union with a typedef." },
  { correct: "  unsigned int int_val;", distractors: [{ "text": "int int_val;", reason: "Signed int might confuse byte interpretation due to sign extension." }], indent: 1, explanation: "A member to hold a 4-byte integer." },
  { correct: "  unsigned char bytes[4];", distractors: [{ "text": "char bytes[4];", reason: "Signed char could misrepresent byte values." }], indent: 1, explanation: "A member to access the same 4 bytes individually." },
  { correct: "} IntConverter;", distractors: [{ "text": "} int_converter;", reason: "Incorrect `typedef` syntax; defines a variable, not a type." }], indent: 0, explanation: "Create the alias `IntConverter` for the union." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Incorrect; `main` must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "IntConverter converter;", distractors: [{ "text": "IntConverter *converter;", reason: "Declares a pointer but doesn’t allocate memory." }], indent: 1, explanation: "Declare a variable of our union type." },
  { correct: "printf(\"Size of union: %zu bytes\\n\", sizeof(IntConverter));", distractors: [{ "text": "printf(\"Size: %zu\\n\", sizeof(unsigned int) + sizeof(unsigned char[4]));", reason: "Unions use the largest member’s size, not the sum." }], indent: 1, explanation: "Print the size of the union. It will be large enough for its largest member." },
  { correct: "// Assign a value to the integer member.", distractors: [{ "text": "// Set integer", reason: "Too vague; doesn’t specify the member." }], indent: 1, explanation: "Comment on assigning a value." },
  { correct: "converter.int_val = 0x1A2B3C4D; // A hexadecimal integer", distractors: [{ "text": "converter.bytes = {0x1A, 0x2B, 0x3C, 0x4D};", reason: "Cannot assign an array like this after declaration." }], indent: 1, explanation: "Store a hexadecimal value in the `int_val` member." },
  { correct: "printf(\"Stored integer value: 0x%X\\n\\n\", converter.int_val);", distractors: [{ "text": "printf(\"Value: %d\\n\", converter.int_val);", reason: "Prints decimal instead of hex, missing the point." }], indent: 1, explanation: "Print the integer value to confirm it was stored." },
  { correct: "// Now, access the *same memory* through the bytes array.", distractors: [{ "text": "// Access bytes", reason: "Lacks emphasis on shared memory." }], indent: 1, explanation: "Explain the type punning step." },
  { correct: "printf(\"Individual bytes (memory layout depends on endianness):\\n\");", distractors: [{ "text": "printf(\"Bytes:\\n\");", reason: "Misses endianness note, reducing clarity." }], indent: 1, explanation: "Note that the output order depends on system architecture (Little Endian vs. Big Endian)." },
  { correct: "for (int i = 0; i < 4; i++) {", distractors: [{ "text": "for (int i = 0; i <= 4; i++) {", reason: "Accesses beyond the array bounds (4 bytes)." }], indent: 1, explanation: "Loop through the 4 bytes of the union." },
  { correct: "printf(\"Byte %d: 0x%02X\\n\", i, converter.bytes[i]);", distractors: [{ "text": "printf(\"Byte %d: 0x%02X\\n\", i, converter.int_val[i]);", reason: "Cannot index an integer; must use the `bytes` member." }], indent: 2, explanation: "Print each byte's value in hexadecimal format." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a loop." }], indent: 1, explanation: "Close the loop." },
  { correct: "// Modify a single byte and see its effect on the integer.", distractors: [{ "text": "// Change byte", reason: "Doesn’t explain the effect on the union." }], indent: 1, explanation: "Demonstrate modifying memory through one member affects the other." },
  { correct: "printf(\"\\nModifying Byte 0 to 0xEE...\\n\");", distractors: [{ "text": "printf(\"Changing byte\\n\");", reason: "Less specific; misses what’s being changed." }], indent: 1, explanation: "Informational message." },
  { correct: "converter.bytes[0] = 0xEE;", distractors: [{ "text": "converter.int_val = 0xEE;", reason: "Overwrites the whole integer, not just one byte." }], indent: 1, explanation: "Change the value of the first byte in the array." },
  { correct: "printf(\"New integer value: 0x%X\\n\", converter.int_val);", distractors: [{ "text": "printf(\"Value: %d\\n\", converter.int_val);", reason: "Decimal format obscures the byte change." }], indent: 1, explanation: "Print the `int_val` again to see how it has changed." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "Incorrect; 0 indicates success." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Wrong syntax for function close." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 42: Advanced Preprocessor Macros
  {
    goal: "Create and use advanced preprocessor macros with arguments, demonstrating common pitfalls and the stringizing (#) operator.",
    concepts: "Preprocessor, macros, #define, macro arguments, operator precedence, stringizing operator (#)",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <string.h>", reason: "Not needed here; `<stdio.h>` covers I/O." }], indent: 0, explanation: "Include standard I/O." },
  { correct: "// A simple but FLAWED macro for squaring a number", distractors: [{ "text": "// Square macro", reason: "Doesn’t warn about the flaw." }], indent: 0, explanation: "Introduce a macro with a common flaw." },
  { correct: "#define FLAWED_SQUARE(x) x * x", distractors: [{ "text": "#define FLAWED_SQUARE(x) x^2", reason: "`^` is bitwise XOR, not exponentiation." }], indent: 0, explanation: "Define the flawed macro without parentheses." },
  { correct: "// A robust macro needs parentheses to handle operator precedence", distractors: [{ "text": "// Robust macro", reason: "Misses the precedence explanation." }], indent: 0, explanation: "Introduce the corrected version." },
  { correct: "#define SQUARE(x) ((x) * (x))", distractors: [{ "text": "#define SQUARE(x) (x*x)", reason: "Parentheses around the result but not arguments; fails with `SQUARE(2+3)`." }], indent: 0, explanation: "Define a robust macro with full parentheses for safety." },
  { correct: "// A macro using the stringizing operator (#) to print a variable's name and value", distractors: [{ "text": "// Print macro", reason: "Doesn’t mention stringizing operator." }], indent: 0, explanation: "Introduce the stringizing operator." },
  { correct: "#define PRINT_VAR(var) printf(#var \" = %d\\n\", var)", distractors: [{ "text": "#define PRINT_VAR(var) printf(\"var = %d\\n\", var)", reason: "Prints literal 'var' instead of the variable name." }], indent: 0, explanation: "Define a macro that turns its argument into a string literal." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "`main` must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "int a = 5;", distractors: [{ "text": "int a;", reason: "Uninitialized; undefined value when used." }], indent: 1, explanation: "Declare an integer variable." },
  { correct: "printf(\"Using robust SQUARE(5): %d\\n\", SQUARE(a));", distractors: [{ "text": "printf(\"Result: %d\\n\", SQUARE(5));", reason: "Uses literal but misses variable demo." }], indent: 1, explanation: "Demonstrate the correct macro." },
  { correct: "printf(\"Using robust SQUARE(2+3): %d\\n\", SQUARE(2+3));", distractors: [{ "text": "printf(\"SQUARE(5): %d\\n\", (2+3)*(2+3));", reason: "Manual expansion defeats the macro demo." }], indent: 1, explanation: "Show how the robust macro correctly handles expressions." },
  { correct: "printf(\"\\nNow, showing the FLAWED macro:\\n\");", distractors: [{ "text": "printf(\"Flawed macro:\\n\");", reason: "Less descriptive; misses transition context." }], indent: 1, explanation: "Header for the flawed example." },
  { correct: "printf(\"Using FLAWED_SQUARE(2+3): %d\\n\", FLAWED_SQUARE(2+3));", distractors: [{ "text": "printf(\"Result: %d\\n\", 2+3*2+3);", reason: "Hardcodes the wrong expansion, bypassing macro." }], indent: 1, explanation: "Demonstrate the flawed macro. It will expand to `2+3*2+3`, which equals 11, not 25." },
  { correct: "printf(\"  (Expands to 2 + 3 * 2 + 3, which is 11, not 25!)\\n\");", distractors: [{ "text": "printf(\"Wrong result\\n\");", reason: "Doesn’t explain why it’s wrong." }], indent: 1, explanation: "Explicitly explain the incorrect result." },
  { correct: "printf(\"\\nUsing the stringizing macro:\\n\");", distractors: [{ "text": "printf(\"Stringizing:\\n\");", reason: "Less clear; doesn’t specify macro." }], indent: 1, explanation: "Header for the stringizing example." },
  { correct: "int my_variable = 123;", distractors: [{ "text": "int my_variable;", reason: "Uninitialized; undefined when printed." }], indent: 1, explanation: "Declare a variable to be printed." },
  { correct: "PRINT_VAR(my_variable);", distractors: [{ "text": "printf(\"my_variable = %d\\n\", my_variable);", reason: "Correct output but bypasses the macro." }], indent: 1, explanation: "Call the PRINT_VAR macro. It will print 'my_variable = 123'." },
  { correct: "PRINT_VAR(a + my_variable);", distractors: [{ "text": "PRINT_VAR(\"a + my_variable\");", reason: "String literal prints as text, not an expression’s value." }], indent: 1, explanation: "Show that the macro can even stringize expressions." },
  { correct: "return 0;", distractors: [{ "text": "return;", reason: "Missing return value for `int main`." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for function close." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 43: `static` Variables and Functions
  {
    goal: "Understand the two main uses of the `static` keyword: creating variables with persistent storage and functions with internal linkage.",
    concepts: "`static` keyword, variable lifetime vs. scope, internal linkage",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is enough for I/O." }], indent: 0, explanation: "Include standard I/O." },
  { correct: "// A static function has internal linkage, meaning it is only visible within this file.", distractors: [{ "text": "// Static function", reason: "Doesn’t explain internal linkage." }], indent: 0, explanation: "Explain static functions." },
  { correct: "static void static_helper_function() {", distractors: [{ "text": "void static_helper_function() {", reason: "Without `static`, it has external linkage." }], indent: 0, explanation: "Define a `static` function." },
  { correct: "printf(\"  -> Inside the static helper function.\\n\");", distractors: [{ "text": "printf(\"Inside function\\n\");", reason: "Less specific; misses context." }], indent: 1, explanation: "Action of the static function." },
  { correct: "}", distractors: [{ "text": "};", reason: "Wrong syntax for function block." }], indent: 0, explanation: "Close the static function." },
  { correct: "// This function demonstrates a static local variable.", distractors: [{ "text": "// Static variable", reason: "Doesn’t specify it’s local or its purpose." }], indent: 0, explanation: "Explain static local variables." },
  { correct: "void counter_function() {", distractors: [{ "text": "int counter_function() {", reason: "Wrong return type; no value returned here." }], indent: 0, explanation: "Define a function that will use a static variable." },
  { correct: "static int call_count = 0;", distractors: [{ "text": "int call_count = 0;", reason: "Non-static resets each call, losing persistence." }], indent: 1, explanation: "Declare a `static` local variable. It is initialized only the first time the function is called." },
  { correct: "call_count++;", distractors: [{ "text": "call_count = 1;", reason: "Overwrites instead of incrementing." }], indent: 1, explanation: "Increment the counter." },
  { correct: "printf(\"This function has been called %d time(s).\\n\", call_count);", distractors: [{ "text": "printf(\"Called %d\\n\", call_count);", reason: "Less clear; misses plurality context." }], indent: 1, explanation: "Print the current value of the persistent counter." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect block closure." }], indent: 0, explanation: "Close the counter function." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "// --- Demonstrate static local variable ---", distractors: [{ "text": "// Static demo", reason: "Less descriptive; doesn’t specify what’s demonstrated." }], indent: 1, explanation: "Header for first demonstration." },
  { correct: "counter_function();", distractors: [{ "text": "counter_function;", reason: "Missing `()`; doesn’t call the function." }], indent: 1, explanation: "Call the function the first time. Output: 1." },
  { correct: "counter_function();", distractors: [{ "text": "counter_function(1);", reason: "Function takes no arguments; this won’t compile." }], indent: 1, explanation: "Call again. The `call_count` variable remembers its value. Output: 2." },
  { correct: "counter_function();", distractors: [{ "text": "call_count++;", reason: "Tries to access `call_count` directly, but it’s out of scope." }], indent: 1, explanation: "Call a third time. Output: 3." },
  { correct: "// `call_count` is not accessible here in main, its scope is the function.", distractors: [{ "text": "// Can’t use call_count", reason: "Doesn’t explain scope vs. lifetime." }], indent: 1, explanation: "Explain that lifetime and scope are different." },
  { correct: "// --- Demonstrate static function ---", distractors: [{ "text": "// Function demo", reason: "Misses the `static` focus." }], indent: 1, explanation: "Header for second demonstration." },
  { correct: "printf(\"\\nCalling the static helper function from main:\\n\");", distractors: [{ "text": "printf(\"Calling function:\\n\");", reason: "Doesn’t specify it’s static." }], indent: 1, explanation: "Informational message." },
  { correct: "static_helper_function();", distractors: [{ "text": "static_helper_function;", reason: "Missing `()`; doesn’t invoke the function." }], indent: 1, explanation: "Call the static function. This is allowed because we are in the same file where it was defined." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 44: Flexible Array Members
  {
    goal: "Define and use a struct with a flexible array member to create a variable-sized object.",
    concepts: "struct, flexible array member, dynamic memory allocation, sizeof",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <math.h>", reason: "Unrelated; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <stdlib.h>", distractors: [{ "text": "#include <stdio.h>", reason: "Already included; `<stdlib.h>` is for `malloc`." }], indent: 0, explanation: "Include for malloc/free." },
  { correct: "#include <string.h>", distractors: [{ "text": "#include <strings.h>", reason: "Wrong header; `<string.h>` is standard for `memcpy`." }], indent: 0, explanation: "Include for strcpy/memcpy." },
  { correct: "// A struct with a flexible array member must have at least one other member.", distractors: [{ "text": "// Flexible array struct", reason: "Doesn’t mention the requirement." }], indent: 0, explanation: "Rule for flexible array members." },
  { correct: "// The flexible array member must be the LAST member of the struct.", distractors: [{ "text": "// Last member", reason: "Misses why it’s required." }], indent: 0, explanation: "Another critical rule." },
  { correct: "typedef struct {", distractors: [{ "text": "struct {", reason: "Missing `typedef` means no alias is created." }], indent: 0, explanation: "Begin defining the struct." },
  { correct: "  size_t length;", distractors: [{ "text": "int length;", reason: "`int` might be too small for large sizes; `size_t` is preferred." }], indent: 1, explanation: "A member to store the length of the flexible data part." },
  { correct: "  char data[];", distractors: [{ "text": "char data[1];", reason: "Struct hack; less flexible than `[]`." }], indent: 1, explanation: "Declare the flexible array member. It has an incomplete type." },
  { correct: "} StringPacket;", distractors: [{ "text": "} string_packet;", reason: "Incorrect `typedef` syntax; defines a variable." }], indent: 0, explanation: "Create the `StringPacket` alias." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "const char* message = \"Hello Flexible Array!\";", distractors: [{ "text": "char message[] = \"Hello Flexible Array!\";", reason: "Works but isn’t a pointer; less flexible for this demo." }], indent: 1, explanation: "The string data we want to store." },
  { correct: "size_t message_len = strlen(message);", distractors: [{ "text": "int message_len = strlen(message);", reason: "`size_t` is safer for lengths; `int` might overflow." }], indent: 1, explanation: "Get the length of the string." },
  { correct: "// Allocate memory for the struct AND the flexible array data.", distractors: [{ "text": "// Allocate memory", reason: "Doesn’t specify the flexible array part." }], indent: 1, explanation: "Explain the special allocation." },
  { correct: "StringPacket *packet = malloc(sizeof(StringPacket) + message_len + 1);", distractors: [{ "text": "StringPacket *packet = malloc(sizeof(StringPacket));", reason: "Doesn’t allocate space for the flexible array." }], indent: 1, explanation: "Allocate space for the base struct PLUS the length of our message PLUS 1 for the null terminator." },
  { correct: "if (!packet) { return 1; } // Check for malloc failure", distractors: [{ "text": "if (packet == NULL) { exit(1); }", reason: "Works but `exit` skips cleanup; `return` is cleaner here." }], indent: 1, explanation: "Always check the result of malloc." },
  { correct: "// Now, initialize the packet", distractors: [{ "text": "// Initialize", reason: "Too vague; doesn’t specify what’s initialized." }], indent: 1, explanation: "Comment on initialization." },
  { correct: "packet->length = message_len;", distractors: [{ "text": "packet.length = message_len;", reason: "Incorrect syntax; `->` needed for pointers." }], indent: 1, explanation: "Store the length of the string in the `length` member." },
  { correct: "memcpy(packet->data, message, message_len + 1);", distractors: [{ "text": "strcpy(packet->data, message);", reason: "Works but `memcpy` is used here for demonstration." }], indent: 1, explanation: "Copy the message string into the `data` flexible array member." },
  { correct: "// Use the created packet", distractors: [{ "text": "// Use packet", reason: "Less informative; doesn’t specify creation." }], indent: 1, explanation: "Comment on using the data." },
  { correct: "printf(\"Packet created.\\n\");", distractors: [{ "text": "printf(\"Created\\n\");", reason: "Doesn’t specify what was created." }], indent: 1, explanation: "Confirmation message." },
  { correct: "printf(\"  Stored length: %zu\\n\", packet->length);", distractors: [{ "text": "printf(\"Length: %d\\n\", packet->length);", reason: "`%d` is for `int`; `size_t` needs `%zu`." }], indent: 1, explanation: "Print the stored length." },
  { correct: "printf(\"  Stored data: %s\\n\", packet->data);", distractors: [{ "text": "printf(\"Data: %s\\n\", packet);", reason: "Prints the struct pointer, not the data string." }], indent: 1, explanation: "Print the stored string." },
  { correct: "printf(\"  sizeof(*packet): %zu (shows size of base struct only!)\\n\", sizeof(*packet));", distractors: [{ "text": "printf(\"Size: %zu\\n\", sizeof(packet));", reason: "Size of pointer, not struct." }], indent: 1, explanation: "`sizeof` on a struct with a flexible array member does not include the flexible part's size." },
  { correct: "// Clean up", distractors: [{ "text": "// Free memory", reason: "Slightly less broad; ‘clean up’ covers more." }], indent: 1, explanation: "Comment on cleanup." },
  { correct: "free(packet);", distractors: [{ "text": "free(packet->data);", reason: "Flexible array is part of the struct; only one `free` needed." }], indent: 1, explanation: "A single `free` call releases all the memory for the struct and the flexible array." },
  { correct: "return 0;", distractors: [{ "text": "return;", reason: "Missing value for `int main`." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 45: Variable-Length Arrays (VLAs)
  {
    goal: "Create and use a Variable-Length Array (VLA), whose size is determined at runtime rather than compile time.",
    concepts: "Variable-Length Arrays (VLA), stack memory, runtime sizing, C99 standard",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; VLAs don’t use `malloc`." }], indent: 0, explanation: "Include standard I/O." },
  { correct: "void process_vla(int size, int vla[size]);", distractors: [{ "text": "void process_vla(int vla[]);", reason: "Missing size parameter; VLAs need it explicitly." }], indent: 0, explanation: "Prototype a function that can accept a VLA." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "int desired_size;", distractors: [{ "text": "int desired_size = 0;", reason: "Initialized to 0; user input would be ignored." }], indent: 1, explanation: "Declare a variable to hold the runtime size." },
  { correct: "printf(\"Enter the desired size for the array: \");", distractors: [{ "text": "printf(\"Size: \");", reason: "Less clear; doesn’t prompt for input." }], indent: 1, explanation: "Prompt the user for input." },
  { correct: "scanf(\"%d\", &desired_size);", distractors: [{ "text": "scanf(\"%d\", desired_size);", reason: "Missing `&`; needs address of variable." }], indent: 1, explanation: "Read the size from the user." },
  { correct: "if (desired_size <= 0) {", distractors: [{ "text": "if (desired_size < 0) {", reason: "Misses invalid case of 0 size." }], indent: 1, explanation: "Add a check for invalid input." },
  { correct: "printf(\"Size must be positive.\\n\");", distractors: [{ "text": "printf(\"Error\\n\");", reason: "Doesn’t explain the error." }], indent: 2, explanation: "Error message." },
  { correct: "return 1;", distractors: [{ "text": "exit(1);", reason: "Works but `return` is simpler in `main`." }], indent: 2, explanation: "Exit with an error code." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the validation block." },
  { correct: "// Declare a Variable-Length Array (VLA) on the stack", distractors: [{ "text": "// VLA", reason: "Doesn’t mention stack allocation." }], indent: 1, explanation: "Comment explaining the VLA declaration." },
  { correct: "int my_vla[desired_size];", distractors: [{ "text": "int *my_vla = malloc(desired_size * sizeof(int));", reason: "Uses heap, not stack; VLAs are simpler." }], indent: 1, explanation: "The array's size is not a compile-time constant, but the variable `desired_size`." },
  { correct: "printf(\"VLA of %d integers created on the stack.\\n\", desired_size);", distractors: [{ "text": "printf(\"Array created\\n\");", reason: "Doesn’t confirm VLA or size." }], indent: 1, explanation: "Confirmation message." },
  { correct: "// Note: VLAs were introduced in C99 but became an optional feature in C11.", distractors: [{ "text": "// VLAs in C", reason: "Lacks version history." }], indent: 1, explanation: "Important note about compiler support for VLAs." },
  { correct: "// Initialize the VLA", distractors: [{ "text": "// Set values", reason: "Less specific; doesn’t mention VLA." }], indent: 1, explanation: "Comment on initialization." },
  { correct: "for (int i = 0; i < desired_size; i++) {", distractors: [{ "text": "for (int i = 0; i <= desired_size; i++) {", reason: "Exceeds array bounds." }], indent: 1, explanation: "Loop up to the runtime size." },
  { correct: "my_vla[i] = i * 10;", distractors: [{ "text": "my_vla[i] = i;", reason: "Works but less illustrative." }], indent: 2, explanation: "Assign a value to each element." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the initialization loop." },
  { correct: "// Pass the VLA to a function", distractors: [{ "text": "// Use VLA", reason: "Doesn’t mention passing." }], indent: 1, explanation: "Comment on passing the VLA." },
  { correct: "process_vla(desired_size, my_vla);", distractors: [{ "text": "process_vla(my_vla);", reason: "Missing size parameter." }], indent: 1, explanation: "Call the function, passing the size and the array." },
  { correct: "// No need to `free()` a VLA, it is deallocated when it goes out of scope.", distractors: [{ "text": "// Free VLA", reason: "Misleading; VLAs don’t need `free`." }], indent: 1, explanation: "Key difference between stack (VLA) and heap (malloc) memory." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 is error; 0 is success." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main." },
  { correct: "void process_vla(int size, int vla[size]) {", distractors: [{ "text": "void process_vla(int size, int vla[]) {", reason: "Doesn’t specify VLA size." }], indent: 0, explanation: "Define the function that accepts the VLA." },
  { correct: "printf(\"Inside process_vla. Array contents:\\n\");", distractors: [{ "text": "printf(\"Contents:\\n\");", reason: "Doesn’t specify function context." }], indent: 1, explanation: "Header message." },
  { correct: "for (int i = 0; i < size; i++) {", distractors: [{ "text": "for (int i = 0; i <= size; i++) {", reason: "Exceeds bounds." }], indent: 1, explanation: "Loop through the passed VLA." },
  { correct: "printf(\"%d \", vla[i]);", distractors: [{ "text": "printf(\"%d\\n\", vla[i]);", reason: "Prints each on a new line; intended as a list." }], indent: 2, explanation: "Print each element." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the loop." },
  { correct: "printf(\"\\n\");", distractors: [{ "text": "printf(\"\");", reason: "Doesn’t add a newline." }], indent: 1, explanation: "Final newline." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close the function." }
]
  },

  // Level 46: `goto` for Centralized Cleanup
  {
    goal: "Demonstrate a legitimate use of `goto` for centralized error handling and resource cleanup.",
    concepts: "`goto`, labels, resource management, error handling",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <string.h>", reason: "Not needed; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <stdlib.h>", distractors: [{ "text": "#include <stdio.h>", reason: "Already included; `<stdlib.h>` is for `malloc`." }], indent: 0, explanation: "Include for malloc/free." },
  { correct: "// While `goto` is often discouraged, one of its accepted uses", distractors: [{ "text": "// Goto usage", reason: "Doesn’t explain its purpose." }], indent: 0, explanation: "Preface about goto usage." },
  { correct: "// is to handle cleanup in a function with multiple resources and exit points.", distractors: [{ "text": "// Cleanup", reason: "Misses context about resources and exits." }], indent: 0, explanation: "Continuing the explanation." },
  { correct: "void process_resources() {", distractors: [{ "text": "int process_resources() {", reason: "No return value needed here." }], indent: 0, explanation: "Define the function that will use goto." },
  { correct: "FILE *file1 = NULL;", distractors: [{ "text": "FILE file1;", reason: "Incorrect; `FILE` is a pointer type." }], indent: 1, explanation: "Declare a pointer for the first resource." },
  { correct: "char *buffer = NULL;", distractors: [{ "text": "char buffer[1024];", reason: "Static array doesn’t need freeing; we’re demoing dynamic allocation." }], indent: 1, explanation: "Declare a pointer for the second resource." },
  { correct: "int error_status = 0;", distractors: [{ "text": "int error_status;", reason: "Uninitialized; could be misleading." }], indent: 1, explanation: "A variable to hold the final status." },
  { correct: "printf(\"Attempting to allocate resources...\\n\");", distractors: [{ "text": "printf(\"Starting...\\n\");", reason: "Less specific; doesn’t mention resources." }], indent: 1, explanation: "Informational message." },
  { correct: "file1 = fopen(\"output.tmp\", \"w\");", distractors: [{ "text": "file1 = fopen(\"output.tmp\", \"r\");", reason: "Read mode doesn’t allow writing." }], indent: 1, explanation: "Attempt to allocate the first resource (open a file)." },
  { correct: "if (file1 == NULL) {", distractors: [{ "text": "if (!file1) {", reason: "Same but less explicit; `== NULL` is clearer." }], indent: 1, explanation: "Check if the first allocation failed." },
  { correct: "  perror(\"Failed to open file1\");", distractors: [{ "text": "printf(\"Error\\n\");", reason: "`perror` provides specific error info." }], indent: 2, explanation: "Print an error." },
  { correct: "  error_status = -1;", distractors: [{ "text": "error_status = 1;", reason: "Positive values typically mean success; -1 indicates error." }], indent: 2, explanation: "Set the error status." },
  { correct: "  goto cleanup;", distractors: [{ "text": "return;", reason: "Exits without cleanup." }], indent: 2, explanation: "Jump to the centralized cleanup block." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the first error check." },
  { correct: "printf(\"  -> File opened successfully.\\n\");", distractors: [{ "text": "printf(\"Success\\n\");", reason: "Less informative." }], indent: 1, explanation: "Success message for resource 1." },
  { correct: "buffer = malloc(1024);", distractors: [{ "text": "buffer = malloc(1024 * sizeof(char));", reason: "Redundant; `sizeof(char)` is 1." }], indent: 1, explanation: "Attempt to allocate the second resource (memory)." },
  { correct: "if (buffer == NULL) {", distractors: [{ "text": "if (buffer) {", reason: "Reverses logic; checks success instead of failure." }], indent: 1, explanation: "Check if the second allocation failed." },
  { correct: "  perror(\"Failed to allocate buffer\");", distractors: [{ "text": "printf(\"Malloc failed\\n\");", reason: "Doesn’t show system error." }], indent: 2, explanation: "Print an error." },
  { correct: "  error_status = -1;", distractors: [{ "text": "error_status = 0;", reason: "0 implies success, not failure." }], indent: 2, explanation: "Set the error status." },
  { correct: "  goto cleanup;", distractors: [{ "text": "return;", reason: "Skips cleanup." }], indent: 2, explanation: "Jump to the same cleanup block." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the second error check." },
  { correct: "printf(\"  -> Buffer allocated successfully.\\n\");", distractors: [{ "text": "printf(\"Buffer OK\\n\");", reason: "Less clear." }], indent: 1, explanation: "Success message for resource 2." },
  { correct: "printf(\"...All resources allocated. Performing work...\\n\");", distractors: [{ "text": "printf(\"Working...\\n\");", reason: "Doesn’t confirm allocation." }], indent: 1, explanation: "Simulate doing work with the resources." },
  { correct: "cleanup:", distractors: [{ "text": "label cleanup;", reason: "Incorrect label syntax." }], indent: 0, explanation: "Define the label. The `goto` statements will jump here." },
  { correct: "printf(\"\\n--- Reached cleanup block ---\\n\");", distractors: [{ "text": "printf(\"Cleanup\\n\");", reason: "Less distinctive." }], indent: 1, explanation: "Indicate that the cleanup code is running." },
  { correct: "if (buffer) {", distractors: [{ "text": "if (buffer != NULL) { free(buffer); }", reason: "Redundant; `if (buffer)` is sufficient." }], indent: 1, explanation: "Check if the buffer was allocated before trying to free it." },
  { correct: "  free(buffer);", distractors: [{ "text": "delete buffer;", reason: "C++ syntax, not C." }], indent: 2, explanation: "Free the buffer." },
  { correct: "  printf(\"  -> Buffer freed.\\n\");", distractors: [{ "text": "printf(\"Freed\\n\");", reason: "Doesn’t specify what was freed." }], indent: 2, explanation: "Confirmation." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close buffer check." },
  { correct: "if (file1) {", distractors: [{ "text": "if (file1 == 0) {", reason: "Reverses logic; checks if null instead of not null." }], indent: 1, explanation: "Check if the file was opened before trying to close it." },
  { correct: "  fclose(file1);", distractors: [{ "text": "close(file1);", reason: "Wrong function; `fclose` is for `FILE*`." }], indent: 2, explanation: "Close the file." },
  { correct: "  printf(\"  -> File closed.\\n\");", distractors: [{ "text": "printf(\"Closed\\n\");", reason: "Doesn’t specify what was closed." }], indent: 2, explanation: "Confirmation." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close file check." },
  { correct: "if (error_status != 0) { printf(\"Function finished with errors.\\n\"); }", distractors: [{ "text": "printf(\"Error status: %d\\n\", error_status);", reason: "Always prints; we only want error case." }], indent: 1, explanation: "Report final status." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close the function." },
  { correct: "int main() { process_resources(); return 0; }", distractors: [{ "text": "void main() { process_resources(); }", reason: "Must return `int` and value." }], indent: 0, explanation: "Main function to run the demo." }
]
  },

  // Level 47: Memory Alignment (`_Alignas`, `_Alignof`)
  {
    goal: "Understand and control memory alignment of structs using C11's `_Alignas` and `_Alignof` operators.",
    concepts: "Memory alignment, _Alignas, _Alignof, sizeof, C11 standard",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is enough." }], indent: 0, explanation: "Include for standard I/O." },
  { correct: "#include <stdalign.h>", distractors: [{ "text": "#include <align.h>", reason: "Wrong header; `<stdalign.h>` is standard." }], indent: 0, explanation: "Include for the more readable `alignas` and `alignof` macros." },
  { correct: "// --- A default-aligned struct ---", distractors: [{ "text": "// Default struct", reason: "Doesn’t mention alignment." }], indent: 0, explanation: "Comment for the first struct." },
  { correct: "struct DefaultAligned {", distractors: [{ "text": "typedef struct DefaultAligned {", reason: "Unnecessary `typedef` here; just defining a struct." }], indent: 0, explanation: "Begin definition of a normal struct." },
  { correct: "  char a;", distractors: [{ "text": "int a;", reason: "Changes alignment; we want minimal size first." }], indent: 1, explanation: "A 1-byte char." },
  { correct: "  int b;", distractors: [{ "text": "short b;", reason: "Alters padding demo; `int` is typically 4 bytes." }], indent: 1, explanation: "A 4-byte int." },
  { correct: "  char c;", distractors: [{ "text": "char *c;", reason: "Pointer changes size and alignment needs." }], indent: 1, explanation: "Another 1-byte char." },
  { correct: "};", distractors: [{ "text": "}", reason: "Missing semicolon; struct definition needs it." }], indent: 0, explanation: "Close the struct. The compiler will add padding for default alignment." },
  { correct: "// --- A struct with specific alignment ---", distractors: [{ "text": "// Aligned struct", reason: "Doesn’t specify it’s specific alignment." }], indent: 0, explanation: "Comment for the specially-aligned struct." },
  { correct: "// Use `alignas` (from <stdalign.h>) which is a macro for `_Alignas`", distractors: [{ "text": "// Use alignas", reason: "Misses header and macro info." }], indent: 0, explanation: "Explain the `alignas` macro." },
  { correct: "struct alignas(16) CustomAligned {", distractors: [{ "text": "struct CustomAligned alignas(16) {", reason: "Incorrect syntax; `alignas` precedes `struct`." }], indent: 0, explanation: "Define a struct and force it to be aligned on a 16-byte boundary." },
  { correct: "  char a;", distractors: [{ "text": "int a;", reason: "Changes size and padding demo." }], indent: 1, explanation: "A 1-byte char." },
  { correct: "  int b;", distractors: [{ "text": "short b;", reason: "Alters intended alignment effect." }], indent: 1, explanation: "A 4-byte int." },
  { correct: "  char c;", distractors: [{ "text": "char *c;", reason: "Pointer changes alignment needs." }], indent: 1, explanation: "Another 1-byte char." },
  { correct: "};", distractors: [{ "text": "}", reason: "Missing semicolon." }], indent: 0, explanation: "Close the struct." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "printf(\"--- Default Aligned Struct ---\\n\");", distractors: [{ "text": "printf(\"Default:\\n\");", reason: "Less descriptive." }], indent: 1, explanation: "Header for the first analysis." },
  { correct: "// `alignof` (macro for `_Alignof`) gets the alignment requirement of a type.", distractors: [{ "text": "// alignof", reason: "Doesn’t explain its purpose or origin." }], indent: 1, explanation: "Explain the `alignof` macro." },
  { correct: "printf(\"Required alignment: %zu\\n\", alignof(struct DefaultAligned));", distractors: [{ "text": "printf(\"Alignment: %d\\n\", alignof(struct DefaultAligned));", reason: "`%d` is wrong for `size_t`; use `%zu`." }], indent: 1, explanation: "Print the default alignment requirement (usually that of the largest member, e.g., 4 for `int`)." },
  { correct: "printf(\"Size with padding:  %zu\\n\", sizeof(struct DefaultAligned));", distractors: [{ "text": "printf(\"Size: %zu\\n\", sizeof(char) + sizeof(int) + sizeof(char));", reason: "Ignores padding." }], indent: 1, explanation: "Print the size, which will include padding bytes to meet alignment rules (e.g., 12 bytes)." },
  { correct: "printf(\"\\n--- Custom Aligned Struct ---\\n\");", distractors: [{ "text": "printf(\"Custom:\\n\");", reason: "Misses alignment context." }], indent: 1, explanation: "Header for the second analysis." },
  { correct: "printf(\"Required alignment: %zu\\n\", alignof(struct CustomAligned));", distractors: [{ "text": "printf(\"Alignment: %d\\n\", alignof(struct CustomAligned));", reason: "Wrong format specifier." }], indent: 1, explanation: "Print the required alignment, which we forced to be 16." },
  { correct: "printf(\"Size with padding:  %zu\\n\", sizeof(struct CustomAligned));", distractors: [{ "text": "printf(\"Size: %zu\\n\", 1+4+1);", reason: "Sum ignores alignment padding." }], indent: 1, explanation: "Print the size, which will now be a multiple of 16 (e.g., 16 bytes)." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 is error; 0 is success." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 48: Introduction to Atomics
  {
    goal: "Use C11 atomic types and operations from `<stdatomic.h>` to perform thread-safe modifications to a variable.",
    concepts: "Atomics, stdatomic.h, atomic_int, atomic_store, atomic_load, atomic_fetch_add, thread safety (conceptual)",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` covers I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <stdatomic.h>", distractors: [{ "text": "#include <atomic.h>", reason: "Wrong header; `<stdatomic.h>` is C11 standard." }], indent: 0, explanation: "Include the C11 standard header for atomic operations." },
  { correct: "// Atomics are used for lock-free programming, often in multi-threaded code.", distractors: [{ "text": "// Atomics", reason: "Doesn’t explain usage." }], indent: 0, explanation: "Explain the primary use case for atomics." },
  { correct: "// Operations like `i++` are not atomic. They are a read-modify-write sequence.", distractors: [{ "text": "// i++ isn’t safe", reason: "Misses why it’s unsafe." }], indent: 0, explanation: "Explain why `++` isn't thread-safe." },
  { correct: "// An atomic operation is guaranteed to execute completely without interruption.", distractors: [{ "text": "// Atomic ops", reason: "Lacks detail on atomicity." }], indent: 0, explanation: "Define an atomic operation." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "// Declare an atomic integer variable.", distractors: [{ "text": "// Atomic variable", reason: "Doesn’t specify type." }], indent: 1, explanation: "Comment on declaration." },
  { correct: "atomic_int shared_counter;", distractors: [{ "text": "int shared_counter;", reason: "Not atomic; not thread-safe." }], indent: 1, explanation: "Use `atomic_int` to declare an integer that can be safely manipulated by multiple threads." },
  { correct: "// 1. Initialize the atomic variable using atomic_store.", distractors: [{ "text": "// Set atomic", reason: "Less precise; misses method." }], indent: 1, explanation: "Explain atomic initialization." },
  { correct: "atomic_store(&shared_counter, 0);", distractors: [{ "text": "shared_counter = 0;", reason: "Not guaranteed atomic." }], indent: 1, explanation: "Safely store the initial value of 0 into the atomic variable." },
  { correct: "printf(\"Initial value (read with atomic_load): %d\\n\", atomic_load(&shared_counter));", distractors: [{ "text": "printf(\"Value: %d\\n\", shared_counter);", reason: "Direct access isn’t atomic." }], indent: 1, explanation: "Safely read the current value using `atomic_load`." },
  { correct: "// 2. Atomically add a value and get the *old* value back.", distractors: [{ "text": "// Add value", reason: "Doesn’t mention atomicity or return value." }], indent: 1, explanation: "Explain atomic fetch-and-add." },
  { correct: "int old_value = atomic_fetch_add(&shared_counter, 10);", distractors: [{ "text": "int old_value = shared_counter += 10;", reason: "Not atomic." }], indent: 1, explanation: "Atomically add 10 to the counter and return the value the counter held *before* the addition." },
  { correct: "printf(\"Called atomic_fetch_add(10). Old value was: %d\\n\", old_value);", distractors: [{ "text": "printf(\"Old: %d\\n\", old_value);", reason: "Less descriptive." }], indent: 1, explanation: "Print the returned old value." },
  { correct: "int new_value = atomic_load(&shared_counter);", distractors: [{ "text": "int new_value = shared_counter;", reason: "Non-atomic read." }], indent: 1, explanation: "Safely load the new, current value." },
  { correct: "printf(\"Current value is now: %d\\n\", new_value);", distractors: [{ "text": "printf(\"New: %d\\n\", new_value);", reason: "Less clear." }], indent: 1, explanation: "Print the new value to show the result of the addition." },
  { correct: "// 3. Atomically subtract a value.", distractors: [{ "text": "// Subtract", reason: "Misses atomicity." }], indent: 1, explanation: "Explain atomic subtraction." },
  { correct: "atomic_fetch_sub(&shared_counter, 3);", distractors: [{ "text": "shared_counter -= 3;", reason: "Not atomic." }], indent: 1, explanation: "Atomically subtract 3 from the counter." },
  { correct: "printf(\"Called atomic_fetch_sub(3). Current value is: %d\\n\", atomic_load(&shared_counter));", distractors: [{ "text": "printf(\"Value: %d\\n\", shared_counter);", reason: "Non-atomic read." }], indent: 1, explanation: "Load and print the final value." },
  { correct: "// Other atomic operations include exchange, compare-and-swap, and bitwise ops.", distractors: [{ "text": "// More atomics", reason: "Doesn’t list examples." }], indent: 1, explanation: "Mention other available atomic functions." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 is error." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main function." }
]
  },
  // Level 49: Non-Local Jumps with setjmp/longjmp
  {
    goal: "Implement an exception-like error recovery mechanism using `setjmp` to save an execution context and `longjmp` to return to it from a nested function.",
    concepts: "`setjmp`, `longjmp`, `<setjmp.h>`, non-local gotos, stack unwinding",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is sufficient." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <setjmp.h>", distractors: [{ "text": "#include <jmp.h>", reason: "Wrong header; `<setjmp.h>` is correct." }], indent: 0, explanation: "Include the header for non-local jump functionality." },
  { correct: "// `jmp_buf` is a type that holds the information needed to restore a calling environment.", distractors: [{ "text": "// jmp_buf", reason: "Doesn’t explain its purpose." }], indent: 0, explanation: "Explain the jmp_buf type." },
  { correct: "jmp_buf error_handler_buffer;", distractors: [{ "text": "jmp_buf *error_handler_buffer;", reason: "`jmp_buf` is an array type, not a pointer." }], indent: 0, explanation: "Declare a global jump buffer to store the program's state." },
  { correct: "void function_c(int should_error) {", distractors: [{ "text": "int function_c(int should_error) {", reason: "No return value needed." }], indent: 0, explanation: "Define a deeply nested function that might 'throw' an error." },
  { correct: "printf(\"  -> Entered function_c.\\n\");", distractors: [{ "text": "printf(\"Entered\\n\");", reason: "Less specific." }], indent: 1, explanation: "Trace message." },
  { correct: "if (should_error) {", distractors: [{ "text": "if (should_error == 1) {", reason: "Redundant; any non-zero value is true." }], indent: 2, explanation: "Check if we need to trigger the error." },
  { correct: "printf(\"  !! Error in function_c! Jumping back to main...\\n\");", distractors: [{ "text": "printf(\"Error\\n\");", reason: "Doesn’t indicate action." }], indent: 3, explanation: "Error message." },
  { correct: "longjmp(error_handler_buffer, 404);", distractors: [{ "text": "setjmp(error_handler_buffer);", reason: "`setjmp` saves; `longjmp` jumps." }], indent: 3, explanation: "Jump back to where `setjmp` was called, making it return the value 404." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 2, explanation: "Close the error check." },
  { correct: "printf(\"  -> Exited function_c normally.\\n\");", distractors: [{ "text": "printf(\"Exited\\n\");", reason: "Less clear." }], indent: 1, explanation: "Trace message for the non-error path." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close function_c." },
  { correct: "void function_b() { printf(\" -> Entered function_b.\\n\"); function_c(1); printf(\" -> Exited function_b normally.\\n\"); }", distractors: [{ "text": "void function_b() { function_c(1); }", reason: "Misses tracing for clarity." }], indent: 0, explanation: "An intermediate function in the call stack." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start the main function." },
  { correct: "// `setjmp` returns 0 on its initial call.", distractors: [{ "text": "// setjmp", reason: "Doesn’t explain behavior." }], indent: 1, explanation: "Explain `setjmp`'s return value." },
  { correct: "// If `longjmp` is called, `setjmp` returns the value passed to `longjmp`.", distractors: [{ "text": "// longjmp changes setjmp", reason: "Vague; misses return value detail." }], indent: 1, explanation: "Explain how `longjmp` affects `setjmp`." },
  { correct: "int return_code = setjmp(error_handler_buffer);", distractors: [{ "text": "int return_code = longjmp(error_handler_buffer, 0);", reason: "`longjmp` jumps, doesn’t set." }], indent: 1, explanation: "Set the recovery point. On the first run, it returns 0." },
  { correct: "if (return_code == 0) {", distractors: [{ "text": "if (!return_code) {", reason: "Same but less explicit." }], indent: 1, explanation: "This block acts as the 'try' block, executing on the initial run." },
  { correct: "printf(\"Initial call to setjmp returned 0. Running main logic...\\n\");", distractors: [{ "text": "printf(\"Starting...\\n\");", reason: "Misses `setjmp` context." }], indent: 2, explanation: "Trace message." },
  { correct: "function_b();", distractors: [{ "text": "function_c(1);", reason: "Bypasses call stack demo." }], indent: 2, explanation: "Call the function that will eventually trigger the error." },
  { correct: "printf(\"Main logic finished without errors.\\n\");", distractors: [{ "text": "printf(\"Done\\n\");", reason: "Less informative." }], indent: 2, explanation: "This line will be skipped due to the `longjmp`." },
  { correct: "} else {", distractors: [{ "text": "} if (return_code) {", reason: "Incorrect structure; `else` is needed." }], indent: 1, explanation: "This block acts as the 'catch' block. It runs when `longjmp` is called." },
  { correct: "printf(\"longjmp was called! setjmp returned %d.\\n\", return_code);", distractors: [{ "text": "printf(\"Error: %d\\n\", return_code);", reason: "Less specific about `longjmp`." }], indent: 2, explanation: "Handle the 'error' and print the code passed by `longjmp`." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the if/else block." },
  { correct: "printf(\"Program finished.\\n\");", distractors: [{ "text": "printf(\"End\\n\");", reason: "Less clear." }], indent: 1, explanation: "This line runs regardless of the path taken." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 is error." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 50: The `restrict` Keyword
  {
    goal: "Understand how the `restrict` keyword informs the compiler that pointers do not alias, allowing for better optimization.",
    concepts: "`restrict` keyword, pointer aliasing, compiler optimization",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is sufficient." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <setjmp.h>", distractors: [{ "text": "#include <jmp.h>", reason: "Wrong header; `<setjmp.h>` is correct." }], indent: 0, explanation: "Include the header for non-local jump functionality." },
  { correct: "// `jmp_buf` is a type that holds the information needed to restore a calling environment.", distractors: [{ "text": "// jmp_buf", reason: "Doesn’t explain its purpose." }], indent: 0, explanation: "Explain the jmp_buf type." },
  { correct: "jmp_buf error_handler_buffer;", distractors: [{ "text": "jmp_buf *error_handler_buffer;", reason: "`jmp_buf` is an array type, not a pointer." }], indent: 0, explanation: "Declare a global jump buffer to store the program's state." },
  { correct: "void function_c(int should_error) {", distractors: [{ "text": "int function_c(int should_error) {", reason: "No return value needed." }], indent: 0, explanation: "Define a deeply nested function that might 'throw' an error." },
  { correct: "printf(\"  -> Entered function_c.\\n\");", distractors: [{ "text": "printf(\"Entered\\n\");", reason: "Less specific." }], indent: 1, explanation: "Trace message." },
  { correct: "if (should_error) {", distractors: [{ "text": "if (should_error == 1) {", reason: "Redundant; any non-zero value is true." }], indent: 2, explanation: "Check if we need to trigger the error." },
  { correct: "printf(\"  !! Error in function_c! Jumping back to main...\\n\");", distractors: [{ "text": "printf(\"Error\\n\");", reason: "Doesn’t indicate action." }], indent: 3, explanation: "Error message." },
  { correct: "longjmp(error_handler_buffer, 404);", distractors: [{ "text": "setjmp(error_handler_buffer);", reason: "`setjmp` saves; `longjmp` jumps." }], indent: 3, explanation: "Jump back to where `setjmp` was called, making it return the value 404." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 2, explanation: "Close the error check." },
  { correct: "printf(\"  -> Exited function_c normally.\\n\");", distractors: [{ "text": "printf(\"Exited\\n\");", reason: "Less clear." }], indent: 1, explanation: "Trace message for the non-error path." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close function_c." },
  { correct: "void function_b() { printf(\" -> Entered function_b.\\n\"); function_c(1); printf(\" -> Exited function_b normally.\\n\"); }", distractors: [{ "text": "void function_b() { function_c(1); }", reason: "Misses tracing for clarity." }], indent: 0, explanation: "An intermediate function in the call stack." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start the main function." },
  { correct: "// `setjmp` returns 0 on its initial call.", distractors: [{ "text": "// setjmp", reason: "Doesn’t explain behavior." }], indent: 1, explanation: "Explain `setjmp`'s return value." },
  { correct: "// If `longjmp` is called, `setjmp` returns the value passed to `longjmp`.", distractors: [{ "text": "// longjmp changes setjmp", reason: "Vague; misses return value detail." }], indent: 1, explanation: "Explain how `longjmp` affects `setjmp`." },
  { correct: "int return_code = setjmp(error_handler_buffer);", distractors: [{ "text": "int return_code = longjmp(error_handler_buffer, 0);", reason: "`longjmp` jumps, doesn’t set." }], indent: 1, explanation: "Set the recovery point. On the first run, it returns 0." },
  { correct: "if (return_code == 0) {", distractors: [{ "text": "if (!return_code) {", reason: "Same but less explicit." }], indent: 1, explanation: "This block acts as the 'try' block, executing on the initial run." },
  { correct: "printf(\"Initial call to setjmp returned 0. Running main logic...\\n\");", distractors: [{ "text": "printf(\"Starting...\\n\");", reason: "Misses `setjmp` context." }], indent: 2, explanation: "Trace message." },
  { correct: "function_b();", distractors: [{ "text": "function_c(1);", reason: "Bypasses call stack demo." }], indent: 2, explanation: "Call the function that will eventually trigger the error." },
  { correct: "printf(\"Main logic finished without errors.\\n\");", distractors: [{ "text": "printf(\"Done\\n\");", reason: "Less informative." }], indent: 2, explanation: "This line will be skipped due to the `longjmp`." },
  { correct: "} else {", distractors: [{ "text": "} if (return_code) {", reason: "Incorrect structure; `else` is needed." }], indent: 1, explanation: "This block acts as the 'catch' block. It runs when `longjmp` is called." },
  { correct: "printf(\"longjmp was called! setjmp returned %d.\\n\", return_code);", distractors: [{ "text": "printf(\"Error: %d\\n\", return_code);", reason: "Less specific about `longjmp`." }], indent: 2, explanation: "Handle the 'error' and print the code passed by `longjmp`." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close the if/else block." },
  { correct: "printf(\"Program finished.\\n\");", distractors: [{ "text": "printf(\"End\\n\");", reason: "Less clear." }], indent: 1, explanation: "This line runs regardless of the path taken." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 is error." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 51: Generic Selection with _Generic
  {
    goal: "Use C11's `_Generic` keyword to create a macro that calls a different function based on the type of its argument.",
    concepts: "`_Generic` keyword, type-based selection, macros, C11 standard",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is enough." }], indent: 0, explanation: "Include for I/O functions." },
  { correct: "// Define functions for handling specific types", distractors: [{ "text": "// Functions", reason: "Doesn’t specify purpose." }], indent: 0, explanation: "Comment on helper functions." },
  { correct: "void print_int(int i) { printf(\"INT: %d\\n\", i); }", distractors: [{ "text": "int print_int(int i) { printf(\"INT: %d\\n\", i); }", reason: "No return value needed." }], indent: 0, explanation: "A function that handles integers." },
  { correct: "void print_double(double d) { printf(\"DOUBLE: %f\\n\", d); }", distractors: [{ "text": "void print_double(float d) { printf(\"FLOAT: %f\\n\", d); }", reason: "Float promotes to double in `_Generic`." }], indent: 0, explanation: "A function that handles doubles." },
  { correct: "void print_string(char* s) { printf(\"STRING: \\\"%s\\\"\\n\", s); }", distractors: [{ "text": "void print_string(char s) { printf(\"CHAR: %c\\n\", s); }", reason: "Handles char, not string." }], indent: 0, explanation: "A function that handles character strings." },
  { correct: "// `_Generic` is a compile-time construct that selects an expression", distractors: [{ "text": "// _Generic", reason: "No explanation." }], indent: 0, explanation: "Explain `_Generic`." },
  { correct: "// based on the type of its controlling expression.", distractors: [{ "text": "// Type selection", reason: "Misses compile-time detail." }], indent: 0, explanation: "Continue explanation." },
  { correct: "#define print(X) _Generic((X), \\", distractors: [{ "text": "#define print(X) _Generic(X, \\", reason: "Missing parentheses; type evaluation needs them." }], indent: 0, explanation: "Start defining the macro. The `\\` allows continuing on the next line." },
  { correct: "    int: print_int, \\", distractors: [{ "text": "\"int\": print_int, \\", reason: "Types aren’t strings in `_Generic`." }], indent: 1, explanation: "If `X` is `int`, select `print_int`." },
  { correct: "    double: print_double, \\", distractors: [{ "text": "float: print_double, \\", reason: "Float promotes to double; use `double`." }], indent: 1, explanation: "If `X` is `double`, select `print_double`." },
  { correct: "    char*: print_string, \\", distractors: [{ "text": "char[]: print_string, \\", reason: "Arrays decay to pointers; `char*` is correct." }], indent: 1, explanation: "If `X` is `char*`, select `print_string`." },
  { correct: "    default: print_int \\", distractors: [{ "text": "default: printf, \\", reason: "`printf` isn’t type-specific like the others." }], indent: 1, explanation: "A default case is required if the type might not match any other case." },
  { correct: ")(X)", distractors: [{ "text": "(X);", reason: "Semicolon inside macro is incorrect." }], indent: 0, explanation: "Call the selected function pointer with `(X)`." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "int my_int = 123;", distractors: [{ "text": "int my_int;", reason: "Uninitialized." }], indent: 1, explanation: "Declare an integer." },
  { correct: "double my_double = 3.14;", distractors: [{ "text": "float my_double = 3.14;", reason: "Promotes to double in `_Generic`." }], indent: 1, explanation: "Declare a double." },
  { correct: "char* my_string = \"Hello C11!\";", distractors: [{ "text": "char my_string = 'H';", reason: "Single char, not string." }], indent: 1, explanation: "Declare a string." },
  { correct: "printf(\"Calling generic print() macro...\\n\");", distractors: [{ "text": "printf(\"Starting...\\n\");", reason: "Doesn’t mention macro." }], indent: 1, explanation: "Informational message." },
  { correct: "print(my_int);", distractors: [{ "text": "print_int(my_int);", reason: "Bypasses `_Generic` demo." }], indent: 1, explanation: "`_Generic` selects `print_int`." },
  { correct: "print(my_double);", distractors: [{ "text": "print_double(my_double);", reason: "Misses macro usage." }], indent: 1, explanation: "`_Generic` selects `print_double`." },
  { correct: "print(my_string);", distractors: [{ "text": "print_string(my_string);", reason: "Direct call defeats purpose." }], indent: 1, explanation: "`_Generic` selects `print_string`." },
  { correct: "print(5.5f); // A float is promoted to double and matches", distractors: [{ "text": "print(5);", reason: "Less illustrative; uses int." }], indent: 1, explanation: "Show type promotion with generic selection." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 is error." }], indent: 1, explanation: "Indicate success." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 52: Signal Handling
  {
    goal: "Catch the `SIGINT` signal (generated by Ctrl+C) and execute a custom handler function instead of terminating immediately.",
    concepts: "Signal handling, `<signal.h>`, `signal()`, `SIGINT`, signal handlers",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "`<stdlib.h>` is included later for `exit`; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <signal.h>", distractors: [{ "text": "#include <sig.h>", reason: "Incorrect header; the standard header is `<signal.h>`." }], indent: 0, explanation: "Include the header for signal handling functions." },
  { correct: "#include <stdlib.h>", distractors: [{ "text": "#include <stdio.h>", reason: "Already included; `<stdlib.h>` is for `exit()`." }], indent: 0, explanation: "Include for `exit()`." },
  { correct: "// A signal handler is a function that is called when a signal is received.", distractors: [{ "text": "// Signal handler", reason: "Lacks explanation of its purpose." }], indent: 0, explanation: "Explain what a signal handler is." },
  { correct: "// It must take an integer (the signal number) as an argument.", distractors: [{ "text": "// Takes an integer", reason: "Does not specify that the integer is the signal number." }], indent: 0, explanation: "Explain the required function signature." },
  { correct: "void handle_sigint(int sig_num) {", distractors: [{ "text": "void handle_sigint() {", reason: "Signal handlers must take an integer parameter for the signal number." }], indent: 0, explanation: "Define our custom signal handler." },
  { correct: "// Note: Only async-safe functions are strictly allowed in a handler.", distractors: [{ "text": "// Any function can be used in a handler.", reason: "Incorrect; only async-safe functions are safe to use in signal handlers." }], indent: 1, explanation: "Important note on signal safety." },
  { correct: "// `printf` is used here for demonstration but isn’t officially safe.", distractors: [{ "text": "// `printf` is safe to use in signal handlers.", reason: "Incorrect; `printf` is not async-safe and should be avoided in signal handlers." }], indent: 1, explanation: "Clarify `printf` usage." },
  { correct: "printf(\"\\nCaught signal %d (SIGINT). Exiting gracefully.\\n\", sig_num);", distractors: [{ "text": "printf(\"Caught signal\\n\");", reason: "Does not provide the signal number or specify the signal type." }], indent: 1, explanation: "Print a message inside the handler." },
  { correct: "exit(0);", distractors: [{ "text": "return;", reason: "Signal handlers should not return; use `exit` to terminate the program." }], indent: 1, explanation: "Perform a graceful exit." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax; function blocks use `}` not `};`." }], indent: 0, explanation: "Close the handler function." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "C standard requires `int main()` for proper return type." }], indent: 0, explanation: "Start main function." },
  { correct: "// The `signal()` function registers a handler for a specific signal.", distractors: [{ "text": "// `signal()` is used to handle signals.", reason: "Too vague; does not explain that it registers a handler." }], indent: 1, explanation: "Explain `signal`." },
  { correct: "signal(SIGINT, handle_sigint);", distractors: [{ "text": "signal(SIGINT, handle_sigint());", reason: "Calls the function immediately instead of registering it." }, { "text": "handle_sigint(SIGINT);", reason: "Directly calls the handler instead of registering it with `signal()`." }], indent: 1, explanation: "Register `handle_sigint` for `SIGINT`." },
  { correct: "printf(\"Signal handler registered for SIGINT (Ctrl+C).\\n\");", distractors: [{ "text": "printf(\"Handler set\\n\");", reason: "Less informative; does not specify the signal or key combination." }], indent: 1, explanation: "Confirmation message." },
  { correct: "printf(\"Program is now in an infinite loop. Press Ctrl+C to exit.\\n\");", distractors: [{ "text": "printf(\"Running...\\n\");", reason: "Does not instruct the user on how to exit the program." }], indent: 1, explanation: "Instruct the user how to trigger the signal." },
  { correct: "int counter = 0;", distractors: [{ "text": "volatile int counter = 0;", reason: "Not necessary here; the loop is for demonstration, not for signal handling." }], indent: 1, explanation: "A counter for the loop." },
  { correct: "while (1) {", distractors: [{ "text": "while (counter < 100) {", reason: "Finite loop; the point is to have an infinite loop interrupted by the signal." }], indent: 1, explanation: "Start an infinite loop." },
  { correct: "printf(\"...running loop, iteration %d\\r\", counter++);", distractors: [{ "text": "printf(\"Running...\\n\");", reason: "Does not show progress or use carriage return for overwriting." }], indent: 2, explanation: "Show progress; `\\r` returns cursor to start." },
  { correct: "fflush(stdout);", distractors: [{ "text": "fflush(stdin);", reason: "Flushes input buffer, which is not needed here." }], indent: 2, explanation: "Flush output so it appears immediately." },
  { correct: "for (long i = 0; i < 50000000; i++); // Artificial delay", distractors: [{ "text": "sleep(1);", reason: "Requires `<unistd.h>`, which is not included, and is less portable." }], indent: 2, explanation: "A simple busy-wait delay." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a loop." }], indent: 1, explanation: "Close the loop." },
  { correct: "// Code beyond this point is unreachable because the handler exits.", distractors: [{ "text": "// Handler might return.", reason: "Incorrect; the handler uses `exit` and does not return." }], indent: 1, explanation: "Comment on flow." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success, but this line is unreachable." }], indent: 1, explanation: "Will never be executed." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a function." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 53: Opaque Pointers for Encapsulation
  {
    goal: "Create an abstract data type with a hidden implementation using an opaque pointer (incomplete type).",
    concepts: "Opaque pointers, incomplete types, encapsulation, information hiding, API design",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "`<stdlib.h>` is included later for `exit`; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <signal.h>", distractors: [{ "text": "#include <sig.h>", reason: "Incorrect header; the standard header is `<signal.h>`." }], indent: 0, explanation: "Include the header for signal handling functions." },
  { correct: "#include <stdlib.h>", distractors: [{ "text": "#include <stdio.h>", reason: "Already included; `<stdlib.h>` is for `exit()`." }], indent: 0, explanation: "Include for `exit()`." },
  { correct: "// A signal handler is a function that is called when a signal is received.", distractors: [{ "text": "// Signal handler", reason: "Lacks explanation of its purpose." }], indent: 0, explanation: "Explain what a signal handler is." },
  { correct: "// It must take an integer (the signal number) as an argument.", distractors: [{ "text": "// Takes an integer", reason: "Does not specify that the integer is the signal number." }], indent: 0, explanation: "Explain the required function signature." },
  { correct: "void handle_sigint(int sig_num) {", distractors: [{ "text": "void handle_sigint() {", reason: "Signal handlers must take an integer parameter for the signal number." }], indent: 0, explanation: "Define our custom signal handler." },
  { correct: "// Note: Only async-safe functions are strictly allowed in a handler.", distractors: [{ "text": "// Any function can be used in a handler.", reason: "Incorrect; only async-safe functions are safe to use in signal handlers." }], indent: 1, explanation: "Important note on signal safety." },
  { correct: "// `printf` is used here for demonstration but isn’t officially safe.", distractors: [{ "text": "// `printf` is safe to use in signal handlers.", reason: "Incorrect; `printf` is not async-safe and should be avoided in signal handlers." }], indent: 1, explanation: "Clarify `printf` usage." },
  { correct: "printf(\"\\nCaught signal %d (SIGINT). Exiting gracefully.\\n\", sig_num);", distractors: [{ "text": "printf(\"Caught signal\\n\");", reason: "Does not provide the signal number or specify the signal type." }], indent: 1, explanation: "Print a message inside the handler." },
  { correct: "exit(0);", distractors: [{ "text": "return;", reason: "Signal handlers should not return; use `exit` to terminate the program." }], indent: 1, explanation: "Perform a graceful exit." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax; function blocks use `}` not `};`." }], indent: 0, explanation: "Close the handler function." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "C standard requires `int main()` for proper return type." }], indent: 0, explanation: "Start main function." },
  { correct: "// The `signal()` function registers a handler for a specific signal.", distractors: [{ "text": "// `signal()` is used to handle signals.", reason: "Too vague; does not explain that it registers a handler." }], indent: 1, explanation: "Explain `signal`." },
  { correct: "signal(SIGINT, handle_sigint);", distractors: [{ "text": "signal(SIGINT, handle_sigint());", reason: "Calls the function immediately instead of registering it." }, { "text": "handle_sigint(SIGINT);", reason: "Directly calls the handler instead of registering it with `signal()`." }], indent: 1, explanation: "Register `handle_sigint` for `SIGINT`." },
  { correct: "printf(\"Signal handler registered for SIGINT (Ctrl+C).\\n\");", distractors: [{ "text": "printf(\"Handler set\\n\");", reason: "Less informative; does not specify the signal or key combination." }], indent: 1, explanation: "Confirmation message." },
  { correct: "printf(\"Program is now in an infinite loop. Press Ctrl+C to exit.\\n\");", distractors: [{ "text": "printf(\"Running...\\n\");", reason: "Does not instruct the user on how to exit the program." }], indent: 1, explanation: "Instruct the user how to trigger the signal." },
  { correct: "int counter = 0;", distractors: [{ "text": "volatile int counter = 0;", reason: "Not necessary here; the loop is for demonstration, not for signal handling." }], indent: 1, explanation: "A counter for the loop." },
  { correct: "while (1) {", distractors: [{ "text": "while (counter < 100) {", reason: "Finite loop; the point is to have an infinite loop interrupted by the signal." }], indent: 1, explanation: "Start an infinite loop." },
  { correct: "printf(\"...running loop, iteration %d\\r\", counter++);", distractors: [{ "text": "printf(\"Running...\\n\");", reason: "Does not show progress or use carriage return for overwriting." }], indent: 2, explanation: "Show progress; `\\r` returns cursor to start." },
  { correct: "fflush(stdout);", distractors: [{ "text": "fflush(stdin);", reason: "Flushes input buffer, which is not needed here." }], indent: 2, explanation: "Flush output so it appears immediately." },
  { correct: "for (long i = 0; i < 50000000; i++); // Artificial delay", distractors: [{ "text": "sleep(1);", reason: "Requires `<unistd.h>`, which is not included, and is less portable." }], indent: 2, explanation: "A simple busy-wait delay." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a loop." }], indent: 1, explanation: "Close the loop." },
  { correct: "// Code beyond this point is unreachable because the handler exits.", distractors: [{ "text": "// Handler might return.", reason: "Incorrect; the handler uses `exit` and does not return." }], indent: 1, explanation: "Comment on flow." },
  { correct: "return 0;", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success, but this line is unreachable." }], indent: 1, explanation: "Will never be executed." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax for closing a function." }], indent: 0, explanation: "Close main function." }
]
  },

  // Level 54: Standard Library `qsort`
  {
    goal: "Sort an array of structs using the standard library's generic `qsort` function by providing a custom comparison function.",
    concepts: "`qsort`, `<stdlib.h>`, function pointers, comparison functions, generic programming",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <string.h>", reason: "Included later for `strcmp`; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <stdlib.h>", distractors: [{ "text": "#include <math.h>", reason: "Not needed; `<stdlib.h>` is for `qsort`." }], indent: 0, explanation: "Include for `qsort`." },
  { correct: "#include <string.h>", distractors: [{ "text": "#include <strings.h>", reason: "Non-standard header; use `<string.h>` for `strcmp`." }], indent: 0, explanation: "Include for `strcmp`." },
  { correct: "typedef struct { int id; char name[20]; } User;", distractors: [{ "text": "struct User { int id; char name[20]; };", reason: "Missing `typedef`; would require `struct User` each time." }], indent: 0, explanation: "Define a User struct we want to sort." },
  { correct: "// `qsort` needs a comparison function with a specific signature:", distractors: [{ "text": "// Comparison function", reason: "Does not specify the required signature." }], indent: 0, explanation: "Explain requirement." },
  { correct: "// `int func(const void* a, const void* b)`", distractors: [{ "text": "// `int func(void* a, void* b)`", reason: "Parameters should be `const void*` to indicate they are not modified." }], indent: 0, explanation: "Show required signature." },
  { correct: "// It returns < 0 if a < b, 0 if a == b, > 0 if a > b.", distractors: [{ "text": "// Returns a boolean value.", reason: "Incorrect; it must return an integer indicating order." }], indent: 0, explanation: "Explain return values." },
  { correct: "int compareUsersByID(const void* a, const void* b) {", distractors: [{ "text": "int compareUsersByID(void* a, void* b) {", reason: "Should use `const void*` for clarity and safety." }], indent: 0, explanation: "Define comparison by ID." },
  { correct: "// Cast the void pointers back to the correct struct pointer type.", distractors: [{ "text": "// No casting needed.", reason: "Incorrect; `void*` must be cast to access members." }], indent: 1, explanation: "Explain casting." },
  { correct: "const User* userA = (const User*)a;", distractors: [{ "text": "User* userA = a;", reason: "Missing cast; `a` is `void*`, not `User*`." }], indent: 1, explanation: "Cast the first argument." },
  { correct: "const User* userB = (const User*)b;", distractors: [{ "text": "User* userB = b;", reason: "Again, missing cast." }], indent: 1, explanation: "Cast the second argument." },
  { correct: "if (userA->id < userB->id) return -1;", distractors: [{ "text": "return userA->id - userB->id;", reason: "Can cause integer overflow; better to use explicit comparisons." }], indent: 1, explanation: "Return -1 if A's ID is smaller." },
  { correct: "if (userA->id > userB->id) return 1;", distractors: [{ "text": "return 1;", reason: "Always returns 1, ignoring the condition." }], indent: 1, explanation: "Return 1 if A's ID is larger." },
  { correct: "return 0;", distractors: [{ "text": "return userA->id == userB->id;", reason: "Returns a boolean, not an integer as required." }], indent: 1, explanation: "Return 0 if equal." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close comparison function." },
  { correct: "int compareUsersByName(const void* a, const void* b) {", distractors: [{ "text": "int compareUsersByName(const char* a, const char* b) {", reason: "Parameters should be `const void*`, not `const char*`." }], indent: 0, explanation: "Define comparison by name." },
  { correct: "const User* userA = (const User*)a;", distractors: [{ "text": "const char* userA = (const char*)a;", reason: "Incorrect type; should be `User*`." }], indent: 1, explanation: "Cast arguments." },
  { correct: "const User* userB = (const User*)b;", distractors: [{ "text": "const char* userB = (const char*)b;", reason: "Incorrect type." }], indent: 1, explanation: "Cast arguments." },
  { correct: "return strcmp(userA->name, userB->name);", distractors: [{ "text": "return userA->name - userB->name;", reason: "Subtracting pointers is meaningless for comparison." }], indent: 1, explanation: "`strcmp` returns the correct ordering." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close name comparison." },
  { correct: "void printUsers(User arr[], int size) {", distractors: [{ "text": "void printUsers(User* arr, int size) {", reason: "Same as correct; arrays decay to pointers." }], indent: 0, explanation: "Helper to print the array." },
  { correct: "for (int i = 0; i < size; i++) { printf(\"ID: %d, Name: %s\\n\", arr[i].id, arr[i].name); }", distractors: [{ "text": "for (int i = 0; i < size; i++) { printf(\"%d %s\\n\", arr[i].id, arr[i].name); }", reason: "Lacks labels, making output less clear." }], indent: 1, explanation: "Loop and print each user." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close print helper." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main." },
  { correct: "User users[] = { {3, \"Charlie\"}, {1, \"Alice\"}, {4, \"David\"}, {2, \"Bob\"} };", distractors: [{ "text": "User users[4];", reason: "Uninitialized; would have garbage values." }], indent: 1, explanation: "Declare unsorted array." },
  { correct: "int n = sizeof(users) / sizeof(users[0]);", distractors: [{ "text": "int n = 4;", reason: "Hardcoded size; less flexible if array changes." }], indent: 1, explanation: "Calculate element count." },
  { correct: "printf(\"--- Original Array ---\\n\"); printUsers(users, n);", distractors: [{ "text": "printUsers(users, 4);", reason: "Hardcoded size; better to use calculated `n`." }], indent: 1, explanation: "Print original state." },
  { correct: "// Sort by ID", distractors: [{ "text": "// Sort", reason: "Does not specify sorting criterion." }], indent: 1, explanation: "Comment on ID sort." },
  { correct: "qsort(users, n, sizeof(User), compareUsersByID);", distractors: [{ "text": "qsort(users, n, sizeof(User*), compareUsersByID);", reason: "Uses pointer size instead of element size, leading to incorrect sorting." }, { "text": "qsort(users, sizeof(users), sizeof(User), compareUsersByID);", reason: "Second argument should be number of elements, not total size." }], indent: 1, explanation: "Call `qsort` by ID." },
  { correct: "printf(\"\\n--- Sorted by ID ---\\n\"); printUsers(users, n);", distractors: [{ "text": "printf(\"Sorted:\\n\"); printUsers(users, n);", reason: "Does not specify sorting criterion." }], indent: 1, explanation: "Print sorted by ID." },
  { correct: "// Sort by Name", distractors: [{ "text": "// Sort again", reason: "Does not specify new criterion." }], indent: 1, explanation: "Comment on name sort." },
  { correct: "qsort(users, n, sizeof(User), compareUsersByName);", distractors: [{ "text": "qsort(users, n, sizeof(User), compareUsersByID);", reason: "Uses wrong comparison function." }], indent: 1, explanation: "Call `qsort` by name." },
  { correct: "printf(\"\\n--- Sorted by Name ---\\n\"); printUsers(users, n);", distractors: [{ "text": "printf(\"Sorted:\\n\"); printUsers(users, n);", reason: "Does not specify sorting criterion." }], indent: 1, explanation: "Print sorted by name." },
  { correct: "return 0; }", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 55: Variadic Functions
  {
    goal: "Create and use a variadic function that can accept a variable number of arguments, similar to `printf`.",
    concepts: "Variadic functions, `<stdarg.h>`, `va_list`, `va_start`, `va_arg`, `va_end`",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "#include <stdarg.h>", distractors: [{ "text": "#include <varargs.h>", reason: "Obsolete header; use `<stdarg.h>` for variadic functions." }], indent: 0, explanation: "Include for variable argument macros." },
  { correct: "// A variadic function must have at least one named parameter.", distractors: [{ "text": "// Variadic function", reason: "Does not mention the requirement for a named parameter." }], indent: 0, explanation: "Rule for variadic functions." },
  { correct: "// The ellipsis `...` indicates that more arguments may follow.", distractors: [{ "text": "// `...` for extra args", reason: "Less precise; does not explain the syntax." }], indent: 0, explanation: "Explain the `...` syntax." },
  { correct: "int sum_integers(int num_args, ...) {", distractors: [{ "text": "int sum_integers(...) {", reason: "Variadic functions must have at least one named parameter before the ellipsis." }], indent: 0, explanation: "Define a function with a count and variable args." },
  { correct: "int sum = 0;", distractors: [{ "text": "int sum;", reason: "Uninitialized variable; could lead to undefined behavior." }], indent: 1, explanation: "Initialize sum." },
  { correct: "// 1. Declare a `va_list` variable to hold the arguments.", distractors: [{ "text": "// Use va_list", reason: "Does not explain its purpose." }], indent: 1, explanation: "Explain `va_list`." },
  { correct: "va_list arg_pointer;", distractors: [{ "text": "va_list *arg_pointer;", reason: "`va_list` is typically an array type, not a pointer." }], indent: 1, explanation: "Declare the argument list." },
  { correct: "// 2. Initialize the `va_list` with `va_start`.", distractors: [{ "text": "// Start va_list", reason: "Less informative." }], indent: 1, explanation: "Explain `va_start`." },
  { correct: "// It needs the `va_list` and the last named parameter.", distractors: [{ "text": "// Needs va_list", reason: "Omits the last named parameter requirement." }], indent: 1, explanation: "Explain arguments to `va_start`." },
  { correct: "va_start(arg_pointer, num_args);", distractors: [{ "text": "va_start(arg_pointer);", reason: "Missing the last named parameter, which is required." }, { "text": "va_start(arg_pointer, sum);", reason: "Incorrect; `sum` is not the last named parameter." }], indent: 1, explanation: "Initialize for retrieval." },
  { correct: "// 3. Access the arguments with `va_arg`.", distractors: [{ "text": "// Get arguments", reason: "Does not specify the macro used." }], indent: 1, explanation: "Explain `va_arg`." },
  { correct: "for (int i = 0; i < num_args; i++) {", distractors: [{ "text": "while (1) {", reason: "Infinite loop; needs a condition to stop." }], indent: 1, explanation: "Loop for each argument." },
  { correct: "sum += va_arg(arg_pointer, int);", distractors: [{ "text": "sum += va_arg(arg_pointer, double);", reason: "Incorrect type; expects `int`, not `double`." }, { "text": "sum += *va_arg(arg_pointer, int);", reason: "Unnecessary dereference; `va_arg` returns the value." }], indent: 2, explanation: "Retrieve and add an `int`." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close loop." },
  { correct: "// 4. Clean up the `va_list` with `va_end`.", distractors: [{ "text": "// End va_list", reason: "Does not emphasize cleanup." }], indent: 1, explanation: "Explain `va_end`." },
  { correct: "va_end(arg_pointer);", distractors: [{ "text": "va_end();", reason: "Must pass the `va_list` variable." }], indent: 1, explanation: "Cleanup." },
  { correct: "return sum;", distractors: [{ "text": "return 0;", reason: "Always returns 0, ignoring the sum." }], indent: 1, explanation: "Return the sum." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 0, explanation: "Close variadic function." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main." },
  { correct: "printf(\"Calling sum_integers(3, 10, 20, 30)...\\n\");", distractors: [{ "text": "printf(\"Calling sum_integers\\n\");", reason: "Does not show arguments." }], indent: 1, explanation: "Informational." },
  { correct: "int result1 = sum_integers(3, 10, 20, 30);", distractors: [{ "text": "int result1 = sum_integers(2, 10, 20, 30);", reason: "Mismatches `num_args` with actual arguments, leading to undefined behavior." }], indent: 1, explanation: "Call with three args." },
  { correct: "printf(\"Result 1: %d\\n\", result1);", distractors: [{ "text": "printf(\"Result: %d\\n\", sum_integers(3, 10, 20, 30));", reason: "Redundant call; `result1` is already computed." }], indent: 1, explanation: "Print result." },
  { correct: "printf(\"\\nCalling sum_integers(5, 1, 2, 3, 4, 5)...\\n\");", distractors: [{ "text": "printf(\"Calling again\\n\");", reason: "Does not specify arguments." }], indent: 1, explanation: "Informational." },
  { correct: "int result2 = sum_integers(5, 1, 2, 3, 4, 5);", distractors: [{ "text": "int result2 = sum_integers(5, 1, 2, 3);", reason: "Provides fewer arguments than specified, causing undefined behavior." }], indent: 1, explanation: "Call with five args." },
  { correct: "printf(\"Result 2: %d\\n\", result2);", distractors: [{ "text": "printf(\"Result: %d\\n\", result2);", reason: "Minor difference; 'Result 2' is clearer." }], indent: 1, explanation: "Print result." },
  { correct: "return 0; }", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 56: Bit-fields in Structs
  {
    goal: "Use bit-fields within a struct to pack data tightly and reduce memory usage.",
    concepts: "struct, bit-fields, memory optimization, sizeof",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` is for I/O." }], indent: 0, explanation: "Include for I/O." },
  { correct: "// --- A standard struct for comparison ---", distractors: [{ "text": "// Normal struct", reason: "Less precise; does not indicate it's for comparison." }], indent: 0, explanation: "Comment for the non-bit-field struct." },
  { correct: "struct NormalFlags {", distractors: [{ "text": "typedef struct NormalFlags {", reason: "Unnecessary `typedef`; just defining a struct." }], indent: 0, explanation: "Define a regular struct." },
  { correct: "  unsigned int is_active;", distractors: [{ "text": "int is_active;", reason: "Signed int is unnecessary for flags; unsigned is clearer." }], indent: 1, explanation: "Each `unsigned int` likely takes 4 bytes." },
  { correct: "  unsigned int is_visible;", distractors: [{ "text": "unsigned char is_visible;", reason: "Changes size; we want to show waste in memory usage." }], indent: 1, explanation: "Another 4 bytes." },
  { correct: "  unsigned int access_level; // 0-7", distractors: [{ "text": "unsigned int access_level : 3;", reason: "Bit-field syntax in a non-bit-field struct." }], indent: 1, explanation: "Even though only a few bits needed, this takes 4 bytes." },
  { correct: "};", distractors: [{ "text": "}", reason: "Missing semicolon; struct definition requires it." }], indent: 0, explanation: "Close the regular struct." },
  { correct: "// --- A struct using bit-fields ---", distractors: [{ "text": "// Bit-field struct", reason: "Does not emphasize comparison." }], indent: 0, explanation: "Comment for the bit-field struct." },
  { correct: "struct BitFieldFlags {", distractors: [{ "text": "struct BitFieldFlags { int flags : 32; };", reason: "Uses bit-field but misses the point of packing multiple fields." }], indent: 0, explanation: "Define a struct using bit-fields." },
  { correct: "// The colon `:` followed by a number specifies the number of bits.", distractors: [{ "text": "// Bit-field syntax", reason: "Does not explain the syntax clearly." }], indent: 1, explanation: "Explain bit-field syntax." },
  { correct: "  unsigned int is_active    : 1;", distractors: [{ "text": "unsigned int is_active : 32;", reason: "Uses 32 bits, which is the same as a full `unsigned int`, defeating the purpose." }], indent: 1, explanation: "Allocate exactly 1 bit for this flag." },
  { correct: "  unsigned int is_visible   : 1;", distractors: [{ "text": "unsigned int is_visible : 2;", reason: "Only 1 bit is needed; 2 bits are unnecessary." }], indent: 1, explanation: "Allocate exactly 1 bit for this flag." },
  { correct: "  unsigned int access_level : 3;", distractors: [{ "text": "unsigned int access_level : 2;", reason: "2 bits can only store 0-3, but we need 0-7." }], indent: 1, explanation: "Allocate 3 bits (values 0-7)." },
  { correct: "  unsigned int            : 27;", distractors: [{ "text": "unsigned int padding : 27;", reason: "Named padding is unnecessary; unnamed is sufficient." }], indent: 1, explanation: "Unnamed bit-field to pad up to 32 bits." },
  { correct: "};", distractors: [{ "text": "}", reason: "Missing semicolon." }], indent: 0, explanation: "Close the bit-field struct." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main." },
  { correct: "printf(\"--- Memory Usage Comparison ---\\n\");", distractors: [{ "text": "printf(\"Memory usage:\\n\");", reason: "Less specific; does not indicate comparison." }], indent: 1, explanation: "Header." },
  { correct: "printf(\"sizeof(NormalFlags):   %zu bytes\\n\", sizeof(struct NormalFlags));", distractors: [{ "text": "printf(\"Size: %d\\n\", sizeof(struct NormalFlags));", reason: "Uses `%d` instead of `%zu` for `size_t`." }], indent: 1, explanation: "Print size of the normal struct." },
  { correct: "printf(\"sizeof(BitFieldFlags): %zu bytes\\n\", sizeof(struct BitFieldFlags));", distractors: [{ "text": "printf(\"Size: %zu\\n\", sizeof(struct BitFieldFlags) * 8);", reason: "Prints bits instead of bytes." }], indent: 1, explanation: "Print size of the bit-field struct." },
  { correct: "// Using the bit-field struct", distractors: [{ "text": "// Bit-fields", reason: "Does not specify usage." }], indent: 1, explanation: "Comment on usage." },
  { correct: "struct BitFieldFlags my_flags;", distractors: [{ "text": "struct NormalFlags my_flags;", reason: "Uses the wrong struct type." }], indent: 1, explanation: "Declare a bit-field struct variable." },
  { correct: "my_flags.is_active = 1;", distractors: [{ "text": "my_flags.is_active = 2;", reason: "A 1-bit field can only hold 0 or 1; 2 would be truncated to 0." }], indent: 1, explanation: "Assign a value to a bit-field." },
  { correct: "my_flags.is_visible = 0;", distractors: [{ "text": "my_flags.is_visible = -1;", reason: "Bit-fields are unsigned; -1 would be interpreted as a large positive number." }], indent: 1, explanation: "Set another bit-field member." },
  { correct: "my_flags.access_level = 5;", distractors: [{ "text": "my_flags.access_level = 8;", reason: "3 bits can only hold 0-7; 8 would wrap around to 0." }], indent: 1, explanation: "Set the 3-bit member." },
  { correct: "printf(\"\\n--- Accessing Bit-Fields ---\\n\");", distractors: [{ "text": "printf(\"Accessing:\\n\");", reason: "Less specific." }], indent: 1, explanation: "Header." },
  { correct: "if (my_flags.is_active) {", distractors: [{ "text": "if (my_flags.is_active == 1) {", reason: "Unnecessary; `if (my_flags.is_active)` is sufficient." }], indent: 1, explanation: "Check a bit-field." },
  { correct: "  printf(\"The system is active.\\n\");", distractors: [{ "text": "printf(\"Active\\n\");", reason: "Less descriptive." }], indent: 2, explanation: "Conditional message." },
  { correct: "}", distractors: [{ "text": "};", reason: "Incorrect syntax." }], indent: 1, explanation: "Close if." },
  { correct: "printf(\"Access Level: %u\\n\", my_flags.access_level);", distractors: [{ "text": "printf(\"Access Level: %d\\n\", my_flags.access_level);", reason: "Uses `%d` for signed int; bit-fields are unsigned, so `%u` is better." }], indent: 1, explanation: "Print the 3-bit member." },
  { correct: "// Note: You cannot take the address (`&`) of a bit-field member.", distractors: [{ "text": "// Bit-fields have addresses.", reason: "Incorrect; bit-fields do not have addresses." }], indent: 1, explanation: "Important limitation." },
  { correct: "return 0; }", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 57: Formatted String I/O (`sscanf`, `sprintf`)
  {
    goal: "Use `sprintf` to format data into a string buffer and `sscanf` to parse data out of a string.",
    concepts: "`sprintf`, `sscanf`, string buffers, formatted I/O",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` includes `sprintf` and `sscanf`." }], indent: 0, explanation: "Include for `sprintf`, `sscanf`, and `printf`." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "// --- Using `sprintf` to write formatted data to a string ---", distractors: [{ "text": "// sprintf", reason: "Does not explain its purpose." }], indent: 1, explanation: "Header for `sprintf` section." },
  { correct: "char buffer[100];", distractors: [{ "text": "char *buffer;", reason: "Uninitialized pointer; must allocate space." }, { "text": "char buffer[10];", reason: "Buffer too small; risk of overflow." }], indent: 1, explanation: "Declare a buffer for the formatted string." },
  { correct: "char* name = \"Alex\";", distractors: [{ "text": "char name[] = \"Alex\";", reason: "Array instead of pointer; both work, but pointer is used here." }], indent: 1, explanation: "Data to be formatted." },
  { correct: "int score = 42;", distractors: [{ "text": "int score;", reason: "Uninitialized; would print garbage." }], indent: 1, explanation: "More data to be formatted." },
  { correct: "int chars_written = sprintf(buffer, \"Player: %s, Score: %d\", name, score);", distractors: [{ "text": "int chars_written = printf(\"Player: %s, Score: %d\", name, score);", reason: "`printf` writes to stdout, not to the buffer." }, { "text": "sprintf(buffer, \"Player: %s, Score: %d\", name, score);", reason: "Does not capture the number of characters written." }], indent: 1, explanation: "`sprintf` writes formatted data into `buffer` and returns the character count." },
  { correct: "printf(\"`sprintf` demo:\\n\");", distractors: [{ "text": "printf(\"Demo:\\n\");", reason: "Less specific." }], indent: 1, explanation: "Header." },
  { correct: "printf(\"  - Buffer content: \\\"%s\\\"\\n\", buffer);", distractors: [{ "text": "printf(\"Buffer: %s\\n\", buffer);", reason: "Does not escape the string for clarity." }], indent: 1, explanation: "Print buffer contents." },
  { correct: "printf(\"  - Characters written: %d\\n\", chars_written);", distractors: [{ "text": "printf(\"Chars: %d\\n\", chars_written);", reason: "Less descriptive." }], indent: 1, explanation: "Print return value of `sprintf`." },
  { correct: "// --- Using `sscanf` to parse formatted data from a string ---", distractors: [{ "text": "// sscanf", reason: "Does not explain its purpose." }], indent: 1, explanation: "Header for `sscanf` section." },
  { correct: "const char* data_string = \"Timestamp:2025-06-28,ID:12345\";", distractors: [{ "text": "char data_string[] = \"Timestamp:2025-06-28,ID:12345\";", reason: "Array instead of pointer; both work." }], indent: 1, explanation: "String containing structured data." },
  { correct: "// Declare variables to hold the parsed data.", distractors: [{ "text": "// Variables", reason: "Does not specify they are for parsed data." }], indent: 1, explanation: "Comment on destination variables." },
  { correct: "int year, month, day, id;", distractors: [{ "text": "int year, month, day; char id[10];", reason: "ID is an integer, not a string." }], indent: 1, explanation: "Declare integer variables." },
  { correct: "// The format string for `sscanf` can include literal text to match.", distractors: [{ "text": "// Format string", reason: "Does not mention literal text matching." }], indent: 1, explanation: "Explain `sscanf` format strings." },
  { correct: "int items_matched = sscanf(data_string, \"Timestamp:%d-%d-%d,ID:%d\", &year, &month, &day, &id);", distractors: [{ "text": "int items_matched = sscanf(data_string, \"%d-%d-%d,%d\", &year, &month, &day, &id);", reason: "Missing literal text; would not match the input string." }, { "text": "sscanf(data_string, \"Timestamp:%d-%d-%d,ID:%d\", year, month, day, id);", reason: "Forgot to pass addresses with `&`." }, { "text": "int items_matched = scanf(\"Timestamp:%d-%d-%d,ID:%d\", &year, &month, &day, &id);", reason: "`scanf` reads from stdin, not from a string." }], indent: 1, explanation: "`sscanf` parses the string into variables and returns the count matched." },
  { correct: "printf(\"\\n`sscanf` demo:\\n\");", distractors: [{ "text": "printf(\"Demo:\\n\");", reason: "Less specific." }], indent: 1, explanation: "Header." },
  { correct: "printf(\"  - Successfully matched %d items.\\n\", items_matched);", distractors: [{ "text": "printf(\"Matched: %d\\n\", items_matched);", reason: "Less descriptive." }], indent: 1, explanation: "Print return value of `sscanf`." },
  { correct: "printf(\"  - Parsed Year: %d\\n\", year);", distractors: [{ "text": "printf(\"Year: %d\\n\", &year);", reason: "Prints address instead of value." }], indent: 1, explanation: "Print parsed year." },
  { correct: "printf(\"  - Parsed Month: %d\\n\", month);", distractors: [{ "text": "printf(\"Month: %s\\n\", month);", reason: "Uses `%s` for an integer." }], indent: 1, explanation: "Print parsed month." },
  { correct: "printf(\"  - Parsed Day: %d\\n\", day);", distractors: [{ "text": "printf(\"Day: %d\\n\", day);", reason: "Same as correct; no mistake." }], indent: 1, explanation: "Print parsed day." },
  { correct: "printf(\"  - Parsed ID: %d\\n\", id);", distractors: [{ "text": "printf(\"ID: %s\\n\", id);", reason: "Uses `%s` for an integer." }], indent: 1, explanation: "Print parsed ID." },
  { correct: "return 0; }", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success." }], indent: 0, explanation: "Close main." }
]
  },

  // Level 58: File Positioning (`fseek`, `ftell`)
  {
    goal: "Manipulate the file position indicator using `fseek` to read from arbitrary locations and `ftell` to determine the current position.",
    concepts: "File I/O, file position, `fseek`, `ftell`, `rewind`, `SEEK_SET`, `SEEK_CUR`, `SEEK_END`",
    sequence: [
  { correct: "#include <stdio.h>", distractors: [{ "text": "#include <stdlib.h>", reason: "Not needed; `<stdio.h>` includes file I/O functions." }], indent: 0, explanation: "Include for I/O." },
  { correct: "int main() {", distractors: [{ "text": "void main() {", reason: "Must return `int`." }], indent: 0, explanation: "Start main function." },
  { correct: "const char* filename = \"test_seek.txt\";", distractors: [{ "text": "char filename[] = \"test_seek.txt\";", reason: "Array instead of pointer; both work." }], indent: 1, explanation: "Name of the test file." },
  { correct: "FILE* fp = fopen(filename, \"w+\");", distractors: [{ "text": "FILE* fp = fopen(filename, \"r\");", reason: "\"r\" is read-only; \"w+\" allows reading and writing." }, { "text": "FILE* fp = fopen(\"test_seek.txt\", \"w+\");", reason: "Hardcodes filename; using a variable is better." }], indent: 1, explanation: "Open a file for writing and reading ('w+')." },
  { correct: "if (!fp) { return 1; }", distractors: [{ "text": "if (fp == NULL) { exit(1); }", reason: "Uses `exit` instead of `return`; `return` is sufficient in `main`." }], indent: 1, explanation: "Error check." },
  { correct: "fputs(\"0123456789abcdefghijklmnopqrstuvwxyz\", fp);", distractors: [{ "text": "fprintf(fp, \"0123456789abcdefghijklmnopqrstuvwxyz\");", reason: "`fprintf` is for formatted output; `fputs` is simpler for strings." }], indent: 1, explanation: "Write known content to the file." },
  { correct: "// --- Using ftell to get current position ---", distractors: [{ "text": "// ftell", reason: "Does not explain its purpose." }], indent: 1, explanation: "Header for `ftell`." },
  { correct: "long pos = ftell(fp);", distractors: [{ "text": "int pos = ftell(fp);", reason: "`ftell` returns `long`, not `int`; could truncate on large files." }], indent: 1, explanation: "Get current file position (end of file)." },
  { correct: "printf(\"After writing, position is at: %ld\\n\", pos);", distractors: [{ "text": "printf(\"Position: %d\\n\", pos);", reason: "Uses `%d` for `long`; should be `%ld`." }], indent: 1, explanation: "Print the position (file size)." },
  { correct: "// --- Using rewind to go to the beginning ---", distractors: [{ "text": "// Rewind", reason: "Does not explain its effect." }], indent: 1, explanation: "Header for `rewind`." },
  { correct: "rewind(fp);", distractors: [{ "text": "fseek(fp, 0, SEEK_SET);", reason: "Same effect, but `rewind` is simpler for this purpose." }], indent: 1, explanation: "Move to the beginning of the file." },
  { correct: "printf(\"After rewind, position is at: %ld\\n\", ftell(fp));", distractors: [{ "text": "printf(\"Position: %ld\\n\", 0);", reason: "Assumes position without checking." }], indent: 1, explanation: "Confirm position is 0." },
  { correct: "// --- Using fseek to jump to a specific offset ---", distractors: [{ "text": "// fseek", reason: "Does not specify its usage." }], indent: 1, explanation: "Header for `fseek`." },
  { correct: "// `fseek` parameters: file pointer, offset, and origin.", distractors: [{ "text": "// fseek params", reason: "Does not explain the parameters." }], indent: 1, explanation: "Explain `fseek` parameters." },
  { correct: "if (fseek(fp, 10, SEEK_SET) != 0) { return 1; }", distractors: [{ "text": "fseek(fp, 10, SEEK_SET);", reason: "Does not check return value; `fseek` can fail." }, { "text": "if (fseek(fp, 10, SEEK_CUR) != 0) { return 1; }", reason: "Uses `SEEK_CUR` instead of `SEEK_SET`, changing the offset meaning." }], indent: 1, explanation: "Move 10 bytes from the beginning." },
  { correct: "printf(\"After fseek(10, SEEK_SET), position is at: %ld\\n\", ftell(fp));", distractors: [{ "text": "printf(\"Position: 10\\n\");", reason: "Assumes success without checking." }], indent: 1, explanation: "Confirm the new position." },
  { correct: "char c = fgetc(fp);", distractors: [{ "text": "int c = fgetc(fp);", reason: "Better to use `int` to handle EOF, but `char` works for this demo." }], indent: 1, explanation: "Read a character at the new position." },
  { correct: "printf(\"Character at position 10 is: '%c'\\n\", c); // Should be 'a'", distractors: [{ "text": "printf(\"Char: %c\\n\", c);", reason: "Less specific." }], indent: 1, explanation: "Verify the character." },
  { correct: "// --- Using fseek to jump from the end ---", distractors: [{ "text": "// Seek from end", reason: "Does not explain the action." }], indent: 1, explanation: "Header for `SEEK_END`." },
  { correct: "fseek(fp, -6, SEEK_END);", distractors: [{ "text": "fseek(fp, 6, SEEK_END);", reason: "Positive offset from end would seek past the end, which is invalid for reading." }, { "text": "fseek(fp, -6, SEEK_SET);", reason: "Negative offset from beginning is invalid." }], indent: 1, explanation: "Move 6 bytes backward from end." },
  { correct: "printf(\"After fseek(-6, SEEK_END), position is at: %ld\\n\", ftell(fp));", distractors: [{ "text": "printf(\"Position: %ld\\n\", pos - 6);", reason: "Assumes `pos` is still the file size; better to use `ftell`." }], indent: 1, explanation: "Confirm the new position." },
  { correct: "char buffer[10] = {0};", distractors: [{ "text": "char buffer[10];", reason: "Uninitialized; could contain garbage." }], indent: 1, explanation: "Buffer for remaining data." },
  { correct: "fgets(buffer, 10, fp);", distractors: [{ "text": "fread(buffer, 1, 10, fp);", reason: "`fread` reads binary data; `fgets` is for strings." }], indent: 1, explanation: "Read the rest of the file into buffer." },
  { correct: "printf(\"Reading from there until end: \\\"%s\\\"\\n\", buffer); // Should be \"uvwxyz\"", distractors: [{ "text": "printf(\"Data: %s\\n\", buffer);", reason: "Less specific." }], indent: 1, explanation: "Verify content." },
  { correct: "fclose(fp);", distractors: [{ "text": "close(fp);", reason: "Wrong function; `fclose` is for `FILE*`." }], indent: 1, explanation: "Close the file." },
  { correct: "return 0; }", distractors: [{ "text": "return 1;", reason: "1 indicates failure; 0 is success." }], indent: 0, explanation: "Close main." }
]
  },

    // Level 59: Resizing Memory with `realloc`
    {
        goal: "Dynamically resize an existing memory block using `realloc` to make it larger and smaller.",
        concepts: "`realloc`, dynamic memory, memory management, NULL return",
        sequence: [
            { "correct": "#include <stdio.h>", distractors: [{"text": "#include <io.h>", reason: "`io.h` is a non-standard header found on some systems; `stdio.h` is the correct standard C header for input/output functions like `printf`."}, {"text": "include <stdio.h>", reason: "Preprocessor directives must begin with a `#` symbol to be processed before compilation."}], indent: 0, explanation: "Include for I/O." },
            { "correct": "#include <stdlib.h>", distractors: [{"text": "#include <malloc.h>", reason: "`malloc.h` is an outdated, non-standard header. The modern C standard places all dynamic memory functions like `malloc`, `realloc`, and `free` in `stdlib.h`."}, {"text": "#include \"stdlib.h\"", reason: "Use angle brackets `<>` for standard library headers and double quotes `\"\"` for local project headers."}], indent: 0, explanation: "Include for `malloc` and `realloc`." },
            { "correct": "void print_array(int* arr, int size) {", distractors: [{"text": "void print_array(int arr[], int size) {", reason: "This syntax is also correct and is often used as it's more readable. Both `int* arr` and `int arr[]` are treated identically by the compiler for function parameters."}, {"text": "void print_array(int arr, int size) {", reason: "You must use `int*` or `int[]` to indicate that the function accepts a pointer (the memory address of the array), not just a single integer value."}], indent: 0, explanation: "A helper function to print an array's contents." },
            { "correct": "  printf(\"Array (size %d): \", size);", distractors: [{"text": "  printf(\"Array (size %s): \", size);", reason: "The `%s` format specifier is for printing strings. Using it for an `int` like `size` results in undefined behavior."}, {"text": "  printf(\"Array (size %d): \");", reason: "The `%d` tells `printf` to expect an integer variable, but none was provided. This will print a garbage value from memory."}], indent: 1, explanation: "Print a header with the size." },
            { "correct": "  for(int i=0; i<size; i++) { printf(\"%d \", arr[i]); }", distractors: [{"text": "  for(int i=0; i<size; i++) { printf(\"%d \", *(arr+i)); }", reason: "This is also correct. Using pointer arithmetic `*(arr+i)` is equivalent to array subscripting `arr[i]`, but subscripting is generally more common and readable."}, {"text": "  for(int i=0; i<=size; i++) { printf(\"%d \", arr[i]); }", reason: "The `<` condition is correct. Using `<=` would cause the loop to run one extra time, attempting to read `arr[size]`, which is outside the allocated memory block."}], indent: 1, explanation: "Loop and print each element." },
            { "correct": "  printf(\"\\n\");", distractors: [{"text": "  puts(\"\");", reason: "`puts` with an empty string is a valid way to print just a newline character."}, {"text": "  printf(\"\\n\");", reason: "This would also work, but a semicolon is required to make it a complete statement in C."}], indent: 1, explanation: "Print a newline." },
            { "correct": "}", distractors: [{"text": "  return;", reason: "An explicit `return;` is valid but optional at the end of a `void` function; the closing brace `}` is sufficient."}, {"text": "};", reason: "Semicolons are not used after the closing brace of a function definition."}], indent: 0, explanation: "Close the helper function." },
            { "correct": "int main() {", distractors: [{"text": "void main() {", reason: "The C standard requires `main` to be defined with an `int` return type to signal an exit status to the operating system."}, {"text": "int main(void) {", reason: "This is also a perfectly valid and often preferred way to define `main`, making it explicit that it takes no command-line arguments."}], indent: 0, explanation: "Start main function." },
            { "correct": "int initial_size = 5;", distractors: [{"text": "#define INITIAL_SIZE 5", reason: "Using a preprocessor macro is a valid alternative, but a `const int` or a simple `int` variable is often preferred in modern C for better type safety."}, {"text": "let initial_size = 5;", reason: "`let` is not a C keyword for variable declaration; you must specify the type, like `int`."}], indent: 1, explanation: "Define the initial size of our dynamic array." },
            { "correct": "// 1. Allocate an initial block of memory", distractors: [{"text": "// Allocate array", reason: "This comment is okay, but being more specific about it being the 'initial block' and using `malloc` is more descriptive of this step."}, {"text": "/* Malloc */", reason: "This is a valid comment style, but the other comment is more descriptive of the action being performed."}], indent: 1, explanation: "First step: `malloc`." },
            { "correct": "int* numbers = (int*)malloc(initial_size * sizeof(int));", distractors: [{"text": "int* numbers = (int*)malloc(initial_size);", reason: "This is a critical error. `malloc` needs the total number of *bytes*. You must multiply the number of elements by the size of each element (`sizeof(int)`)."}, {"text": "int* numbers = (int*)calloc(initial_size, sizeof(int));", reason: "`calloc` is also a valid choice. It allocates and also initializes all bytes to zero, whereas `malloc` leaves the memory uninitialized."}], indent: 1, explanation: "Allocate memory for 5 integers." },
            { "correct": "if (!numbers) { return 1; }", distractors: [{"text": "if (numbers == NULL) { return 1; }", reason: "This is also correct and does the exact same thing. Using `!numbers` is a common shorthand for `numbers == NULL`."}, {"text": "if (numbers) { return 1; }", reason: "This logic is reversed. This would exit if the allocation *succeeded*, not if it failed."}], indent: 1, explanation: "Always check if allocation succeeded." },
            { "correct": "for (int i=0; i<initial_size; i++) { numbers[i] = i+1; }", distractors: [{"text": "for (int i=0; i<initial_size; i++) { *(numbers+i) = i+1; }", reason: "This is also correct. Using pointer arithmetic is equivalent to using the array subscript `[]` operator."}, {"text": "for (int i=1; i<=initial_size; i++) { numbers[i] = i; }", reason: "This is a dangerous off-by-one error. Array indices are 0 to `size-1`. Accessing `numbers[initial_size]` writes outside the allocated memory."}], indent: 1, explanation: "Initialize the allocated memory with values 1 through 5." },
            { "correct": "print_array(numbers, initial_size);", distractors: [{"text": "print_array(&numbers, initial_size);", reason: "`numbers` is already a pointer (the address). `&numbers` gives the address of the pointer variable itself (`int**`), which is the wrong type for the function."}, {"text": "print_array(*numbers, initial_size);", reason: "`*numbers` dereferences the pointer, passing the *value* of the first element (`numbers[0]`), not the pointer to the array."}], indent: 1, explanation: "Print the initial array." },
            { "correct": "// 2. Expand the memory block using `realloc`", distractors: [{"text": "// Malloc more memory", reason: "`realloc` is more appropriate here because its purpose is to resize an *existing* block, preserving the contents."}, {"text": "// Resize the array", reason: "This is a good comment, but mentioning `realloc` is more specific about the C function being used."}], indent: 1, explanation: "Second step: expand." },
            { "correct": "int new_size = 10;", distractors: [{"text": "int initial_size = 10;", reason: "This would cause a variable redefinition error. A new variable name like `new_size` must be used."}, {"text": "const int new_size = 10;", reason: "Using `const` is fine, but unnecessary here as the value is not meant to be a fixed constant used elsewhere in the program."}], indent: 1, explanation: "Define the new, larger size." },
            { "correct": "int* temp = (int*)realloc(numbers, new_size * sizeof(int));", distractors: [{"text":"numbers = (int*)realloc(numbers, new_size * sizeof(int));", reason:"This is a common but dangerous pattern. If `realloc` fails, it returns NULL and the original `numbers` pointer would be overwritten and lost, causing a memory leak. Use a temporary pointer."}, {"text": "int* temp = (int*)malloc(new_size * sizeof(int));", reason: "Using `malloc` would allocate a new block, but it would not copy the data from the old `numbers` block. `realloc` handles the copying."}], indent: 1, explanation: "Attempt to resize the memory block. `realloc` may move the entire block to a new location." },
            { "correct": "if (!temp) {", distractors: [{"text": "if (temp == NULL) {", reason: "This is a perfectly valid and often clearer way to check for a NULL pointer returned by `realloc` on failure."}, {"text": "if (temp == numbers) {", reason: "This checks if the memory block was expanded in-place. It doesn't correctly check for allocation failure, which is indicated by a NULL return."}], indent: 1, explanation: "Check if the reallocation failed." },
            { "correct": "  printf(\"Failed to reallocate memory!\\n\");", distractors: [{"text": "  perror(\"realloc\");", reason: "`perror` is an excellent choice for error reporting. It prints your string followed by a system error message, which can be more descriptive."}, {"text": "  return 1;", reason: "It's good practice to print an error message to the user before exiting so they know what went wrong."}], indent: 2, explanation: "Error message." },
            { "correct": "  free(numbers); // Free the original block before exiting", distractors: [{"text": "  free(temp);", reason: "This is incorrect. Inside this `if` block, `temp` is NULL. You must free the original pointer, `numbers`, which is still valid if `realloc` failed."}, {"text": "  // Do nothing", reason: "If you don't free `numbers` here, and `realloc` has failed, you have created a memory leak. The original block must be cleaned up."}], indent: 2, explanation: "On failure, the original memory is still valid and must be freed." },
            { "correct": "  return 1;", distractors: [{"text": "  exit(1);", reason: "`exit(1)` can also be used here. It terminates the program immediately, whereas `return 1;` only exits the `main` function."}, {"text": "  return -1;", reason: "Returning any non-zero value typically signals an error. `1` and `-1` are both common conventions."}], indent: 2, explanation: "Exit with an error." },
            { "correct": "}", distractors: [{"text": " } else {", reason: "An `else` block is not strictly necessary. The code can just continue after the `if` block if the allocation was successful."}], indent: 1, explanation: "Close error check." },
            { "correct": "numbers = temp;", distractors: [{"text": "*numbers = *temp;", reason: "This only copies the value of the first element (`temp[0]`) into `numbers[0]`. It does not make `numbers` point to the new memory block."}, {"text": "memcpy(numbers, temp, new_size * sizeof(int));", reason: "This would copy the data, but it's unnecessary as `realloc` already preserved it. The key step is updating the `numbers` pointer itself to point to the new block."}], indent: 1, explanation: "If successful, assign the new memory location back to the original pointer." },
            { "correct": "for(int i=initial_size; i<new_size; i++) { numbers[i] = i+1; }", distractors: [{"text": "for(int i=0; i<new_size; i++) { numbers[i] = i+1; }", reason: "Starting the loop from 0 would overwrite the old data that `realloc` carefully preserved. We only need to initialize the *newly added* space."}, {"text": "memset(numbers + initial_size, 0, (new_size - initial_size) * sizeof(int));", reason: "`memset` is a good way to initialize the new memory (e.g., to 0), but the goal here is to fill it with specific sequential values."}], indent: 1, explanation: "Initialize the *new* part of the expanded array." },
            { "correct": "print_array(numbers, new_size);", distractors: [{"text": "print_array(numbers, initial_size);", reason: "This would only print the first part of the array, not the newly expanded and initialized section."}, {"text": "print_array(temp, new_size);", reason: "This would also work, since `numbers` and `temp` now point to the same memory address."}], indent: 1, explanation: "Print the larger array." },
            { "correct": "// 3. Shrink the memory block", distractors: [{"text": "// Deallocate memory", reason: "`Deallocate` usually implies `free`. Here we are just resizing the block to be smaller, not completely releasing it."}, {"text": "// Truncate the array", reason: "This is an accurate description of the outcome, but the comment is more helpful if it mentions the action being taken."}], indent: 1, explanation: "Third step: shrink." },
            { "correct": "int final_size = 3;", distractors: [{"text": "int new_size = 3;", reason: "This would be a redefinition error because `new_size` already exists in this scope. A unique variable name is required."}, {"text": "initial_size = 3;", reason: "This would work, but using a new, descriptive variable name like `final_size` makes the code's intent clearer."}], indent: 1, explanation: "Define the final, smaller size." },
            { "correct": "numbers = (int*)realloc(numbers, final_size * sizeof(int));", distractors: [{"text": "free(numbers + final_size);", reason: "You cannot `free` a partial memory block. `realloc` is the correct function to shrink a block."}, {"text": "int* final_ptr = (int*)realloc(numbers, final_size*sizeof(int));", reason: "Using a temporary pointer is always the safest practice, but since shrinking memory is unlikely to fail, direct assignment is often used as a shorthand."}], indent: 1, explanation: "Shrinking a block will usually not fail, so we can often assign directly (though using a temp pointer is always safest)." },
            { "correct": "print_array(numbers, final_size);", distractors: [{"text": "print_array(numbers, new_size);", reason: "This would cause the print function to read past the end of the newly shrunken array, accessing freed memory and causing undefined behavior."}, {"text": "print_array(&numbers[0], final_size);", reason: "This is also a correct way to call the function, as `&numbers[0]` evaluates to the memory address of the first element, which is the same as `numbers`."}], indent: 1, explanation: "Print the shrunken array." },
            { "correct": "free(numbers);", distractors: [{"text": "free(&numbers);", reason: "`free` expects a pointer to the allocated memory (`int*`). `&numbers` is the address of the pointer variable itself (`int**`) and is the wrong argument for `free`."}, {"text": "// Memory is freed automatically", reason: "This is false in C. You must explicitly `free` any memory you dynamically allocate with `malloc`, `calloc`, or `realloc` to prevent memory leaks."}], indent: 1, explanation: "Free the final memory block." },
            { "correct": "return 0; }", distractors: [{"text": "free(numbers); return 0; }", reason: "This will cause a 'double free' error. The `numbers` pointer was already passed to `free` in the previous step and is no longer valid."}, {"text": "}", reason: "In modern C (C99 and later), `main` will implicitly `return 0;` if it reaches the end. However, explicitly writing `return 0;` is still considered good practice for clarity."}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 60: Generic Memory Manipulation (memcpy, memmove, memset)
    {
        goal: "Use the generic memory manipulation functions `memset`, `memcpy`, and `memmove` from `<string.h>`.",
        concepts: "`memset`, `memcpy`, `memmove`, `sizeof`, pointers, overlapping memory",
        sequence: [
            { "correct": "#include <stdio.h>", distractors: [{"text": "include <stdio.h>", reason: "Preprocessor directives must begin with a `#` symbol to be recognized by the compiler."}, {"text": "#include \"stdio.h\"", reason: "Use angle brackets `<>` for standard library headers. Double quotes `\"\"` are typically used for local headers in your own project."}], indent: 0, explanation: "Include for I/O." },
            { "correct": "#include <string.h>", distractors: [{"text": "#include <memory.h>", reason: "While some older systems have `<memory.h>`, the C standard specifies that these memory manipulation functions are in `<string.h>`."}, {"text": "// No include needed", reason: "These are standard library functions, not built-in keywords. You must include the correct header to use them."}], indent: 0, explanation: "Include for `mem...` functions." },
            { "correct": "typedef struct { int id; double val; } Data;", distractors: [{"text": "struct Data { int id; double val; };", reason: "This is also correct for defining a struct, but you would then have to declare variables as `struct Data my_var;`. `typedef` creates a type alias so you can just use `Data my_var;`."}, {"text": "typedef { int id; double val; } Data;", reason: "This is missing the `struct` keyword, which is required when defining the structure."}], indent: 0, explanation: "A simple struct for demonstration." },
            { "correct": "int main() {", distractors: [{"text": "void main() {", reason: "The C standard requires `main` to return an `int` to report an exit status to the operating system."}, {"text": "int main(void) {", reason: "This is also a perfectly valid and often preferred way to define `main`, making it explicit that it takes no command-line arguments."}], indent: 0, explanation: "Start main function." },
            { "correct": "// --- 1. `memset`: Fill a block of memory with a specific value ---", distractors: [{"text": "// Initialize memory", reason: "This is true, but the original comment is better because it specifically names the function being demonstrated."}, {"text": "/* Using memset */", reason: "This is a valid multi-line comment, but single-line comments with `//` are often preferred for short notes."}], indent: 1, explanation: "Introduce `memset`." },
            { "correct": "int my_array[5];", distractors: [{"text": "int my_array[5] = {0};", reason: "This is a great way to initialize an array to zero and is often preferred over `memset`. `memset` is more general and useful for non-zero values (on chars) or re-setting memory later."}, {"text": "int* my_array = malloc(5 * sizeof(int));", reason: "Dynamic allocation is not necessary here, as the size is fixed and known at compile time. A stack-allocated array is simpler and safer."}], indent: 1, explanation: "Declare an uninitialized array." },
            { "correct": "memset(my_array, 0, 5 * sizeof(int));", distractors: [{"text":"memset(my_array, 0, 5);", reason:"The third argument is the number of *bytes* to set. You must multiply the number of elements by the size of each element to get the correct total byte count."}, {"text":"for(int i=0; i<5; i++) { my_array[i] = 0; }", reason:"A loop is a valid way to zero an array, but `memset` is often a faster, single function call to do the same for raw bytes."}, {"text": "memset(my_array, 1, 5 * sizeof(int));", reason: "`memset` sets each *byte* to the given value. Setting all bytes of an integer to 1 results in a strange number (0x01010101), not the integer value `1`."}], indent: 1, explanation: "Set all bytes in `my_array` to 0. This is a common way to zero-initialize." },
            { "correct": "printf(\"Array after memset to 0: %d %d %d\\n\", my_array[0], my_array[1], my_array[2]);", distractors: [{"text": "printf(\"Array: %d\\n\", my_array);", reason: "Passing an array name to `printf` with `%d` is incorrect. The array name decays to a pointer, and printing it as a decimal is meaningless."}, {"text": "printf(\"Array: %d %d %d\\n\");", reason: "The format string has three `%d` specifiers, which tells `printf` to expect three integer arguments, but none were provided. This leads to undefined behavior."}], indent: 1, explanation: "Verify the array is zeroed." },
            { "correct": "// --- 2. `memcpy`: Copy memory from a source to a destination ---", distractors: [{"text": "// Copying a struct", reason: "This is too generic. The original comment is better as it highlights the specific function (`memcpy`) being demonstrated."}, {"text": "// Copy block of memory", reason: "Also correct, but less specific than the original comment."}], indent: 1, explanation: "Introduce `memcpy`." },
            { "correct": "Data source = { .id = 101, .val = 3.14 };", distractors: [{"text": "Data source = { 101, 3.14 };", reason: "This positional initializer is also correct in C99 and later. Using designated initializers (`.id = ...`) is often clearer and less error-prone if the struct definition changes."}, {"text": "Data source; source.id = 101; source.val = 3.14;", reason: "This is also a perfectly valid way to initialize the struct, just more verbose."}], indent: 1, explanation: "Create a source struct." },
            { "correct": "Data dest;", distractors: [{"text": "Data dest = {0};", reason: "Initializing `dest` to zero is good practice but not strictly necessary here, since `memcpy` will overwrite it completely anyway."}, {"text": "Data* dest = NULL;", reason: "This creates a pointer, not an actual instance of the struct. We need a concrete memory location for `dest` to copy the data into."}], indent: 1, explanation: "Create a destination struct." },
            { "correct": "memcpy(&dest, &source, sizeof(Data));", distractors: [{"text":"dest = source;", reason:"Struct assignment with `=` works and is often clearer. `memcpy` is more general and useful when you just have void pointers or need to copy raw byte blocks."}, {"text":"memcpy(&dest, &source, sizeof(Data*));", reason:"The size must be of the data itself (`sizeof(Data)`), not the size of a pointer to the data, which is much smaller."}, {"text": "memcpy(&source, &dest, sizeof(Data));", reason: "The arguments are in the wrong order. `memcpy`'s signature is `(destination, source, size)`, so this would copy the uninitialized `dest` over `source`."}], indent: 1, explanation: "Copy all bytes from `source` to `dest`. `memcpy` behavior is undefined if memory regions overlap." },
            { "correct": "printf(\"Copied struct: ID=%d, Val=%f\\n\", dest.id, dest.val);", distractors: [{"text": "printf(\"Copied: %d, %f\\n\", dest);", reason: "You cannot print an entire struct this way. You must access and print each member individually."}, {"text": "printf(\"Copied: ID=%d, Val=%lf\\n\", dest.id, dest.val);", reason: "While `%lf` is required for `scanf` to read a double, `%f` works for printing both floats and doubles with `printf` due to default argument promotion."}], indent: 1, explanation: "Verify the copy was successful." },
            { "correct": "// --- 3. `memmove`: Safely copy memory, even if regions overlap ---", distractors: [{"text": "// Overlapping memcpy", reason: "`memcpy` is the unsafe function here. The comment should focus on `memmove`, which is the safe solution being demonstrated."}, {"text": "// Moving memory", reason: "This is a good summary. The original comment is slightly better as it names the function explicitly."}], indent: 1, explanation: "Introduce `memmove`." },
            { "correct": "char text[] = \"hello world\";", distractors: [{"text": "char* text = \"hello world\";", reason: "This creates a pointer to a read-only string literal. Attempting to modify it (as we do later) results in undefined behavior (often a crash). An array `[]` creates a mutable copy on the stack."}, {"text": "char text[12] = \"hello world\";", reason: "This is also correct. Explicitly sizing the array works, while `[]` automatically calculates the size (11 chars + 1 null terminator = 12)."}], indent: 1, explanation: "Create a string to work with." },
            { "correct": "// We want to copy \"world\" over \"hello\" to get \"world world\"", distractors: [{"text": "// Overwrite the start of the string", reason: "This is correct but less descriptive than specifying the exact desired outcome."}, {"text": "// strcpy(\"world\", text);", reason: "`strcpy` is a function, not a comment. Furthermore, it would not achieve the desired result here and would likely cause a buffer overflow."}], indent: 1, explanation: "Define the goal for the overlapping copy." },
            { "correct": "// The source is `text+6` (\"world\"), destination is `text` (\"hello\")", distractors: [{"text": "// Source is index 6, destination is index 0", reason: "This is also a correct way to think about it. Using pointers `text+6` is how you would express this in the function call itself."}, {"text": "// Copy from the back to the front", reason: "This is a good, high-level description of the operation."}], indent: 1, explanation: "Identify the source and destination pointers." },
            { "correct": "// These regions overlap, so `memcpy` is unsafe. `memmove` is required.", distractors: [{"text": "// Use `memmove` for safety.", reason: "This is true, but it doesn't explain *why* it's safer. Mentioning the overlap and the danger of `memcpy` is key."}, {"text": "// `memcpy` might work, but it's not guaranteed.", reason: "This is the essence of undefined behavior. It might appear to work on some compilers/systems but will fail on others. You can never rely on it."}], indent: 1, explanation: "Explain why `memmove` is needed." },
            { "correct": "memmove(text, text + 6, 5);", distractors: [{"text":"memcpy(text, text + 6, 5);", reason:"Using `memcpy` on overlapping regions results in *undefined behavior*. `memmove` correctly handles this by using an intermediate buffer if necessary."}, {"text": "memmove(text, &text[6], 5);", reason: "This is also a perfectly correct way to write the call. `text + 6` and `&text[6]` are equivalent expressions for the address of the 7th character."}, {"text": "memmove(text, text + 6, strlen(text+6));", reason: "This is also correct, as `strlen(\"world\")` returns 5. Explicitly using the number `5` is slightly more efficient as it avoids a function call."}], indent: 1, explanation: "Safely copy 5 bytes from `text+6` to `text`." },
            { "correct": "printf(\"String after memmove: \\\"%s\\\"\\n\", text);", distractors: [{"text": "puts(text);", reason: "`puts` would also work and is simpler. It would print the string followed by a newline. `printf` is used here for custom formatting (the quotes)."}, {"text": "printf(text);", reason: "Never pass user-controlled or dynamically generated strings as the first argument to `printf`. It's a security risk (format string vulnerability). Always use `printf(\"%s\", text);`."}], indent: 1, explanation: "Verify the result is 'world world'." },
            { "correct": "return 0; }", distractors: [{"text": "return 0;", reason: "This is missing the closing brace `}` for the `main` function."}, {"text": "}", reason: "Explicitly writing `return 0;` at the end of `main` is standard practice for clarity, even though modern C compilers will do it implicitly."}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 61: Standard Library `bsearch`
    {
        goal: "Use the standard library's `bsearch` function to perform a binary search on a sorted array of structs.",
        concepts: "`bsearch`, binary search, `<stdlib.h>`, function pointers, comparison functions",
        sequence: [
    { "correct": "#include <stdio.h>", distractors: [{"text": "#include <io.h>", reason: "`io.h` is not a standard C header; `stdio.h` is the correct header for standard input/output functions."}, {"text": "#include \"stdio.h\"", reason: "Use angle brackets `<>` for standard library headers. Double quotes `\"\"` are generally for local project files."}], indent: 0, explanation: "Include for I/O." },
    { "correct": "#include <stdlib.h>", distractors: [{"text": "#include <bsearch.h>", reason: "There is no separate `bsearch.h` header; `bsearch`, `qsort`, and other general utilities are located in the standard library header, `stdlib.h`."}, {"text": "#include <string.h>", reason: "`string.h` is for string manipulation functions. `bsearch` is a general utility function found in `stdlib.h`."}], indent: 0, explanation: "Include for `bsearch` and `qsort`." },
    { "correct": "typedef struct { int key; char* value; } Item;", distractors: [{"text": "struct Item { int key; char* value; };", reason: "This is also a valid way to define a struct, but you would need to use `struct Item my_var;` to declare variables. `typedef` allows you to simply use `Item my_var;`."}, {"text": "typedef struct Item { int key, char* value };", reason: "Members in a struct definition must be separated by semicolons, not commas."}], indent: 0, explanation: "Define a key-value item struct." },
    { "correct": "// Comparison function for qsort and bsearch. Must have this signature.", distractors: [{"text": "// Function to compare two items", reason: "This is too generic. The original comment is better because it highlights that the function's specific signature (`int name(const void*, const void*)`) is a requirement for `bsearch`."}, {"text": "/* bsearch comparator */", reason: "This is a valid multi-line comment, but the original is more descriptive about the function's specific signature requirements."}], indent: 0, explanation: "Comment on the required comparison function." },
    { "correct": "int compareItems(const void* a, const void* b) {", distractors: [{"text": "int compareItems(const Item* a, const Item* b) {", reason: "This is a common mistake. The comparator for `bsearch` MUST accept `const void*` arguments to be generic. The casting happens inside the function."}, {"text": "void compareItems(const void* a, const void* b) {", reason: "The comparison function must return an `int` (negative, zero, or positive) to tell `bsearch` whether the key is less than, equal to, or greater than the array element."}], indent: 0, explanation: "Define the comparison function." },
    { "correct": "// For bsearch, one argument will be a pointer to the key,", distractors: [{"text": "// The first argument is the key value", reason: "This is a subtle but important error. `bsearch` passes a *pointer* to the key, not the key's value itself."}, {"text": "// Both arguments are Items", reason: "This is not true for `bsearch`. It passes the key and an element from the array to the comparator."}], indent: 1, explanation: "Explain `bsearch`'s use of the comparator." },
    { "correct": "// and the other will be a pointer to an element in the array.", distractors: [{"text": "// The second argument is the array", reason: "This is incorrect. `bsearch` handles iterating the array itself; it passes only a single element from the array to the comparator in each check."}, {"text": "// The other argument is the key's value", reason: "This is false; both arguments passed to the comparator are pointers."}], indent: 1, explanation: "Continue explanation." },
    { "correct": "const int* key = (const int*)a;", distractors: [{"text": "const int key = *(const int*)a;", reason: "This is incorrect. It dereferences the pointer to get the integer value. The rest of the function expects `key` to be a pointer so it can be dereferenced later."}, {"text": "const Item* key = (const Item*)a;", reason: "The first argument from `bsearch` is a pointer to our search key (an `int`), not a full `Item` struct."}], indent: 1, explanation: "Cast the first argument, which `bsearch` will pass as our key." },
    { "correct": "const Item* item = (const Item*)b;", distractors: [{"text": "const Item item = *(const Item*)b;", reason: "This creates a copy of the struct on the stack. It's more efficient to work with a pointer (`Item*`) directly to avoid the copy."}, {"text": "const int* item = (const int*)b;", reason: "The second argument from `bsearch` is a pointer to a full `Item` element from the array, not just an integer."}], indent: 1, explanation: "Cast the second argument, which will be an element from the array." },
    { "correct": "return (*key - item->key);", distractors: [{"text":"return (item->key - *key);", reason:"The order of subtraction is critical. `bsearch` relies on a consistent comparison (e.g., key vs. item). Reversing this would invert the search logic and cause it to fail."}, {"text": "return *key > item->key;", reason: "A comparison function must return a negative, zero, or positive `int`. A boolean expression like this will only return 0 (false) or 1 (true), losing the crucial 'less than' information."}], indent: 1, explanation: "Return the difference to determine ordering. This simple subtraction works for integers." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon is not placed after the closing brace of a function definition."}, {"text": "return 0; }", reason: "This function is defined to return an `int` result from the comparison; it should not always return 0."}], indent: 0, explanation: "Close the comparison function." },
    { "correct": "int main() {", distractors: [{"text": "void main() {", reason: "The C standard requires `main` to return an `int` as an exit code to the operating system."}, {"text": "main() {", reason: "While some older compilers might allow omitting the return type, standard C requires you to explicitly state it (e.g., `int`)." }], indent: 0, explanation: "Start main function." },
    { "correct": "// bsearch requires the array to be sorted first!", distractors: [{"text": "// `bsearch` will sort the array for you.", reason: "This is false. `bsearch` assumes the array is *already* sorted according to the provided comparison function. You must sort it yourself beforehand, usually with `qsort`."}, {"text": "// Create a sorted array.", reason: "This is inaccurate. The array is being created in an *unsorted* state on the next line."}], indent: 1, explanation: "Crucial prerequisite for binary search." },
    { "correct": "Item items[] = { {10, \"Ten\"}, {50, \"Fifty\"}, {20, \"Twenty\"}, {40, \"Forty\"}, {30, \"Thirty\"} };", distractors: [{"text": "Item items[] = { (10, \"Ten\"), (50, \"Fifty\") };", reason: "Struct initializers in an array must use curly braces `{}` for each element, not parentheses `()`."}, {"text": "Item items[5]; items[0] = {10, \"Ten\"};", reason: "You cannot use an initializer list `{}` to assign to a struct after it has been declared. You would have to assign each member individually (e.g., `items[0].key = 10;`)."}], indent: 1, explanation: "Create an unsorted array of items." },
    { "correct": "int n = sizeof(items) / sizeof(items[0]);", distractors: [{"text": "int n = sizeof(items);", reason: "`sizeof(items)` gives the total size of the array in *bytes*. To get the number of elements, you must divide by the size of a single element."}, {"text": "int n = 5;", reason: "Hardcoding the size is bad practice. If you add or remove elements from the array, you would have to remember to update this number, which is a common source of bugs."}], indent: 1, explanation: "Calculate the number of items." },
    { "correct": "// We need a different comparator for qsort, as it compares two full elements", distractors: [{"text": "// We can reuse the `compareItems` function for `qsort`.", reason: "This is incorrect. Our `compareItems` expects one argument to be a key (`int*`) and the other an `Item*`. `qsort` passes two `Item*`s, so it would fail."}], indent: 1, explanation: "Explain why a different comparator is needed for `qsort`." },
    { "correct": "int qsort_compare(const void*a, const void*b) { return ((Item*)a)->key - ((Item*)b)->key; }", distractors: [{"text": "int qsort_compare(const void*a, const void*b) { return compareItems(a, b); }", reason: "This would not work. `qsort` passes two `Item*`s. `compareItems` expects the first argument to be an `int*`, so the cast inside it would be incorrect."}], indent: 1, explanation: "Define a simple, in-line comparator for `qsort`." },
    { "correct": "qsort(items, n, sizeof(Item), qsort_compare);", distractors: [{"text": "qsort(items, n, sizeof(Item), compareItems);", reason: "This is a logical error. `qsort` passes two full `Item` elements to its comparator. Our `compareItems` function expects the first argument to be just a key (`int*`), so the logic would fail."}, {"text": "qsort(items, n, sizeof(Item*), qsort_compare);", reason: "The size argument must be the size of an *element* in the array (`sizeof(Item)`), not the size of a pointer (`sizeof(Item*)`)." }], indent: 1, explanation: "Sort the array by key." },
    { "correct": "printf(\"Sorted array ready for searching...\\n\");", distractors: [{"text": "puts(\"Sorted array ready for searching...\");", reason: "`puts` is a simpler way to print a string literal followed by a newline, and would also be correct here."}, {"text": "printf(items);", reason: "You cannot print an array or its contents this way. It would decay to a pointer and print a meaningless address."}], indent: 1, explanation: "Confirmation message." },
    { "correct": "// Now, search for an item with a specific key.", distractors: [{"text": "// Loop through the array to find the key.", reason: "A loop would work, but it would be a linear search (O(n)). The purpose here is to use the much faster binary search (O(log n)) provided by `bsearch`."}], indent: 1, explanation: "Comment on the search operation." },
    { "correct": "int key_to_find = 40;", distractors: [{"text": "const int key_to_find = 40;", reason: "Using `const` is good practice here as the key we are searching for does not change."}, {"text": "Item key_to_find = {40, \"\"};", reason: "While you could search for a full `Item`, `bsearch` is flexible. By writing our comparator correctly, we can search using just the `int` key."}], indent: 1, explanation: "The key we want to find." },
    { "correct": "printf(\"Searching for item with key: %d\\n\", key_to_find);", distractors: [{"text": "printf(\"Searching for item with key: %s\\n\", key_to_find);", reason: "The `%s` format specifier is for strings. Using it to print an `int` like `key_to_find` results in undefined behavior."}, {"text": "printf(\"Searching for item with key: %d\");", reason: "The format specifier `%d` tells `printf` to expect an integer argument, but none was provided. This would print a garbage value."}], indent: 1, explanation: "Informational message." },
    { "correct": "Item* found_item = bsearch(&key_to_find, items, n, sizeof(Item), compareItems);", distractors: [{"text":"Item* found_item = bsearch(key_to_find, items, n, sizeof(Item), compareItems);", reason:"The first argument must be a pointer to the key you are searching for, not the key value itself."}, {"text": "Item* found_item = bsearch(&key_to_find, items, n, sizeof(Item), qsort_compare);", reason: "This is a subtle error. `qsort_compare` expects both its arguments to be `Item*`. `bsearch` passes an `int*` as the first argument, which would cause the cast inside `qsort_compare` to be incorrect."}], indent: 1, explanation: "Call `bsearch`: pass a pointer to the key, the array, count, element size, and the comparator." },
    { "correct": "// Check the result", distractors: [{"text": "// See if the pointer is valid", reason: "This is another good way to describe the action of checking for a non-NULL pointer."}, {"text": "// If found", reason: "This is too brief. The original comment is better as it implies checking a return value."}], indent: 1, explanation: "Comment on checking the return value." },
    { "correct": "if (found_item != NULL) {", distractors: [{"text": "if (found_item) {", reason: "This is also a correct and common shorthand way to check if a pointer is not NULL."}, {"text": "if (*found_item) {", reason: "This is dangerous. If `found_item` is NULL, dereferencing it with `*` will cause a crash (segmentation fault)."}] , indent: 1, explanation: "`bsearch` returns a pointer to the found item, or NULL if not found." },
    { "correct": "printf(\"Found! Value is \\\"%s\\\".\\n\", found_item->value);", distractors: [{"text": "printf(\"Found! Value is \\\"%s\\\".\\n\", (*found_item).value);", reason: "The `(*ptr).member` syntax is also correct and is equivalent to the `ptr->member` syntax. The arrow operator `->` is generally preferred as it is cleaner."}, {"text": "printf(\"Found! Value is \\\"%s\\\".\\n\", found_item.value);", reason: "`found_item` is a pointer to a struct. You must use the arrow operator `->` to access its members, not the dot operator `.`."}], indent: 2, explanation: "Print the value of the found item." },
    { "correct": "} else {", distractors: [{"text": "} else if (found_item == NULL) {", reason: "The extra `if` condition is redundant. If the first `if` was false, we already know `found_item` must be NULL."}], indent: 1, explanation: "Handle the case where the item was not found." },
    { "correct": "printf(\"Item with key %d not found.\\n\", key_to_find);", distractors: [{"text": "puts(\"Item not found.\");", reason: "`puts` would also be a correct and simpler way to print a static 'not found' message."}, {"text": "printf(\"Item with key %d not found.\");", reason: "The format specifier `%d` requires an integer argument. Forgetting to pass `key_to_find` would result in a garbage value being printed."}], indent: 2, explanation: "Not found message." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon is not needed after the closing brace of an if/else block."}], indent: 1, explanation: "Close the if/else block." },
    { "correct": "return 0; }", distractors: [{"text": "}", reason: "While modern C compilers will implicitly add `return 0;` to `main`, explicitly writing it is standard practice and makes the code's intent clear."}, {"text": "return 1; }", reason: "Returning a non-zero value like 1 typically signals that an error occurred. `0` should be returned to indicate success."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 62: String Tokenizing with `strtok`
    {
        goal: "Parse a string into tokens (substrings) based on a delimiter using the `strtok` function.",
        concepts: "`strtok`, string parsing, delimiters, static internal state, side effects",
        sequence: [
    { "correct": "#include <stdio.h>", distractors: [{"text": "include <stdio.h>", reason: "Preprocessor directives in C must always begin with a `#` symbol to be recognized."}, {"text": "#include <io.h>", reason: "The standard C header for Input/Output functions like `printf` is `<stdio.h>`, not `<io.h>`."}], indent: 0, explanation: "Include for I/O." },
    { "correct": "#include <string.h>", distractors: [{"text": "#include <strings.h>", reason: "While some systems have `<strings.h>`, the standard C header containing `strtok`, `strlen`, etc., is `<string.h>`."}, {"text": "#include <stdlib.h>", reason: "`<stdlib.h>` contains general utilities like memory allocation, but string-specific functions are in `<string.h>`."}], indent: 0, explanation: "Include for `strtok`." },
    { "correct": "// `strtok` is used to split a string into a series of tokens.", distractors: [{"text": "// `strtok` finds substrings.", reason: "While it does return substrings (tokens), its primary purpose is 'splitting' or 'tokenizing' a string based on delimiters, which is a more specific description."}, {"text": "// `strtok` makes a copy of the string to tokenize.", reason: "This is dangerously false. The most important feature of `strtok` is that it modifies the original string in place."}], indent: 0, explanation: "Explain `strtok`." },
    { "correct": "// WARNING: `strtok` MODIFIES the original string by inserting null characters!", distractors: [{"text": "// `strtok` reads from the original string.", reason: "This is too mild. It doesn't just read; it actively writes null characters into the string, which is a destructive action."}, {"text": "// NOTE: `strtok` returns pointers into the original string.", reason: "This is true, but the more critical warning is that the function *modifies* the source string, which is a major side effect."}], indent: 0, explanation: "Crucial warning about `strtok`'s side effects." },
    { "correct": "// It is also NOT re-entrant or thread-safe due to its use of a static internal buffer.", distractors: [{"text": "// You can use `strtok` on multiple strings at once.", reason: "This is false and a key limitation. Because of its internal state, you cannot interleave calls to `strtok` for different strings. You must fully tokenize one before starting another."}, {"text": "// `strtok` is a modern, safe function.", reason: "This is misleading. `strtok` is an old function with significant drawbacks (destructiveness, not thread-safe). Safer alternatives like `strtok_r` or `strtok_s` exist."}], indent: 0, explanation: "Another important warning." },
    { "correct": "int main() {", distractors: [{"text": "void main() {", reason: "Standard C requires `main` to have an `int` return type to signal an exit status to the operating system."}, {"text": "main() {", reason: "While some very old compilers allowed this, modern C standards require an explicit return type for all functions, including `main`."}], indent: 0, explanation: "Start main function." },
    { "correct": "char data_string[] = \"-l /usr/bin -p 8080 -v\";", distractors: [{"text":"const char* data_string = \"-l /usr/bin -p 8080 -v\";", reason:"This is a critical error. `strtok` modifies the string it's parsing. A string literal (`const char*`) is often in read-only memory and cannot be modified, which would cause a crash."}, {"text": "char* data_string = \"-l /usr/bin -p 8080 -v\";", reason: "This is also unsafe and deprecated. It creates a pointer to a string literal, which should not be modified. Using an array `[]` correctly creates a mutable copy."}], indent: 1, explanation: "Create a modifiable character array to be tokenized." },
    { "correct": "printf(\"Original string: \\\"%s\\\"\\n\", data_string);", distractors: [{"text": "puts(data_string);", reason: "`puts` is also correct for printing the string, but `printf` allows for more complex formatting like adding the surrounding quotes."}, {"text": "printf(data_string);", reason: "Never pass a variable string as the first argument to `printf`. It's a security vulnerability. Always use a format specifier like `\"%s\"`."}], indent: 1, explanation: "Show the original string." },
    { "correct": "const char* delimiters = \" \";", distractors: [{"text":"const char* delimiters = ' ';", reason:"The delimiters argument must be a string (a character array pointed to by `char*`), even if it only contains one character. A single character literal `' '` has type `int` and is incorrect here."}, {"text": "char delimiters[] = \" \";", reason: "This also works, but since the delimiters are not going to be modified, declaring it as a pointer to a constant string literal (`const char*`) is better practice."}], indent: 1, explanation: "Define the delimiter characters. Here, we're just splitting by space." },
    { "correct": "// The first call to `strtok` requires the string.", distractors: [{"text": "// `strtok` always requires the string.", reason: "This is false. Only the very first call for a given parsing session requires the string pointer."}, {"text": "// Use NULL on the first call.", reason: "This is incorrect. Using NULL on the first call is only valid if you have already started tokenizing a previous string."}], indent: 1, explanation: "Explain the first call." },
    { "correct": "char* token = strtok(data_string, delimiters);", distractors: [{"text": "const char* token = strtok(data_string, delimiters);", reason: "Although `strtok` returns a `char*`, assigning it to a `const char*` is safe. However, `token` is typically a `char*` as it's a pointer to a modifiable string section."}, {"text": "char* token = strtok(delimiters, data_string);", reason: "The arguments are reversed. The correct order is `strtok(string_to_tokenize, delimiters)`."}], indent: 1, explanation: "Get the first token. `strtok` returns a pointer to it." },
    { "correct": "// Subsequent calls use NULL to continue tokenizing the same string.", distractors: [{"text": "// You must create a new string for each new token.", reason: "This is false. `strtok`'s main feature is its internal state, which remembers where it left off in the original string."}, {"text": "// Subsequent calls use the same string pointer.", reason: "This would cause `strtok` to restart from the beginning every time, creating an infinite loop."}], indent: 1, explanation: "Explain subsequent calls." },
    { "correct": "while (token != NULL) {", distractors: [{"text": "while (token) {", reason: "This is also a correct and common C idiom. A non-NULL pointer evaluates to true, and a NULL pointer evaluates to false."}, {"text": "for (; token != NULL; ) {", reason: "A `for` loop can also be used, but a `while` loop is generally more natural and readable for this pattern."}], indent: 1, explanation: "Loop as long as `strtok` keeps returning valid tokens." },
    { "correct": "printf(\"Token: %s\\n\", token);", distractors: [{"text": "puts(token);", reason: "`puts` would also be correct and is a simpler way to print a string followed by a newline."}, {"text": "printf(\"Token: %c\\n\", *token);", reason: "This would only print the first character of the token, not the entire token string."}], indent: 2, explanation: "Print the current token." },
    { "correct": "token = strtok(NULL, delimiters);", distractors: [{"text":"token = strtok(data_string, delimiters);", reason:"If you pass the original string again, `strtok` will just restart from the beginning and return the first token repeatedly, likely causing an infinite loop."}, {"text": "strtok(NULL, delimiters);", reason: "This would correctly find the next token but would not assign its address to the `token` variable. The loop condition `while (token != NULL)` would never change, causing an infinite loop."}], indent: 2, explanation: "Get the *next* token from the same string by passing NULL." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon is not used after the closing brace of a `while` loop block."}], indent: 1, explanation: "Close the loop." },
    { "correct": "printf(\"\\nOriginal string after strtok: \");", distractors: [{"text": "printf(\"\\nOriginal string is unchanged: \");", reason: "This is incorrect and misleading. The entire point of this demonstration is to show that the original string *is* changed by `strtok`."}], indent: 1, explanation: "Header to show the modified string." },
    { "correct": "// The original string has been modified with null terminators (`\\0`).", distractors: [{"text": "// The string now contains spaces.", reason: "This is the opposite of what happened. `strtok` replaced the spaces (our delimiters) with null terminators (`\\0`)."}], indent: 1, explanation: "Explain the side effect." },
    { "correct": "for(int i=0; i<strlen(data_string); i++) {", distractors: [{"text": "printf(\"%s\", data_string);", reason: "This would not work as expected. `printf` with `%s` stops at the first null character, so it would only print the first token (`-l`)."}, {"text": "for(int i=0; data_string[i] != '\\0'; i++) {", reason: "This loop condition would also stop at the first null terminator inserted by `strtok`, so it would not inspect the entire modified string."}], indent: 1, explanation: "Loop to inspect the raw bytes." },
    { "correct": "  putchar(data_string[i] ? data_string[i] : '*'); // Print `*` for null char", distractors: [{"text": "  printf(\"%c\", data_string[i]);", reason: "This would print the characters, but the null terminators would be invisible, defeating the purpose of showing how the string was modified."}, {"text": "  if (data_string[i] == '\\0') { putchar('*'); } else { putchar(data_string[i]); }", reason: "This `if/else` block is also perfectly correct and achieves the same result. The ternary operator `?:` is just a more compact way to write it."}], indent: 2, explanation: "Print each character, replacing the nulls `strtok` inserted with a visible character." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon is not placed after the closing brace of a `for` loop."}], indent: 1, explanation: "Close the inspection loop." },
    { "correct": "printf(\"\\n\");", distractors: [{"text": "puts(\"\");", reason: "Calling `puts` with an empty string is another valid way to print a single newline character."}], indent: 1, explanation: "Final newline." },
    { "correct": "return 0; }", distractors: [{"text": "return 1; }", reason: "Returning a non-zero value like 1 is conventionally used to signal that an error occurred. `0` should be returned to indicate success."}, {"text": "}", reason: "While modern C compilers will implicitly add `return 0;` if it's omitted from `main`, explicitly writing it is standard practice and makes the code's intent clearer."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 63: Formatted File I/O (fprintf, fscanf)
    {
        goal: "Write structured data to a human-readable text file with `fprintf` and read it back with `fscanf`.",
        concepts: "`fprintf`, `fscanf`, formatted file I/O, text files",
        sequence: [
    { "correct": "#include <stdio.h>", distractors: [{"text": "#include <file.h>", reason: "There is no standard C header named `<file.h>`. All standard file I/O functions like `fopen` and `fprintf` are in `<stdio.h>`."}, {"text": "#include \"stdio.h\"", reason: "Use angle brackets `<>` for standard library headers. Double quotes `\"\"` are typically reserved for local header files within your own project."}], indent: 0, explanation: "Include for file I/O." },
    { "correct": "#include <stdlib.h>", distractors: [{"text": "#include <process.h>", reason: "While some systems might have a `<process.h>`, the standard C function `exit()` is located in the main standard library, `<stdlib.h>`."}, {"text": "// No include needed for exit", reason: "This is false. `exit` is a standard library function, not a built-in keyword, and requires `<stdlib.h>` to be included."}], indent: 0, explanation: "Include for `exit`." },
    { "correct": "typedef struct { int id; char name[20]; } Record;", distractors: [{"text": "struct Record { int id; char name[20]; };", reason: "This is also a valid way to define a struct. The `typedef` keyword creates a type alias, so you can declare variables as `Record r;` instead of `struct Record r;`."}, {"text": "typedef struct { int id, char name[20] } Record;", reason: "The members of a struct definition must be separated by semicolons, not commas."}], indent: 0, explanation: "A simple struct to read and write." },
    { "correct": "const char* filename = \"data.txt\";", distractors: [{"text": "char filename[] = \"data.txt\";", reason: "This also works correctly. Using `const char*` is often preferred for string literals that won't be modified, as it makes the intent clear."}, {"text": "const char* filename = 'data.txt';", reason: "In C, single quotes `'` are for single character literals. String literals must always be enclosed in double quotes `\"\"`."}], indent: 0, explanation: "The name of our text file." },
    { "correct": "int main() {", distractors: [{"text": "void main() {", reason: "The C standard requires that `main` returns an `int` value to the operating system to indicate its exit status."}, {"text": "int main(void) {", reason: "This is also correct and often preferred, as it explicitly states that the main function takes no arguments."}], indent: 0, explanation: "Start main function." },
    { "correct": "// --- Write formatted data to a text file ---", distractors: [{"text": "// Writing to disk", reason: "This is true, but the original comment is more specific, mentioning both 'formatted data' and 'text file', which is more descriptive."}, {"text": "// Saving structs", reason: "This is also true, but the original comment better describes the *format* of the output (formatted text)."}] , indent: 1, explanation: "Header for writing." },
    { "correct": "Record records_out[] = { {1, \"CPU\"}, {2, \"Memory\"}, {3, \"Disk\"} };", distractors: [{"text": "Record records_out[3]; records_out[0] = {1, \"CPU\"};", reason: "This is invalid syntax. After declaration, you cannot use an initializer list `{...}` for assignment. You must assign each member individually (e.g., `records_out[0].id = 1;`)."}, {"text": "Record records_out[] = ( {1, \"CPU\"}, {2, \"Memory\"} );", reason: "The outer container for an array initializer list must be curly braces `{}`, not parentheses `()`."}], indent: 1, explanation: "An array of data to write." },
    { "correct": "FILE *fp = fopen(filename, \"w\");", distractors: [{"text":"FILE *fp = fopen(filename, \"wb\");", reason:"The \"wb\" mode is for writing in *binary* mode, which is not human-readable. For plain text files, you should use \"w\"."}, {"text": "FILE *fp = fopen(filename, \"r\");", reason: "The \"r\" mode is for reading. If the file doesn't exist, `fopen` in read mode will fail (return NULL). \"w\" mode correctly creates a new file for writing."}], indent: 1, explanation: "Open the file in write mode." },
    { "correct": "if (!fp) { perror(\"fopen for write\"); exit(1); }", distractors: [{"text": "if (fp == NULL) { perror(\"fopen\"); exit(1); }", reason: "This is also a perfectly correct and often clearer way to check if the file pointer is NULL after an `fopen` failure."}, {"text": "if (fp) { fclose(fp); }", reason: "This logic is reversed. This `if` block only runs on success, not on failure. The program should exit on failure."}], indent: 1, explanation: "Error check." },
    { "correct": "printf(\"Writing to %s...\\n\", filename);", distractors: [{"text": "puts(\"Writing to file...\");", reason: "This is a valid way to print a message, but it doesn't include the specific filename, which is useful for debugging."}, {"text": "fprintf(fp, \"Writing to %s...\\n\", filename);", reason: "This would write the informational message into the file itself, which is usually not the desired behavior. `printf` correctly writes to the console."}], indent: 1, explanation: "Informational message." },
    { "correct": "for (int i=0; i<3; i++) {", distractors: [{"text": "int i=0; while(i<3) { ... i++; }", reason: "A `while` loop is also a perfectly valid way to accomplish this. A `for` loop is often more conventional for iterating a fixed number of times."}, {"text": "for (int i=0; i<=3; i++) {", reason: "This is a classic off-by-one error. Using `<=` would cause the loop to run 4 times, attempting to access `records_out[3]`, which is outside the array's bounds."}], indent: 1, explanation: "Loop through the data to write." },
    { "correct": "fprintf(fp, \"%d %s\\n\", records_out[i].id, records_out[i].name);", distractors: [{"text":"printf(\"%d %s\\n\", records_out[i].id, records_out[i].name);", reason:"`printf` always writes to standard output (the console). To write to a file, you must use `fprintf` and provide the `FILE*` pointer as the first argument."}, {"text": "fputs(records_out[i].name, fp);", reason: "`fputs` only writes a string. It cannot handle formatted output with other data types like the integer `id`."}], indent: 2, explanation: "Write the ID and name for each record to the file, separated by a space and followed by a newline." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon is not used after the closing brace of a `for` loop's body."}], indent: 1, explanation: "Close the writing loop." },
    { "correct": "fclose(fp);", distractors: [{"text": "// fclose is optional", reason: "This is false and dangerous. If you don't call `fclose`, the output buffer may not be flushed to the disk, resulting in an incomplete or empty file. It also causes a resource leak."}, {"text": "free(fp);", reason: "`fp` is a special `FILE` structure, not a generic memory block from `malloc`. It must be closed with `fclose`, not `free`."}], indent: 1, explanation: "Close the file." },
    { "correct": "// --- Read formatted data from the text file ---", distractors: [{"text": "// Get data from file", reason: "This comment is okay, but the original is more descriptive by specifying 'formatted data' and 'text file'."}, {"text": "/* Reading Section */", reason: "This is a valid multi-line comment style, but single-line `//` is often preferred for simple section headers."}], indent: 1, explanation: "Header for reading." },
    { "correct": "Record records_in[3];", distractors: [{"text": "Record records_in[3] = {0};", reason: "This is an excellent practice. It initializes the entire array to zeros before reading, which can prevent issues with garbage data if the read fails partway through."}, {"text": "Record* records_in = malloc(3 * sizeof(Record));", reason: "Dynamic allocation would also work, but since the size is small and fixed, a stack-allocated array is simpler and automatically cleaned up."}], indent: 1, explanation: "An array to hold the data we read back." },
    { "correct": "fp = fopen(filename, \"r\");", distractors: [{"text": "fp = fopen(filename, \"w\");", reason: "Using write mode `\"w\"` here would be a disaster. It would erase the contents of the file we just wrote before we could read from it."}, {"text": "fp = fopen(filename, \"a\");", reason: "Append mode `\"a\"` is for adding to the end of a file. For reading from the beginning, you must use read mode `\"r\"`."}], indent: 1, explanation: "Re-open the file in read mode." },
    { "correct": "if (!fp) { perror(\"fopen for read\"); exit(1); }", distractors: [{"text": "if (fp == NULL) { /* handle error */ }", reason: "This is also a completely correct way to check for a file open error."}, {"text": "if (fp) { exit(1); }", reason: "This logic is reversed. It would cause the program to exit if the file was opened *successfully*."}], indent: 1, explanation: "Error check." },
    { "correct": "printf(\"Reading from %s...\\n\", filename);", distractors: [{"text": "fprintf(fp, \"Reading from %s...\\n\", filename);", reason: "This would attempt to write this message into the file we just opened for reading, which is not allowed and would fail."}, {"text": "printf(\"Reading from file...\\n\");", reason: "This works, but including the actual filename is better for providing clear, useful output to the user."}], indent: 1, explanation: "Informational message." },
    { "correct": "int i = 0;", distractors: [{"text": "int i;", reason: "While this is not technically an error, it's very good practice to initialize variables when you declare them to avoid using them with an unpredictable garbage value."}, {"text": "size_t i = 0;", reason: "`size_t` is also a suitable type for an index, and is often considered more correct than `int` as it's guaranteed to be unsigned and large enough for any array index."}], indent: 1, explanation: "An index for our read-in array." },
    { "correct": "while (fscanf(fp, \"%d %s\", &records_in[i].id, records_in[i].name) == 2) {", distractors: [{"text":"while (!feof(fp)) { fscanf(fp, \"%d %s\", &records_in[i].id, records_in[i].name); i++; }", reason:"This is a classic C anti-pattern. You should always check the return value of the read function (`fscanf`, `fread`, etc.) instead of checking `feof()` before a read. This avoids errors on the last line."}, {"text": "while (fscanf(...) != EOF) { ... }", reason: "Checking against EOF is also a common pattern. However, checking if the return value equals the number of items you expect (2) is more robust and precise."}], indent: 1, explanation: "Loop while `fscanf` successfully scans 2 items (an int and a string) per line." },
    { "correct": "i++;", distractors: [{"text": "++i;", reason: "The pre-increment `++i` and post-increment `i++` have the same effect when used as a standalone statement like this."}, {"text": "i = i + 1;", reason: "This is also a perfectly valid way to increment the variable, just more verbose than the `++` operator."}], indent: 2, explanation: "Increment the array index." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon is not used after the closing brace of a `while` loop."}], indent: 1, explanation: "Close the reading loop." },
    { "correct": "fclose(fp);", distractors: [{"text": "close(fp);", reason: "`close()` is a function from a different, lower-level I/O library (POSIX). The `FILE*` from `fopen` must be closed with `fclose`."}, {"text": "// No need to close a file opened for reading", reason: "This is false. You must always close any file you open to free up system resources, regardless of the mode."}], indent: 1, explanation: "Close the file." },
    { "correct": "// Verify the data", distractors: [{"text": "// Print the array", reason: "This comment is okay, but 'Verify the data' is better because it implies checking that what was read matches what was written."}, {"text": "/* Verification */", reason: "This is a valid multi-line comment style for the same purpose."}], indent: 1, explanation: "Comment on verification." },
    { "correct": "for (int j=0; j<i; j++) {", distractors: [{"text": "for (int j=0; j<3; j++) {", reason: "Using the hardcoded number `3` is less safe. The variable `i` correctly holds the number of records that were *actually read* from the file, which might be less than 3."}, {"text": "int j=0; while(j<i) { ... j++; }", reason: "A `while` loop would also work perfectly here. A `for` loop is just a more compact syntax for the same logic."}], indent: 1, explanation: "Loop through the records that were read." },
    { "correct": "printf(\"Record %d -> ID: %d, Name: %s\\n\", j, records_in[j].id, records_in[j].name);", distractors: [{"text": "printf(\"Record: %d, %s\\n\", records_in[j].id, records_in[j].name);", reason: "This works, but the original `printf` statement is more descriptive by labeling the fields ('ID', 'Name') and printing the record index `j`."}, {"text": "printf(\"Record %d -> ID: %d, Name: %s\\n\", j, records_out[j].id, records_out[j].name);", reason: "This is a logical error. It prints the original `records_out` data instead of the `records_in` data, so it doesn't actually verify what was read from the file."}], indent: 2, explanation: "Print the data to confirm it was read correctly." },
    { "correct": "}", distractors: [{"text": "};", reason: "Semicolons are not placed after the closing brace `}` of a `for` loop body."}], indent: 1, explanation: "Close the verification loop." },
    { "correct": "return 0; }", distractors: [{"text": "return 1; }", reason: "Returning 1 traditionally signals that an error occurred during execution. `0` should be returned to indicate a successful run."}, {"text": "}", reason: "While modern C compilers will implicitly return 0 from `main`, explicitly writing `return 0;` is considered good practice for clarity and portability."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 64: Character Classification (`<ctype.h>`)
    {
        goal: "Analyze a string by classifying each character using the functions from `<ctype.h>`.",
        concepts: "Character classification, `<ctype.h>`, `isalpha`, `isdigit`, `isspace`, `ispunct`, text parsing",
        sequence: [
    { "correct": "#include <stdio.h>", distractors: [{"text": "#include <io.h>", reason: "The standard C header for Input/Output functions is `<stdio.h>`, not `<io.h>`."}, {"text": "include <stdio.h>", reason: "Preprocessor directives in C, like `#include`, must always begin with a `#` symbol."}], indent: 0, explanation: "Include for I/O." },
    { "correct": "#include <ctype.h>", distractors: [{"text": "#include <string.h>", reason: "`<string.h>` is for string manipulation functions like `strlen`. Character classification functions like `isalpha` are in `<ctype.h>`."}, {"text": "#include <character.h>", reason: "There is no standard C header named `<character.h>`. The correct header for character type functions is `<ctype.h>`."}], indent: 0, explanation: "Include the header for character type functions." },
    { "correct": "int main() {", distractors: [{"text": "void main() {", reason: "The C standard requires `main` to have an `int` return type to signal an exit status to the operating system."}, {"text": "int main(void) {", reason: "This is also correct and often preferred, as it explicitly states that the main function takes no arguments."}], indent: 0, explanation: "Start main function." },
    { "correct": "const char* text = \"Hello, C World! Version 1.2.3 is here.\";", distractors: [{"text": "char text[] = \"...\";", reason: "This is also a correct way to create a string. Since we are not modifying the string, using `const char*` is good practice to point to the read-only literal."}, {"text": "const char* text = '...';", reason: "In C, single quotes `'` are for single character literals. String literals must always be enclosed in double quotes `\"\"`."}], indent: 1, explanation: "The input string to analyze." },
    { "correct": "// Initialize counters for different character types.", distractors: [{"text": "// Declare variables", reason: "This is too generic. The original comment is better because it explains the *purpose* of these variables (as counters for character types)."}, {"text": "/* Set up counters */", reason: "This is a valid multi-line comment that achieves the same purpose."}], indent: 1, explanation: "Comment on counters." },
    { "correct": "int alpha_count = 0;", distractors: [{"text": "int alpha_count;", reason: "This is dangerous. Uninitialized local variables hold garbage values. Counters must always be initialized to zero before you start incrementing them."}, {"text": "unsigned int alpha_count = 0;", reason: "Using `unsigned int` is a good choice for a counter that can never be negative, though a simple `int` is also very common."}], indent: 1, explanation: "Counter for alphabetic characters." },
    { "correct": "int digit_count = 0;", distractors: [{"text": "int digit_count;", reason: "Counters must be initialized to 0. An uninitialized variable will contain a random garbage value, making the final count incorrect."}], indent: 1, explanation: "Counter for digits." },
    { "correct": "int space_count = 0;", distractors: [{"text": "int space_count;", reason: "Forgetting to initialize a counter to 0 is a common source of bugs. Its initial value will be unpredictable."}], indent: 1, explanation: "Counter for whitespace characters." },
    { "correct": "int punct_count = 0;", distractors: [{"text": "int punct_count;", reason: "All counter variables must be explicitly initialized to 0 before they are used in calculations or increments."}], indent: 1, explanation: "Counter for punctuation characters." },
    { "correct": "int upper_count = 0;", distractors: [{"text": "int upper_count;", reason: "Like all counters, this must be initialized to 0 to ensure the count starts from a known value and not from a random one."}], indent: 1, explanation: "Counter for uppercase letters." },
    { "correct": "int lower_count = 0;", distractors: [{"text": "int lower_count;", reason: "An uninitialized counter variable leads to undefined behavior, as its starting value is whatever was previously in that memory location."}], indent: 1, explanation: "Counter for lowercase letters." },
    { "correct": "int i = 0;", distractors: [{"text": "size_t i = 0;", reason: "`size_t` is also a suitable type for an index, and is often considered more correct than `int` as it's guaranteed to be unsigned and large enough for any array index."}, {"text": "int i;", reason: "It's best practice to initialize loop counters when they are declared to avoid accidentally using them with a garbage value."}], indent: 1, explanation: "Initialize a loop counter." },
    { "correct": "printf(\"Analyzing string: \\\"%s\\\"\\n\", text);", distractors: [{"text": "puts(text);", reason: "`puts` would also print the string, but it automatically adds a newline and doesn't allow for custom formatting like adding quotes."}, {"text": "printf(\"Analyzing string: \\\"%s\\\"\\n\");", reason: "The format specifier `%s` tells `printf` to expect a string argument (`char*`), but none was provided. This results in undefined behavior."}], indent: 1, explanation: "Print the string being analyzed." },
    { "correct": "while (text[i] != '\\0') {", distractors: [{"text": "while (i < strlen(text)) {", reason: "This works, but it is very inefficient. `strlen` has to recount the entire string on every single iteration of the loop. Checking for the null terminator `\\0` is much faster."}, {"text": "for (int i=0; text[i] != '\\0'; i++) {", reason: "A `for` loop is also a perfectly good way to structure this loop; a `while` loop is just a stylistic choice."}], indent: 1, explanation: "Loop through every character in the string." },
    { "correct": "char c = text[i];", distractors: [{"text": "// No variable needed", reason: "While you could use `text[i]` directly in each `if` statement, assigning it to a variable `c` makes the code cleaner and easier to read."}, {"text": "int c = text[i];", reason: "This also works because a `char` is just a small integer type. However, using the `char` type makes the code's intent clearer."}], indent: 2, explanation: "Get the current character." },
    { "correct": "if (isalpha(c)) { alpha_count++; }", distractors: [{"text": "if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) { alpha_count++; }", reason: "This manual check works for ASCII, but `isalpha` is better because it's more readable and is locale-aware (it works correctly for character sets beyond simple ASCII)."}], indent: 2, explanation: "Check if the character is a letter (a-z, A-Z)." },
    { "correct": "if (isdigit(c)) { digit_count++; }", distractors: [{"text": "if (c >= '0' && c <= '9') { digit_count++; }", reason: "This manual check is common, but using the `isdigit` function is considered better practice for portability and clarity."}], indent: 2, explanation: "Check if the character is a digit (0-9)." },
    { "correct": "if (isspace(c)) { space_count++; }", distractors: [{"text": "if (c == ' ') { space_count++; }", reason: "This is incomplete. The `isspace` function is more comprehensive, checking for space, tab (`\\t`), newline (`\\n`), and other whitespace characters."}], indent: 2, explanation: "Check if the character is whitespace (space, tab, newline, etc.)." },
    { "correct": "if (ispunct(c)) { punct_count++; }", distractors: [{"text": "if (c == '.' || c == ',' || c == '!') { punct_count++; }", reason: "This manual check is very incomplete. `ispunct` correctly identifies a wide range of punctuation characters, making it much more robust."}], indent: 2, explanation: "Check if the character is punctuation." },
    { "correct": "if (isupper(c)) { upper_count++; }", distractors: [{"text": "if (isalpha(c) && !islower(c)) { upper_count++; }", reason: "This logic is valid, but calling `isupper` directly is more efficient and clearly states the intent."}], indent: 2, explanation: "Check if the character is an uppercase letter." },
    { "correct": "if (islower(c)) { lower_count++; }", distractors: [{"text": "if (c >= 'a' && c <= 'z') { lower_count++; }", reason: "This works for ASCII, but the `islower` function is preferred because it is more portable to other character encodings."}], indent: 2, explanation: "Check if the character is a lowercase letter." },
    { "correct": "i++;", distractors: [{"text": "++i;", reason: "When used as a standalone statement, the pre-increment `++i` and post-increment `i++` operators have the exact same effect."}, {"text": "i = i + 1;", reason: "This is also a perfectly valid way to increment the variable, it's just more verbose than the `++` operator."}], indent: 2, explanation: "Move to the next character." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon is not used after the closing brace of a `while` loop's body."}], indent: 1, explanation: "Close the loop." },
    { "correct": "printf(\"\\n--- Analysis Results ---\\n\");", distractors: [{"text": "puts(\"\\n--- Analysis Results ---\");", reason: "`puts` automatically adds a newline, so the explicit `\\n` would result in a blank line before the text. `puts(\"--- Analysis Results ---\")` would be a closer alternative."}], indent: 1, explanation: "Header for the results." },
    { "correct": "printf(\"Alphabetic Chars: %d\\n\", alpha_count);", distractors: [{"text": "printf(\"Alphabetic Chars: %d\\n\");", reason: "The `%d` format specifier requires an integer argument. Forgetting to provide `alpha_count` results in printing a garbage value."}], indent: 1, explanation: "Print the alphabet count." },
    { "correct": "printf(\"  (Upper: %d, Lower: %d)\\n\", upper_count, lower_count);", distractors: [{"text": "printf(\"  (Upper: %d, Lower: %d)\\n\", alpha_count - lower_count, alpha_count - upper_count);", reason: "This is a clever but incorrect way to derive the counts. It's much clearer and safer to use the dedicated counters."}, {"text": "printf(\"Upper: %d\\nLower: %d\\n\", upper_count, lower_count);", reason: "This would also work, but the original formatting presents the data more compactly on a single indented line."}], indent: 1, explanation: "Print the case breakdown." },
    { "correct": "printf(\"Digits:           %d\\n\", digit_count);", distractors: [{"text": "printf(\"Digits: %d\\n\", digit_count);", reason: "This works, but the extra spaces in the original format string help align the numbers vertically in the output, making it neater."}], indent: 1, explanation: "Print the digit count." },
    { "correct": "printf(\"Whitespace:       %d\\n\", space_count);", distractors: [{"text": "printf(\"Whitespace: %d\\n\", space_count);", reason: "The extra spaces are for visual alignment in the final output. Functionally, this code is identical."}], indent: 1, explanation: "Print the whitespace count." },
    { "correct": "printf(\"Punctuation:      %d\\n\", punct_count);", distractors: [{"text": "printf(\"Punctuation: %s\\n\", punct_count);", reason: "`%s` is the format specifier for a string (`char*`). Using it for an `int` like `punct_count` will lead to a crash or garbage output."}], indent: 1, explanation: "Print the punctuation count." },
    { "correct": "return 0; }", distractors: [{"text": "return 1; }", reason: "Returning 1 conventionally signals that an error occurred. To indicate a successful execution, `main` should return 0."}, {"text": "}", reason: "While modern C compilers will implicitly return 0 from `main`, explicitly writing `return 0;` is standard practice for clarity and portability."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 65: Debugging with `assert`
    {
        goal: "Use the `assert` macro from `<assert.h>` to check for program invariants and preconditions, and understand how it can be disabled.",
        concepts: "`assert`, `<assert.h>`, debugging, preconditions, `NDEBUG` macro",
        sequence: [
    { "correct": "#define NDEBUG // Uncomment this line to disable assertions", distractors: [{"text": "// #define NDEBUG", reason: "This is how the line should look to *enable* assertions. The `#define` must be active (not commented out) to have an effect."}, {"text": "#define DEBUG", reason: "The standard C macro to disable assertions is `NDEBUG` (for 'No Debug'). `DEBUG` is a common but non-standard macro with no effect on `assert`."}], indent: 0, explanation: "Introduce the NDEBUG macro, which disables `assert`. Keep it commented out for now." },
    { "correct": "#include <stdio.h>", distractors: [{"text": "#include <io.h>", reason: "`<stdio.h>` is the correct standard header for input/output functions. `<io.h>` is a non-standard header found on some older systems."}, {"text": "#include \"stdio.h\"", reason: "Use angle brackets `<>` for standard library headers. Double quotes `\"\"` are typically used for your own project's local header files."}], indent: 0, explanation: "Include for I/O." },
    { "correct": "#include <assert.h>", distractors: [{"text": "#include <debug.h>", reason: "There is no standard C header named `<debug.h>`. The `assert` macro is located in `<assert.h>`."}, {"text": "#include <stdlib.h>", reason: "`<stdlib.h>` contains many general utilities, but the specific macro for assertions, `assert`, has its own header."}], indent: 0, explanation: "Include the header for the `assert` macro." },
    { "correct": "// `assert(expression)` checks if an expression is true.", distractors: [{"text": "// `assert(expression)` returns true or false.", reason: "This is a crucial misunderstanding. `assert` does not return a value. It does nothing if the expression is true, and aborts the program if it's false."}, {"text": "// `assert` is a function.", reason: "`assert` is actually a macro, not a function. This is why it can be completely removed from the code by defining `NDEBUG` before including the header."}], indent: 0, explanation: "Explain the purpose of `assert`." },
    { "correct": "// If the expression is false (0), it prints an error message to stderr", distractors: [{"text": "// If the expression is false, it prints a warning and continues.", reason: "This is incorrect. The behavior of `assert` is severe; it does not just warn, it terminates the program immediately via `abort()`."}, {"text": "// If the expression is false, it returns -1.", reason: "`assert` never returns a value. Its purpose is to halt execution on an unexpected, critical failure."}], indent: 0, explanation: "Explain what happens on failure." },
    { "correct": "// with the file name, line number, and expression text, then aborts the program.", distractors: [{"text": "// and then cleans up memory.", reason: "This is false. `assert` calls `abort()`, which causes immediate, abnormal termination. It does not perform any cleanup like closing files or freeing memory."}, {"text": "// and then waits for user input.", reason: "This is incorrect. The program's execution is halted immediately and unconditionally."}], indent: 0, explanation: "Continue explaining failure behavior." },
    { "correct": "double divide(double a, double b) {", distractors: [{"text": "double divide(double a, double b);", reason: "A semicolon here would make this a function declaration (prototype), not a function definition (which includes the body in `{...}`)."}, {"text": "int divide(double a, double b) {", reason: "The function performs floating-point division, so its return type should be `double` to handle fractional results, not `int`."}], indent: 0, explanation: "Define a function where a precondition is important." },
    { "correct": "// Precondition: The divisor `b` must not be zero.", distractors: [{"text": "// Postcondition: The divisor `b` must not be zero.", reason: "A precondition is a condition that must be true *before* a function is called. A postcondition is a condition that must be true *after* it finishes."}, {"text": "// Check if b is zero.", reason: "This is too generic. 'Precondition' is the correct computer science term for a requirement that must be met by the caller of the function."}], indent: 1, explanation: "State the function's precondition." },
    { "correct": "assert(b != 0.0);", distractors: [{"text":"if (b == 0.0) { return 0.0; }", reason:"Returning a value is one way to handle an error, but `assert` is for catching *programmer errors* during development. It indicates a condition that should *never* happen in a correct program."}, {"text": "assert(b);", reason: "This is also a correct way to write the assertion, since any non-zero double evaluates to true. However, `b != 0.0` is more explicit and clearer about the specific condition being checked."}], indent: 1, explanation: "Use `assert` to enforce the precondition. If this fails, it indicates a bug in the code that *called* this function." },
    { "correct": "return a / b;", distractors: [{"text": "if (b != 0.0) { return a / b; }", reason: "This `if` check is redundant. The `assert` on the previous line already guarantees that `b` is not zero. If it were zero, the program would have already aborted."}, {"text": "return (int)(a / b);", reason: "Casting the result to an `int` would truncate any fractional part, which is likely not the desired behavior for a function that returns a `double`."}], indent: 1, explanation: "Perform the division if the assertion passes." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon should not be placed after the closing brace `}` of a function definition."}], indent: 0, explanation: "Close the divide function." },
    { "correct": "int main() {", distractors: [{"text": "void main() {", reason: "Standard C requires `main` to return an `int` to signal its exit status to the operating system."}], indent: 0, explanation: "Start main." },
    { "correct": "double x = 10.0;", distractors: [{"text": "int x = 10;", reason: "Using an `int` here would work, but since we are performing floating-point division, it's better to use `double` for all related variables for consistency."}], indent: 1, explanation: "Declare a numerator." },
    { "correct": "double y = 2.0;", distractors: [{"text": "double y;", reason: "It's important to initialize variables. An uninitialized variable holds a garbage value, which would lead to unpredictable results in the division."}], indent: 1, explanation: "Declare a valid denominator." },
    { "correct": "printf(\"--- Demonstrating `assert` ---\\n\");", distractors: [{"text": "puts(\"--- Demonstrating `assert` ---\");", reason: "`puts` is also a good way to print a simple string literal, and it automatically adds a newline."}, {"text": "assert(printf(\"...\"));", reason: "`printf` returns the number of characters printed, which would be non-zero (true). Wrapping it in `assert` has no real benefit and is confusing."}], indent: 1, explanation: "Header." },
    { "correct": "printf(\"Calling divide(10.0, 2.0)...\\n\");", distractors: [{"text": "printf(\"Calling divide(%f, %f)...\\n\", x, y);", reason: "This is also a good way to print the message, making it more dynamic if `x` and `y` were to change."}, {"text": "fprintf(stderr, \"Calling divide(10.0, 2.0)...\\n\");", reason: "`fprintf` to `stderr` is for printing error messages. Standard informational output should go to `stdout` via `printf`."}], indent: 1, explanation: "Informational message for the valid call." },
    { "correct": "double result = divide(x, y);", distractors: [{"text": "divide(x, y);", reason: "This would correctly call the function and the assertion would pass, but the calculated value returned by the function would be lost because it wasn't assigned to a variable."}, {"text": "assert(divide(x, y));", reason: "This would assert that the *result* of the division is non-zero. It doesn't check the preconditions *before* the call, which is the primary use of `assert`."}], indent: 1, explanation: "Call the function with valid arguments. The assertion will pass." },
    { "correct": "printf(\"Result: %f\\n\", result);", distractors: [{"text": "printf(\"Result: %d\\n\", result);", reason: "`%d` is the format specifier for integers. Using it for a `double` will result in incorrect, garbage output."}, {"text": "printf(\"Result: %f\\n\");", reason: "The `%f` specifier tells `printf` to expect a `double` argument. Forgetting to provide the `result` variable leads to undefined behavior."}], indent: 1, explanation: "Print the successful result." },
    { "correct": "printf(\"\\nNow, calling divide(10.0, 0.0) to trigger the assertion...\\n\");", distractors: [{"text": "puts(\"\\nNow calling divide to fail...\");", reason: "`puts` adds its own newline, so the `\\n` at the beginning would create an extra blank line. `puts(\"Now...\")` would be a closer alternative."}], indent: 1, explanation: "Informational message for the invalid call." },
    { "correct": "printf(\"(If NDEBUG is not defined, the program will abort here.)\\n\");", distractors: [{"text": "printf(\"(This will cause an error.)\\n\");", reason: "'Error' is generic. The original text is better because it explains *exactly* what will happen (the program will abort) and under what condition (`NDEBUG` is not defined)."}], indent: 1, explanation: "Explain what the user should expect." },
    { "correct": "result = divide(x, 0.0);", distractors: [{"text": "assert(divide(x, 0.0));", reason: "This is a logic error. The `assert` *inside* `divide` will fail first and abort the program. This outer `assert` will never even be evaluated."}, {"text": "if (y != 0) { result = divide(x, 0.0); }", reason: "This is a logic error. The check `y != 0` is true (y is 2.0), so the code proceeds to call `divide` with a hardcoded 0.0, triggering the assertion."}], indent: 1, explanation: "Call the function with invalid arguments. This will trigger the `assert` and terminate the program." },
    { "correct": "// The following lines will not be reached if assertions are enabled.", distractors: [{"text": "// This code will probably not run.", reason: "'Probably' is too weak. If assertions are on, this code is *guaranteed* not to run. Being precise is important."}, {"text": "// If the assertion fails, we skip this.", reason: "This is an understatement. The entire program is aborted; it doesn't just 'skip' to a later part of the code."}], indent: 1, explanation: "Comment on unreachable code." },
    { "correct": "printf(\"This line will not print if assert is triggered.\\n\");", distractors: [{"text": "return 1; // exit with error", reason: "This line is unreachable because the `assert` in the `divide` function will have already aborted the program."}, {"text": "assert(0); // Fail here too", reason: "This would also abort the program, but it's unreachable because the first failing assertion in the `divide` function already terminated execution."}], indent: 1, explanation: "An example of unreachable code." },
    { "correct": "return 0; }", distractors: [{"text": "return 1; }", reason: "This line is unreachable. If the assertion fails, the program aborts and never gets to a return statement. If all assertions pass, it should `return 0` to indicate success."}, {"text": "}", reason: "This line is unreachable. While an implicit return is allowed, it's irrelevant here because the program will either abort or explicitly `return 0` (in a non-demo scenario where the failing call isn't present)."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 66: Data Type Limits
    {
        goal: "Query and print the value ranges and precision limits of fundamental data types using the constants from `<limits.h>` and `<float.h>`.",
        concepts: "Data type limits, `<limits.h>`, `<float.h>`, portability, integer and floating point representation",
        sequence: [
    { "correct": "#include <stdio.h>", distractors: [{"text": "#include <io.h>", reason: "The standard C header for Input/Output functions is `<stdio.h>`, not `<io.h>`."}, {"text": "include <stdio.h>", reason: "Preprocessor directives in C, like `#include`, must always begin with a `#` symbol."}], indent: 0, explanation: "Include for I/O." },
    { "correct": "#include <limits.h>", distractors: [{"text": "#include <integers.h>", reason: "There is no standard C header named `<integers.h>`. The constants for integer type limits are defined in `<limits.h>`."}, {"text": "// No include needed for INT_MAX", reason: "This is false. `INT_MAX` and other limit constants are not built-in keywords; they are macros defined in the `<limits.h>` header file."}], indent: 0, explanation: "Include for integer type limit constants." },
    { "correct": "#include <float.h>", distractors: [{"text": "#include <math.h>", reason: "`<math.h>` contains mathematical *functions* like `sin()` and `pow()`, but the *constants* defining the limits of float types are in `<float.h>`."}, {"text": "#include <double.h>", reason: "There is no standard C header named `<double.h>`. Both `float` and `double` limits are defined in `<float.h>`."}], indent: 0, explanation: "Include for floating-point type limit constants." },
    { "correct": "int main() {", distractors: [{"text": "void main() {", reason: "The C standard requires `main` to return an `int` to signal its exit status. `void` is not a standard return type for `main`."}, {"text": "int main(void) {", reason: "This is also correct and often preferred, as it explicitly states that `main` takes no arguments."}], indent: 0, explanation: "Start main function." },
    { "correct": "printf(\"--- Integer Type Limits from <limits.h> ---\\n\");", distractors: [{"text": "puts(\"--- Integer Type Limits from <limits.h> ---\");", reason: "`puts` is a simpler alternative that also works here. It prints a string literal and adds a newline automatically."}, {"text": "printf(\"Integer Limits:\\n\");", reason: "This works, but the original is more descriptive by mentioning the header file where the constants come from."}], indent: 1, explanation: "Header for integer limits." },
    { "correct": "printf(\"Number of bits in a char: %d\\n\", CHAR_BIT);", distractors: [{"text": "printf(\"Size of a char: %d\\n\", sizeof(char));", reason: "`sizeof(char)` returns the size in *bytes*, which is guaranteed to be 1. `CHAR_BIT` returns the number of *bits* in a byte, which is usually, but not guaranteed to be, 8."}], indent: 1, explanation: "Print the number of bits in a byte (usually 8)." },
    { "correct": "printf(\"Minimum value of char: %d\\n\", CHAR_MIN);", distractors: [{"text": "printf(\"Minimum value of char: %d\\n\", -128);", reason: "While -128 is a common value for `CHAR_MIN`, hardcoding it makes your code less portable. Using the `CHAR_MIN` constant ensures it's correct on any system."}], indent: 1, explanation: "Print the minimum value for a char." },
    { "correct": "printf(\"Maximum value of char: %d\\n\", CHAR_MAX);", distractors: [{"text": "printf(\"Maximum value of char: %d\\n\", 127);", reason: "Hardcoding the value 127 is not portable. The `CHAR_MAX` constant from `<limits.h>` guarantees you get the correct maximum value for the specific system your code is compiled on."}], indent: 1, explanation: "Print the maximum value for a char." },
    { "correct": "printf(\"Minimum value of int: %d\\n\", INT_MIN);", distractors: [{"text": "printf(\"Minimum value of int: %u\\n\", INT_MIN);", reason: "`INT_MIN` is a large negative number. Using `%u` (unsigned) to print it would cause the value to be misinterpreted as a very large positive number."}], indent: 1, explanation: "Print the minimum value for a standard integer." },
    { "correct": "printf(\"Maximum value of int: %d\\n\", INT_MAX);", distractors: [{"text": "printf(\"Maximum value of int: %lld\\n\", INT_MAX);", reason: "While `%lld` (long long) would work, `%d` is the correct specifier for a standard `int`. Using the matching specifier is best practice."}], indent: 1, explanation: "Print the maximum value for a standard integer." },
    { "correct": "printf(\"Maximum value of unsigned int: %u\\n\", UINT_MAX);", distractors: [{"text":"printf(\"Max unsigned int: %d\\n\", UINT_MAX);", reason:"`UINT_MAX` is a very large positive number. Printing it with `%d` (signed decimal) will cause it to wrap around and appear as -1. `%u` (unsigned decimal) is required."}, {"text": "printf(\"Max unsigned int: %u\\n\", INT_MAX * 2);", reason: "This is not a reliable way to calculate `UINT_MAX` and could lead to overflow during the multiplication itself, resulting in an incorrect value."}], indent: 1, explanation: "Print the maximum value for an unsigned integer." },
    { "correct": "printf(\"Maximum value of long long: %lld\\n\", LLONG_MAX);", distractors: [{"text": "printf(\"Maximum value of long long: %d\\n\", LLONG_MAX);", reason: "A standard `int` (`%d`) is not large enough to hold the value of `LLONG_MAX`. This would result in overflow and incorrect output. The `long long` specifier (`%lld`) is required."}, {"text": "printf(\"Maximum value of long long: %ld\\n\", LLONG_MAX);", reason: "A `long` (`%ld`) might not be the same size as a `long long`. To be portable and correct, you must use the matching `%lld` specifier."}], indent: 1, explanation: "Print the maximum value for a long long, using the `%lld` format specifier." },
    { "correct": "printf(\"Maximum value of unsigned long long: %llu\\n\", ULLONG_MAX);", distractors: [{"text": "printf(\"Maximum value of unsigned long long: %lld\\n\", ULLONG_MAX);", reason: "Using the signed specifier `%lld` will cause the very large unsigned value to be misinterpreted as a signed number, likely printing as -1."}, {"text": "printf(\"Maximum value of unsigned long long: %u\\n\", ULLONG_MAX);", reason: "An `unsigned int` (`%u`) is too small to hold the value of `ULLONG_MAX`. This would lead to overflow and incorrect output. The correct specifier is `%llu`."}], indent: 1, explanation: "Print the maximum for an unsigned long long, using `%llu`." },
    { "correct": "printf(\"\\n--- Floating-Point Type Limits from <float.h> ---\\n\");", distractors: [{"text": "printf(\"--- Float Limits ---\\n\");", reason: "This works, but the original is more educational as it specifies that the constants come from the `<float.h>` header."}], indent: 1, explanation: "Header for floating-point limits." },
    { "correct": "printf(\"Minimum positive value of float: %e\\n\", FLT_MIN);", distractors: [{"text": "printf(\"Minimum positive value of float: %f\\n\", FLT_MIN);", reason: "`FLT_MIN` is a very small number close to zero. Printing it with `%f` would likely just show `0.000000`. Scientific notation (`%e`) is much better for displaying its true value."}, {"text": "printf(\"Minimum value of float: %e\\n\", -FLT_MAX);", reason: "This would give the largest-magnitude negative number. `FLT_MIN` is specifically the smallest *positive* value greater than zero that a float can represent."}], indent: 1, explanation: "Print the smallest positive number a float can represent, using scientific notation `%e`." },
    { "correct": "printf(\"Maximum value of float: %e\\n\", FLT_MAX);", distractors: [{"text": "printf(\"Maximum value of float: %f\\n\", FLT_MAX);", reason: "`FLT_MAX` is a very large number. Using `%f` might print a long, hard-to-read sequence of digits. Scientific notation (`%e`) is a more compact and readable format for such large values."}], indent: 1, explanation: "Print the largest number a float can represent." },
    { "correct": "printf(\"Float precision (decimal digits): %d\\n\", FLT_DIG);", distractors: [{"text": "printf(\"Float precision (bytes): %d\\n\", sizeof(float));", reason: "`sizeof(float)` gives the size of a float in bytes (usually 4), which is different from its precision in decimal digits. `FLT_DIG` gives the number of decimal digits that are guaranteed to be accurate."}, {"text": "printf(\"Float precision (binary digits): %d\\n\", FLT_MANT_DIG);", reason: "`FLT_MANT_DIG` is the number of binary digits (bits) in the mantissa, which is a related but different concept from the guaranteed number of decimal digits of precision (`FLT_DIG`)."}] , indent: 1, explanation: "Print the number of decimal digits of precision for a float." },
    { "correct": "printf(\"Float epsilon (smallest x such that 1.0+x != 1.0): %e\\n\", FLT_EPSILON);", distractors: [{"text": "printf(\"Float epsilon: %e\\n\", FLT_MIN);", reason: "This is a common confusion. `FLT_MIN` is the smallest positive number the type can represent, while `FLT_EPSILON` is the smallest number that makes a difference when added to 1.0."}], indent: 1, explanation: "Print the epsilon, which represents the difference between 1.0 and the next representable float value." },
    { "correct": "printf(\"Maximum value of double: %e\\n\", DBL_MAX);", distractors: [{"text": "printf(\"Maximum value of double: %f\\n\", DBL_MAX);", reason: "Because `DBL_MAX` is an extremely large number, using standard decimal notation (`%f`) would produce a very long and unreadable output. Scientific notation (`%e`) is much more suitable."}], indent: 1, explanation: "Print the maximum value for a double." },
    { "correct": "printf(\"Double precision (decimal digits): %d\\n\", DBL_DIG);", distractors: [{"text": "printf(\"Double precision (bytes): %d\\n\", sizeof(double));", reason: "`sizeof(double)` tells you the memory storage (usually 8 bytes), not its precision. `DBL_DIG` correctly gives the number of decimal digits that are guaranteed to be precise."}, {"text": "printf(\"Double precision (float digits): %d\\n\", FLT_DIG);", reason: "`FLT_DIG` is the precision for a `float`, which is lower than the precision for a `double`. `DBL_DIG` is the correct constant for a double's precision."}], indent: 1, explanation: "Print the number of decimal digits of precision for a double." },
    { "correct": "return 0; }", distractors: [{"text": "return 1; }", reason: "Returning 1 conventionally signals that an error occurred. This program should return 0 to indicate that it ran successfully."}, {"text": "}", reason: "While modern C compilers will implicitly return 0 from `main`, explicitly writing `return 0;` is standard practice for clarity and portability."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 67: Token-Pasting Operator (##)
    {
        goal: "Use the preprocessor's token-pasting operator (`##`) to create macros that generate identifiers like variable or function names.",
        concepts: "Preprocessor, macros, token-pasting operator (##), metaprogramming",
        sequence: [
    { "correct": "#include <stdio.h>", distractors: [{"text": "#include <io.h>", reason: "`<io.h>` is not a standard C header. The correct header for standard Input/Output is `<stdio.h>`."}, {"text": "include <stdio.h>", reason: "Preprocessor directives in C, such as `#include`, must always begin with a hash (`#`) symbol."}], indent: 0, explanation: "Include for I/O." },
    { "correct": "// The `##` operator, or token-paster, concatenates two tokens in a macro expansion.", distractors: [{"text": "// The `##` operator creates a string from a token.", reason: "This is incorrect. That is the job of the stringizing operator (`#`). The token-pasting operator (`##`) joins two tokens into a single new token."}, {"text": "// The `##` operator compares two tokens.", reason: "This is false. `##` is a preprocessor operator for concatenation, not a comparison operator like `==`."}], indent: 0, explanation: "Explain the `##` operator." },
    { "correct": "// It allows us to generate code dynamically at compile time.", distractors: [{"text": "// It allows us to generate code at runtime.", reason: "This is a key distinction. The preprocessor runs *before* compilation, so code generation with macros happens at compile time, not at runtime."}, {"text": "// It makes the program run faster.", reason: "While macros can sometimes result in faster code by avoiding function call overhead, their main purpose here is code generation, not necessarily performance."}], indent: 0, explanation: "Explain its use case." },
    { "correct": "#define CREATE_VARIABLE(type, name) type var_##name", distractors: [{"text":"#define CREATE_VARIABLE(type, name) type var_#name", reason:"The stringizing operator `#` would create a string literal \"name\", resulting in `type var_\"name\"`, which is a syntax error. `##` is needed to paste `var_` and `name` together into a single identifier."}, {"text": "#define CREATE_VARIABLE(type, name) type var_ name", reason: "Without the `##` operator, the preprocessor would see `var_` and `name` as two separate tokens, resulting in an invalid variable name (`int var_ counter;`)."}], indent: 0, explanation: "Define a macro to declare a variable with a prefixed name." },
    { "correct": "#define CALL_FUNCTION(name) func_##name()", distractors: [{"text": "#define CALL_FUNCTION(name) \"func_\"##name()", reason: "The `##` operator works on preprocessor tokens, not string literals. This would be a syntax error."}, {"text": "#define CALL_FUNCTION(name) func_name()", reason: "This would not use the macro argument. It would expand to the literal text `func_name()` every time, regardless of the argument passed to `CALL_FUNCTION`."}], indent: 0, explanation: "Define a macro to call a function with a prefixed name." },
    { "correct": "// Define some functions that the macro can call", distractors: [{"text": "// The macro defines these functions for us", reason: "This is false. The macro only generates *calls* to functions; the functions themselves must be defined separately using standard C syntax."}, {"text": "// Include a library for these functions", reason: "These are custom functions defined directly in our code, not part of a standard library."}], indent: 0, explanation: "Comment on function definitions." },
    { "correct": "void func_start() { printf(\"Start function called.\\n\"); }", distractors: [{"text": "void func_start; { ... }", reason: "Function definitions should not have a semicolon after the parentheses."}, {"text": "func_start() { ... }", reason: "All functions in C must have an explicitly stated return type, such as `void` if it returns nothing."}], indent: 0, explanation: "Define the start function." },
    { "correct": "void func_stop() { printf(\"Stop function called.\\n\"); }", distractors: [{"text": "void stop() { ... }", reason: "This function name does not match the pattern `func_...` that our `CALL_FUNCTION` macro expects, so `CALL_FUNCTION(stop)` would fail to call it."}, {"text": "int func_stop() { ... }", reason: "While this would compile, it's good practice to define functions as `void` if they do not explicitly return a value."}], indent: 0, explanation: "Define the stop function." },
    { "correct": "int main() {", distractors: [{"text": "void main() {", reason: "The C standard requires `main` to return an `int` to signal its exit status to the operating system."}, {"text": "int main(void) {", reason: "This is also correct and often preferred, as it explicitly states that the main function takes no arguments."}], indent: 0, explanation: "Start main function." },
    { "correct": "printf(\"--- Using `##` to create variable names ---\\n\");", distractors: [{"text": "puts(\"--- Using `##` to create variable names ---\");", reason: "`puts` is a simpler alternative that also works here, as it prints a string literal and adds a newline automatically."}], indent: 1, explanation: "Header for the variable example." },
    { "correct": "// This line `CREATE_VARIABLE(int, counter);` will expand to `int var_counter;`", distractors: [{"text": "// This line will expand to `int var_name;`", reason: "This is incorrect. The preprocessor replaces the parameter `name` with the argument `counter` *before* pasting, resulting in `var_counter`."}, {"text": "// This line will expand to `int var_\"counter\";`", reason: "This is what would happen if you used the stringizing operator `#` instead of the token-pasting operator `##`."}], indent: 1, explanation: "Explain the macro expansion." },
    { "correct": "CREATE_VARIABLE(int, counter);", distractors: [{"text": "CREATE_VARIABLE int counter;", reason: "Macros must be called with their arguments inside parentheses, just like functions."}, {"text": "int var_counter;", reason: "This is the code that the macro expands to. The point of the exercise is to use the macro to generate this code, not write it manually."}], indent: 1, explanation: "Use the macro to declare an integer." },
    { "correct": "CREATE_VARIABLE(double, temperature);", distractors: [{"text": "CREATE_VARIABLE(\"double\", \"temperature\");", reason: "Macro arguments for types and names should be identifiers, not string literals. The preprocessor works with tokens, not strings."}, {"text": "CREATE_VARIABLE(double);", reason: "This would cause a compilation error because the macro expects two arguments (`type` and `name`), but only one was provided."}], indent: 1, explanation: "Use the macro to declare a double." },
    { "correct": "// Now we can use the variables that the macro created.", distractors: [{"text": "// The variables only exist inside the macro.", reason: "This is false. The macro generates code that is placed directly into the `main` function, so the variables exist within the scope of `main`."}], indent: 1, explanation: "Comment on using the generated variables." },
    { "correct": "var_counter = 100;", distractors: [{"text": "counter = 100;", reason: "This is a key error. The macro created a variable named `var_counter`. The identifier `counter` by itself was only a macro argument and does not exist as a variable."}, {"text": "CREATE_VARIABLE(int, counter) = 100;", reason: "The macro expands to a declaration (`int var_counter;`), which is a statement, not an expression that can be assigned a value."}], indent: 1, explanation: "Assign a value to the generated integer variable." },
    { "correct": "var_temperature = 98.6;", distractors: [{"text": "temperature = 98.6;", reason: "This is incorrect. The actual variable created by the macro is `var_temperature`. The name `temperature` alone is not a declared variable in this scope."}, {"text": "var_##temperature = 98.6;", reason: "The `##` operator is only used inside a `#define` directive. In regular code, this is not valid syntax."}], indent: 1, explanation: "Assign a value to the generated double variable." },
    { "correct": "printf(\"var_counter = %d\\n\", var_counter);", distractors: [{"text": "printf(\"counter = %d\\n\", counter);", reason: "This would result in a compile error, as `counter` is not a declared variable. You must use the actual variable name, `var_counter`."}, {"text": "printf(\"var_counter = %f\\n\", var_counter);", reason: "`%f` is the format specifier for a `double`. Using it for an `int` will result in incorrect, garbage output."}], indent: 1, explanation: "Print the integer's value." },
    { "correct": "printf(\"var_temperature = %f\\n\", var_temperature);", distractors: [{"text": "printf(\"var_temperature = %d\\n\", var_temperature);", reason: "`%d` is the format specifier for an `int`. Using it to print a `double` will result in meaningless output."}, {"text": "printf(\"temperature = %f\\n\", temperature);", reason: "This will not compile because no variable named `temperature` exists. The variable is `var_temperature`."}], indent: 1, explanation: "Print the double's value." },
    { "correct": "printf(\"\\n--- Using `##` to create function calls ---\\n\");", distractors: [{"text": "printf(\"--- Calling Functions ---\");", reason: "This works, but the original is more descriptive because it mentions the specific C feature (`##`) being used to achieve the goal."}], indent: 1, explanation: "Header for the function call example." },
    { "correct": "// `CALL_FUNCTION(start);` will expand to `func_start();`", distractors: [{"text": "// `CALL_FUNCTION(start);` will call `func_name()`.", reason: "This is incorrect. The macro argument `start` replaces the parameter `name`, resulting in `func_start()`."}, {"text": "// This macro defines the function `func_start()`", reason: "This is false. The function `func_start` must already exist. The macro only generates the code to *call* it."}], indent: 1, explanation: "Explain the next macro expansion." },
    { "correct": "CALL_FUNCTION(start);", distractors: [{"text": "CALL_FUNCTION(\"start\");", reason: "The argument should be the token `start`, not the string literal `\"start\"`. The preprocessor would fail to paste `func_` and `\"start\"`."}, {"text": "func_start();", reason: "This is the code that the macro generates. The purpose of the exercise is to use the macro, not to write the code it produces manually."}], indent: 1, explanation: "Use the macro to call the start function." },
    { "correct": "CALL_FUNCTION(stop);", distractors: [{"text": "CALL_FUNCTION(end);", reason: "This would expand to `func_end();`. Since we have not defined a function with that name, this would result in a linker error."}, {"text": "CALL_FUNCTION stop;", reason: "Macro arguments must be enclosed in parentheses, like `CALL_FUNCTION(stop)`."}], indent: 1, explanation: "Use the macro to call the stop function." },
    { "correct": "return 0; }", distractors: [{"text": "return 1; }", reason: "Returning 1 conventionally signals an error occurred. To indicate success, `main` should return 0."}, {"text": "}", reason: "While modern C compilers will implicitly add `return 0;`, explicitly stating it is standard practice for clarity and portability."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 68: Wide Characters and Locales
    {
        goal: "Use wide characters (`wchar_t`) and set the program's locale to correctly handle and print non-ASCII text.",
        concepts: "Wide characters, `<wchar.h>`, `<locale.h>`, `wchar_t`, `L` prefix, `wprintf`, `setlocale`",
        sequence: [
    { "correct": "#include <stdio.h>", distractors: [{"text": "#include <io.h>", reason: "`<io.h>` is not a standard C header. All standard I/O functions like `printf` are in `<stdio.h>`."}, {"text": "include <stdio.h>", reason: "Preprocessor directives in C, like `#include`, must always start with a hash (`#`) symbol."}], indent: 0, explanation: "Include for standard I/O." },
    { "correct": "#include <wchar.h>", distractors: [{"text": "#include <widechar.h>", reason: "There is no standard C header named `<widechar.h>`. The correct header for wide character types and functions is `<wchar.h>`."}, {"text": "// No include needed for wchar_t", reason: "This is false. `wchar_t` is a type, and its related functions like `wprintf` are defined in the `<wchar.h>` header."}], indent: 0, explanation: "Include the header for wide character functions and types." },
    { "correct": "#include <locale.h>", distractors: [{"text": "#include <localize.h>", reason: "There is no standard C header named `<localize.h>`. The `setlocale` function is defined in `<locale.h>`."}, {"text": "#include <stdlib.h>", reason: "While `<stdlib.h>` contains some localization functions, `setlocale` itself is specifically in `<locale.h>`."}], indent: 0, explanation: "Include the header for locale settings." },
    { "correct": "int main() {", distractors: [{"text": "void main() {", reason: "The C standard requires `main` to return an `int` to the operating system to signal its exit status."}, {"text": "int main(void) {", reason: "This is also a correct and often preferred way to define `main`, making it explicit that it takes no command-line arguments."}], indent: 0, explanation: "Start main function." },
    { "correct": "// A normal char string cannot reliably store characters outside the ASCII set.", distractors: [{"text": "// A `char` can store any character.", reason: "This is false. A `char` can typically only store 256 different values, which is not enough for all characters in global languages. How multi-byte characters are stored is implementation-defined (like UTF-8)."}], indent: 1, explanation: "Explain the limitation of `char`." },
    { "correct": "const char* narrow_string = \"Euro: €\";", distractors: [{"text": "char narrow_string[] = 'Euro: €';", reason: "Single quotes `'` are for single character literals in C. String literals must always use double quotes `\"\"`."}, {"text": "char* narrow_string = \"Euro: €\";", reason: "This is valid but deprecated. `const char*` is safer for pointing to a string literal, as it prevents accidental modification."}], indent: 1, explanation: "A narrow string. How the '€' is stored is implementation-defined (e.g., UTF-8)." },
    { "correct": "// A wide character string uses `wchar_t` and is prefixed with `L`.", distractors: [{"text": "// A wide character string is declared with `string`.", reason: "C has no built-in `string` type. A string is a `char*` or `wchar_t*`. `string` is a C++ class."}], indent: 1, explanation: "Introduce wide strings." },
    { "correct": "const wchar_t* wide_string = L\"Euro: €, Złoty: zł, Pi: π\";", distractors: [{"text":"const wchar_t* wide_string = \"Euro: €, Złoty: zł, Pi: π\";", reason:"A wide string literal must be prefixed with `L` to tell the compiler to create an array of `wchar_t` characters instead of standard `char` characters."}, {"text": "wchar_t wide_string[] = L\"...\";", reason: "This is also a correct way to declare a wide string. Using `const wchar_t*` points to a read-only literal, which is good practice if the string won't be modified."}], indent: 1, explanation: "Declare a wide character string literal." },
    { "correct": "// To correctly print wide characters, we need to set the program's locale.", distractors: [{"text": "// Wide characters print automatically.", reason: "This is false. Without the correct locale set, the I/O system won't know how to convert the wide characters to a byte stream that the console can understand, often resulting in garbage output."}], indent: 1, explanation: "Explain the need for setting a locale." },
    { "correct": "// An empty string \"\" tells `setlocale` to use the user's default environment locale.", distractors: [{"text": "// Using `NULL` will set the default locale.", reason: "This is incorrect. Passing `NULL` to `setlocale` makes it *query* the current locale without changing it. An empty string `\"\"` is used to *set* the locale to the user's environment default."}], indent: 1, explanation: "Explain the `setlocale` argument." },
    { "correct": "setlocale(LC_ALL, \"\");", distractors: [{"text":"setlocale(LC_CTYPE, \"\");", reason:"`LC_CTYPE` sets only the character handling category. For I/O operations to work correctly with wide characters, all categories should be set via `LC_ALL`."}, {"text": "setlocale(\"\");", reason: "The `setlocale` function requires two arguments: the category (e.g., `LC_ALL`) and the locale name string."}], indent: 1, explanation: "Set the program's locale to the system default." },
    { "correct": "printf(\"--- Printing Strings ---\\n\");", distractors: [{"text": "puts(\"--- Printing Strings ---\");", reason: "`puts` is also a valid way to print a simple string literal, and it automatically adds a newline."}, {"text": "wprintf(L\"--- Printing Strings ---\\n\");", reason: "`wprintf` is for wide character strings. For a simple ASCII string like this, standard `printf` is perfectly fine and more conventional."}], indent: 1, explanation: "Header." },
    { "correct": "printf(\"Attempting to print narrow string: %s\\n\", narrow_string);", distractors: [{"text": "wprintf(L\"Attempting to print narrow string: %s\\n\", narrow_string);", reason: "`wprintf` expects the `%s` specifier to correspond to a narrow string (`char*`), but the format string itself must be wide. While this might work, it's confusing. Use `printf` for narrow strings."}], indent: 1, explanation: "Printing the narrow string. It may or may not display correctly depending on the console." },
    { "correct": "// To print a wide string, we must use `wprintf`.", distractors: [{"text": "// `printf` can print any string.", reason: "This is a common misconception. `printf` is for narrow (`char*`) strings. It is not guaranteed to handle wide character strings correctly, which is why `wprintf` exists."}], indent: 1, explanation: "Introduce `wprintf`." },
    { "correct": "// It uses a wide format string (prefixed with `L`) and the `%ls` specifier.", distractors: [{"text": "// It uses the `%ws` specifier.", reason: "The specifier for a wide string is `%ls` (for 'long string'), not `%ws`."}, {"text": "// The `L` prefix is optional for the format string.", reason: "This is false. The first argument to `wprintf` must be a wide character string, which requires the `L` prefix."}], indent: 1, explanation: "Explain `wprintf` format specifiers." },
    { "correct": "wprintf(L\"Printing wide string with wprintf: %ls\\n\", wide_string);", distractors: [{"text":"printf(\"Wide string: %ls\\n\", wide_string);", reason:"While some modern systems might handle this, `printf` is not guaranteed to correctly process the `%ls` specifier for wide strings. `wprintf` is the standard, portable function for this task."}, {"text":"wprintf(L\"Wide string: %s\\n\", wide_string);", reason:"`wprintf` expects the wide string format specifier (`%ls`). Using the narrow specifier (`%s`) with a wide string argument leads to undefined behavior."}], indent: 1, explanation: "Use `wprintf` to correctly print the wide character string." },
    { "correct": "printf(\"\\n--- Sizing ---\\n\");", distractors: [{"text": "puts(\"\\n--- Sizing ---\");", reason: "`puts` automatically adds a newline, so the initial `\\n` would create an unwanted blank line. `puts(\"--- Sizing ---\")` would be a closer alternative."}], indent: 1, explanation: "Header for size comparison." },
    { "correct": "printf(\"sizeof(char): %zu byte\\n\", sizeof(char));", distractors: [{"text": "printf(\"sizeof(char): %d byte\\n\", sizeof(char));", reason: "The `sizeof` operator returns a value of type `size_t`. The correct format specifier for `size_t` is `%zu`. Using `%d` can fail on systems where `size_t` is larger than `int`."}, {"text": "printf(\"strlen(char): %zu byte\\n\", strlen(\"a\"));", reason: "`strlen` measures the length of a string, while `sizeof` measures the memory size of a type or variable."}], indent: 1, explanation: "`char` is guaranteed to be 1 byte." },
    { "correct": "printf(\"sizeof(wchar_t): %zu bytes\\n\", sizeof(wchar_t));", distractors: [{"text": "printf(\"sizeof(wchar_t): %d bytes\\n\", sizeof(wchar_t));", reason: "The correct, portable format specifier for `size_t` (the type returned by `sizeof`) is `%zu`, not `%d`."}, {"text": "printf(\"sizeof(wchar_t): %zu bytes\\n\", sizeof(L'€'));", reason: "This also correctly gives the size of a single wide character constant, which is equivalent to `sizeof(wchar_t)`."}], indent: 1, explanation: "`wchar_t` is larger, typically 2 or 4 bytes, to accommodate larger character sets." },
    { "correct": "return 0; }", distractors: [{"text": "return 1; }", reason: "Returning 1 conventionally signals an error occurred. To indicate success, `main` should return 0."}, {"text": "}", reason: "While modern C compilers will implicitly return 0 from `main`, explicitly writing `return 0;` is standard practice for clarity and portability."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 69: command-line to-do list
    {
        "goal": "Build a command-line to-do list application that persists tasks to a file.",
        concepts: "structs, dynamic arrays, realloc, file I/O (fprintf, fscanf), argc/argv parsing, strcmp",
        sequence: [
    { "correct": "#include <stdio.h>", distractors: [{"text": "#include <io.h>", reason: "The standard C header for Input/Output functions is `<stdio.h>`, not `<io.h>`."}], indent: 0, explanation: "Include for standard input/output functions." },
    { "correct": "#include <stdlib.h>", distractors: [{"text": "#include <memory.h>", reason: "The standard library header for memory allocation functions like `malloc` and `realloc` is `<stdlib.h>`."}], indent: 0, explanation: "Include for memory allocation (`malloc`, `realloc`, `free`) and string conversion." },
    { "correct": "#include <string.h>", distractors: [{"text": "#include <strings.h>", reason: "While some systems have `<strings.h>`, the standard C header containing `strcpy`, `strcmp`, etc., is `<string.h>`."}], indent: 0, explanation: "Include for string manipulation functions like `strcpy` and `strcmp`." },
    { "correct": "#define MAX_TASK_LEN 256", distractors: [{"text": "const int MAX_TASK_LEN = 256;", reason: "Using a `const int` is also a valid way to create a constant. A `#define` is a preprocessor macro that replaces the text before compilation."}], indent: 0, explanation: "Define a constant for the maximum length of a single task description." },
    { "correct": "#define TASKS_FILENAME \"tasks.txt\"", distractors: [{"text": "#define TASKS_FILENAME tasks.txt", reason: "When defining a string constant with `#define`, the value must be enclosed in double quotes to make it a string literal."}], indent: 0, explanation: "Define the filename where tasks will be stored." },
    { "correct": "// Define a structure to hold information about a single task.", distractors: [{"text": "// A class for a task", reason: "C does not have classes; that is a C++ concept. The equivalent in C is a structure (`struct`)."}], indent: 0, explanation: "Comment explaining the purpose of the Task struct." },
    { "correct": "typedef struct {", distractors: [{"text": "struct Task {", reason: "This also works, but then you must declare variables as `struct Task t;`. Using `typedef` allows the more convenient `Task t;`."}], indent: 0, explanation: "Begin defining the Task structure with a typedef for convenience." },
    { "correct": "  int id;", distractors: [{"text": "  unsigned int id;", reason: "Using `unsigned int` is a good choice for an ID that will never be negative."}], indent: 1, explanation: "A unique identifier for each task." },
    { "correct": "  char description[MAX_TASK_LEN];", distractors: [{"text": "  char* description;", reason: "Using a `char*` would require separate dynamic memory allocation (`malloc`) for every single task's description, adding significant complexity."}], indent: 1, explanation: "The text description of the task." },
    { "correct": "  int is_complete;", distractors: [{"text": "  bool is_complete;", reason: "To use the `bool` type, you must first `#include <stdbool.h>`. An `int` is often used as a simple boolean flag in older C code."}], indent: 1, explanation: "A flag (0 or 1) to indicate if the task is completed." },
    { "correct": "} Task;", distractors: [{"text": "};", reason: "A standalone `struct` definition ends with `};`. Because we are using `typedef`, we must include the new type name (`Task`) before the final semicolon."}], indent: 0, explanation: "Create the alias `Task` for our struct." },
    { "correct": "// Global variables to hold the list of tasks.", distractors: [{"text": "// It is best practice to use global variables.", reason: "This is generally false. Global variables can make code harder to reason about. They are used here for simplicity, but in a larger application, it's often better to pass state through function parameters."}], indent: 0, explanation: "Comment explaining the global task list." },
    { "correct": "Task* tasks = NULL;", distractors: [{"text": "Task tasks[100];", reason: "This creates a static array with a fixed limit of 100 tasks. A dynamic array (`Task*`) allows the list to grow to any size."}], indent: 0, explanation: "A dynamic array to store all tasks. Initialize to NULL." },
    { "correct": "int task_count = 0;", distractors: [{"text": "int task_count;", reason: "An uninitialized global variable is automatically set to zero, but it is much clearer and better practice to initialize it explicitly."}], indent: 0, explanation: "A counter for the number of tasks currently in the list." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text": "// Function Headers", reason: "The more standard term for these forward declarations is 'prototypes'."}], indent: 0, explanation: "Declare all our functions upfront for organization." },
    { "correct": "void load_tasks_from_file();", distractors: [{"text": "int load_tasks_from_file();", reason: "The function's purpose is to modify a global state, not to calculate and return a value, so `void` is an appropriate return type."}], indent: 0, explanation: "Prototype for the function that loads tasks from the file." },
    { "correct": "void save_tasks_to_file();", distractors: [{"text": "void save_tasks_to_file(Task* tasks_to_save);", reason: "Since `tasks` is a global variable, we don't need to pass it as a parameter. If it were a local variable in `main`, this would be necessary."}], indent: 0, explanation: "Prototype for the function that saves tasks to the file." },
    { "correct": "void add_task(const char* description);", distractors: [{"text": "void add_task(char* description);", reason: "Using `const` is better because it indicates that the `add_task` function promises not to modify the input `description` string."}], indent: 0, explanation: "Prototype for adding a new task." },
    { "correct": "void list_tasks();", distractors: [{"text": "void list_tasks(void);", reason: "Specifying `(void)` is a clearer way to indicate a function takes no arguments, but empty parentheses `()` are also allowed."}], indent: 0, explanation: "Prototype for listing all tasks." },
    { "correct": "void complete_task(int id);", distractors: [{"text": "void complete_task(char* id);", reason: "The task ID is conceptually a number. It's better to work with it as an `int` rather than a string."}], indent: 0, explanation: "Prototype for marking a task as complete." },
    { "correct": "void print_usage();", distractors: [{"text": "void help();", reason: "A different function name would work, but `print_usage` is a common and descriptive convention for this purpose."}], indent: 0, explanation: "Prototype for printing help information." },
    { "correct": "// --- Main Function: Program Entry Point & Argument Parsing ---", distractors: [{"text": "// Main function", reason: "This is correct, but the original is more descriptive about the function's specific roles in this program."}], indent: 0, explanation: "The main driver of our application." },
    { "correct": "int main(int argc, char* argv[]) {", distractors: [{"text": "int main() {", reason: "To access command-line arguments, `main` must be defined with the `argc` (argument count) and `argv` (argument vector) parameters."}], indent: 0, explanation: "Start main, accepting command-line arguments." },
    { "correct": "load_tasks_from_file();", distractors: [{"text": "save_tasks_to_file();", reason: "Calling `save_tasks_to_file` at the start would erase any existing tasks before they could be loaded."}], indent: 1, explanation: "The first action is to load any existing tasks from our file." },
    { "correct": "if (argc < 2) {", distractors: [{"text": "if (argc == 1) {", reason: "This is also correct. `argc` is 1 when only the program name itself is present, meaning no command was given."}], indent: 1, explanation: "Check if the user provided any command." },
    { "correct": "  print_usage();", distractors: [{"text": "  printf(\"Error: No command given.\\n\");", reason: "Printing a single error message is okay, but calling a dedicated `print_usage` function is better because it gives the user helpful instructions."}], indent: 2, explanation: "If no command is given, show the usage instructions." },
    { "correct": "  return 1;", distractors: [{"text": "  return 0;", reason: "By convention, returning a non-zero value like 1 indicates that the program terminated with an error."}], indent: 2, explanation: "Exit with an error code." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon is not used after the closing brace of an `if` block."}], indent: 1, explanation: "Close the argument count check." },
    { "correct": "// Compare the first argument to determine the command.", distractors: [{"text": "// Check argv[1]", reason: "This is too brief. The original comment is better because it explains *why* we are checking it (to determine the command)."}], indent: 1, explanation: "Comment explaining command parsing." },
    { "correct": "if (strcmp(argv[1], \"add\") == 0) {", distractors: [{"text": "if (argv[1] == \"add\") {", reason: "This is a critical error. You cannot compare strings in C with `==`. This compares pointer addresses, not content. You must use `strcmp`."}], indent: 1, explanation: "Check if the command is 'add'." },
    { "correct": "  if (argc < 3) {", distractors: [{"text": "  if (argv[2] == NULL) {", reason: "This is also a valid way to check if the second argument is missing."}], indent: 2, explanation: "The 'add' command requires a task description." },
    { "correct": "    printf(\"Error: 'add' command requires a description.\\n\");", distractors: [{"text": "    puts(\"Error: 'add' command requires a description.\");", reason: "`puts` is a simpler alternative for printing a fixed string followed by a newline."}], indent: 3, explanation: "Print an error if the description is missing." },
    { "correct": "    print_usage();", distractors: [{"text": "    return 1;", reason: "It's better to show the usage instructions to the user before exiting."}], indent: 3, explanation: "Show usage." },
    { "correct": "  } else {", distractors: [{"text": "  } else if (argc >= 3) {", reason: "This `if` is redundant. If `argc < 3` is false, we already know `argc >= 3` must be true."}], indent: 2, explanation: "If the description exists..." },
    { "correct": "    add_task(argv[2]);", distractors: [{"text": "    add_task(\"argv[2]\");", reason: "This would pass the literal string \"argv[2]\" to the function, not the content of the command-line argument."}], indent: 3, explanation: "Call the add_task function with the provided description." },
    { "correct": "  }", distractors: [{"text": "};", reason: "A semicolon is not used after the closing brace of an `if-else` block."}], indent: 2, explanation: "Close the add command logic." },
    { "correct": "} else if (strcmp(argv[1], \"list\") == 0) {", distractors: [{"text": "} if (strcmp(argv[1], \"list\") == 0) {", reason: "To chain conditional logic, you must use `else if`, not a separate `if`."}], indent: 1, explanation: "Check if the command is 'list'." },
    { "correct": "  list_tasks();", distractors: [{"text": "  printf(\"%s\\n\", tasks);", reason: "You cannot print an array of structs directly. You need a dedicated function like `list_tasks` to loop through and format the output."}], indent: 2, explanation: "Call the function to list all tasks." },
    { "correct": "} else if (strcmp(argv[1], \"complete\") == 0) {", distractors: [{"text": "if (strcmp(argv[1], \"complete\") == 0) {", reason: "Without the `else`, this block would execute even if a previous command like 'add' was already handled."}], indent: 1, explanation: "Check if the command is 'complete'." },
    { "correct": "  if (argc < 3) {", distractors: [{"text": "  if (argc != 3) {", reason: "This is too strict. It would fail for commands like `todo complete 2 extra_arg`, which should ideally work. `argc < 3` correctly checks only for the minimum required arguments."}], indent: 2, explanation: "The 'complete' command requires a task ID." },
    { "correct": "    printf(\"Error: 'complete' command requires a task ID.\\n\");", distractors: [{"text": "    perror(\"Missing argument\");", reason: "`perror` is for system errors (like file I/O failure), not for user input validation errors."}], indent: 3, explanation: "Print an error if the ID is missing." },
    { "correct": "    print_usage();", distractors: [{"text": "    return;", reason: "This would cause a compiler warning. The `main` function must return an `int`, not be `void`."}], indent: 3, explanation: "Show usage." },
    { "correct": "  } else {", distractors: [{"text": "  }", reason: "An `else` block is necessary here to contain the logic that should only run when the `if` condition (missing argument) is false."}], indent: 2, explanation: "If the ID is provided..." },
    { "correct": "    complete_task(atoi(argv[2]));", distractors: [{"text": "    complete_task(argv[2]);", reason: "`argv[2]` is a string (`char*`). The function expects an `int`. You must convert the string to an integer using a function like `atoi`."}], indent: 3, explanation: "Convert the ID from a string to an integer with `atoi` and call the function." },
    { "correct": "  }", distractors: [{"text": "};", reason: "A semicolon is not used after a closing brace `}`."}], indent: 2, explanation: "Close the complete command logic." },
    { "correct": "} else {", distractors: [{"text": "}", reason: "Without an `else` block, an unknown command would simply do nothing, providing no feedback to the user."}], indent: 1, explanation: "Handle any unknown commands." },
    { "correct": "  printf(\"Error: Unknown command '%s'\\n\", argv[1]);", distractors: [{"text": "  printf(\"Error: Unknown command\\n\");", reason: "This is okay, but it's better to print the specific command the user typed to give them more context."}], indent: 2, explanation: "Print an error for an unrecognized command." },
    { "correct": "  print_usage();", distractors: [{"text": "  // Do nothing", reason: "It's much more user-friendly to show the correct usage instructions after an invalid command."}], indent: 2, explanation: "Show usage." },
    { "correct": "}", distractors: [{"text": "end;", reason: "C uses curly braces `{}` to denote code blocks, not keywords like `end`."}], indent: 1, explanation: "Close the command parsing logic." },
    { "correct": "free(tasks);", distractors: [{"text": "// No free needed for global variables", reason: "This is false. Any memory allocated with `malloc`/`realloc` must be explicitly freed, regardless of whether the pointer is global or local."}], indent: 1, explanation: "Before exiting, free the memory allocated for the tasks array." },
    { "correct": "return 0;", distractors: [{"text": "return;", reason: "`main` is defined to return an `int`, so it must return an integer value. An empty `return` is only for `void` functions."}], indent: 1, explanation: "Indicate successful execution." },
    { "correct": "}", distractors: [{"text": "end main;", reason: "C uses a closing brace `}` to end a function block, not keywords."}], indent: 0, explanation: "Close the main function." },
    { "correct": "// --- Function Implementations ---", distractors: [{"text": "// Function bodies", reason: "'Implementations' is the more standard term for the code that defines what a function does."}], indent: 0, explanation: "Define the functions declared earlier." },
    { "correct": "void load_tasks_from_file() {", distractors: [{"text": "int load_tasks_from_file() {", reason: "This function's definition must match its prototype, which was declared to return `void`."}], indent: 0, explanation: "Implementation for loading tasks." },
    { "correct": "  FILE* fp = fopen(TASKS_FILENAME, \"r\");", distractors: [{"text": "  FILE* fp = fopen(TASKS_FILENAME, \"w\");", reason: "Using write mode `\"w\"` here would erase the file as soon as it's opened, preventing you from loading any tasks."}], indent: 1, explanation: "Open the tasks file in read mode." },
    { "correct": "  if (fp == NULL) {", distractors: [{"text": "  if (!fp) {", reason: "This is a common and perfectly valid shorthand for checking if a pointer is NULL."}], indent: 1, explanation: "If the file doesn't exist (e.g., first run), it's not an error." },
    { "correct": "    return; // No tasks to load.", distractors: [{"text": "    exit(1);", reason: "The file not existing on the first run is expected behavior, not an error. The program should continue with an empty list."}], indent: 2, explanation: "Simply return and start with an empty list." },
    { "correct": "  }", distractors: [{"text": "};", reason: "A semicolon is not used after the closing brace of an `if` block."}], indent: 1, explanation: "Close the file check." },
    { "correct": "  Task temp_task;", distractors: [{"text": "  Task* temp_task = malloc(sizeof(Task));", reason: "Dynamic allocation is unnecessary here. A temporary stack variable is simpler and automatically cleaned up when the function exits."}], indent: 1, explanation: "A temporary struct to hold data read from a line." },
    { "correct": "  while(fscanf(fp, \"%d,%d,%[^\n]\n\", &temp_task.id, &temp_task.is_complete, temp_task.description) == 3) {", distractors: [{"text": "  while(!feof(fp)) { fscanf(...); }", reason: "This is a common anti-pattern. You should always check the return value of the read function (`fscanf` here), not call `feof` before a read."}], indent: 1, explanation: "Read each line using a format string. `%[^\\n]` reads all characters until a newline." },
    { "correct": "    add_task(temp_task.description); // Add task, but will get a new ID", distractors: [{"text": "    tasks[task_count++] = temp_task;", reason: "This is a logic error. The `tasks` array hasn't been resized yet, so this would write to out-of-bounds memory."}], indent: 2, explanation: "Use our existing `add_task` logic to add the loaded task." },
    { "correct": "    tasks[task_count - 1].is_complete = temp_task.is_complete; // Restore completion status", distractors: [{"text": "    // No need to restore status", reason: "`add_task` sets `is_complete` to 0 by default. We must overwrite it with the status loaded from the file."}], indent: 2, explanation: "Update the completion status from the file." },
    { "correct": "  }", distractors: [{"text": "};", reason: "Semicolons are not used after the closing brace of a `while` loop."}], indent: 1, explanation: "Close the reading loop." },
    { "correct": "  fclose(fp);", distractors: [{"text": "  free(fp);", reason: "`fp` is a `FILE` handle, not a memory block from `malloc`. It must be closed with `fclose`."}], indent: 1, explanation: "Close the file." },
    { "correct": "}", distractors: [{"text": "end;", reason: "Function blocks are closed with `}`, not with keywords like `end`."}], indent: 0, explanation: "Close the load function." },
    { "correct": "void save_tasks_to_file() {", distractors: [{"text": "int save_tasks_to_file() { return 0; }", reason: "The function definition's return type must match the prototype, which was `void`."}], indent: 0, explanation: "Implementation for saving tasks." },
    { "correct": "  FILE* fp = fopen(TASKS_FILENAME, \"w\");", distractors: [{"text": "  FILE* fp = fopen(TASKS_FILENAME, \"a\");", reason: "Append mode `\"a\"` would add the entire task list to the end of the file every time. Write mode `\"w\"` correctly overwrites the file with the current state."}], indent: 1, explanation: "Open the file in write mode, overwriting the old file." },
    { "correct": "  if (fp == NULL) { perror(\"Error saving tasks\"); return; }", distractors: [{"text": "  if (!fp) { perror(\"Error\"); }", reason: "This shorthand `!fp` is also correct. The rest of the original line is needed to handle the error gracefully."}], indent: 1, explanation: "Handle potential errors with opening the file for writing." },
    { "correct": "  for (int i = 0; i < task_count; i++) {", distractors: [{"text": "  int i=0; while(i < task_count) { ... i++; }", reason: "A `while` loop is also a perfectly valid way to write this loop."}], indent: 1, explanation: "Loop through every task in our list." },
    { "correct": "    fprintf(fp, \"%d,%d,%s\\n\", tasks[i].id, tasks[i].is_complete, tasks[i].description);", distractors: [{"text": "    fprintf(fp, \"%d %d %s\\n\", ...);", reason: "Using spaces as delimiters is fine, but commas are more conventional for CSV-style data, especially if task descriptions might contain spaces."}], indent: 2, explanation: "Write the task's data to the file in a comma-separated format." },
    { "correct": "  }", distractors: [{"text": "};", reason: "Semicolons are not used after the closing brace of a `for` loop."}], indent: 1, explanation: "Close the writing loop." },
    { "correct": "  fclose(fp);", distractors: [{"text": "  // fclose is optional", reason: "This is false. If you don't call `fclose`, the write buffer may not be flushed to disk, resulting in a partial or empty file."}], indent: 1, explanation: "Close the file." },
    { "correct": "}", distractors: [{"text": "end function;", reason: "This is not valid C syntax for closing a function block."}], indent: 0, explanation: "Close the save function." },
    { "correct": "void add_task(const char* description) {", distractors: [{"text": "void add_task(const char description[]) {", reason: "In a function parameter, `const char*` and `const char[]` are treated identically by the compiler."}], indent: 0, explanation: "Implementation for adding a task." },
    { "correct": "  task_count++;", distractors: [{"text": "  task_count = task_count + 1;", reason: "This is also correct, but `task_count++` is the more common and concise C idiom."}], indent: 1, explanation: "Increment the total number of tasks." },
    { "correct": "  Task* new_tasks = realloc(tasks, task_count * sizeof(Task));", distractors: [{"text": "  tasks = realloc(tasks, task_count * sizeof(Task));", reason: "This is a dangerous pattern. If `realloc` fails, it returns NULL and overwrites `tasks`, leaking the original memory. Using a temporary pointer is safer."}], indent: 1, explanation: "Resize the dynamic array to make room for the new task. Using a temp pointer is safer but omitted for brevity." },
    { "correct": "  if (new_tasks == NULL) { perror(\"Failed to add task\"); task_count--; return; }", distractors: [{"text": "  if (!new_tasks) { exit(1); }", reason: "Exiting the whole program is too drastic. It's better to print an error, revert the state (`task_count--`), and allow the program to continue or exit gracefully."}], indent: 1, explanation: "Check if reallocation failed and revert the count." },
    { "correct": "  tasks = new_tasks;", distractors: [{"text": "  new_tasks = tasks;", reason: "This is backwards. It assigns the old (and now invalid) pointer to the temporary variable, while `tasks` remains unchanged."}], indent: 1, explanation: "Assign the new memory block back to our global pointer." },
    { "correct": "  tasks[task_count - 1].id = task_count;", distractors: [{"text": "  tasks[task_count - 1].id = task_count + 1;", reason: "This would create 1-based IDs, but since our array is 0-indexed, `task_count` itself works as a simple 1-based ID system."}], indent: 1, explanation: "Set the ID of the new task (simple 1-based indexing)." },
    { "correct": "  tasks[task_count - 1].is_complete = 0;", distractors: [{"text": "  tasks[task_count - 1].is_complete = false;", reason: "To use `false`, you must `#include <stdbool.h>`. Using `0` for false is the traditional C way."}], indent: 1, explanation: "New tasks are not complete by default." },
    { "correct": "  strncpy(tasks[task_count - 1].description, description, MAX_TASK_LEN - 1);", distractors: [{"text": "  strcpy(tasks[task_count-1].description, description);", reason: "`strcpy` is unsafe. If the source `description` is longer than the destination, it will cause a buffer overflow. `strncpy` is safer."}], indent: 1, explanation: "Copy the description into the new task struct using `strncpy` for safety." },
    { "correct": "  tasks[task_count - 1].description[MAX_TASK_LEN - 1] = '\\0';", distractors: [{"text": "  // strncpy adds the null terminator.", reason: "This is a common misconception. `strncpy` will *not* null-terminate if the source string is as long or longer than the size limit. You must ensure null-termination manually."}], indent: 1, explanation: "Ensure the description is null-terminated." },
    { "correct": "  printf(\"Added task %d: '%s'\\n\", task_count, description);", distractors: [{"text": "  puts(\"Task added.\");", reason: "This is a valid confirmation, but printing the actual task provides better feedback to the user."}], indent: 1, explanation: "Print a confirmation message." },
    { "correct": "  save_tasks_to_file();", distractors: [{"text": "  // No need to save yet", reason: "Saving after every change ensures data persistence. If the program crashes before saving, the new task would be lost."}], indent: 1, explanation: "Save the updated list to the file immediately." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon is not used after the closing brace of a function."}], indent: 0, explanation: "Close the add function." },
    { "correct": "void list_tasks() {", distractors: [{"text": "void list_tasks(void) {", reason: "This is also correct and is considered a clearer way to state that a function takes no parameters."}], indent: 0, explanation: "Implementation for listing tasks." },
    { "correct": "  printf(\"\\n--- TO-DO LIST ---\\n\");", distractors: [{"text": "  puts(\"\\n--- TO-DO LIST ---\");", reason: "`puts` automatically adds its own newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Print a header." },
    { "correct": "  if (task_count == 0) {", distractors: [{"text": "  if (!task_count) {", reason: "This is a common and valid shorthand for `task_count == 0`."}], indent: 1, explanation: "Check if there are no tasks." },
    { "correct": "    printf(\"No tasks found.\\n\");", distractors: [{"text": "    puts(\"No tasks found.\");", reason: "This is a simpler and perfectly valid way to print this message."}], indent: 2, explanation: "Message for an empty list." },
    { "correct": "  } else {", distractors: [{"text": "  }", reason: "The `else` block is necessary to contain the code that should only run if there are tasks to list."}], indent: 1, explanation: "If there are tasks..." },
    { "correct": "    for (int i = 0; i < task_count; i++) {", distractors: [{"text": "    for (int i = 0; i <= task_count - 1; i++) {", reason: "This is also a correct way to write the loop condition."}], indent: 2, explanation: "Loop through all tasks." },
    { "correct": "      char status_char = tasks[i].is_complete ? 'X' : ' ';", distractors: [{"text": "      char status_char; if(tasks[i].is_complete) { status_char = 'X'; } else { status_char = ' '; }", reason: "This `if/else` block is also correct. The ternary operator `? :` is just a more compact way to write the same logic."}], indent: 3, explanation: "Use a ternary operator to determine the status character." },
    { "correct": "      printf(\"[%c] %d: %s\\n\", status_char, tasks[i].id, tasks[i].description);", distractors: [{"text": "      printf(\"%d: %s [%c]\\n\", tasks[i].id, tasks[i].description, status_char);", reason: "This is a valid alternative formatting choice."}], indent: 3, explanation: "Print the formatted task line." },
    { "correct": "    }", distractors: [{"text": "};", reason: "A semicolon should not follow the closing brace of a `for` loop."}], indent: 2, explanation: "Close the loop." },
    { "correct": "  }", distractors: [{"text": "};", reason: "A semicolon should not follow the closing brace of an `else` block."}], indent: 1, explanation: "Close the else block." },
    { "correct": "  printf(\"--------------------\\n\");", distractors: [{"text": "  puts(\"--------------------\");", reason: "`puts` is a simpler and equally valid way to print the footer line."}], indent: 1, explanation: "Print a footer." },
    { "correct": "}", distractors: [{"text": "end;", reason: "C uses `}` to close a code block, not keywords."}], indent: 0, explanation: "Close the list function." },
    { "correct": "void complete_task(int id) {", distractors: [{"text": "int complete_task(int id) {", reason: "This function's definition must match its prototype, which was declared to return `void`."}], indent: 0, explanation: "Implementation for completing a task." },
    { "correct": "  if (id <= 0 || id > task_count) {", distractors: [{"text": "  if (id < 1 || id > task_count) {", reason: "This is also a correct way to write the same validation check."}], indent: 1, explanation: "Validate the provided ID." },
    { "correct": "    printf(\"Error: Invalid task ID %d\\n\", id);", distractors: [{"text": "    fprintf(stderr, \"Error: Invalid task ID %d\\n\", id);", reason: "Printing errors to `stderr` instead of `stdout` is a common and good practice."}], indent: 2, explanation: "Print an error for an invalid ID." },
    { "correct": "    return;", distractors: [{"text": "    exit(1);", reason: "This is a recoverable user error, not a critical program failure. It's better to print a message and `return` rather than terminating the whole program."}], indent: 2, explanation: "Exit the function." },
    { "correct": "  }", distractors: [{"text": "};", reason: "Semicolons do not follow the closing brace of an `if` block."}], indent: 1, explanation: "Close the validation." },
    { "correct": "  tasks[id - 1].is_complete = 1;", distractors: [{"text": "  tasks[id].is_complete = 1;", reason: "This is a classic off-by-one error. Task IDs are 1-based for the user, but C arrays are 0-based, so you must subtract 1."}], indent: 1, explanation: "Set the completion flag for the correct task (adjusting for 0-based array index)." },
    { "correct": "  printf(\"Completed task %d: '%s'\\n\", id, tasks[id-1].description);", distractors: [{"text": "  printf(\"Completed task %d\\n\", id);", reason: "This is okay, but printing the description of the completed task provides better confirmation to the user."}], indent: 1, explanation: "Print a confirmation message." },
    { "correct": "  save_tasks_to_file();", distractors: [{"text": "  // No need to save here", reason: "The program should save the state after every modification to ensure data is not lost if the program terminates unexpectedly."}], indent: 1, explanation: "Save the changes to the file." },
    { "correct": "}", distractors: [{"text": "end function;", reason: "This is not valid C syntax."}], indent: 0, explanation: "Close the complete function." },
    { "correct": "void print_usage() {", distractors: [{"text": "void print_usage(void) {", reason: "This is an equally valid and often preferred way to define a function that takes no arguments."}], indent: 0, explanation: "Implementation for printing usage." },
    { "correct": "  printf(\"\\nUsage:\\n\");", distractors: [{"text": "  puts(\"\\nUsage:\");", reason: "`puts` automatically adds a newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Print usage header." },
    { "correct": "  printf(\"  todo add \\\"<task description>\\\"  - Adds a new task\\n\");", distractors: [{"text": "  puts(\"  todo add \\\"<task description>\\\"  - Adds a new task\");", reason: "`puts` is also a valid way to print this line."}], indent: 1, explanation: "Explain the 'add' command." },
    { "correct": "  printf(\"  todo list                       - Lists all tasks\\n\");", distractors: [{"text": "  puts(\"  todo list                       - Lists all tasks\");", reason: "`puts` is also a valid way to print this line."}], indent: 1, explanation: "Explain the 'list' command." },
    { "correct": "  printf(\"  todo complete <task_id>         - Marks a task as complete\\n\");", distractors: [{"text": "  puts(\"  todo complete <task_id>         - Marks a task as complete\");", reason: "`puts` is also a valid way to print this line."}], indent: 1, explanation: "Explain the 'complete' command." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon is not needed after a function's closing brace."}], indent: 0, explanation: "Close the print_usage function." }
]
    },
    // Level 70: analyze data from CSV files
    {
        "goal": "Read and analyze data from a CSV file containing city population records.",
        concepts: "fgets, strtok, realloc, structs, file I/O, atof, error handling",
        sequence:[
    { "correct": "#include <stdio.h>", distractors: [{"text": "#include <stdlib.h>", reason: "`printf` and file operations like `fopen` and `fgets` are part of the Standard Input/Output library, which is `<stdio.h>`."}], indent: 0, explanation: "Include for file operations and printing." },
    { "correct": "#include <stdlib.h>", distractors: [{"text": "#include <string.h>", reason: "`realloc` and `atof` are general utilities found in the Standard Library, `<stdlib.h>`, not the string library."}], indent: 0, explanation: "Include for memory management and `atof`." },
    { "correct": "#include <string.h>", distractors: [{"text": "#include <ctype.h>", reason: "`strtok` and `strcpy` are string manipulation functions, which are located in `<string.h>`. `<ctype.h>` is for character classification."}], indent: 0, explanation: "Include for `strtok`, `strcpy`." },
    { "correct": "#define MAX_LINE_LEN 512", distractors: [{"text": "const int MAX_LINE_LEN = 512;", reason: "This is also a valid way to create a constant. A `#define` is a preprocessor macro, which performs a text replacement before compilation."}], indent: 0, explanation: "Define max length for a line read from the file." },
    { "correct": "#define MAX_FIELD_LEN 128", distractors: [{"text": "#define MAX_FIELD_LEN, 128", reason: "The syntax for `#define` is `#define NAME value`. A comma is not used."}], indent: 0, explanation: "Define max length for any single field (like city name)." },
    { "correct": "// Structure to hold the parsed data for one city.", distractors: [{"text": "// A class to hold city data", reason: "C uses `struct` (structures) to group data. `class` is a C++ keyword."}], indent: 0, explanation: "Comment explaining the CityData struct." },
    { "correct": "typedef struct {", distractors: [{"text": "struct CityData {", reason: "This is also correct, but you would then have to declare variables as `struct CityData c;`. The `typedef` allows for the shorter `CityData c;`."}], indent: 0, explanation: "Begin defining the CityData struct." },
    { "correct": "  char name[MAX_FIELD_LEN];", distractors: [{"text": "  char* name;", reason: "Using `char*` would require you to dynamically allocate memory for the name of *every single city*, which adds significant complexity. A fixed-size array is simpler."}], indent: 1, explanation: "The name of the city." },
    { "correct": "  char country[MAX_FIELD_LEN];", distractors: [{"text": "  char* country[MAX_FIELD_LEN];", reason: "This declares an array of character pointers, which is incorrect. We need a single array of characters for the country name."}], indent: 1, explanation: "The country of the city." },
    { "correct": "  double population_millions;", distractors: [{"text": "  int population_millions;", reason: "Since the population is in millions, it will likely have fractional parts. `double` is the appropriate type for floating-point numbers."}], indent: 1, explanation: "The city's population in millions." },
    { "correct": "} CityData;", distractors: [{"text": "};", reason: "When using `typedef` with a struct definition, you must provide the new type alias name (`CityData`) before the final semicolon."}], indent: 0, explanation: "Create the `CityData` alias." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text": "// Function Declarations", reason: "'Prototype' is the standard C term for a function declaration that specifies its name, return type, and parameters before its actual implementation."}], indent: 0, explanation: "Declare functions before use." },
    { "correct": "int parse_csv(const char* filename, CityData** data_arr);", distractors: [{"text": "int parse_csv(const char* filename, CityData* data_arr);", reason: "This is a key error. The function needs to modify the caller's pointer (`all_cities`), so we must pass a pointer *to that pointer* (`CityData**`)."}], indent: 0, explanation: "A function to parse the CSV, which will return the number of records found." },
    { "correct": "void analyze_data(CityData* data_arr, int count);", distractors: [{"text": "int analyze_data(CityData* data_arr, int count);", reason: "This function's purpose is to print an analysis, not calculate a single value to return. `void` is the most appropriate return type."}], indent: 0, explanation: "A function to perform analysis on the parsed data." },
    { "correct": "void free_data(CityData* data_arr);", distractors: [{"text": "void free_data(CityData** data_arr);", reason: "This function only needs the pointer to the memory to be freed (`CityData*`), not a pointer to that pointer."}], indent: 0, explanation: "A function to free the dynamically allocated memory." },
    { "correct": "// --- Main Function ---", distractors: [{"text": "// Program Start", reason: "While true, 'Main Function' is the more technically accurate description of this code block."}], indent: 0, explanation: "The main driver of the program." },
    { "correct": "int main(int argc, char* argv[]) {", distractors: [{"text": "int main() {", reason: "To access command-line arguments (like the filename), `main` must be defined with the `argc` and `argv` parameters."}], indent: 0, explanation: "Start main, accepting command-line arguments." },
    { "correct": "if (argc != 2) {", distractors: [{"text": "if (argc < 2) {", reason: "This is also correct, but `!= 2` is more precise. It correctly handles cases where the user provides too few *or* too many arguments."}], indent: 1, explanation: "Check that the user provided exactly one argument: the filename." },
    { "correct": "  printf(\"Usage: %s <csv_filename>\\n\", argv[0]);", distractors: [{"text": "  printf(\"Usage: todo <csv_filename>\\n\");", reason: "Hardcoding the program name is less robust. `argv[0]` always contains the name the program was actually run with, making the message more accurate."}], indent: 2, explanation: "Print usage instructions if the argument count is wrong." },
    { "correct": "  return 1;", distractors: [{"text": "  return 0;", reason: "By convention, returning 0 signals success. A non-zero value like 1 should be returned to indicate an error occurred."}], indent: 2, explanation: "Exit with an error." },
    { "correct": "}", distractors: [{"text": "};", reason: "Semicolons do not follow the closing brace `}` of an `if` block."}], indent: 1, explanation: "Close argument check." },
    { "correct": "CityData* all_cities = NULL;", distractors: [{"text": "CityData* all_cities;", reason: "It is critical to initialize pointers to NULL. An uninitialized pointer contains a garbage address, which can cause `realloc` to fail unpredictably."}], indent: 1, explanation: "Initialize the pointer for our dynamic array to NULL." },
    { "correct": "int record_count = parse_csv(argv[1], &all_cities);", distractors: [{"text": "int record_count = parse_csv(argv[1], all_cities);", reason: "This is incorrect. `all_cities` is the pointer itself (currently NULL). We must pass its address (`&all_cities`) so the `parse_csv` function can modify it."}], indent: 1, explanation: "Call the parser, passing the filename and the address of our pointer." },
    { "correct": "if (record_count > 0) {", distractors: [{"text": "if (record_count != -1) {", reason: "This is also a valid check, since our function returns -1 on error. Checking for `> 0` is slightly more robust as it also handles the case of an empty (but valid) file."}], indent: 1, explanation: "If any records were successfully parsed..." },
    { "correct": "  analyze_data(all_cities, record_count);", distractors: [{"text": "  analyze_data(&all_cities, record_count);", reason: "`analyze_data` expects a pointer to the data (`CityData*`), not a pointer to the pointer (`CityData**`)."}], indent: 2, explanation: "Perform the data analysis." },
    { "correct": "  free_data(all_cities);", distractors: [{"text": "  free(all_cities);", reason: "It's good practice to wrap memory deallocation in its own function (`free_data`) for better code organization and clarity."}], indent: 2, explanation: "Free the allocated memory." },
    { "correct": "}", distractors: [{"text": "end if;", reason: "This is not valid C syntax. Code blocks are closed with `}`."}], indent: 1, explanation: "Close the check." },
    { "correct": "return 0;", distractors: [{"text": "return;", reason: "`main` is defined to return an `int`, so it must return an integer value. An empty return is only for `void` functions."}], indent: 1, explanation: "Indicate successful execution." },
    { "correct": "}", distractors: [{"text": "end;", reason: "C uses `}` to end a function block, not keywords."}], indent: 0, explanation: "Close the main function." },
    { "correct": "// --- Function Implementations ---", distractors: [{"text": "// Function Definitions", reason: "'Implementations' and 'Definitions' are often used interchangeably for the function bodies."}], indent: 0, explanation: "Define the functions." },
    { "correct": "int parse_csv(const char* filename, CityData** data_arr_ptr) {", distractors: [{"text": "int parse_csv(const char* filename, CityData* data_arr_ptr) {", reason: "The function definition must match the prototype. This would cause a compiler error or warning."}], indent: 0, explanation: "Start the parser function definition. It takes a double pointer to modify the caller's pointer." },
    { "correct": "  FILE* fp = fopen(filename, \"r\");", distractors: [{"text": "  FILE* fp = fopen(filename, \"w\");", reason: "Write mode (`\"w\"`) would erase the file. We need to open it in read mode (`\"r\"`) to parse its contents."}], indent: 1, explanation: "Open the specified file for reading." },
    { "correct": "  if (!fp) { perror(\"Error opening file\"); return -1; }", distractors: [{"text": "  if (fp == NULL) { printf(\"Error\\n\"); return -1; }", reason: "This works, but `perror` is better because it prints the system's specific error message (e.g., 'No such file or directory'), which is more helpful."}], indent: 1, explanation: "Handle file open errors." },
    { "correct": "  char line[MAX_LINE_LEN];", distractors: [{"text": "  char* line = malloc(MAX_LINE_LEN);", reason: "Dynamic allocation is not necessary for a temporary buffer inside a function. A stack-allocated array is simpler and automatically cleaned up."}], indent: 1, explanation: "A buffer to hold one line from the file." },
    { "correct": "  int count = 0;", distractors: [{"text": "  int count;", reason: "It's critical to initialize counters to 0. An uninitialized local variable holds a garbage value, which would cause `realloc` to fail."}], indent: 1, explanation: "A counter for the number of records parsed." },
    { "correct": "  // Skip the header line", distractors: [{"text": "  // Read the first line of data", reason: "This comment is misleading. The first `fgets` call is specifically intended to read and discard the header, not process it as data."}], indent: 1, explanation: "It's common for CSV files to have a header on the first line." },
    { "correct": "  fgets(line, MAX_LINE_LEN, fp);", distractors: [{"text": "  fscanf(fp, \"%s\", line);", reason: "`fscanf` with `%s` would stop at the first space, not read the entire header line. `fgets` is the correct choice for reading a full line."}], indent: 1, explanation: "Read and discard the first line." },
    { "correct": "  while (fgets(line, MAX_LINE_LEN, fp)) {", distractors: [{"text": "  while (!feof(fp)) { fgets(...); }", reason: "This is a common anti-pattern. You should always loop on the result of the read function (`fgets` here), not `feof`, to avoid errors on the last line."}], indent: 1, explanation: "Loop, reading one line at a time into the buffer." },
    { "correct": "    count++;", distractors: [{"text": "    count = count + 1;", reason: "This is also correct, but `count++` is the more conventional and concise C idiom."}], indent: 2, explanation: "Increment the record counter." },
    { "correct": "    *data_arr_ptr = realloc(*data_arr_ptr, count * sizeof(CityData));", distractors: [{"text": "    *data_arr_ptr = malloc(count * sizeof(CityData));", reason: "`malloc` would allocate new memory each time, orphaning the old memory and causing a massive leak. `realloc` correctly resizes the existing block."}], indent: 2, explanation: "Resize the dynamic array to fit the new record." },
    { "correct": "    if (!(*data_arr_ptr)) { perror(\"realloc failed\"); fclose(fp); return -1; }", distractors: [{"text": "    if (!(*data_arr_ptr)) { return -1; }", reason: "It's important to `fclose(fp)` before returning on error to avoid leaking the file handle resource."}], indent: 2, explanation: "Check if reallocation failed." },
    { "correct": "    CityData* current_record = &((*data_arr_ptr)[count - 1]);", distractors: [{"text": "    CityData current_record = (*data_arr_ptr)[count - 1];", reason: "This would create a *copy* of the struct. We want a pointer to the struct *in the array* so we can modify it directly."}], indent: 2, explanation: "Get a pointer to the newly allocated record for easier access." },
    { "correct": "    // Tokenize the line", distractors: [{"text": "    // Split the string", reason: "'Tokenize' is the more standard term for splitting a string by delimiters."}], indent: 2, explanation: "Comment on parsing the line." },
    { "correct": "    char* token = strtok(line, \",\");", distractors: [{"text": "    char* token = strtok(NULL, \",\");", reason: "The *first* call to `strtok` for a new string must pass the string itself (`line`). Subsequent calls use `NULL`."}], indent: 2, explanation: "Get the first token (city name)." },
    { "correct": "    if (token) strncpy(current_record->name, token, MAX_FIELD_LEN - 1);", distractors: [{"text": "    if (token) strcpy(current_record->name, token);", reason: "`strcpy` is unsafe and can cause buffer overflows if `token` is too long. `strncpy` is a safer alternative."}], indent: 2, explanation: "If the token is valid, copy it to the struct." },
    { "correct": "    token = strtok(NULL, \",\");", distractors: [{"text": "    token = strtok(line, \",\");", reason: "Calling `strtok` with the original string `line` again would restart parsing from the beginning, returning the first token again."}], indent: 2, explanation: "Get the second token (country name)." },
    { "correct": "    if (token) strncpy(current_record->country, token, MAX_FIELD_LEN - 1);", distractors: [{"text": "    if (token) current_record->country = token;", reason: "This is a pointer assignment, not a string copy. It would make the struct member point to memory inside `line`, which will be overwritten on the next loop iteration."}], indent: 2, explanation: "Copy the country name." },
    { "correct": "    token = strtok(NULL, \",\\n\");", distractors: [{"text": "    token = strtok(NULL, \",\");", reason: "The last field on a line might be followed by a newline (`\\n`) instead of a comma. Including `\\n` in the delimiter set handles this."}], indent: 2, explanation: "Get the third token (population), also using newline as a delimiter." },
    { "correct": "    if (token) current_record->population_millions = atof(token);", distractors: [{"text": "    if (token) current_record->population_millions = atoi(token);", reason: "`atoi` converts a string to an `int`, which would truncate any fractional part of the population. `atof` correctly converts to a `double`."}], indent: 2, explanation: "Use `atof` (ASCII to float/double) to convert the population string to a number." },
    { "correct": "  }", distractors: [{"text": "};", reason: "A semicolon is not used after the closing brace of a `while` loop."}], indent: 1, explanation: "Close the file reading loop." },
    { "correct": "  fclose(fp);", distractors: [{"text": "  free(fp);", reason: "`fp` is a `FILE` handle from `fopen`, not a memory block from `malloc`. It must be closed with `fclose`."}], indent: 1, explanation: "Close the file." },
    { "correct": "  printf(\"Parsed %d records from %s\\n\", count, filename);", distractors: [{"text": "  printf(\"Parsed records\\n\");", reason: "This works, but printing the specific count and filename provides much better user feedback."}], indent: 1, explanation: "Print a summary of the parsing." },
    { "correct": "  return count;", distractors: [{"text": "  return 0;", reason: "The function's purpose is to return the number of records it found, so it should return the `count` variable."}], indent: 1, explanation: "Return the total number of records parsed." },
    { "correct": "}", distractors: [{"text": "end function;", reason: "This is not valid C syntax."}], indent: 0, explanation: "Close the parser function." },
    { "correct": "void analyze_data(CityData* data_arr, int count) {", distractors: [{"text": "void analyze_data(CityData data_arr[], int count) {", reason: "In a function parameter, `CityData*` and `CityData[]` are treated identically by the compiler."}], indent: 0, explanation: "Implementation of the analysis function." },
    { "correct": "  printf(\"\\n--- Data Analysis ---\\n\");", distractors: [{"text": "  puts(\"\\n--- Data Analysis ---\");", reason: "`puts` automatically adds a newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Print a header." },
    { "correct": "  double total_population = 0.0;", distractors: [{"text": "  double total_population;", reason: "Accumulator variables must be initialized to 0. An uninitialized local variable contains garbage, which would make the final sum incorrect."}], indent: 1, explanation: "Initialize a variable to accumulate the total population." },
    { "correct": "  int us_cities_count = 0;", distractors: [{"text": "  int us_cities_count;", reason: "Counters must always be initialized to zero. Otherwise, you'd be incrementing a random garbage value."}], indent: 1, explanation: "A counter for a specific query." },
    { "correct": "  CityData* largest_city = &data_arr[0];", distractors: [{"text": "  CityData* largest_city = NULL;", reason: "Initializing to NULL would require a special check inside the loop. Assuming the first element is the largest is a common and simple starting point."}], indent: 1, explanation: "Assume the first city is the largest to start." },
    { "correct": "  for (int i = 0; i < count; i++) {", distractors: [{"text": "  for (int i = 0; i <= count - 1; i++) {", reason: "This is a logically equivalent and correct way to write the loop condition."}], indent: 1, explanation: "Loop through all the parsed records." },
    { "correct": "    total_population += data_arr[i].population_millions;", distractors: [{"text": "    total_population = total_population + data_arr[i].population_millions;", reason: "This is also correct, but the `+=` operator is a more common and concise idiom in C."}], indent: 2, explanation: "Add the current city's population to the total." },
    { "correct": "    if (strcmp(data_arr[i].country, \"USA\") == 0) {", distractors: [{"text": "    if (data_arr[i].country == \"USA\") {", reason: "This is a critical error. You must use `strcmp` to compare string content in C. The `==` operator compares memory addresses."}], indent: 2, explanation: "Check if the city is in the USA." },
    { "correct": "      us_cities_count++;", distractors: [{"text": "      us_cities_count = us_cities_count + 1;", reason: "This works, but `++` is the more idiomatic way to increment a variable in C."}], indent: 3, explanation: "Increment the USA city counter." },
    { "correct": "    }", distractors: [{"text": "};", reason: "A semicolon does not follow the closing brace `}` of an `if` block."}], indent: 2, explanation: "Close country check." },
    { "correct": "    if (data_arr[i].population_millions > largest_city->population_millions) {", distractors: [{"text": "    if (data_arr[i].population_millions > largest_city.population_millions) {", reason: "`largest_city` is a pointer, so you must use the arrow operator `->` to access its members, not the dot operator `.`."}], indent: 2, explanation: "Check if the current city is larger than the largest one found so far." },
    { "correct": "      largest_city = &data_arr[i];", distractors: [{"text": "      *largest_city = data_arr[i];", reason: "This would *copy* the data from `data_arr[i]` into the struct pointed to by `largest_city`. We want to update the pointer itself to point to the new largest city."}], indent: 3, explanation: "If it is, update our pointer to the largest city." },
    { "correct": "    }", distractors: [{"text": "};", reason: "Semicolons are not used here."}], indent: 2, explanation: "Close largest city check." },
    { "correct": "  }", distractors: [{"text": "end loop;", reason: "This is not valid C syntax."}], indent: 1, explanation: "Close the analysis loop." },
    { "correct": "  // Print the results of the analysis", distractors: [{"text": "  // Show output", reason: "This works, but 'Print the results of the analysis' is more descriptive of what the following code does."}], indent: 1, explanation: "Comment on printing results." },
    { "correct": "  double average_population = total_population / count;", distractors: [{"text": "  double average_population = total_population / (double)count;", reason: "Casting `count` to a double is good practice for clarity, but not strictly necessary here since `total_population` is already a double, promoting the result to a double."}], indent: 1, explanation: "Calculate the average population." },
    { "correct": "  printf(\"Average population: %.2f million\\n\", average_population);", distractors: [{"text": "  printf(\"Average population: %f million\\n\", average_population);", reason: "`%.2f` is a format specifier that nicely rounds the output to two decimal places, which is more readable than the default precision of `%f`."}], indent: 1, explanation: "Print the average." },
    { "correct": "  printf(\"Number of cities in USA: %d\\n\", us_cities_count);", distractors: [{"text": "  printf(\"Number of cities in USA: %d\\n\");", reason: "The `%d` format specifier requires an integer argument. Forgetting to provide `us_cities_count` leads to undefined behavior."}], indent: 1, explanation: "Print the count of US cities." },
    { "correct": "  printf(\"Largest city found: %s, %s (%.2f million)\\n\", largest_city->name, largest_city->country, largest_city->population_millions);", distractors: [{"text": "  printf(\"Largest city: %s\\n\", largest_city->name);", reason: "This is okay, but printing all the relevant details of the largest city provides a more complete and useful summary."}], indent: 1, explanation: "Print the details of the largest city found." },
    { "correct": "  printf(\"---------------------\\n\");", distractors: [{"text": "  puts(\"---------------------\");", reason: "This is a simpler and equally valid way to print this footer line."}], indent: 1, explanation: "Print a footer." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon does not follow the closing brace of a function."}], indent: 0, explanation: "Close the analysis function." },
    { "correct": "void free_data(CityData* data_arr) {", distractors: [{"text": "void free_data(void) {", reason: "This function needs to know which memory block to free, so it must take the `CityData*` pointer as an argument."}], indent: 0, explanation: "Implementation of the memory cleanup function." },
    { "correct": "  free(data_arr);", distractors: [{"text": "  for (int i=0; i<count; i++) { free(data_arr[i]); }", reason: "This is a critical error. The entire block of memory was allocated with a single `realloc` call. It must be freed with a single `free` call. Freeing individual elements is incorrect."}], indent: 1, explanation: "Free the entire dynamic array." },
    { "correct": "  printf(\"Memory has been freed.\\n\");", distractors: [{"text": "  puts(\"Memory has been freed.\");", reason: "This is a simpler and equally valid way to print the confirmation message."}], indent: 1, explanation: "Confirmation message." },
    { "correct": "}", distractors: [{"text": "end;", reason: "Function blocks in C are closed with `}`."}], indent: 0, explanation: "Close the free function." }
]
    },
    // Level 71: parsing .ini configuration files
    {
        "goal": "Build a reusable library for parsing .ini configuration files using opaque pointers and linked lists.",
        concepts: "Opaque pointers, linked lists, dynamic memory, file I/O, `strtok`, `strcpy`, encapsulation, API design",
        sequence:[
    { "correct": "// === Stage 1: The Public API Header File (e.g., 'ini_parser.h') ===", distractors: [{"text":"// === The Main Program ===", reason:"This comment is inaccurate. We are starting with the public header file, which defines the library's interface, not the main program that uses it."}], indent: 0, explanation: "We begin by defining the public interface that users of our library will see. Implementation details will be hidden." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <string.h>", reason:"While our implementation will use strings, the public header only needs `<stdio.h>` for the `FILE` type, which isn't even used here but is good practice if any file-related types were exposed."}], indent: 0, explanation: "Include for file operations, needed for function prototypes." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <memory.h>", reason:"The standard header for `size_t` and memory allocation function prototypes is `<stdlib.h>`."}], indent: 0, explanation: "Include for `size_t` and memory allocation." },
    { "correct": "// 1. Forward-declare the main struct without revealing its members.", distractors: [{"text":"// 1. Define the main struct.", reason:"This is a key distinction. We are only *declaring* that the struct exists, not *defining* its contents. This is what makes it opaque."}], indent: 0, explanation: "This is the core of the opaque pointer technique. Users know the type `struct IniConfig` exists but not what's inside." },
    { "correct": "struct IniConfig;", distractors: [{"text":"struct IniConfig {};", reason:"This provides a full (but empty) definition, making it a complete type. A simple forward declaration (`struct IniConfig;`) is an *incomplete* type, which is what we need to hide the implementation details."}], indent: 0, explanation: "This makes `struct IniConfig` an incomplete type in this header." },
    { "correct": "// 2. Create a typedef for a pointer to the opaque struct.", distractors: [{"text":"// 2. Create a copy of the struct.", reason:"This is incorrect. A `typedef` creates a type alias (a new name), not a copy of any data."}], indent: 0, explanation: "Users will interact exclusively with this handle, not the struct itself." },
    { "correct": "typedef struct IniConfig* IniHandle;", distractors: [{"text":"typedef struct IniConfig IniHandle;", reason:"This would make `IniHandle` an alias for the struct itself, not a pointer. The user would have to manage pointers (`IniHandle*`), which defeats the purpose of a clean, opaque handle."}], indent: 0, explanation: "Define `IniHandle` as the public type." },
    { "correct": "// 3. Declare the public API functions.", distractors: [{"text":"// 3. Define the API functions.", reason:"The header file only *declares* the function prototypes. The *definitions* (implementations) belong in the `.c` source file."}], indent: 0, explanation: "These are the functions users can call." },
    { "correct": "IniHandle ini_load(const char* filename);", distractors: [{"text":"void ini_load(const char* filename);", reason:"This function needs to create and return a handle to the parsed data, so its return type must be `IniHandle`."}], indent: 0, explanation: "Prototype for the function that loads and parses an INI file." },
    { "correct": "const char* ini_get_string(IniHandle handle, const char* section, const char* key);", distractors: [{"text":"char* ini_get_string(...);", reason:"Returning a `const char*` is safer. It prevents the user of the library from accidentally trying to modify the internal string data, which would corrupt the state."}], indent: 0, explanation: "Prototype to get a string value from a specific section and key." },
    { "correct": "int ini_get_integer(IniHandle handle, const char* section, const char* key, int default_val);", distractors: [{"text":"int ini_get_integer(IniHandle handle, const char* section, const char* key);", reason:"Without a default value parameter, the API has no way to signal 'not found' for an integer. Providing a default is a common and robust pattern."}], indent: 0, explanation: "Prototype to get an integer value, with a default if not found." },
    { "correct": "void ini_free(IniHandle handle);", distractors: [{"text":"IniHandle ini_free(IniHandle handle);", reason:"The `free` function's job is to clean up memory; it doesn't need to return anything, so its return type should be `void`."}], indent: 0, explanation: "Prototype for the function that frees all memory associated with the INI configuration." },
    { "correct": "// === Stage 2: The Private Implementation File (e.g., 'ini_parser.c') ===", distractors: [{"text":"// === Stage 2: The Main Program ===", reason:"This is incorrect. This is the implementation file for the library itself. The main program that *uses* the library is a separate stage."}], indent: 0, explanation: "Now we switch to the source file where all the private logic and data structures are defined." },
    { "correct": "#include <string.h>", distractors: [{"text":"// No extra includes needed", reason:"`strcpy`, `strtok`, etc., are not built-in. They are library functions that require `<string.h>`."}], indent: 0, explanation: "Include for `strcpy`, `strtok`, `strcmp`." },
    { "correct": "#include <ctype.h>", distractors: [{"text":"#include \"ctype.h\"", reason:"Use angle brackets `<>` for standard library headers. Double quotes are for local project headers."}], indent: 0, explanation: "Include for `isspace` to trim whitespace." },
    { "correct": "// #include \"ini_parser.h\" // In a real project, you'd include the header.", distractors: [{"text":"// No need to include our own header.", reason:"Including your own header is crucial. It allows the compiler to verify that your function definitions in the `.c` file match the prototypes you declared in the `.h` file."}], indent: 0, explanation: "Include our own public header to ensure our definitions match the declarations." },
    { "correct": "// 4. Define the private data structures.", distractors: [{"text":"// 4. These structs should be in the .h file.", reason:"No, placing these definitions in the header would expose the implementation details to the user, breaking the opaque pointer design."}], indent: 0, explanation: "These structs are the hidden implementation of our INI parser." },
    { "correct": "typedef struct KeyValuePair {", distractors: [{"text":"struct KeyValuePair {", reason:"Without `typedef`, you would have to write `struct KeyValuePair* next;` inside the struct, which is more verbose."}], indent: 0, explanation: "A struct to hold a single key-value pair." },
    { "correct": "  char* key;", distractors: [{"text":"  char key[128];", reason:"A fixed-size array is simpler but less flexible. Using `char*` allows keys of any length, but requires careful dynamic memory management."}], indent: 1, explanation: "The key string." },
    { "correct": "  char* value;", distractors: [{"text":"  const char* value;", reason:"The value should be modifiable within the library if needed, and will be allocated dynamically. `const` is not appropriate here."}], indent: 1, explanation: "The value string." },
    { "correct": "  struct KeyValuePair* next;", distractors: [{"text":"  KeyValuePair next;", reason:"This would try to embed an entire `KeyValuePair` struct inside itself, which is impossible as it would have an infinite size. It must be a pointer."}], indent: 1, explanation: "Pointer to the next pair in the section." },
    { "correct": "} KeyValuePair;", distractors: [{"text":"};", reason:"Because this is a `typedef`, the new type name (`KeyValuePair`) must be provided before the semicolon."}], indent: 0, explanation: "Close the KeyValuePair definition." },
    { "correct": "typedef struct Section {", distractors: [{"text":"struct Section {", reason:"Using `typedef` allows us to simply write `Section* next;` inside the struct definition."}], indent: 0, explanation: "A struct to hold a section name and a list of its pairs." },
    { "correct": "  char* name;", distractors: [{"text":"  char name[128];", reason:"A fixed-size array limits the length of section names. `char*` is more flexible but requires dynamic allocation."}], indent: 1, explanation: "The name of the section (e.g., '[database]')." },
    { "correct": "  KeyValuePair* pairs;", distractors: [{"text":"  KeyValuePair pairs[100];", reason:"This would create a fixed-size array, limiting each section to 100 key-value pairs. A linked list (`KeyValuePair*`) is dynamically sized."}], indent: 1, explanation: "A pointer to the head of the linked list of key-value pairs." },
    { "correct": "  struct Section* next;", distractors: [{"text":"  Section next;", reason:"A struct cannot contain a member of its own type, as this would create an infinite recursion. It must be a pointer to its own type."}], indent: 1, explanation: "Pointer to the next section in the file." },
    { "correct": "} Section;", distractors: [{"text":"};", reason:"This `typedef` requires the alias `Section` before the semicolon."}], indent: 0, explanation: "Close the Section definition." },
    { "correct": "// 5. Provide the full definition for the previously opaque struct.", distractors: [{"text":"// 5. This should be in the header file.", reason:"No, this is the entire point of the opaque pointer. The full definition is private to the `.c` file."}], indent: 0, explanation: "Here we complete the type that was hidden from the user." },
    { "correct": "struct IniConfig {", distractors: [{"text":"typedef struct IniConfig {", reason:"We already created the `IniHandle` typedef in the header. Here, we just need to provide the full definition for the `struct IniConfig` that was forward-declared."}], indent: 0, explanation: "The main handle struct." },
    { "correct": "  Section* head;", distractors: [{"text":"  Section head;", reason:"This would embed the head section directly. We need a pointer so it can be `NULL` for an empty config and can point to dynamically allocated sections."}], indent: 1, explanation: "It simply contains a pointer to the head of the sections linked list." },
    { "correct": "};", distractors: [{"text": "}", reason:"Definitions for `struct`, `union`, and `enum` require a semicolon after the closing brace."}], indent: 0, explanation: "Close the main struct definition." },
    { "correct": "// 6. A helper function to trim leading/trailing whitespace.", distractors: [{"text":"// 6. This function should be in the header.", reason:"Since this is a private helper function only used by `ini_load`, it should not be part of the public API in the header file. This is encapsulation."}], indent: 0, explanation: "Utility function for cleaning up parsed strings." },
    { "correct": "char* trim_whitespace(char* str) {", distractors: [{"text":"const char* trim_whitespace(const char* str) {", reason:"This function modifies the string in-place by writing a null terminator, so the input cannot be `const`."}], indent: 0, explanation: "Start the trim function." },
    { "correct": "  char* end;", distractors: [{"text":"  char* end = str;", reason:"Initializing `end` here is fine, but it will be reassigned later anyway."}], indent: 1, explanation: "Declare a pointer to find the end of the string." },
    { "correct": "  while (isspace((unsigned char)*str)) str++;", distractors: [{"text":"  while (isspace(*str++)) ;", reason:"This shorthand also works, but can be harder to read. The original is more explicit."}], indent: 1, explanation: "Move the start pointer forward past any leading whitespace." },
    { "correct": "  if (*str == 0) return str;", distractors: [{"text":"  if (!*str) return str;", reason:"`!*str` is a valid and common shorthand for checking if the character is the null terminator."}], indent: 1, explanation: "If the whole string was whitespace, it's now empty." },
    { "correct": "  end = str + strlen(str) - 1;", distractors: [{"text":"  end = &str[strlen(str) - 1];", reason:"This is an equivalent way to get a pointer to the last character of the string."}], indent: 1, explanation: "Point `end` to the last character." },
    { "correct": "  while (end > str && isspace((unsigned char)*end)) end--;", distractors: [{"text":"  while (isspace(*end)) end--;", reason:"This is missing the `end > str` check, which is a bug. It could cause the pointer to go before the start of the string if the string is all whitespace."}], indent: 1, explanation: "Move `end` backward past any trailing whitespace." },
    { "correct": "  end[1] = '\\0';", distractors: [{"text":"  *end = '\\0';", reason:"This would erase the last non-whitespace character. We need to place the null terminator *after* it."}], indent: 1, explanation: "Write a null terminator after the last non-space character." },
    { "correct": "  return str;", distractors: [{"text":"  return end;", reason:"This would return a pointer to the end of the trimmed string, not the beginning."}], indent: 1, explanation: "Return the pointer to the trimmed string." },
    { "correct": "}", distractors: [{"text":"};", reason:"Semicolons are not used after a function's closing brace."}], indent: 0, explanation: "Close the trim function." },
    { "correct": "// 7. Implementation of the `ini_load` function.", distractors: [{"text":"// 7. This should be a small function.", reason:"Parsing is often complex. This function has a lot of responsibility: memory allocation, file I/O, and string tokenizing, so it is naturally large."}], indent: 0, explanation: "This is the largest and most complex function." },
    { "correct": "IniHandle ini_load(const char* filename) {", distractors: [{"text":"void* ini_load(const char* filename) {", reason:"While this would work, it's better API design to return the specific handle type `IniHandle` so the user doesn't have to cast it."}], indent: 0, explanation: "Start the definition of `ini_load`." },
    { "correct": "  IniHandle handle = malloc(sizeof(struct IniConfig));", distractors: [{"text":"  IniHandle handle = malloc(sizeof(IniHandle));", reason:"This is a critical error. `IniHandle` is a pointer type. This would only allocate memory for a pointer (e.g., 8 bytes), not for the actual `struct IniConfig` it's supposed to point to."}], indent: 1, explanation: "Allocate memory for the main config handle." },
    { "correct": "  if (!handle) return NULL;", distractors: [{"text":"  if (handle == NULL) return NULL;", reason:"This is an equally valid way to check for a allocation failure."}], indent: 1, explanation: "Check for allocation failure." },
    { "correct": "  handle->head = NULL;", distractors: [{"text":"  // No initialization needed.", reason:"This is false. The `head` pointer will hold a garbage value if not initialized to `NULL`, which will cause the linked list logic to fail."}], indent: 1, explanation: "Initialize the head of the sections list to NULL." },
    { "correct": "  FILE* fp = fopen(filename, \"r\");", distractors: [{"text":"  FILE* fp = fopen(filename, \"w\");", reason:"Write mode (`\"w\"`) would erase the file. We need to open it in read mode (`\"r\"`) to parse it."}], indent: 1, explanation: "Open the INI file for reading." },
    { "correct": "  if (!fp) { free(handle); return NULL; }", distractors: [{"text":"  if (!fp) { return NULL; }", reason:"This is a memory leak. If opening the file fails, you must `free` the `handle` you just allocated before returning."}], indent: 1, explanation: "If the file can't be opened, clean up and return NULL." },
    { "correct": "  char line[512];", distractors: [{"text":"  char* line;", reason:"This only declares a pointer. It doesn't allocate any memory for `fgets` to read data into, which would cause a crash."}], indent: 1, explanation: "A buffer to read each line of the file." },
    { "correct": "  Section* current_section = NULL;", distractors: [{"text":"  Section* current_section;", reason:"It is critical to initialize pointers to NULL. If uninitialized, the check `if (current_section ...)` later on would use a garbage value."}], indent: 1, explanation: "A pointer to keep track of the section we are currently parsing." },
    { "correct": "  while (fgets(line, sizeof(line), fp)) {", distractors: [{"text":"  while (!feof(fp)) { fgets(...); }", reason:"This is a common C anti-pattern. You should always loop on the return value of the read function (`fgets` here), not on `feof`."}], indent: 1, explanation: "Loop, reading the file line by line." },
    { "correct": "    char* trimmed_line = trim_whitespace(line);", distractors: [{"text":"    strcpy(line, trim_whitespace(line));", reason:"This is unnecessary. Since `trim_whitespace` modifies the string in-place, `trimmed_line` and `line` will point to the (now trimmed) same string data."}], indent: 2, explanation: "Clean up the line first." },
    { "correct": "    if (trimmed_line[0] == '#' || trimmed_line[0] == ';') continue; // Skip comments", distractors: [{"text":"    if (trimmed_line[0] == '/') continue;", reason:"In INI files, comments typically start with `;` or `#`, not `//` like in C."}], indent: 2, explanation: "Ignore lines that are comments." },
    { "correct": "    if (trimmed_line[0] == '[') { // This is a section header", distractors: [{"text":"    if (strchr(trimmed_line, '[')) {", reason:"This is less precise. It would match a `[` anywhere on the line, but a section header must start with it."}], indent: 2, explanation: "Check for a section header like `[database]`." },
    { "correct": "      char* section_name = strtok(trimmed_line + 1, \"]\");", distractors: [{"text":"      char* section_name = strtok(trimmed_line, \"[]\");", reason:"This would also work, but `trimmed_line + 1` is slightly more precise as it starts tokenizing *after* the opening bracket."}], indent: 3, explanation: "Use `strtok` to extract the name from between the brackets." },
    { "correct": "      if (section_name) {", distractors: [{"text":"      if (section_name != NULL) {", reason:"This is an equally valid and often clearer way to check if `strtok` returned a valid pointer."}], indent: 3, explanation: "If a name was successfully extracted..." },
    { "correct": "        current_section = malloc(sizeof(Section));", distractors: [{"text":"        Section new_section;", reason:"This would create a temporary stack variable. It would be destroyed when the `while` loop iterates, making it invalid. We need persistent memory from `malloc`."}], indent: 4, explanation: "Allocate memory for a new Section struct." },
    { "correct": "        current_section->name = strdup(section_name);", distractors: [{"text":"        current_section->name = section_name;", reason:"This is a critical error. `section_name` points inside the `line` buffer, which will be overwritten on the next `fgets` call. You must make a persistent copy of the string."}], indent: 4, explanation: "`strdup` allocates memory and copies the string in one step." },
    { "correct": "        current_section->pairs = NULL;", distractors: [{"text":"        // No need to initialize pairs", reason:"This is false. The `pairs` pointer must be initialized to NULL so that the key-value linked list for this new section starts empty."}], indent: 4, explanation: "Initialize the key-value pair list for this section." },
    { "correct": "        current_section->next = handle->head;", distractors: [{"text":"        handle->head = current_section;", reason:"This step must come *after* you've linked the new section. Doing it here would lose the rest of the list."}], indent: 4, explanation: "Link the new section to the front of the main sections list." },
    { "correct": "        handle->head = current_section;", distractors: [{"text":"        current_section->next = handle->head;", reason:"This would create a circular list where the new section's `next` pointer points back to itself."}], indent: 4, explanation: "Update the main handle's head to point to the new section." },
    { "correct": "      }", distractors: [{"text":"};", reason:"A semicolon does not follow the closing brace of an `if` block."}], indent: 3, explanation: "Close section name check." },
    { "correct": "    } else if (current_section && strchr(trimmed_line, '=')) { // This is a key-value pair", distractors: [{"text":"    } else if (strchr(trimmed_line, '=')) {", reason:"This is missing the `current_section` check. A key-value pair is only valid if it's inside a section."}], indent: 2, explanation: "Check if this line is a key-value pair within the current section." },
    { "correct": "      char* key = strtok(trimmed_line, \"=\");", distractors: [{"text":"      char* key = strtok(NULL, \"=\");", reason:"This is the first `strtok` call for this `trimmed_line`, so it must contain the string pointer, not `NULL`."}], indent: 3, explanation: "Get the part before the '=' as the key." },
    { "correct": "      char* value = strtok(NULL, \"\"); // Get the rest of the line as the value", distractors: [{"text":"      char* value = strtok(NULL, \"=\");", reason:"An empty delimiter string `\"\"` tells `strtok` to read to the end of the original string. Using `\"=\"` would fail if the value itself contained an equals sign."}], indent: 3, explanation: "Get everything after the '=' as the value." },
    { "correct": "      if (key && value) {", distractors: [{"text":"      if (key != NULL && value != NULL) {", reason:"This is an equally valid and clearer way to check that both tokens were found."}], indent: 3, explanation: "If both key and value were found..." },
    { "correct": "        KeyValuePair* new_pair = malloc(sizeof(KeyValuePair));", distractors: [{"text":"        KeyValuePair new_pair;", reason:"This creates a temporary stack variable that will be destroyed at the end of the `if` block. Dynamically allocating with `malloc` is required."}], indent: 4, explanation: "Allocate memory for the new key-value pair." },
    { "correct": "        new_pair->key = strdup(trim_whitespace(key));", distractors: [{"text":"        new_pair->key = key;", reason:"This is a bug. `key` is a pointer into the `line` buffer, which is temporary. A separate, permanent copy of the string must be made."}], indent: 4, explanation: "Allocate and copy the trimmed key." },
    { "correct": "        new_pair->value = strdup(trim_whitespace(value));", distractors: [{"text":"        new_pair->value = value;", reason:"This would make the struct member point into the temporary `line` buffer. `strdup` correctly allocates new memory and makes a copy."}], indent: 4, explanation: "Allocate and copy the trimmed value." },
    { "correct": "        new_pair->next = current_section->pairs;", distractors: [{"text":"        current_section->pairs = new_pair;", reason:"This must happen *after* linking. Doing it first would orphan the rest of the key-value pair list."}], indent: 4, explanation: "Link the new pair to the front of the current section's pair list." },
    { "correct": "        current_section->pairs = new_pair;", distractors: [{"text":"        new_pair->next = NULL;", reason:"This would work, but it would mean every new pair becomes the *only* pair in the list, overwriting previous ones."}], indent: 4, explanation: "Update the section's head to point to the new pair." },
    { "correct": "      }", distractors: [{"text":"};", reason:"A semicolon is not needed here."}], indent: 3, explanation: "Close key/value check." },
    { "correct": "    }", distractors: [{"text":"end if;", reason:"This is not valid C syntax."}], indent: 2, explanation: "Close the else-if." },
    { "correct": "  }", distractors: [{"text":"end while;", reason:"This is not valid C syntax."}], indent: 1, explanation: "Close the `while fgets` loop." },
    { "correct": "  fclose(fp);", distractors: [{"text":"  free(fp);", reason:"`fp` is a `FILE` handle and must be closed with `fclose`. `free` is for memory allocated with `malloc`."}], indent: 1, explanation: "Close the file." },
    { "correct": "  return handle;", distractors: [{"text":"  return handle->head;", reason:"The public API promises to return an `IniHandle` (`struct IniConfig*`), not a `Section*`. The user should not have access to the internal `head` pointer."}], indent: 1, explanation: "Return the fully parsed config handle." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to end a function block."}], indent: 0, explanation: "Close the `ini_load` function." },
    { "correct": "// 8. Implementation of getter functions.", distractors: [{"text":"// 8. These should be in the header file.", reason:"No, only the prototypes belong in the header. The implementations belong in the `.c` file."}], indent: 0, explanation: "Define the functions to retrieve data." },
    { "correct": "const char* ini_get_string(IniHandle handle, const char* section, const char* key) {", distractors: [{"text":"char* ini_get_string(...)", reason:"The definition must match the prototype's return type (`const char*`)."}], indent: 0, explanation: "Start the string getter function." },
    { "correct": "  for (Section* s = handle->head; s != NULL; s = s->next) {", distractors: [{"text":"  for (Section* s = handle->head; s; s = s->next) {", reason:"This is a common and valid shorthand. A non-NULL pointer evaluates to true."}], indent: 1, explanation: "Iterate through the list of sections." },
    { "correct": "    if (strcmp(s->name, section) == 0) {", distractors: [{"text":"    if (s->name == section) {", reason:"This is a critical error. Strings must be compared with `strcmp`. The `==` operator compares memory addresses, not content."}], indent: 2, explanation: "If we find the correct section..." },
    { "correct": "      for (KeyValuePair* p = s->pairs; p != NULL; p = p->next) {", distractors: [{"text":"      for (KeyValuePair* p = s->pairs; p != NULL; p = p->key) {", reason:"This is a logic error. The loop must iterate through the `next` pointer of the linked list, not the `key`."}], indent: 3, explanation: "Iterate through that section's list of key-value pairs." },
    { "correct": "        if (strcmp(p->key, key) == 0) {", distractors: [{"text":"        if (!strcmp(p->key, key)) {", reason:"This is a valid and common shorthand, as `strcmp` returns 0 on a match, and `!0` is true."}], indent: 4, explanation: "If we find the correct key..." },
    { "correct": "          return p->value; // Found it!", distractors: [{"text":"          return strdup(p->value);", reason:"This would return a *copy* of the value. The API should return a pointer to the internal data to avoid forcing the user to manage memory."}], indent: 5, explanation: "Return the associated value." },
    { "correct": "        }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 4, explanation: "Close key check." },
    { "correct": "      }", distractors: [{"text":"end for;", reason:"This is not valid C syntax."}], indent: 3, explanation: "Close pairs loop." },
    { "correct": "    }", distractors: [{"text":"end if;", reason:"This is not valid C syntax."}], indent: 2, explanation: "Close section check." },
    { "correct": "  }", distractors: [{"text":"end for;", reason:"This is not valid C syntax."}], indent: 1, explanation: "Close sections loop." },
    { "correct": "  return NULL; // Not found", distractors: [{"text":"  return \"\";", reason:"Returning an empty string can be ambiguous. Does it mean the key was found but its value is empty, or the key was not found at all? `NULL` is a clearer signal for 'not found'."}], indent: 1, explanation: "If we finish the loops without a match, return NULL." },
    { "correct": "}", distractors: [{"text":"};", reason:"Semicolons do not follow a function's closing brace."}], indent: 0, explanation: "Close the string getter." },
    { "correct": "int ini_get_integer(IniHandle handle, const char* section, const char* key, int default_val) {", distractors: [{"text":"int ini_get_integer(...) {", reason:"This would compile, but it's good practice to name the parameters for clarity, even if they aren't used."}], indent: 0, explanation: "Start the integer getter function." },
    { "correct": "  const char* val_str = ini_get_string(handle, section, key);", distractors: [{"text":"  char* val_str = ini_get_string(...);", reason:"`ini_get_string` returns a `const char*`, so the variable it's assigned to should also be `const`."}], indent: 1, explanation: "First, try to get the value as a string." },
    { "correct": "  if (val_str) {", distractors: [{"text":"  if (val_str != NULL) {", reason:"This is an equally valid and often clearer way to check if the pointer is not NULL."}], indent: 1, explanation: "If the string was found..." },
    { "correct": "    return atoi(val_str);", distractors: [{"text":"    return strtol(val_str, NULL, 10);", reason:"`strtol` is a more robust alternative to `atoi` because it provides error checking capabilities, but `atoi` is simpler for basic cases."}], indent: 2, explanation: "Use `atoi` to convert it to an integer and return it." },
    { "correct": "  }", distractors: [{"text": "};", reason:"A semicolon is not used here."}], indent: 1, explanation: "Close check." },
    { "correct": "  return default_val;", distractors: [{"text":"  return 0;", reason:"This would be a bug. If the key isn't found, the function should return the `default_val` provided by the user, not always 0."}], indent: 1, explanation: "If the string was not found, return the provided default value." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close blocks."}], indent: 0, explanation: "Close the integer getter." },
    { "correct": "// 9. Implementation of the cleanup function.", distractors: [{"text":"// 9. This function is optional.", reason:"This is very false. For any non-trivial program that allocates memory, a corresponding cleanup function is mandatory to prevent memory leaks."}], indent: 0, explanation: "Define the function to free all allocated memory." },
    { "correct": "void ini_free(IniHandle handle) {", distractors: [{"text":"void ini_free(IniHandle* handle) {", reason:"The handle is already a pointer. Passing a pointer to it (`IniHandle*`, which is `struct IniConfig**`) is unnecessary."}], indent: 0, explanation: "Start the free function." },
    { "correct": "  Section* current_section = handle->head;", distractors: [{"text":"  Section* current_section = NULL;", reason:"This would make the `while` loop condition false immediately, and no memory would be freed."}], indent: 1, explanation: "Get the head of the sections list." },
    { "correct": "  while (current_section) {", distractors: [{"text":"  while (current_section != NULL) {", reason:"This is an equally valid way to write the loop condition."}], indent: 1, explanation: "Loop through all sections." },
    { "correct": "    KeyValuePair* current_pair = current_section->pairs;", distractors: [{"text":"    KeyValuePair* current_pair = NULL;", reason:"This would cause the inner `while` loop to be skipped, leaking all the key-value pairs in this section."}], indent: 2, explanation: "Get the head of the current section's pair list." },
    { "correct": "    while (current_pair) {", distractors: [{"text":"    if (current_pair) {", reason:"An `if` would only execute once. A `while` loop is needed to iterate through the entire linked list of pairs."}], indent: 2, explanation: "Loop through all pairs in this section." },
    { "correct": "      KeyValuePair* next_pair = current_pair->next;", distractors: [{"text":"      free(current_pair);", reason:"This is a classic use-after-free bug. If you free `current_pair` first, you can no longer access `current_pair->next` to move to the next node."}], indent: 3, explanation: "Save the pointer to the next pair before freeing the current one." },
    { "correct": "      free(current_pair->key);", distractors: [{"text":"      // No need to free key", reason:"This is a memory leak. The `key` was allocated with `strdup` (which uses `malloc`), so it must be freed."}], indent: 3, explanation: "Free the key string." },
    { "correct": "      free(current_pair->value);", distractors: [{"text":"      // No need to free value", reason:"This is a memory leak. `strdup` was used, so `free` is required."}], indent: 3, explanation: "Free the value string." },
    { "correct": "      free(current_pair);", distractors: [{"text":"      current_pair = next_pair;", reason:"This would move to the next pair but would leak the memory for the `current_pair` struct itself."}], indent: 3, explanation: "Free the KeyValuePair struct itself." },
    { "correct": "      current_pair = next_pair;", distractors: [{"text":"      // No need to update pointer", reason:"This is a bug. Without this line, `current_pair` would never change, resulting in an infinite loop."}], indent: 3, explanation: "Move to the next pair." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 2, explanation: "Close pairs loop." },
    { "correct": "    Section* next_section = current_section->next;", distractors: [{"text":"    free(current_section);", reason:"This is a use-after-free error. You must save the `next` pointer *before* freeing the current section struct."}], indent: 2, explanation: "Save the pointer to the next section." },
    { "correct": "    free(current_section->name);", distractors: [{"text":"    // No need to free name", reason:"This would be a memory leak. The section name was allocated with `strdup` and must be freed."}], indent: 2, explanation: "Free the section name string." },
    { "correct": "    free(current_section);", distractors: [{"text":"    current_section = next_section;", reason:"This would move to the next section but leak the memory for the `current_section` struct itself."}], indent: 2, explanation: "Free the Section struct itself." },
    { "correct": "    current_section = next_section;", distractors: [{"text":"    // Not needed", reason:"This is a bug. Without this, `current_section` would never be updated, leading to an infinite loop."}], indent: 2, explanation: "Move to the next section." },
    { "correct": "  }", distractors: [{"text":"end while;", reason:"This is not valid C syntax."}], indent: 1, explanation: "Close sections loop." },
    { "correct": "  free(handle);", distractors: [{"text":"  // The handle is on the stack", reason:"This is false. The handle was explicitly allocated on the heap with `malloc` at the beginning of `ini_load`, so it must be freed."}], indent: 1, explanation: "Finally, free the main handle struct." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "Close the free function." },
    { "correct": "// === Stage 3: The Main Program File (e.g., 'main.c') ===", distractors: [{"text":"// === Stage 3: The Library File ===", reason:"This is the user's program, which *uses* the library. It is separate from the library's own source code."}], indent: 0, explanation: "A separate file that demonstrates how a user would use our library." },
    { "correct": "int main() {", distractors: [{"text":"int main(int argc, char* argv[]) {", reason:"Since this simple test program doesn't use command-line arguments, the simpler `int main()` signature is fine."}], indent: 0, explanation: "Start the main user program." },
    { "correct": "  // In a real project, this file would be in `config.ini`", distractors: [{"text":"  // Reading from stdin", reason:"This is incorrect. The code is demonstrating file I/O by creating and reading from a file named `config.ini`."}], indent: 1, explanation: "Simulate the INI file content." },
    { "correct": "  FILE* f = fopen(\"config.ini\", \"w\");", distractors: [{"text":"  FILE* f = fopen(\"config.ini\", \"r\");", reason:"This would fail. Read mode (`\"r\"`) requires the file to exist, but we are creating it here for the first time."}], indent: 1, explanation: "Create the dummy INI file for our test." },
    { "correct": "  fprintf(f, \"; user settings\\n[user]\\nname=Alice\\nemail=alice@example.com\\n\");", distractors: [{"text":"  printf(...);", reason:"`printf` writes to the console (stdout). To write to our file, we must use `fprintf` with the file handle `f`."}], indent: 1, explanation: "Write the user section." },
    { "correct": "  fprintf(f, \"\\n[database]\\nhost=localhost\\nport=5432\\n\");", distractors: [{"text":"  fputs(\"\\n[database]\\nhost=localhost\\nport=5432\\n\", f);", reason:"`fputs` is another valid way to write a string to a file."}], indent: 1, explanation: "Write the database section." },
    { "correct": "  fclose(f);", distractors: [{"text":"  // No need to close", reason:"This is false. Forgetting to close the file could result in the data not being written to disk correctly."}], indent: 1, explanation: "Close the dummy file." },
    { "correct": "  printf(\"Loading config.ini...\\n\");", distractors: [{"text":"  puts(\"Loading config.ini...\");", reason:"`puts` is a simpler and equally valid way to print this message."}], indent: 1, explanation: "Informational message." },
    { "correct": "  IniHandle config = ini_load(\"config.ini\");", distractors: [{"text":"  struct IniConfig* config = ini_load(...);", reason:"This is also correct, but since we created the `IniHandle` typedef, it's cleaner to use it."}], indent: 1, explanation: "Load the configuration using our library's API." },
    { "correct": "  if (!config) { printf(\"Failed to load config.\\n\"); return 1; }", distractors: [{"text":"  // No need to check for errors", reason:"This is dangerous. The `ini_load` function can fail (e.g., file not found), and you must always check its return value before using the handle."}], indent: 1, explanation: "Check if loading was successful." },
    { "correct": "  printf(\"--- Retrieving Values ---\\n\");", distractors: [{"text":"  puts(\"--- Retrieving Values ---\");", reason:"`puts` is a valid alternative for printing this header."}], indent: 1, explanation: "Header for value retrieval." },
    { "correct": "  const char* user_name = ini_get_string(config, \"user\", \"name\");", distractors: [{"text":"  char* user_name = config->head->pairs->value;", reason:"This is a critical error. You must not access the internal members of an opaque pointer. You must use the provided API function (`ini_get_string`)."}], indent: 1, explanation: "Get the user's name." },
    { "correct": "  int db_port = ini_get_integer(config, \"database\", \"port\", 0);", distractors: [{"text":"  int db_port = atoi(ini_get_string(config, \"database\", \"port\"));", reason:"This would work, but it's less robust. It doesn't handle the case where the key isn't found, which would pass `NULL` to `atoi` and cause a crash."}], indent: 1, explanation: "Get the database port as an integer." },
    { "correct": "  const char* db_pass = ini_get_string(config, \"database\", \"password\");", distractors: [{"text":"  char db_pass[128]; strcpy(db_pass, ini_get_string(...));", reason:"This is dangerous. If `ini_get_string` returns NULL, `strcpy` will crash. The return value must be checked first."}], indent: 1, explanation: "Attempt to get a key that doesn't exist." },
    { "correct": "  printf(\"User Name: %s\\n\", user_name ? user_name : \"not found\");", distractors: [{"text":"  printf(\"User Name: %s\\n\", user_name);", reason:"This is a bug. If `user_name` is NULL (because the key wasn't found), passing it to `%s` results in undefined behavior (often a crash). The ternary operator is a safe way to handle this."}], indent: 1, explanation: "Print the retrieved user name, handling a NULL return." },
    { "correct": "  printf(\"Database Port: %d\\n\", db_port);", distractors: [{"text":"  printf(\"Database Port: %f\\n\", db_port);", reason:"`%f` is for doubles. Using it for an `int` will result in garbage output."}], indent: 1, explanation: "Print the retrieved database port." },
    { "correct": "  printf(\"Database Password: %s\\n\", db_pass ? db_pass : \"not found\");", distractors: [{"text":"  if (db_pass) { printf(\"Password: %s\\n\", db_pass); }", reason:"An `if` block is another perfectly valid way to safely print the value only if it's not NULL."}], indent: 1, explanation: "Show that the non-existent key was not found." },
    { "correct": "  printf(\"--- Cleaning Up ---\\n\");", distractors: [{"text":"  puts(\"--- Cleaning Up ---\");", reason:"This is a valid alternative."}], indent: 1, explanation: "Header for cleanup." },
    { "correct": "  ini_free(config);", distractors: [{"text":"  free(config);", reason:"This is a memory leak. `free(config)` would only free the top-level `IniConfig` struct, but not the linked lists of sections and pairs inside it. You must use the dedicated `ini_free` function."}], indent: 1, explanation: "Free all memory associated with the config using our API." },
    { "correct": "  printf(\"Configuration freed successfully.\\n\");", distractors: [{"text":"  puts(\"Configuration freed successfully.\");", reason:"`puts` is a simpler and equally valid way to print this message."}], indent: 1, explanation: "Confirmation message." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 signals an error. Since the program completed its task successfully, it should return 0."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 72: stores records in a binary file
    {
        "goal": "Create a command-line contact book that stores records in a binary file.",
        concepts: "Binary I/O (`fread`/`fwrite`), struct serialization, `argc`/`argv`, `realloc`, `strstr`",
        sequence: [
    { "correct": "#include <stdio.h>", distractors: [{"text": "#include <stdlib.h>", reason: "File I/O functions like `fopen`, `fread`, and `fwrite` are part of the Standard Input/Output library, `<stdio.h>`."}], indent: 0, explanation: "Include for standard I/O functions." },
    { "correct": "#include <stdlib.h>", distractors: [{"text": "#include <memory.h>", reason: "Memory management functions (`malloc`, `realloc`, `free`) and program control (`exit`) are in the Standard Library, `<stdlib.h>`."}], indent: 0, explanation: "Include for memory management and exit()." },
    { "correct": "#include <string.h>", distractors: [{"text": "#include <strings.h>", reason: "The standard C header for string functions like `strcmp` and `strstr` is `<string.h>`."}], indent: 0, explanation: "Include for string manipulation functions." },
    { "correct": "#define FILENAME \"contacts.dat\"", distractors: [{"text": "const char* FILENAME = \"contacts.dat\";", reason: "Using a `const char*` variable is also a valid way to define the filename. `#define` creates a preprocessor macro that replaces the text before compilation."}], indent: 0, explanation: "Define the name of our binary data file." },
    { "correct": "#define MAX_NAME 50", distractors: [{"text": "#define MAX_NAME = 50", reason: "The syntax for `#define` is `#define NAME value`. An equals sign is not used."}], indent: 0, explanation: "Define the max length for a contact's name." },
    { "correct": "#define MAX_EMAIL 50", distractors: [{"text": "#define MAX_EMAIL 50;", reason: "Preprocessor macros generally should not end with a semicolon, as it becomes part of the text replacement and can cause syntax errors."}], indent: 0, explanation: "Define the max length for a contact's email." },
    { "correct": "// Define the structure for a single contact.", distractors: [{"text": "// A class for a contact.", reason: "C uses `struct` to group data, not `class`. `class` is a C++ keyword."}], indent: 0, explanation: "This struct will be written directly to the file." },
    { "correct": "typedef struct {", distractors: [{"text": "struct Contact {", reason: "This also works, but requires you to declare variables as `struct Contact c;`. Using `typedef` allows the simpler `Contact c;`."}], indent: 0, explanation: "Begin defining the Contact struct." },
    { "correct": "  int id;", distractors: [{"text": "  unsigned int id;", reason: "Using `unsigned int` is a good choice for an ID that should never be negative."}], indent: 1, explanation: "A unique ID for the contact." },
    { "correct": "  char name[MAX_NAME];", distractors: [{"text": "  char* name;", reason: "This is a key difference. For binary I/O of entire structs, you need fixed-size members. A `char*` would only write the pointer's address, not the string data, which would be useless."}], indent: 1, explanation: "Fixed-size array for the name." },
    { "correct": "  char email[MAX_EMAIL];", distractors: [{"text": "  char email;", reason: "This declares a single character, not an array of characters to hold a string."}], indent: 1, explanation: "Fixed-size array for the email." },
    { "correct": "} Contact;", distractors: [{"text": "};", reason: "When creating a `typedef`, the new type name (`Contact`) must be placed before the final semicolon."}], indent: 0, explanation: "Create the `Contact` alias." },
    { "correct": "// Global variables for our in-memory list of contacts.", distractors: [{"text": "// Using global variables is the best way to manage state.", reason: "This is generally false. Globals are used here for simplicity, but in larger programs, they can make code difficult to manage. Passing state via parameters is often better."}], indent: 0, explanation: "Comment on the global contact list." },
    { "correct": "Contact* contacts = NULL;", distractors: [{"text": "Contact* contacts;", reason: "It is critical to initialize pointers to NULL. An uninitialized pointer holds a garbage address, which can cause `realloc` to crash."}], indent: 0, explanation: "Pointer for the dynamic array of contacts." },
    { "correct": "int contact_count = 0;", distractors: [{"text": "int contact_count;", reason: "While global integers are auto-initialized to 0, it is much clearer and better practice to initialize variables explicitly."}], indent: 0, explanation: "The number of contacts currently loaded." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text": "// Function Declarations", reason: "'Prototype' is the standard C term for a function's forward declaration, which allows it to be called before it is defined."}], indent: 0, explanation: "Declare all functions before use." },
    { "correct": "void load_contacts();", distractors: [{"text": "int load_contacts();", reason: "This function modifies global state directly and doesn't need to return a value, so `void` is the correct return type."}], indent: 0, explanation: "Prototype for loading contacts from the binary file." },
    { "correct": "void save_contacts();", distractors: [{"text": "void save_contacts(void);", reason: "Using `(void)` is an equally valid and often clearer way to declare that a function takes no arguments."}], indent: 0, explanation: "Prototype for saving the contact list to the binary file." },
    { "correct": "void add_contact(const char* name, const char* email);", distractors: [{"text": "void add_contact(char* name, char* email);", reason: "Using `const` is better practice here, as it signals that this function will not modify the original strings passed to it."}], indent: 0, explanation: "Prototype for adding a new contact." },
    { "correct": "void list_contacts();", distractors: [{"text": "void list_contacts(Contact* contacts);", reason: "Since `contacts` is a global variable, we don't need to pass it as a parameter. This makes the function call simpler."}], indent: 0, explanation: "Prototype for listing all loaded contacts." },
    { "correct": "void search_contacts(const char* query);", distractors: [{"text": "Contact* search_contacts(const char* query);", reason: "This would be a valid design choice, returning an array of found contacts. Simply printing them inside the function is a simpler design."}], indent: 0, explanation: "Prototype for searching contacts by name." },
    { "correct": "void print_usage(const char* prog_name);", distractors: [{"text": "void print_usage();", reason: "Passing `prog_name` allows the usage message to be more accurate, showing the actual name the program was run with."}], indent: 0, explanation: "Prototype for printing help info." },
    { "correct": "// --- Main Function: Entry Point & Command Parser ---", distractors: [{"text": "// Program Start", reason: "'Main Function' is the more technically descriptive term for this section."}], indent: 0, explanation: "The main driver of the application." },
    { "correct": "int main(int argc, char* argv[]) {", distractors: [{"text": "int main() {", reason: "To process command-line arguments, `main` must be defined with the `argc` and `argv` parameters."}], indent: 0, explanation: "Start main." },
    { "correct": "load_contacts();", distractors: [{"text": "// No load needed at start", reason: "The program must load existing data from the file first, otherwise any new actions would overwrite the old data."}], indent: 1, explanation: "First, load existing contacts from the data file." },
    { "correct": "if (argc < 2) { print_usage(argv[0]); return 1; }", distractors: [{"text": "if (argc == 1) { print_usage(argv[0]); return 1; }", reason: "This logic is also correct. `argc` is 1 when only the program name is present, meaning no further commands were given."}], indent: 1, explanation: "If no command is given, print usage and exit." },
    { "correct": "const char* command = argv[1];", distractors: [{"text": "char* command = argv[1];", reason: "`argv` elements are technically `char*`, but since we don't intend to modify them, assigning to a `const char*` is safer practice."}], indent: 1, explanation: "Get the command from the arguments." },
    { "correct": "if (strcmp(command, \"add\") == 0) {", distractors: [{"text": "if (command == \"add\") {", reason: "This is a critical C error. You must use `strcmp()` to compare string content. `==` compares pointer addresses, which will not be equal."}], indent: 1, explanation: "Check if the command is 'add'." },
    { "correct": "  if (argc != 4) {", distractors: [{"text": "  if (argc < 4) {", reason: "`!= 4` is more precise here. It correctly flags cases with too few (`todo add name`) or too many (`todo add name email extra`) arguments."}], indent: 2, explanation: "The 'add' command needs a name and an email." },
    { "correct": "    printf(\"Error: 'add' requires a name and an email.\\n\");", distractors: [{"text": "    puts(\"Error: 'add' requires a name and an email.\");", reason: "`puts` is a simpler and equally valid way to print this fixed error string."}], indent: 3, explanation: "Show an error message." },
    { "correct": "    print_usage(argv[0]);", distractors: [{"text": "    return 1;", reason: "It's more user-friendly to show the correct usage instructions before exiting."}], indent: 3, explanation: "Print usage." },
    { "correct": "  } else {", distractors: [{"text": "  }", reason: "An `else` block is required here to contain the logic that should run only when the argument count is correct."}], indent: 2, explanation: "If arguments are correct..." },
    { "correct": "    add_contact(argv[2], argv[3]);", distractors: [{"text": "    add_contact(&argv[2], &argv[3]);", reason: "`argv[2]` is already a pointer (`char*`). Taking its address would create a `char**`, which is the wrong type for the function."}], indent: 3, explanation: "Call the add function with the provided name and email." },
    { "correct": "  }", distractors: [{"text": "};", reason: "Semicolons are not used after the closing brace of an `if/else` block."}], indent: 2, explanation: "Close add logic." },
    { "correct": "} else if (strcmp(command, \"list\") == 0) {", distractors: [{"text": "} if (strcmp(command, \"list\") == 0) {", reason: "You must use `else if` to chain these conditions properly. A separate `if` would execute incorrectly if the first command was also true."}], indent: 1, explanation: "Check if the command is 'list'." },
    { "correct": "  list_contacts();", distractors: [{"text": "  list_contacts(contacts, contact_count);", reason: "Since `contacts` and `contact_count` are global, we don't need to pass them as parameters."}], indent: 2, explanation: "Call the list function." },
    { "correct": "} else if (strcmp(command, \"search\") == 0) {", distractors: [{"text": "if (strcmp(command, \"search\") == 0) {", reason: "Without the `else`, this block could execute even if a previous command was already handled, leading to incorrect behavior."}], indent: 1, explanation: "Check if the command is 'search'." },
    { "correct": "  if (argc != 3) {", distractors: [{"text": "  if (argc < 3) {", reason: "This would incorrectly allow extra arguments after the query. `!= 3` ensures the command has the correct structure."}], indent: 2, explanation: "The 'search' command requires a query term." },
    { "correct": "    printf(\"Error: 'search' requires a name to search for.\\n\");", distractors: [{"text": "    perror(\"Missing argument\");", reason: "`perror` is for printing system-level errors (like file access denied), not for user input validation."}], indent: 3, explanation: "Show an error message." },
    { "correct": "    print_usage(argv[0]);", distractors: [{"text": "    return 1;", reason: "Printing the usage instructions is more helpful to the user than just exiting with an error code."}], indent: 3, explanation: "Print usage." },
    { "correct": "  } else {", distractors: [{"text": "  }", reason: "The `else` is required to ensure the search logic only runs when the arguments are valid."}], indent: 2, explanation: "If query is provided..." },
    { "correct": "    search_contacts(argv[2]);", distractors: [{"text": "    search_contacts(\"argv[2]\");", reason: "This would search for the literal string \"argv[2]\" instead of the value provided on the command line."}], indent: 3, explanation: "Call the search function." },
    { "correct": "  }", distractors: [{"text": "};", reason: "Semicolons are not used after `}` in C."}], indent: 2, explanation: "Close search logic." },
    { "correct": "} else {", distractors: [{"text": "}", reason: "Without a final `else` block, an unknown command would fail silently, leaving the user confused."}], indent: 1, explanation: "Handle unknown commands." },
    { "correct": "  printf(\"Error: Unknown command '%s'.\\n\", command);", distractors: [{"text": "  printf(\"Error: Unknown command.\\n\");", reason: "This works, but echoing the invalid command back to the user is more helpful for debugging their input."}], indent: 2, explanation: "Print an error for unrecognized commands." },
    { "correct": "  print_usage(argv[0]);", distractors: [{"text": "  // Do nothing.", reason: "It's a much better user experience to show the correct commands after the user enters an invalid one."}], indent: 2, explanation: "Print usage." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses curly braces `{}` to define and close code blocks, not keywords like `end`."}], indent: 1, explanation: "Close command parsing logic." },
    { "correct": "if (contacts) { free(contacts); }", distractors: [{"text": "free(contacts);", reason: "Calling `free` on a `NULL` pointer is safe, but this `if` check is good practice to make the intention clear. It's especially useful if `contacts` wasn't guaranteed to be initialized to `NULL`."}], indent: 1, explanation: "Before exiting, free the main contacts array if it was allocated." },
    { "correct": "return 0;", distractors: [{"text": "return;", reason: "`main` is defined to return an `int`, so it must return an integer value. An empty return is only valid for `void` functions."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end main;", reason:"This is not valid C syntax. A function block is always closed with `}`."}], indent: 0, explanation: "Close main." },
    { "correct": "// --- Function Implementations ---", distractors: [{"text": "// Function Definitions", reason: "'Implementations' and 'Definitions' are both common and correct terms for the function bodies."}], indent: 0, explanation: "Define the functions." },
    { "correct": "void save_contacts() {", distractors: [{"text": "int save_contacts() {", reason: "The function definition must match the prototype, which was declared to return `void`."}], indent: 0, explanation: "Start the `save_contacts` implementation." },
    { "correct": "  FILE* fp = fopen(FILENAME, \"wb\");", distractors: [{"text": "  FILE* fp = fopen(FILENAME, \"w\");", reason: "This is a key error. Using text mode `\"w\"` can corrupt binary data on some systems (e.g., newline translation). Binary mode `\"wb\"` is required for writing raw struct data."}], indent: 1, explanation: "Open the file in binary write mode ('wb')." },
    { "correct": "  if (!fp) { perror(\"Failed to save contacts\"); return; }", distractors: [{"text": "  if (fp == NULL) { printf(\"Error\\n\"); return; }", reason: "`perror` is superior to `printf` for system errors because it also prints a descriptive message about what went wrong (e.g., 'Permission denied')."}], indent: 1, explanation: "Handle file open error." },
    { "correct": "// First, write the number of records. This makes loading much easier.", distractors: [{"text": "// Write all data at once.", reason: "This comment is misleading. We are breaking the save into two distinct parts: the count, then the data block."}], indent: 1, explanation: "Comment on the file format design." },
    { "correct": "  fwrite(&contact_count, sizeof(int), 1, fp);", distractors: [{"text": "  fprintf(fp, \"%d\\n\", contact_count);", reason: "`fprintf` writes text. For a binary file format, we should write the raw bytes of the integer using `fwrite`."}], indent: 1, explanation: "Write the integer `contact_count` to the start of the file." },
    { "correct": "  // Then, write the entire array of structs in one block.", distractors: [{"text": "  // Loop and write each struct.", reason: "Looping and writing one struct at a time would also work, but writing the entire array in a single block is much more efficient."}], indent: 1, explanation: "Comment on writing the data block." },
    { "correct": "  fwrite(contacts, sizeof(Contact), contact_count, fp);", distractors: [{"text": "  fwrite(contacts, sizeof(Contact*), contact_count, fp);", reason: "The `size` argument must be the size of a single element (`Contact`), not the size of a pointer to one (`Contact*`)."}, {"text": "  fwrite(contacts, sizeof(Contact), 1, fp);", reason: "This would only write the first contact, not all of them. The `count` argument must be `contact_count`."}] , indent: 1, explanation: "Write the raw bytes of the `contacts` array directly to the file." },
    { "correct": "  fclose(fp);", distractors: [{"text": "  // No need to close file.", reason: "This is false. Failing to close the file can result in the data not being fully written to the disk from the buffer."}], indent: 1, explanation: "Close the file." },
    { "correct": "  printf(\"Contacts saved successfully.\\n\");", distractors: [{"text": "  puts(\"Contacts saved successfully.\");", reason: "`puts` is a valid and simpler alternative for printing this message."}], indent: 1, explanation: "Confirmation message." },
    { "correct": "}", distractors: [{"text": "};", reason: "A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "Close `save_contacts`." },
    { "correct": "void load_contacts() {", distractors: [{"text": "void load_contacts(void) {", reason: "This is an equally valid and often clearer way to declare a function that takes no arguments."}], indent: 0, explanation: "Start the `load_contacts` implementation." },
    { "correct": "  FILE* fp = fopen(FILENAME, \"rb\");", distractors: [{"text": "  FILE* fp = fopen(FILENAME, \"r\");", reason: "Text mode `\"r\"` can cause issues when reading binary data on some systems. You must use binary mode `\"rb\"` to match the `\"wb\"` used for saving."}], indent: 1, explanation: "Open the file in binary read mode ('rb')." },
    { "correct": "  if (!fp) { return; } // File doesn't exist yet, which is fine.", distractors: [{"text": "  if (fp == NULL) { exit(1); }", reason: "The file not existing is expected behavior on the first run. The program should not treat this as a fatal error."}], indent: 1, explanation: "If there's no file, there's nothing to load." },
    { "correct": "  // First, read the number of records.", distractors: [{"text": "  // Guess the number of records.", reason: "We don't need to guess. Our file format was designed to have the exact count as the very first piece of data."}], indent: 1, explanation: "Comment on reading the count." },
    { "correct": "  fread(&contact_count, sizeof(int), 1, fp);", distractors: [{"text": "  fscanf(fp, \"%d\", &contact_count);", reason: "Since this is a binary file, you must use `fread` to read the raw bytes of the integer, not `fscanf` which is for text."}], indent: 1, explanation: "Read the integer from the file into our global `contact_count` variable." },
    { "correct": "  if (contact_count > 0) {", distractors: [{"text": "  if (contact_count) {", reason: "This is a valid and common shorthand for checking if `contact_count` is not zero."}], indent: 1, explanation: "If there are records to read..." },
    { "correct": "    contacts = malloc(contact_count * sizeof(Contact));", distractors: [{"text": "    contacts = realloc(contacts, contact_count * sizeof(Contact));", reason: "Since `contacts` is guaranteed to be `NULL` at this point, `malloc` is slightly clearer. However, `realloc(NULL, ...)` behaves identically to `malloc`."}], indent: 2, explanation: "Allocate exactly enough memory for all the contacts." },
    { "correct": "    if (!contacts) { perror(\"Failed to allocate memory for contacts\"); fclose(fp); exit(1); }", distractors: [{"text": "    if (!contacts) { return; }", reason: "This is a critical failure. The program cannot continue if it fails to allocate memory, so it must exit. Also, `fclose` must be called to prevent a resource leak."}], indent: 2, explanation: "Handle memory allocation failure." },
    { "correct": "    // Read the entire block of contact data from the file.", distractors: [{"text": "    // Loop and read each contact one by one.", reason: "Looping would also work, but reading the entire block at once with a single `fread` call is much more efficient."}], indent: 2, explanation: "Comment on reading the data block." },
    { "correct": "    fread(contacts, sizeof(Contact), contact_count, fp);", distractors: [{"text": "    fread(contacts, sizeof(Contact), 1, fp);", reason: "This is a bug. The count argument should be `contact_count` to read all the records, not just 1."}], indent: 2, explanation: "Read the raw byte data from the file directly into our newly allocated array." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used after `if` blocks."}], indent: 1, explanation: "Close the if block." },
    { "correct": "  fclose(fp);", distractors: [{"text": "  free(fp);", reason: "`fp` is a `FILE` handle managed by the standard library. It must be closed with `fclose`, not `free`."}], indent: 1, explanation: "Close the file." },
    { "correct": "  printf(\"Loaded %d contacts.\\n\", contact_count);", distractors: [{"text": "  puts(\"Loaded contacts.\");", reason: "This is less informative. Printing the actual number of contacts loaded is better user feedback."}], indent: 1, explanation: "Confirmation message." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "Close `load_contacts`." },
    { "correct": "void add_contact(const char* name, const char* email) {", distractors: [{"text":"void add_contact(char name[], char email[]) {", reason:"In function parameters, `char*` and `char[]` are treated identically by the compiler."}], indent: 0, explanation: "Start `add_contact` implementation." },
    { "correct": "  contact_count++;", distractors: [{"text": "  contact_count += 1;", reason: "This is also a correct way to increment the variable, but `++` is the more common C idiom."}], indent: 1, explanation: "Increment the global counter." },
    { "correct": "  contacts = realloc(contacts, contact_count * sizeof(Contact));", distractors: [{"text": "  Contact* temp = realloc(contacts, contact_count * sizeof(Contact));", reason: "Using a temporary pointer is a safer pattern in case `realloc` fails, but direct assignment is often used for brevity in examples."}], indent: 1, explanation: "Resize the contacts array to make space for one more." },
    { "correct": "  if (!contacts) { perror(\"Failed to realloc for new contact\"); exit(1); }", distractors: [{"text": "  if (!contacts) { return; }", reason: "Failing to allocate memory is a critical error. The program cannot safely continue, so it should `exit` rather than just returning."}], indent: 1, explanation: "Handle reallocation failure." },
    { "correct": "  Contact* new_contact = &contacts[contact_count - 1];", distractors: [{"text": "  Contact* new_contact = malloc(sizeof(Contact));", reason: "This is a bug. We don't need to allocate a separate contact; `realloc` already made space for it at the end of the `contacts` array."}], indent: 1, explanation: "Get a pointer to the new slot at the end of the array." },
    { "correct": "  new_contact->id = contact_count;", distractors: [{"text": "  contacts[contact_count - 1].id = contact_count;", reason: "This is also correct. Using the `new_contact` pointer is just a convenient shorthand for `contacts[contact_count - 1]`."}], indent: 1, explanation: "Assign the new ID." },
    { "correct": "  strncpy(new_contact->name, name, MAX_NAME - 1);", distractors: [{"text": "  strcpy(new_contact->name, name);", reason: "`strcpy` is unsafe. If the input `name` is too long, it will cause a buffer overflow. `strncpy` is the safer choice."}], indent: 1, explanation: "Safely copy the name." },
    { "correct": "  new_contact->name[MAX_NAME - 1] = '\\0';", distractors: [{"text": "  // Not needed, strncpy handles this.", reason: "This is a common misconception. `strncpy` does *not* guarantee null-termination if the source string is too long. Manual termination is a crucial safety step."}], indent: 1, explanation: "Ensure null termination." },
    { "correct": "  strncpy(new_contact->email, email, MAX_EMAIL - 1);", distractors: [{"text": "  new_contact->email = email;", reason: "This is a pointer assignment, not a string copy. It would make the struct member point to `argv[3]`, which is incorrect."}], indent: 1, explanation: "Safely copy the email." },
    { "correct": "  new_contact->email[MAX_EMAIL - 1] = '\\0';", distractors: [{"text":"  new_contact->email[MAX_EMAIL] = '\\0';", reason:"This is an off-by-one error. The last valid index is `MAX_EMAIL - 1`. Writing to `MAX_EMAIL` is out of bounds."}], indent: 1, explanation: "Ensure null termination." },
    { "correct": "  save_contacts();", distractors: [{"text": "  // No save needed here.", reason: "The program should save after every modification to ensure data is not lost if the program crashes or is closed."}], indent: 1, explanation: "Call save to persist the new addition to the file." },
    { "correct": "}", distractors: [{"text":"};", reason:"Semicolons are not used after a function's closing brace."}], indent: 0, explanation: "Close `add_contact`." },
    { "correct": "void list_contacts() {", distractors: [{"text":"void list_contacts(void) {", reason:"This is an equally valid way to define a function that takes no parameters."}], indent: 0, explanation: "Start `list_contacts` implementation." },
    { "correct": "  printf(\"\\n--- Contact List (%d) ---\\n\", contact_count);", distractors: [{"text":"  printf(\"\\n--- Contact List ---\\n\");", reason:"This is fine, but including the total count in the header provides more useful information."}], indent: 1, explanation: "Print a formatted header." },
    { "correct": "  for (int i=0; i < contact_count; i++) {", distractors: [{"text":"  for (int i=0; i <= contact_count - 1; i++) {", reason:"This is a logically equivalent and correct way to write the loop's condition."}], indent: 1, explanation: "Loop through all loaded contacts." },
    { "correct": "    printf(\"ID: %-3d | Name: %-20s | Email: %s\\n\", contacts[i].id, contacts[i].name, contacts[i].email);", distractors: [{"text":"    printf(\"%d, %s, %s\\n\", contacts[i].id, contacts[i].name, contacts[i].email);", reason:"This works, but the formatted version (`%-3d`, `%-20s`) aligns the output in neat columns, which is much more readable."}], indent: 2, explanation: "Print the details of each contact with nice formatting." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop's closing brace."}], indent: 1, explanation: "Close the loop." },
    { "correct": "  printf(\"----------------------------\\n\");", distractors: [{"text":"  puts(\"----------------------------\");", reason:"`puts` is a simpler and equally valid way to print this footer line."}], indent: 1, explanation: "Print a footer." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a code block."}], indent: 0, explanation: "Close `list_contacts`." },
    { "correct": "void search_contacts(const char* query) {", distractors: [{"text":"void Contactss(const char* query) {", reason:"This contains a typo. The function name must match the prototype exactly."}], indent: 0, explanation: "Start `Contactss` implementation." },
    { "correct": "  printf(\"\\n--- Search Results for \\\"%s\\\" ---\\n\", query);", distractors: [{"text":"  printf(\"\\n--- Search Results ---\\n\");", reason:"This works, but including the search query makes the output header much clearer to the user."}], indent: 1, explanation: "Print a search header." },
    { "correct": "  int found_count = 0;", distractors: [{"text":"  int found_count;", reason:"All counters must be initialized to 0. An uninitialized variable will contain a garbage value, leading to an incorrect count."}], indent: 1, explanation: "A counter for the number of matches." },
    { "correct": "  for (int i=0; i < contact_count; i++) {", distractors: [{"text":"  for (int i=0; i < MAX_NAME; i++) {", reason:"This is a bug. The loop must iterate up to `contact_count`, not a constant like `MAX_NAME`."}], indent: 1, explanation: "Loop through all contacts." },
    { "correct": "    // `strstr` finds the first occurrence of a substring. It's case-sensitive.", distractors: [{"text":"    // `strcmp` finds substrings.", reason:"This is false. `strcmp` is for exact matches only. `strstr` is the function that finds a substring within another string."}], indent: 2, explanation: "Explain `strstr`." },
    { "correct": "    if (strstr(contacts[i].name, query) != NULL) {", distractors: [{"text":"if (strcmp(contacts[i].name, query) == 0) {", reason:"`strcmp` only finds exact matches. `strstr` finds the query as a substring anywhere within the name, which is better for searching."}, {"text":"if (strstr(contacts[i].name, query)) {", reason:"This is a valid and common shorthand. A non-NULL pointer returned by `strstr` on success evaluates to true."}], indent: 2, explanation: "Use `strstr` to see if the query appears anywhere in the contact's name." },
    { "correct": "      printf(\"ID: %-3d | Name: %-20s | Email: %s\\n\", contacts[i].id, contacts[i].name, contacts[i].email);", distractors: [{"text":"      list_contacts();", reason:"This would be incorrect, as it would list *all* contacts instead of just the one that matched the search."}], indent: 3, explanation: "If it's a match, print the contact's details." },
    { "correct": "      found_count++;", distractors: [{"text":"      found_count = 1;", reason:"This would be a bug. `found_count` needs to be incremented (`++`) to count all matches, not just reset to 1."}], indent: 3, explanation: "Increment the match counter." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 2, explanation: "Close the if block." },
    { "correct": "  }", distractors: [{"text":"end for;", reason:"This is not valid C syntax."}], indent: 1, explanation: "Close the search loop." },
    { "correct": "  if (found_count == 0) {", distractors: [{"text":"  if (!found_count) {", reason:"This is a valid and common shorthand to check if `found_count` is zero."}], indent: 1, explanation: "Check if no matches were found." },
    { "correct": "    printf(\"No contacts found matching your query.\\n\");", distractors: [{"text":"    puts(\"No contacts found.\");", reason:"This is a simpler, valid alternative, though slightly less specific."}], indent: 2, explanation: "Print a not-found message." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 1, explanation: "Close the check." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "Close `Contactss`." },
    { "correct": "void print_usage(const char* prog_name) {", distractors: [{"text":"void print_usage() {", reason:"The prototype and definition must match. Also, accepting `prog_name` makes the usage message more robust."}], indent: 0, explanation: "Start `print_usage` implementation." },
    { "correct": "  printf(\"\\nUsage: %s <command> [options]\\n\", prog_name);", distractors: [{"text":"  printf(\"\\nUsage: contact_book <command> [options]\\n\");", reason:"Hard-coding the program name is less flexible. Using `prog_name` (from `argv[0]`) ensures the message is correct even if the executable is renamed."}], indent: 1, explanation: "Print main usage line." },
    { "correct": "  printf(\"Commands:\\n\");", distractors: [{"text":"  puts(\"Commands:\");", reason:"`puts` is a simpler and equally valid way to print this header line."}], indent: 1, explanation: "Header for commands." },
    { "correct": "  printf(\"  list                            - Show all contacts.\\n\");", distractors: [{"text":"  puts(\"  list                            - Show all contacts.\");", reason:"`puts` is also a valid way to print this line."}], indent: 1, explanation: "Explain list command." },
    { "correct": "  printf(\"  add <name> <email>            - Add a new contact.\\n\");", distractors: [{"text":"  puts(\"  add <name> <email>            - Add a new contact.\");", reason:"`puts` is also a valid way to print this line."}], indent: 1, explanation: "Explain add command." },
    { "correct": "  printf(\"  search <name_query>           - Search for contacts by name.\\n\");", distractors: [{"text":"  puts(\"  search <name_query>           - Search for contacts by name.\");", reason:"`puts` is also a valid way to print this line."}], indent: 1, explanation: "Explain search command." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "Close `print_usage`." }
]
    },
    // Level 73: storing key-value pairs in a hash table
    {
        "goal": "Build a read-only parser for a subset of JSON, storing key-value pairs in a hash table.",
        concepts: "Hash tables, hashing functions, linked lists, dynamic memory, string parsing, `strtok`",
        sequence: [
    { "correct": "// --- Stage 1: Core Data Structures ---", distractors: [{"text":"// --- Stage 1: The Main Program ---", reason:"It's a good design practice to define the fundamental data structures first, before writing the logic that uses them."}], indent: 0, explanation: "First, we define the structures needed to store our parsed JSON data." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"`printf` is a standard I/O function and requires `<stdio.h>`."}], indent: 0, explanation: "Include for standard I/O." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <memory.h>", reason:"Standard memory allocation functions like `malloc` and `free` are prototyped in `<stdlib.h>`."}], indent: 0, explanation: "Include for memory allocation." },
    { "correct": "#include <string.h>", distractors: [{"text":"#include <strings.h>", reason:"The standard C header for string functions like `strcmp` and `strdup` is `<string.h>`."}], indent: 0, explanation: "Include for string manipulation." },
    { "correct": "#define HASH_TABLE_SIZE 64", distractors: [{"text":"#define HASH_TABLE_SIZE 60", reason:"While any size works, using a power of 2 (like 64) can sometimes allow for faster modulo operations by the compiler (using bitwise AND)."}], indent: 0, explanation: "Define the size of our hash table. A power of 2 is often chosen." },
    { "correct": "// A Key-Value pair, forming a node in a linked list for collision handling.", distractors: [{"text":"// An array for storing key-value pairs.", reason:"This is incorrect. The struct itself is a single node; the `next` pointer is what allows them to be chained into a linked list."}], indent: 0, explanation: "Comment on the K-V pair struct." },
    { "correct": "typedef struct KeyValuePair {", distractors: [{"text":"struct KeyValuePair {", reason:"Without `typedef`, you would have to write `struct KeyValuePair* next;` which is more verbose."}], indent: 0, explanation: "Begin KeyValuePair definition." },
    { "correct": "  char* key;", distractors: [{"text":"  char key[64];", reason:"A fixed-size array limits key length and can waste memory. A `char*` is more flexible but requires dynamic memory management."}], indent: 1, explanation: "The JSON key (string)." },
    { "correct": "  char* value;", distractors: [{"text":"  const char* value;", reason:"The data stored in the hash table will be dynamically allocated and owned by the table, so it should not be `const`."}], indent: 1, explanation: "The JSON value (stored as a string)." },
    { "correct": "  struct KeyValuePair* next;", distractors: [{"text":"  KeyValuePair next;", reason:"A struct cannot contain a member of its own type, as this would require infinite memory. It must be a pointer to its own type."}], indent: 1, explanation: "Pointer to the next item in the case of a hash collision." },
    { "correct": "} KeyValuePair;", distractors: [{"text":"};", reason:"When using `typedef` with a struct, you must provide the new type alias (`KeyValuePair`) before the final semicolon."}], indent: 0, explanation: "Close the KeyValuePair typedef." },
    { "correct": "// The Hash Table structure itself.", distractors: [{"text":"// The Linked List structure.", reason:"The hash table is more than just a linked list; it's an array of linked lists."}], indent: 0, explanation: "Comment on the main Hash Table struct." },
    { "correct": "typedef struct {", distractors: [{"text":"struct HashTable {", reason:"Using `typedef` is a convenience that lets us declare variables as `HashTable ht;` instead of `struct HashTable ht;`."}], indent: 0, explanation: "Begin HashTable definition." },
    { "correct": "  KeyValuePair* buckets[HASH_TABLE_SIZE];", distractors: [{"text":"  KeyValuePair buckets[HASH_TABLE_SIZE];", reason:"This creates an array of full `KeyValuePair` structs, not pointers. This would not allow for linked lists to handle collisions; each bucket could only store one item."}], indent: 1, explanation: "An array of pointers, where each element (bucket) is the head of a linked list." },
    { "correct": "} HashTable;", distractors: [{"text":"} HashTable", reason:"A `typedef` definition requires a semicolon at the end."}], indent: 0, explanation: "Close the HashTable typedef." },
    { "correct": "// --- Stage 2: Hash Table Functions ---", distractors: [{"text":"// --- Stage 2: The Parser ---", reason:"Before we can parse, we need to build the fundamental functions that operate on our hash table data structure (`create`, `set`, `get`, `free`)."}], indent: 0, explanation: "Now, we implement the core functions to operate on our hash table." },
    { "correct": "unsigned long hash_function(const char* str) {", distractors: [{"text":"int hash_function(char* str) {", reason:"A hash can be a very large number, so `unsigned long` is a better return type. The input string is not modified, so it should be `const char*`."}], indent: 0, explanation: "Define a hashing function to convert a string key into an index." },
    { "correct": "  unsigned long hash = 5381;", distractors: [{"text":"  unsigned long hash = 0;", reason:"Starting with 0 is possible, but using a non-zero prime number often helps create a better distribution of hash values."}], indent: 1, explanation: "Start with a magic prime number (part of the djb2 algorithm)." },
    { "correct": "  int c;", distractors: [{"text":"  char c;", reason:"`getchar()` and similar functions (like this loop's pattern) return an `int` to accommodate special values like `EOF`. It's standard practice to use `int`."}], indent: 1, explanation: "A variable to hold the current character." },
    { "correct": "  while ((c = *str++)) {", distractors: [{"text":"  for (int i=0; i < strlen(str); i++) { c = str[i]; ... }", reason:"This works, but calling `strlen` first requires an extra pass over the string. The `while` loop is a more efficient C idiom that processes the string in a single pass."}], indent: 1, explanation: "Loop through each character of the string." },
    { "correct": "    hash = ((hash << 5) + hash) + c; /* hash * 33 + c */", distractors: [{"text":"    hash = (hash + c) % HASH_TABLE_SIZE;", reason:"This is a much simpler but less effective hash function. It doesn't distribute keys well, leading to many collisions."}], indent: 2, explanation: "Apply the djb2 hashing algorithm logic." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after the closing brace of a `while` loop."}], indent: 1, explanation: "Close the loop." },
    { "correct": "  return hash % HASH_TABLE_SIZE;", distractors: [{"text":"  return hash;", reason:"This is a critical error. The raw hash value can be huge. The modulo `%` operator is required to scale it down to a valid index for our `buckets` array."}], indent: 1, explanation: "Use the modulo operator to ensure the hash fits within our table size." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "Close the hash function." },
    { "correct": "HashTable* ht_create() {", distractors: [{"text":"HashTable ht_create() {", reason:"This function must return a pointer to the dynamically allocated table, so the return type must be `HashTable*`."}], indent: 0, explanation: "A 'constructor' function to create and initialize a new hash table." },
    { "correct": "  HashTable* ht = malloc(sizeof(HashTable));", distractors: [{"text":"  HashTable* ht = malloc(sizeof(ht));", reason:"This is a bug. `ht` is an uninitialized pointer, so `sizeof(ht)` gives the size of the pointer itself (e.g., 8 bytes), not the much larger size of the `HashTable` struct."}], indent: 1, explanation: "Allocate memory for the main table structure." },
    { "correct": "  if (!ht) return NULL;", distractors: [{"text":"  // No error check needed", reason:"This is dangerous. `malloc` can fail if the system is out of memory. You must always check its return value."}], indent: 1, explanation: "Handle allocation failure." },
    { "correct": "  memset(ht->buckets, 0, sizeof(ht->buckets));", distractors: [{"text":"  for (int i=0; i<HASH_TABLE_SIZE; i++) { ht->buckets[i] = NULL; }", reason:"A `for` loop is also a perfectly correct way to initialize all bucket pointers to NULL. `memset` is just a faster, single-function way to zero out a block of memory."}], indent: 1, explanation: "Use `memset` to initialize all bucket pointers to NULL." },
    { "correct": "  return ht;", distractors: [{"text":"  return *ht;", reason:"This would try to dereference the pointer and return the entire struct by value, which is incorrect. The function's return type is a pointer `HashTable*`."}], indent: 1, explanation: "Return the newly created hash table." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "Close the create function." },
    { "correct": "void ht_set(HashTable* ht, const char* key, const char* value) {", distractors: [{"text":"void ht_set(HashTable ht, ...)", reason:"Passing the hash table by value would pass a copy. Any modifications would be lost when the function returns. We must pass a pointer."}], indent: 0, explanation: "Function to insert a key-value pair into the hash table." },
    { "correct": "  unsigned long index = hash_function(key);", distractors: [{"text":"  int index = strlen(key) % HASH_TABLE_SIZE;", reason:"Using `strlen` as a hash function is simple but very poor, as many different keys ('cat', 'bat') would have the same hash, leading to high collisions."}], indent: 1, explanation: "Calculate the index for this key." },
    { "correct": "  KeyValuePair* new_pair = malloc(sizeof(KeyValuePair));", distractors: [{"text":"  KeyValuePair new_pair;", reason:"This creates a local stack variable that will be destroyed when the function returns. The node must be dynamically allocated with `malloc` to persist."}], indent: 1, explanation: "Allocate memory for the new key-value pair node." },
    { "correct": "  new_pair->key = strdup(key);", distractors: [{"text":"  new_pair->key = key;", reason:"This is a bug. It only copies the pointer, not the string content. The original string (e.g., from a temporary buffer) could be changed or freed, corrupting the key. `strdup` makes a safe copy."}], indent: 1, explanation: "Use `strdup` to allocate and copy the key." },
    { "correct": "  new_pair->value = strdup(value);", distractors: [{"text":"  new_pair->value = value;", reason:"This is a bug. The value string must be copied into new, persistent memory. `strdup` correctly handles the allocation and copy."}], indent: 1, explanation: "Use `strdup` to allocate and copy the value." },
    { "correct": "  // Insert at the head of the linked list for this bucket (handles collisions).", distractors: [{"text":"  // Find the end of the list and insert there.", reason:"Inserting at the tail of a linked list is less efficient (O(n)) than inserting at the head (O(1)), because you have to traverse the whole list first."}], indent: 1, explanation: "Comment on collision handling." },
    { "correct": "  new_pair->next = ht->buckets[index];", distractors: [{"text":"  ht->buckets[index] = new_pair;", reason:"This assignment must happen *after* linking the new pair to the old head. Doing it first would lose the rest of the list."}], indent: 1, explanation: "The new pair's `next` points to the current head of the list." },
    { "correct": "  ht->buckets[index] = new_pair;", distractors: [{"text":"  new_pair->next = NULL;", reason:"This would make the new pair the *only* item in the bucket, overwriting any other items that were already there due to a collision."}], indent: 1, explanation: "The new pair becomes the new head of the list." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "Close the set function." },
    { "correct": "const char* ht_get(HashTable* ht, const char* key) {", distractors: [{"text":"char* ht_get(...)", reason:"The value stored is effectively read-only from the user's perspective. Returning a `const char*` prevents the user from accidentally modifying the internal data."}], indent: 0, explanation: "Function to retrieve a value from the hash table by its key." },
    { "correct": "  unsigned long index = hash_function(key);", distractors: [{"text":"  unsigned long index = key % HASH_TABLE_SIZE;", reason:"`key` is a pointer (an address). This would hash based on the memory location, not the string content, which is incorrect."}], indent: 1, explanation: "Calculate the index where the key should be." },
    { "correct": "  KeyValuePair* current = ht->buckets[index];", distractors: [{"text":"  KeyValuePair current = ht->buckets[index];", reason:"`ht->buckets[index]` is a pointer. This would be a type mismatch, as you cannot assign a pointer to a struct variable."}], indent: 1, explanation: "Get the head of the linked list at that index." },
    { "correct": "  while (current) {", distractors: [{"text":"  if (current) {", reason:"An `if` statement would only check the first node in the bucket. A `while` loop is needed to traverse the entire linked list in case of collisions."}], indent: 1, explanation: "Traverse the linked list (if any)." },
    { "correct": "    if (strcmp(current->key, key) == 0) {", distractors: [{"text":"    if (current->key == key) {", reason:"This is a critical error. The `==` operator compares pointer addresses, not string content. `strcmp` is required for string comparison."}], indent: 2, explanation: "Compare the current node's key with the key we're looking for." },
    { "correct": "      return current->value; // Found it!", distractors: [{"text":"      return current->key;", reason:"This would incorrectly return the key instead of the value associated with it."}], indent: 3, explanation: "If it's a match, return the value." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 2, explanation: "Close the string comparison." },
    { "correct": "    current = current->next;", distractors: [{"text":"    // No need to update current", reason:"This would be a bug. Without advancing `current` to the next node, the `while` loop would never terminate, creating an infinite loop."}], indent: 2, explanation: "Move to the next node in the list." },
    { "correct": "  }", distractors: [{"text":"end while;", reason:"This is not valid C syntax."}], indent: 1, explanation: "Close the traversal loop." },
    { "correct": "  return NULL; // Key not found.", distractors: [{"text":"  return \"not found\";", reason:"Returning a literal string can be ambiguous. `NULL` is the standard, unambiguous way for a function that returns a pointer to signal 'not found'."}], indent: 1, explanation: "If the loop finishes, the key was not in the table." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "Close the get function." },
    { "correct": "void ht_free(HashTable* ht) {", distractors: [{"text":"void ht_free(HashTable ht) {", reason:"The function must accept a pointer so it can free the dynamically allocated memory the pointer refers to."}], indent: 0, explanation: "Function to free all memory used by the hash table." },
    { "correct": "  for (int i = 0; i < HASH_TABLE_SIZE; i++) {", distractors: [{"text":"  free(ht->buckets);", reason:"This is incorrect. `buckets` is an array, not a single block allocated with `malloc`. You must iterate through each bucket to free the linked lists."}], indent: 1, explanation: "Iterate through every bucket in the table." },
    { "correct": "    KeyValuePair* current = ht->buckets[i];", distractors: [{"text":"    free(ht->buckets[i]);", reason:"This would only free the *first* node in the list, leaking all subsequent nodes from a collision."}], indent: 2, explanation: "Get the head of the list for the current bucket." },
    { "correct": "    while (current) {", distractors: [{"text":"    // No loop needed", reason:"A loop is essential to traverse the entire linked list that may exist at this bucket due to hash collisions."}], indent: 2, explanation: "Loop through the linked list to free each node." },
    { "correct": "      KeyValuePair* next = current->next;", distractors: [{"text":"      free(current);", reason:"This is a classic use-after-free bug. If you free `current` first, you can no longer safely access `current->next` to move to the next node in the list."}], indent: 3, explanation: "Save the next pointer before freeing the current node." },
    { "correct": "      free(current->key);", distractors: [{"text":"      // No need to free key", reason:"This is a memory leak. The key was allocated using `strdup` (`malloc`), so it must be explicitly freed."}], indent: 3, explanation: "Free the key string." },
    { "correct": "      free(current->value);", distractors: [{"text":"      // No need to free value", reason:"This is a memory leak. The value was also allocated with `strdup` and must be freed."}], indent: 3, explanation: "Free the value string." },
    { "correct": "      free(current);", distractors: [{"text":"      current = next;", reason:"This would move to the next node but would leak the memory for the `KeyValuePair` struct that `current` was pointing to."}], indent: 3, explanation: "Free the node struct itself." },
    { "correct": "      current = next;", distractors: [{"text":"      // This is the last step", reason:"This is a bug. Without this line, `current` would never be updated, leading to an infinite loop and a crash when it tries to access freed memory."}], indent: 3, explanation: "Move to the next node." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after a `while` loop's closing brace."}], indent: 2, explanation: "Close the inner loop." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop's closing brace."}], indent: 1, explanation: "Close the outer loop." },
    { "correct": "  free(ht);", distractors: [{"text":"  // This is all we need to free.", reason:"This is a massive memory leak. You must free all the individual nodes and strings *before* freeing the main hash table structure itself."}], indent: 1, explanation: "Finally, free the hash table structure itself." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "Close the free function." },
    { "correct": "// --- Stage 3: The JSON Parser Logic ---", distractors: [{"text":"// --- Stage 3: The Hash Table ---", reason:"We already implemented the hash table. This stage is about the logic that *uses* the hash table to parse a specific format."}], indent: 0, explanation: "This function will take a raw string and parse it into our hash table." },
    { "correct": "HashTable* json_parse(char* json_string) {", distractors: [{"text":"HashTable* json_parse(const char* json_string) {", reason:"This is a key error for `strtok`. `strtok` modifies its input string, so it cannot be `const`."}], indent: 0, explanation: "The main parser function." },
    { "correct": "  HashTable* ht = ht_create();", distractors: [{"text":"  HashTable ht;", reason:"This creates a stack-allocated table. The function needs to return a pointer to a heap-allocated table that will persist after the function returns."}], indent: 1, explanation: "Create a new hash table to store the results." },
    { "correct": "  if (!ht) return NULL;", distractors: [{"text":"  if (ht == NULL) return NULL;", reason:"This is an equally valid way to check for allocation failure."}], indent: 1, explanation: "Handle creation failure." },
    { "correct": "  // This is a simplified parser: it assumes a flat JSON object.", distractors: [{"text":"  // This parser handles all JSON features.", reason:"This is false. A full JSON parser is much more complex, needing to handle nested objects, arrays, numbers, booleans, etc."}], indent: 1, explanation: "Note about the limitations of this simple parser." },
    { "correct": "  const char* delimiters = \"\\\"\\t\\n\\r ,{}\";", distractors: [{"text":"  const char* delimiters = \",:\";", reason:"This is too simple. A robust parser needs to treat quotes, curly braces, and whitespace as delimiters to correctly isolate the keys and values."}], indent: 1, explanation: "Define all the characters we want `strtok` to split on or ignore." },
    { "correct": "  char* token = strtok(json_string, delimiters);", distractors: [{"text":"  char* token = strtok(NULL, delimiters);", reason:"The first call to `strtok` for a new string must pass the string itself, not `NULL`."}], indent: 1, explanation: "Get the first token." },
    { "correct": "  while (token) {", distractors: [{"text":"  while (token != NULL) {", reason:"This is an equally valid, and often clearer, way to write the loop condition."}], indent: 1, explanation: "Loop while we have tokens." },
    { "correct": "    char* key = token;", distractors: [{"text":"    char* key = strdup(token);", reason:"This is unnecessary here. The `ht_set` function already makes a copy with `strdup`. Making another copy here would create a memory leak."}], indent: 2, explanation: "Assume the current token is a key." },
    { "correct": "    char* value_token = strtok(NULL, \":\"); // Find the colon", distractors: [{"text":"    char* value_token = strchr(token, ':');", reason:"`strchr` would also work for finding the colon, but `strtok` is used here as part of the overall tokenizing strategy."}], indent: 2, explanation: "Find the colon separator." },
    { "correct": "    value_token = strtok(NULL, delimiters); // The next token is the value", distractors: [{"text":"    value_token = strtok(NULL, \",}\");", reason:"This is less robust. Using the full `delimiters` string correctly handles whitespace and other characters around the value."}], indent: 2, explanation: "Get the actual value token." },
    { "correct": "    if (key && value_token) {", distractors: [{"text":"    if (key || value_token) {", reason:"This is a logic error. We need *both* a key *and* a value to be valid, so we must use the logical AND `&&`."}], indent: 2, explanation: "If we successfully found a key and a value..." },
    { "correct": "      ht_set(ht, key, value_token);", distractors: [{"text":"      ht_set(&ht, key, value_token);", reason:"`ht_set` expects a pointer (`HashTable*`), not a pointer-to-a-pointer (`HashTable**`)."}], indent: 3, explanation: "Set the key-value pair in our hash table." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used after `if` blocks."}], indent: 2, explanation: "Close the if check." },
    { "correct": "    token = strtok(NULL, delimiters);", distractors: [{"text":"    token = strtok(json_string, delimiters);", reason:"Calling `strtok` with the original string again would reset the parser and create an infinite loop."}], indent: 2, explanation: "Move to the next token, which should be the next key." },
    { "correct": "  }", distractors: [{"text":"end while;", reason:"This is not valid C syntax."}], indent: 1, explanation: "Close the parsing loop." },
    { "correct": "  return ht;", distractors: [{"text":"  return &ht;", reason:"`ht` is already a pointer. Returning its address would give a `HashTable**`, which is the wrong type."}], indent: 1, explanation: "Return the populated hash table." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to end function blocks."}], indent: 0, explanation: "Close the JSON parser function." },
    { "correct": "// --- Stage 4: Main Program to Demonstrate the Parser ---", distractors: [{"text":"// --- Stage 4: The Library ---", reason:"This is the main program that *uses* our library, demonstrating how a consumer would interact with it."}], indent: 0, explanation: "Now we write a `main` function to test our parser." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid and often preferred way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start main." },
    { "correct": "  // The JSON string we want to parse. Note: must be a modifiable char array.", distractors: [{"text":"  // The string must be const.", reason:"This is false. `strtok` modifies its input string, so the string cannot be `const`."}], indent: 1, explanation: "Comment on the JSON source string." },
    { "correct": "  char json_data[] = \"{ \\\"name\\\": \\\"Alice\\\", \\\"level\\\": 15, \\\"is_active\\\": true }\";", distractors: [{"text":"  const char* json_data = \"...\";", reason:"This is a critical error. Passing a `const` string literal to our parser would cause a crash, because the parser uses `strtok` which modifies the string."}], indent: 1, explanation: "Define the source JSON data." },
    { "correct": "  printf(\"Parsing JSON: %s\\n\\n\", json_data);", distractors: [{"text":"  puts(json_data);", reason:"`puts` is a valid way to print the string, though it adds a newline which might not be wanted before the other `\\n`."}], indent: 1, explanation: "Print the source data." },
    { "correct": "  HashTable* config = json_parse(json_data);", distractors: [{"text":"  HashTable config = json_parse(json_data);", reason:"`json_parse` returns a pointer (`HashTable*`), not a struct by value."}], indent: 1, explanation: "Call our parser to get the hash table." },
    { "correct": "  if (!config) { printf(\"Failed to parse JSON.\\n\"); return 1; }", distractors: [{"text":"  // No need to check for errors.", reason:"This is very unsafe. Any function that performs allocation or I/O can fail, and you must always check the return value."}], indent: 1, explanation: "Handle parsing failure." },
    { "correct": "  printf(\"--- Retrieving Parsed Values ---\\n\");", distractors: [{"text":"  puts(\"--- Retrieving Parsed Values ---\");", reason:"`puts` is a valid alternative for printing this header."}], indent: 1, explanation: "Header for the results." },
    { "correct": "  const char* name = ht_get(config, \"name\");", distractors: [{"text":"  char* name = ht_get(config, \"name\");", reason:"`ht_get` returns a `const char*` to prevent modification of internal data. The receiving variable should also be `const`."}], indent: 1, explanation: "Retrieve the 'name' value." },
    { "correct": "  const char* level_str = ht_get(config, \"level\");", distractors: [{"text":"  int level = ht_get(config, \"level\");", reason:"`ht_get` returns a string (`const char*`), not an `int`. You must get the string first, then convert it."}], indent: 1, explanation: "Retrieve the 'level' value (as a string)." },
    { "correct": "  const char* active_str = ht_get(config, \"is_active\");", distractors: [{"text":"  const char* active_str = ht_get(config, \"is_active\", \"true\");", reason:"Our `ht_get` function was not designed to take a default value. That logic is in `ini_get_integer` from a previous lesson."}], indent: 1, explanation: "Retrieve the 'is_active' value (as a string)." },
    { "correct": "  const char* not_found = ht_get(config, \"city\");", distractors: [{"text":"  char not_found[64]; ht_get(config, \"city\", not_found);", reason:"Our API was not designed this way. It returns a pointer, which will be `NULL` if the key is not found."}], indent: 1, explanation: "Attempt to retrieve a key that doesn't exist." },
    { "correct": "  printf(\"Name: %s\\n\", name ? name : \"N/A\");", distractors: [{"text":"  printf(\"Name: %s\\n\", name);", reason:"This is a bug. If `name` is `NULL` (because the key wasn't found), passing it to `%s` causes undefined behavior (often a crash). The ternary operator is a safe way to handle this."}], indent: 1, explanation: "Print the name, checking for NULL." },
    { "correct": "  if (level_str) { printf(\"Level: %d\\n\", atoi(level_str)); }", distractors: [{"text":"  printf(\"Level: %d\\n\", atoi(level_str));", reason:"This is unsafe. If `level_str` is `NULL`, passing it to `atoi` will cause a crash. The `if` check is mandatory."}], indent: 1, explanation: "If level was found, convert to int and print." },
    { "correct": "  printf(\"Is Active: %s\\n\", active_str ? active_str : \"N/A\");", distractors: [{"text":"  printf(\"Is Active: %s\\n\", active_str);", reason:"This is unsafe. A `NULL` value from `ht_get` must be handled before passing it to `printf`."}], indent: 1, explanation: "Print the active status." },
    { "correct": "  printf(\"City: %s\\n\", not_found ? not_found : \"N/A\");", distractors: [{"text":"  if (not_found) { printf(\"City: %s\\n\", not_found); }", reason:"Using an `if` block is another perfectly valid way to safely print the value only if it's not `NULL`."}], indent: 1, explanation: "Confirm that the non-existent key returned N/A." },
    { "correct": "  printf(\"\\n--- Cleaning up ---\\n\");", distractors: [{"text":"  puts(\"\\n--- Cleaning up ---\");", reason:"`puts` automatically adds a newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Header for cleanup." },
    { "correct": "  ht_free(config);", distractors: [{"text":"  free(config);", reason:"This is a massive memory leak. `free(config)` would only free the top-level `HashTable` struct, not all the linked lists of nodes and strings inside it. You must use the custom `ht_free` function."}], indent: 1, explanation: "Free all memory used by the hash table and its contents." },
    { "correct": "  printf(\"Memory freed successfully.\\n\");", distractors: [{"text":"  puts(\"Memory freed successfully.\");", reason:"`puts` is a valid and simpler way to print this message."}], indent: 1, explanation: "Confirmation message." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 signals an error. Since the program completed successfully, it should return 0."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 74: rank the most frequent IP addresses in a log file
    {
        "goal": "Build a high-performance log analyzer to find and rank the most frequent IP addresses in a log file.",
        concepts: "Hash tables, `qsort`, file I/O, `fgets`, string parsing, performance",
        sequence: [
    { "correct": "// --- Stage 1: Includes and Data Structures ---", distractors: [{"text":"// --- Stage 1: The Main Program ---", reason:"Good software design often starts with defining the core data structures before writing the logic that operates on them."}], indent: 0, explanation: "Setup the necessary includes and the data structures for storing IP counts." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"File operations like `fopen` and `fgets` are part of the Standard I/O library, `<stdio.h>`."}], indent: 0, explanation: "Standard I/O." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <string.h>", reason:"`malloc` and `qsort` are general utilities found in the Standard Library, `<stdlib.h>`."}], indent: 0, explanation: "Memory management and `qsort`." },
    { "correct": "#include <string.h>", distractors: [{"text":"#include <memory.h>", reason:"`memset`, `strcmp`, and `strncpy` are all part of the standard string library, `<string.h>`."}], indent: 0, explanation: "String manipulation." },
    { "correct": "#define HASH_TABLE_SIZE 1024", distractors: [{"text":"#define HASH_TABLE_SIZE 1000", reason:"While any size will work, hash table sizes that are a power of 2 (like 1024) can allow for faster modulo calculations by the compiler."}], indent: 0, explanation: "A larger hash table size for potentially many unique IPs." },
    { "correct": "// A node in the hash table to store an IP and its frequency count.", distractors: [{"text":"// An array to store IPs.", reason:"This is a single node in a linked list, not a full array. The hash table itself will be an array of these nodes."}], indent: 0, explanation: "Comment on the IP count struct." },
    { "correct": "typedef struct IP_Entry {", distractors: [{"text":"struct IP_Entry {", reason:"Using `typedef` is a convenience that lets us write `IP_Entry*` instead of the more verbose `struct IP_Entry*`."}], indent: 0, explanation: "Begin IP_Entry definition." },
    { "correct": "  char ip_addr[16]; // xxx.xxx.xxx.xxx\\0", distractors: [{"text":"  char* ip_addr;", reason:"Using `char*` would require an extra dynamic allocation for every single IP. For a small, fixed-size string like an IP address, a character array is much more efficient."}], indent: 1, explanation: "Fixed-size buffer to store the IP address string." },
    { "correct": "  int count;", distractors: [{"text":"  unsigned int count;", reason:"Since a count can never be negative, `unsigned int` is arguably a more correct type to use here."}], indent: 1, explanation: "The frequency of this IP." },
    { "correct": "  struct IP_Entry* next;", distractors: [{"text":"  IP_Entry next;", reason:"A struct cannot contain a member of its own type, as this would have an infinite size. It must be a pointer to its own type to form a linked list."}], indent: 1, explanation: "Pointer for collision handling linked list." },
    { "correct": "} IP_Entry;", distractors: [{"text":"};", reason:"When using `typedef` with a struct definition, the new type alias (`IP_Entry`) must be provided before the final semicolon."}], indent: 0, explanation: "Close the IP_Entry typedef." },
    { "correct": "// The Hash Table itself, an array of pointers to entries.", distractors: [{"text":"// A linked list of IPs.", reason:"This is an oversimplification. A hash table is an array where each element is the head of a linked list, used to resolve hash collisions."}], indent: 0, explanation: "Comment on the hash table." },
    { "correct": "typedef struct {", distractors: [{"text":"struct HashTable {", reason:"Using `typedef` allows us to declare variables as `HashTable ht;` instead of `struct HashTable ht;`."}], indent: 0, explanation: "Begin HashTable definition." },
    { "correct": "  IP_Entry* buckets[HASH_TABLE_SIZE];", distractors: [{"text":"  IP_Entry buckets[HASH_TABLE_SIZE];", reason:"This is a critical error. This creates an array of full `IP_Entry` structs, not pointers. This would prevent us from creating linked lists to handle hash collisions."}], indent: 1, explanation: "The array of buckets, each being the head of a linked list." },
    { "correct": "} HashTable;", distractors: [{"text":"} HashTable", reason:"A `typedef` statement must end with a semicolon."}], indent: 0, explanation: "Close the HashTable typedef." },
    { "correct": "// --- Stage 2: Hash Table and Parser Implementation ---", distractors: [{"text":"// --- Stage 2: The Main Program ---", reason:"It's good design to implement the core logic for the data structure before writing the main program that uses it."}], indent: 0, explanation: "Implement the functions needed to manage the hash table and process the log file." },
    { "correct": "unsigned long hash_function(const char* str) {", distractors: [{"text":"int hash_function(const char* str) {", reason:"A hash value can become very large, so `unsigned long` is a safer and more appropriate return type than `int`."}], indent: 0, explanation: "The same djb2 hash function as before, good for general string hashing." },
    { "correct": "  unsigned long hash = 5381;", distractors: [{"text":"  unsigned long hash = 0;", reason:"Starting with 0 is valid, but using a non-zero prime number often creates a better 'avalanche effect', leading to better key distribution."}], indent: 1, explanation: "Start with the magic prime." },
    { "correct": "  int c; while ((c = *str++)) { hash = ((hash << 5) + hash) + c; }", distractors: [{"text":"  for (int i=0; str[i]; i++) { hash += str[i]; }", reason:"This is a much simpler, but far less effective, hashing algorithm. It would produce many collisions for strings with the same characters in different orders (e.g., '127.0.0.1' and '11.0.0.72')."}] , indent: 1, explanation: "Loop through the string and apply the hashing algorithm." },
    { "correct": "  return hash % HASH_TABLE_SIZE;", distractors: [{"text":"  return hash;", reason:"This is a bug. The raw hash value is a large number. The modulo operator `%` is essential to scale it down to a valid index within the bounds of our `buckets` array."}], indent: 1, explanation: "Constrain the hash value to the table size." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "Close the hash function." },
    { "correct": "HashTable* ht_create() {", distractors: [{"text":"HashTable ht_create() {", reason:"This function dynamically allocates memory and must return a pointer to it, so the return type must be `HashTable*`."}], indent: 0, explanation: "The constructor for our hash table." },
    { "correct": "  HashTable* ht = malloc(sizeof(HashTable));", distractors: [{"text":"  HashTable* ht = malloc(sizeof(IP_Entry*));", reason:"This is a bug. This would only allocate enough memory for a single pointer, not the entire `HashTable` structure with its large array of buckets."}], indent: 1, explanation: "Allocate memory for the table structure." },
    { "correct": "  memset(ht->buckets, 0, sizeof(ht->buckets));", distractors: [{"text":"  // No need to initialize", reason:"This is a critical error. If the buckets are not initialized to `NULL`, they will contain garbage pointers, and any attempt to access them will cause a crash."}], indent: 1, explanation: "Initialize all buckets to NULL." },
    { "correct": "  return ht;", distractors: [{"text":"  return &ht;", reason:"`ht` is already a pointer. Returning its address would yield a `HashTable**`, which is the wrong type."}], indent: 1, explanation: "Return the new table." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "Close the constructor." },
    { "correct": "void ht_increment(HashTable* ht, const char* ip) {", distractors: [{"text":"int ht_increment(HashTable* ht, const char* ip) {", reason:"This function modifies the hash table in-place and doesn't need to return a value, so `void` is a good choice for the return type."}], indent: 0, explanation: "A function to find an IP in the table and increment its count, or add it if not found." },
    { "correct": "  unsigned long index = hash_function(ip);", distractors: [{"text":"  int index = hash_function(ip);", reason:"The hash function returns an `unsigned long`. While assigning to an `int` might work, it's safer to use a matching type to avoid potential overflow."}], indent: 1, explanation: "Calculate the index for the given IP." },
    { "correct": "  IP_Entry* current = ht->buckets[index];", distractors: [{"text":"  IP_Entry* current = &ht->buckets[index];", reason:"`ht->buckets[index]` is already a pointer (`IP_Entry*`). Taking its address would give you an `IP_Entry**`, which is the wrong type."}], indent: 1, explanation: "Get the head of the list for this bucket." },
    { "correct": "  while (current) {", distractors: [{"text":"  if (current) {", reason:"An `if` would only check the first entry in the bucket. A `while` loop is necessary to traverse the entire linked list in case of hash collisions."}], indent: 1, explanation: "Traverse the linked list to find an existing entry." },
    { "correct": "    if (strcmp(current->ip_addr, ip) == 0) {", distractors: [{"text":"    if (current->ip_addr == ip) {", reason:"This is a crucial error. `==` compares pointer addresses, not string content. `strcmp` is required to check if the IP strings are identical."}], indent: 2, explanation: "If the IP address already exists in the table..." },
    { "correct": "      current->count++; // Increment count and we're done.", distractors: [{"text":"      current->count = 1;", reason:"This would be a bug. We need to increment (`++`) the existing count, not reset it to 1."}], indent: 3, explanation: "Increment its count." },
    { "correct": "      return;", distractors: [{"text":"      break;", reason:"`break` would only exit the `while` loop, and the code would proceed to incorrectly add a duplicate entry. `return` exits the entire function."}], indent: 3, explanation: "Exit the function." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 2, explanation: "Close the string compare." },
    { "correct": "    current = current->next;", distractors: [{"text":"    // Loop continues automatically", reason:"This is false. You must explicitly advance the pointer (`current = current->next`) to move to the next node, or you'll have an infinite loop."}], indent: 2, explanation: "Move to the next entry in the list." },
    { "correct": "  }", distractors: [{"text":"end while;", reason:"This is not valid C syntax."}], indent: 1, explanation: "Close the traversal loop." },
    { "correct": "  // If we get here, the IP was not found. We must add a new entry.", distractors: [{"text":"  // This part of the code is for errors.", reason:"This is incorrect. This is the normal execution path for an IP that hasn't been seen before."}], indent: 1, explanation: "Comment on adding a new entry." },
    { "correct": "  IP_Entry* new_entry = malloc(sizeof(IP_Entry));", distractors: [{"text":"  IP_Entry new_entry;", reason:"This creates a local stack variable that will be destroyed when the function returns. The entry must be dynamically allocated with `malloc` to persist."}], indent: 1, explanation: "Allocate memory for the new entry." },
    { "correct": "  strncpy(new_entry->ip_addr, ip, 15);", distractors: [{"text":"  strcpy(new_entry->ip_addr, ip);", reason:"`strcpy` is unsafe because it doesn't check buffer sizes. If an IP string longer than 15 characters were passed, it would cause a buffer overflow."}], indent: 1, explanation: "Copy the IP address string into the new entry." },
    { "correct": "  new_entry->ip_addr[15] = '\\0';", distractors: [{"text":"  // `strncpy` always null-terminates.", reason:"This is a common and dangerous myth. If the source string is exactly the size of the limit (or longer), `strncpy` will *not* add a null terminator. You must add it manually."}], indent: 1, explanation: "Ensure null termination." },
    { "correct": "  new_entry->count = 1;", distractors: [{"text":"  new_entry->count = 0;", reason:"When adding a new IP for the first time, its count should start at 1, not 0."}], indent: 1, explanation: "Initialize its count to 1." },
    { "correct": "  new_entry->next = ht->buckets[index];", distractors: [{"text":"  ht->buckets[index] = new_entry;", reason:"This assignment must happen *after* setting the `next` pointer. Doing it first would orphan the rest of the linked list."}], indent: 1, explanation: "Link the new entry to the front of the list." },
    { "correct": "  ht->buckets[index] = new_entry;", distractors: [{"text":"  new_entry->next = NULL;", reason:"This would make the new entry the *only* one in the bucket, overwriting any other entries that were already there due to a hash collision."}], indent: 1, explanation: "The new entry becomes the new head." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "Close the increment function." },
    { "correct": "int parse_log_file(const char* filename, HashTable* ht) {", distractors: [{"text":"void parse_log_file(const char* filename, HashTable* ht) {", reason:"Returning an `int` (the number of lines processed) is good design, as it provides useful feedback to the caller."}], indent: 0, explanation: "Function to read the log file and populate the hash table." },
    { "correct": "  FILE* fp = fopen(filename, \"r\");", distractors: [{"text":"  FILE* fp = fopen(filename, \"rb\");", reason:"Log files are text files, not binary. They should be opened in text mode (`\"r\"`) to correctly handle line endings."}], indent: 1, explanation: "Open the log file." },
    { "correct": "  if (!fp) { perror(\"Failed to open log file\"); return 0; }", distractors: [{"text":"  if (fp == NULL) { return -1; }", reason:"Returning -1 is a common way to signal an error. The current implementation returns 0, which could be ambiguous (an error or an empty file). `perror` is good because it gives a descriptive system error."}], indent: 1, explanation: "Handle file open error." },
    { "correct": "  char line[256];", distractors: [{"text":"  char* line = malloc(256);", reason:"For a temporary buffer within a function, a stack-allocated array is simpler and safer because it's automatically deallocated. `malloc` is unnecessary."}], indent: 1, explanation: "A buffer to hold each line." },
    { "correct": "  int lines_processed = 0;", distractors: [{"text":"  int lines_processed;", reason:"Counters must be initialized to 0. An uninitialized local variable contains a garbage value, which would lead to an incorrect final count."}], indent: 1, explanation: "A counter for processed lines." },
    { "correct": "  while (fgets(line, sizeof(line), fp)) {", distractors: [{"text":"  while (!feof(fp)) { fgets(...); }", reason:"This is a classic C anti-pattern. You must loop on the return value of the read function (`fgets`), not on `feof`, to correctly handle the end of the file."}], indent: 1, explanation: "Read the file line by line." },
    { "correct": "    // Assuming the IP address is the first word on the line.", distractors: [{"text":"    // This parser can handle any log format.", reason:"This is false. This parser is written with a very specific format in mind. A more robust parser would need more complex logic."}], indent: 2, explanation: "State our assumption about the log format." },
    { "correct": "    char* ip = strtok(line, \" \\t\\n\");", distractors: [{"text":"    char* ip = strtok(NULL, \" \");", reason:"This is the first call to `strtok` for this `line`, so it must be passed the string itself, not `NULL`."}], indent: 2, explanation: "Use `strtok` to extract the first token (the IP)." },
    { "correct": "    if (ip) {", distractors: [{"text":"    if (ip != NULL) {", reason:"This is an equally valid, and often clearer, way to check that `strtok` successfully returned a token."}], indent: 2, explanation: "If a token was found..." },
    { "correct": "      ht_increment(ht, ip);", distractors: [{"text":"      ht_increment(&ht, ip);", reason:"`ht` is already a pointer. Passing its address would be a `HashTable**`, which is the wrong type for the function."}], indent: 3, explanation: "Increment the count for this IP in our hash table." },
    { "correct": "      lines_processed++;", distractors: [{"text":"      lines_processed += 1;", reason:"This is also correct, but `++` is the more common C idiom for incrementing by one."}], indent: 3, explanation: "Increment the line counter." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block's closing brace."}], indent: 2, explanation: "Close the if block." },
    { "correct": "  }", distractors: [{"text":"end while;", reason:"This is not valid C syntax."}], indent: 1, explanation: "Close the while loop." },
    { "correct": "  fclose(fp);", distractors: [{"text":"  free(fp);", reason:"`fp` is a `FILE` handle, not a memory block from `malloc`. It must be closed with `fclose`."}], indent: 1, explanation: "Close the log file." },
    { "correct": "  return lines_processed;", distractors: [{"text":"  return 0;", reason:"This function is designed to return the number of lines it processed, which is useful information for the caller. It should return the `lines_processed` variable."}], indent: 1, explanation: "Return the total number of lines processed." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "Close the log parser function." },
    { "correct": "// --- Stage 3: Analysis and Reporting ---", distractors: [{"text":"// --- Stage 3: The Main Program ---", reason:"This section defines the logic for analyzing the data, which is separate from the `main` driver function."}], indent: 0, explanation: "Functions to convert the hash table data into a sortable array and print the results." },
    { "correct": "int compare_entries_by_count(const void* a, const void* b) {", distractors: [{"text":"int compare_entries(const void* a, const void* b) {", reason:"Using a more descriptive name like `compare_entries_by_count` makes the code easier to understand."}], indent: 0, explanation: "A comparison function for `qsort` to sort entries by count in descending order." },
    { "correct": "  IP_Entry* entryA = *(IP_Entry**)a;", distractors: [{"text":"  IP_Entry* entryA = (IP_Entry*)a;", reason:"This is a critical error. We are sorting an array of `IP_Entry*` pointers. `qsort` passes a pointer to an element, so `a` is a pointer to a pointer (`IP_Entry**`). It must be cast and dereferenced correctly."}], indent: 1, explanation: "We will be sorting an array of *pointers* to entries, so we need to dereference twice." },
    { "correct": "  IP_Entry* entryB = *(IP_Entry**)b;", distractors: [{"text":"  IP_Entry entryB = *(IP_Entry*)b;", reason:"This has two errors. First, the cast is wrong (`IP_Entry*` instead of `IP_Entry**`). Second, it dereferences twice, creating a *copy* of the struct, which is less efficient."}], indent: 1, explanation: "Cast and dereference the second argument." },
    { "correct": "  return entryB->count - entryA->count; // Descending order", distractors: [{"text":"  return entryA->count - entryB->count;", reason:"This would sort the entries in *ascending* order (lowest count first). To get the highest counts first, you must subtract A from B."}], indent: 1, explanation: "Subtract B from A to sort from highest to lowest." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "Close the comparison function." },
    { "correct": "void report_top_ips(HashTable* ht, int top_n) {", distractors: [{"text":"void report_top_ips(HashTable* ht) {", reason:"By accepting `top_n` as a parameter, the function is more flexible and reusable, allowing the caller to decide how many results to show."}], indent: 0, explanation: "The main analysis and reporting function." },
    { "correct": "  // First, count the total number of unique IPs.", distractors: [{"text":"  // First, create an array to hold the IPs.", reason:"We don't know how big to make the array yet. We must count the unique IPs first to know how much memory to allocate."}], indent: 1, explanation: "Comment on the first step." },
    { "correct": "  int unique_ips = 0;", distractors: [{"text":"  int unique_ips;", reason:"Counters must be initialized to 0. An uninitialized local variable holds a garbage value, leading to an incorrect count."}], indent: 1, explanation: "Initialize a counter." },
    { "correct": "  for (int i=0; i<HASH_TABLE_SIZE; i++) {", distractors: [{"text":"  for (int i=0; i <= HASH_TABLE_SIZE - 1; i++) {", reason:"This is a logically equivalent and correct way to write the loop condition."}], indent: 1, explanation: "Loop through all buckets." },
    { "correct": "    for (IP_Entry* c = ht->buckets[i]; c != NULL; c = c->next) { unique_ips++; }", distractors: [{"text":"    if (ht->buckets[i]) { unique_ips++; }", reason:"This is a bug. It would only count the number of non-empty *buckets*, not the total number of unique IP entries across all linked lists."}], indent: 2, explanation: "Traverse each linked list and increment the counter." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used after a `for` loop's closing brace."}], indent: 1, explanation: "Close the counting loop." },
    { "correct": "  printf(\"\\n--- Analysis Report ---\\n\");", distractors: [{"text":"  puts(\"\\n--- Analysis Report ---\");", reason:"`puts` automatically adds a newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Print a report header." },
    { "correct": "  printf(\"Found %d unique IP addresses.\\n\", unique_ips);", distractors: [{"text":"  printf(\"Found IP addresses.\\n\");", reason:"This is less useful. Printing the specific count gives the user valuable information about their data."}], indent: 1, explanation: "Print the unique IP count." },
    { "correct": "  if (unique_ips == 0) return;", distractors: [{"text":"  if (!unique_ips) return;", reason:"This is a valid and common shorthand for checking if `unique_ips` is zero."}], indent: 1, explanation: "If no IPs were found, we can stop here." },
    { "correct": "  // Create a flat array of pointers to all entries to make it sortable.", distractors: [{"text":"  // Try to sort the hash table directly.", reason:"Sorting a hash table is not a standard or efficient operation. The correct approach is to transform the data into a simple array, which `qsort` can handle."}], indent: 1, explanation: "Comment on creating the sortable array." },
    { "correct": "  IP_Entry** sortable_array = malloc(unique_ips * sizeof(IP_Entry*));", distractors: [{"text":"  IP_Entry** sortable_array = malloc(unique_ips * sizeof(IP_Entry));", reason:"This is a bug. We are creating an array of *pointers* (`IP_Entry*`), so the size of each element is `sizeof(IP_Entry*)`, not the size of the full struct."}], indent: 1, explanation: "Allocate memory for an array of pointers." },
    { "correct": "  int idx = 0;", distractors: [{"text":"  int idx;", reason:"It's crucial to initialize an index variable to 0 before using it to populate an array."}], indent: 1, explanation: "An index for our new flat array." },
    { "correct": "  for (int i=0; i<HASH_TABLE_SIZE; i++) {", distractors: [{"text":"  // No loop needed.", reason:"This is false. We must iterate through every bucket of the hash table to find all the IP entries."}], indent: 1, explanation: "Loop through the hash table buckets again." },
    { "correct": "    for (IP_Entry* c = ht->buckets[i]; c != NULL; c = c->next) {", distractors: [{"text":"    if (ht->buckets[i]) {", reason:"An `if` would only process the first node in the bucket's list. A `for` or `while` loop is needed to traverse the entire linked list."}], indent: 2, explanation: "Traverse each linked list." },
    { "correct": "      sortable_array[idx++] = c;", distractors: [{"text":"      sortable_array[idx] = c; idx++;", reason:"This is an equally valid way to write the logic. The post-increment `idx++` is just a more compact C idiom."}], indent: 3, explanation: "Copy the pointer to the entry into our flat array." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used after a `for` loop's closing brace."}], indent: 2, explanation: "Close inner loop." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 1, explanation: "Close outer loop." },
    { "correct": "  // Sort the flat array using qsort.", distractors: [{"text":"  // Manually sort the array.", reason:"Manual sorting (e.g., bubble sort) would be much slower and more complex to write than using the highly optimized `qsort` function from the standard library."}], indent: 1, explanation: "Comment on the sorting step." },
    { "correct": "  qsort(sortable_array, unique_ips, sizeof(IP_Entry*), compare_entries_by_count);", distractors: [{"text":"  qsort(sortable_array, unique_ips, sizeof(IP_Entry), compare_entries_by_count);", reason:"This is a critical error. The array contains pointers, so the size of each element is `sizeof(IP_Entry*)`, not `sizeof(IP_Entry)`."}], indent: 1, explanation: "Call `qsort` on our array of pointers." },
    { "correct": "  printf(\"\\n--- Top %d Most Frequent IPs ---\\n\", top_n);", distractors: [{"text":"  printf(\"\\n--- Top IPs ---\\n\");", reason:"This works, but specifying how many IPs are being shown (`top_n`) makes the report header more informative."}], indent: 1, explanation: "Print a header for the final results." },
    { "correct": "  for (int i = 0; i < top_n && i < unique_ips; i++) {", distractors: [{"text":"  for (int i = 0; i < top_n; i++) {", reason:"This is unsafe. If `top_n` is greater than `unique_ips`, this loop would read past the end of the array. The `&& i < unique_ips` check prevents this."}], indent: 1, explanation: "Loop to print the top N results, ensuring we don't go out of bounds." },
    { "correct": "    printf(\"%3d. IP: %-15s | Count: %d\\n\", i + 1, sortable_array[i]->ip_addr, sortable_array[i]->count);", distractors: [{"text":"    printf(\"%s: %d\\n\", sortable_array[i]->ip_addr, sortable_array[i]->count);", reason:"This works, but the formatted version (`%3d`, `%-15s`) produces a much neater, aligned output for the report."}], indent: 2, explanation: "Print the ranked IP address and its count." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "Close the printing loop." },
    { "correct": "  free(sortable_array);", distractors: [{"text":"  // No need to free this.", reason:"This is a memory leak. `sortable_array` was allocated with `malloc` and its memory must be returned to the system with `free` when we are done with it."}], indent: 1, explanation: "Free the temporary sortable array." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "Close the reporting function." },
    { "correct": "// --- Stage 4: Main Program Driver ---", distractors: [{"text":"// --- Stage 4: The Final Stage ---", reason:"'Main Program Driver' is more descriptive, as this section's purpose is to drive the library functions we've built."}], indent: 0, explanation: "The main function to tie it all together." },
    { "correct": "int main(int argc, char* argv[]) {", distractors: [{"text":"int main() {", reason:"To get the log file name from the command line, `main` must be defined with the `argc` and `argv` parameters."}], indent: 0, explanation: "Start main." },
    { "correct": "  if (argc != 2) { printf(\"Usage: %s <logfile>\\n\", argv[0]); return 1; }", distractors: [{"text":"  if (argc < 2) { printf(...); }", reason:"Using `!= 2` is more precise. It correctly handles both too few and too many command-line arguments, whereas `< 2` would allow extras."}], indent: 1, explanation: "Check for the correct number of arguments." },
    { "correct": "  HashTable* ht = ht_create();", distractors: [{"text":"  HashTable ht;", reason:"This would create the hash table on the stack. All our functions are designed to work with a pointer to a dynamically allocated hash table."}], indent: 1, explanation: "Create our hash table." },
    { "correct": "  printf(\"Processing log file: %s\\n\", argv[1]);", distractors: [{"text":"  printf(\"Processing log file...\\n\");", reason:"This is fine, but printing the actual filename from `argv[1]` provides better feedback to the user."}], indent: 1, explanation: "Informational message." },
    { "correct": "  parse_log_file(argv[1], ht);", distractors: [{"text":"  ht = parse_log_file(argv[1], ht);", reason:"Our `parse_log_file` function was designed to return an `int` (the line count), not the hash table pointer. It modifies the hash table passed to it directly."}], indent: 1, explanation: "Parse the specified log file." },
    { "correct": "  report_top_ips(ht, 10);", distractors: [{"text":"  report_top_ips(ht);", reason:"The function requires a second argument to specify how many top IPs to report."}], indent: 1, explanation: "Generate and print a report for the top 10 IPs." },
    { "correct": "  // The `ht_free` function would go here to clean up memory.", distractors: [{"text":"  free(ht);", reason:"This is a massive memory leak. You must call the custom `ht_free(ht)` function to free not only the table structure, but all the linked list nodes and strings inside it."}], indent: 1, explanation: "Comment on where final cleanup would occur." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 signals an error. This program should return 0 to indicate it completed successfully."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end main;", reason:"This is not valid C syntax."}], indent: 0, explanation: "Close main." }
]
    },
     // Level 75: reusable dynamic array (vector)
    {
        "goal": "Build a generic, reusable dynamic array (vector) library that manages its own memory.",
        concepts: "void* pointers, realloc, API design, qsort, function pointers, encapsulation",
        sequence: [
            { correct: "// === Stage 1: The Public API Header File (e.g., 'vector.h') ===", distractors: [{text: "// === Stage 1: The Vector Implementation File ===", reason: "This comment describes the header file, which contains the public API declarations, not the implementation."}, {text: "// === Stage 1: Vector Library Setup ===", reason: "More specific to mention this is the header file containing the public API."}], indent: 0, explanation: "We define the public interface for our vector library. All implementation details will be hidden." },
            { correct: "#include <stdlib.h> // For size_t", distractors: [{text: "#include <stdio.h> // For size_t", reason: "`size_t` is defined in `stdlib.h`, not `stdio.h`."}, {text: "#include <stddef.h> // For size_t", reason: "While `stddef.h` also defines `size_t`, `stdlib.h` is more commonly used in this context and we'll need other stdlib functions."}], indent: 0, explanation: "Include for the `size_t` type." },
            { correct: "// Opaque declaration of the Vector struct. The user doesn't know what's inside.", distractors: [{text: "// Forward declaration of the Vector struct.", reason: "While technically correct, 'opaque declaration' is more precise for this design pattern where we're hiding implementation details."}, {text: "// Incomplete type definition of Vector.", reason: "This is accurate but 'opaque declaration' better conveys the design intent of information hiding."}], indent: 0, explanation: "Forward-declare the struct to hide its implementation." },
            { correct: "struct Vector;", distractors: [{text: "typedef struct Vector Vector;", reason: "This would create a complete type alias, but we want to keep the struct opaque and use a pointer handle instead."}, {text: "struct Vector {};", reason: "An empty struct definition isn't what we want - we need just the forward declaration to keep it opaque."}], indent: 0, explanation: "Declare the incomplete type `struct Vector`." },
            { correct: "typedef struct Vector* VectorHandle;", distractors: [{text: "typedef struct Vector VectorHandle;", reason: "This would expose the struct directly to users. We want a pointer handle to maintain encapsulation."}, {text: "typedef Vector* VectorHandle;", reason: "`Vector` hasn't been typedef'd yet - we need to use `struct Vector*` for the pointer type."}], indent: 0, explanation: "Create a handle that users will interact with." },
            { correct: "// --- Public API Function Prototypes ---", distractors: [{text: "// --- Function Implementations ---", reason: "This is the header file, so we're declaring prototypes, not implementing functions."}, {text: "// --- Vector Operations ---", reason: "More specific to call these 'Public API Function Prototypes' to emphasize the interface design."}], indent: 0, explanation: "Declare the functions that make up our library's API." },
            { correct: "VectorHandle vector_create();", distractors: [{text: "Vector* vector_create();", reason: "We should use our `VectorHandle` typedef for consistency in the public API."}, {text: "struct Vector* vector_create();", reason: "While correct, using `VectorHandle` maintains better abstraction and is more readable."}], indent: 0, explanation: "Creates and returns a new, empty vector." },
            { correct: "void vector_destroy(VectorHandle vec);", distractors: [{text: "void vector_free(VectorHandle vec);", reason: "While 'free' would work, 'destroy' is a more conventional name that pairs with 'create' in API design."}, {text: "int vector_destroy(VectorHandle vec);", reason: "For this simple case, `void` is sufficient. Returning an error code would be overkill."}], indent: 0, explanation: "Frees all memory associated with the vector." },
            { correct: "size_t vector_size(const VectorHandle vec);", distractors: [{text: "int vector_size(const VectorHandle vec);", reason: "`size_t` is the standard type for sizes and counts in C, and can represent larger values than `int`."}, {text: "size_t vector_size(VectorHandle vec);", reason: "The `const` qualifier indicates this function doesn't modify the vector, which is good API design."}], indent: 0, explanation: "Returns the number of elements currently in the vector." },
            { correct: "void vector_push_back(VectorHandle vec, void* item);", distractors: [{text: "int vector_push_back(VectorHandle vec, void* item);", reason: "While returning an error code could be useful, for simplicity we're using `void` and handling errors internally."}, {text: "void vector_push_back(VectorHandle vec, int item);", reason: "Using `void*` makes this a generic container that can store pointers to any type, not just integers."}], indent: 0, explanation: "Adds an item to the end of the vector." },
            { correct: "void* vector_get(const VectorHandle vec, size_t index);", distractors: [{text: "int vector_get(const VectorHandle vec, size_t index);", reason: "We return `void*` to maintain genericity - the caller can cast it to whatever type they stored."}, {text: "void* vector_get(VectorHandle vec, int index);", reason: "The `const` qualifier is good practice for read-only operations, and `size_t` is the standard type for array indices."}], indent: 0, explanation: "Retrieves the item at a specific index." },
            { correct: "void* vector_pop_back(VectorHandle vec);", distractors: [{text: "void vector_pop_back(VectorHandle vec);", reason: "We want to return the popped item so the caller can use it, not just remove it."}, {text: "int vector_pop_back(VectorHandle vec);", reason: "Returning `void*` maintains the generic nature of our container."}], indent: 0, explanation: "Removes and returns the last item from the vector." },
            { correct: "void vector_sort(VectorHandle vec, int (*compare_func)(const void*, const void*));", distractors: [{text: "void vector_sort(VectorHandle vec, int (*compare_func)(void*, void*));", reason: "The comparison function should take `const void*` parameters since it shouldn't modify the elements being compared."}, {text: "void vector_sort(VectorHandle vec, void* compare_func);", reason: "The function pointer type should be explicit: `int (*)(const void*, const void*)` to match `qsort`'s expected signature."}], indent: 0, explanation: "Sorts the vector using a user-provided comparison function." },
            { correct: "// === Stage 2: The Private Implementation File (e.g., 'vector.c') ===", distractors: [{text: "// === Stage 2: The Vector Header Continuation ===", reason: "This marks the start of the implementation file (.c), not a continuation of the header."}, {text: "// === Stage 2: Public Function Definitions ===", reason: "While these are function definitions, it's more accurate to say this is the 'Private Implementation File' since it also contains private structs and helpers."}], indent: 0, explanation: "Here, we define the hidden structures and implement the API functions." },
            { correct: "#include <stdio.h>", distractors: [{text: "#include <stdarg.h>", reason: "We need `stdio.h` for `printf` and error messages, not `stdarg.h` for variadic functions."}, {text: "#include <assert.h>", reason: "While assertions could be useful, we need `stdio.h` for basic I/O operations and error reporting."}], indent: 0, explanation: "Include for error messages." },
            { correct: "#include <string.h>", distractors: [{text: "#include <strings.h>", reason: "`string.h` is the standard header for string functions like `memcpy`. `strings.h` is a different (older) header."}, {text: "#include <memory.h>", reason: "While some systems have `memory.h`, `string.h` is the standard header that contains memory manipulation functions."}], indent: 0, explanation: "Include for memory operations if needed." },
            { correct: "// #include \"vector.h\" // In a real project, include the header.", distractors: [{text: "#include \"vector.h\" // Include our public API", reason: "This is commented out since we're showing everything in one file for the example."}, {text: "// #include <vector.h> // System header", reason: "Our custom header would use quotes (\"\"), not angle brackets (<>) which are for system headers."}], indent: 0, explanation: "Include our own header to link implementation to declaration." },
            { correct: "#define INITIAL_CAPACITY 8", distractors: [{text: "#define INITIAL_CAPACITY 1", reason: "Starting with capacity 1 would cause frequent reallocations. 8 is a good balance between memory usage and performance."}, {text: "#define INITIAL_CAPACITY 0", reason: "A capacity of 0 would cause issues with malloc(0) and immediate reallocation on the first insert."}], indent: 0, explanation: "Define the initial number of elements the vector can hold." },
            { correct: "// Full, private definition of the Vector struct.", distractors: [{text: "// Public definition of the Vector struct.", reason: "This is the private definition - it's hidden from users of the library."}, {text: "// Forward declaration of the Vector struct.", reason: "This is the complete definition, not just a forward declaration."}], indent: 0, explanation: "Complete the opaque type definition." },
            { correct: "struct Vector {", distractors: [{text: "typedef struct {", reason: "We already defined the typedef earlier. This is just completing the struct definition."}, {text: "struct vector {", reason: "C is case-sensitive. The struct name should match our earlier declaration: `Vector` with a capital V."}], indent: 0, explanation: "Begin the struct definition." },
            { correct: "  void** items; // A dynamic array of void pointers, for generic storage.", distractors: [{text: "  void* items; // A dynamic array for generic storage.", reason: "`void*` is a pointer to one item. We need `void**` (pointer to void pointer) to have an array of generic pointers."}, {text: "  int* items; // A dynamic array of integers.", reason: "Using `int*` would limit us to integers only. `void**` allows storing pointers to any type."}], indent: 1, explanation: "The core data store. A pointer-to-a-pointer holds an array of pointers." },
            { correct: "  size_t size;", distractors: [{text: "  int size;", reason: "`size_t` is the standard type for sizes and can represent larger values than `int` on 64-bit systems."}, {text: "  unsigned size;", reason: "While `unsigned` would work, `size_t` is the conventional and portable choice for representing sizes."}], indent: 1, explanation: "The current number of elements stored in the vector." },
            { correct: "  size_t capacity;", distractors: [{text: "  int capacity;", reason: "Like with size, `size_t` is the appropriate type for capacity values."}, {text: "  size_t max_size;", reason: "The conventional term is 'capacity' to distinguish from 'size' (current count)."}], indent: 1, explanation: "The total number of elements the `items` array can currently hold." },
            { correct: "};", distractors: [{text: "} Vector;", reason: "We already typedef'd the struct earlier, so we just need the closing brace and semicolon."}, {text: "}", reason: "Don't forget the semicolon after the struct definition."}], indent: 0, explanation: "Close the struct definition." },
            { correct: "// A private helper function to handle resizing.", distractors: [{text: "// A public function to handle resizing.", reason: "This is a private helper function - users of the library don't need to call it directly."}, {text: "// The main resizing implementation.", reason: "Calling it a 'private helper function' better emphasizes its role in the library's internal design."}], indent: 0, explanation: "This logic is internal to the library." },
            { correct: "static int vector_resize(VectorHandle vec, size_t new_capacity) {", distractors: [{text: "int vector_resize(VectorHandle vec, size_t new_capacity) {", reason: "`static` makes this function internal to this file - it can't be called from outside, which is what we want for a private helper."}, {text: "static void vector_resize(VectorHandle vec, size_t new_capacity) {", reason: "Returning an `int` allows us to signal success (0) or failure (-1) to the caller."}], indent: 0, explanation: "Define the resize function." },
            { correct: "  void** new_items = realloc(vec->items, new_capacity * sizeof(void*));", distractors: [{text: "  void* new_items = realloc(vec->items, new_capacity * sizeof(void*));", reason: "The result should be `void**` to match our items array type, not `void*`."}, {text: "  void** new_items = malloc(new_capacity * sizeof(void*));", reason: "`realloc` is better than `malloc` because it preserves existing data and may avoid copying if possible."}], indent: 1, explanation: "Attempt to resize the `items` array." },
            { correct: "  if (!new_items) return -1; // Failure", distractors: [{text: "  if (new_items == NULL) return 0; // Failure", reason: "We use -1 to indicate failure and 0 for success, following common C conventions."}, {text: "  if (!new_items) exit(1); // Failure", reason: "Returning an error code is better than calling `exit()` - it lets the caller decide how to handle the failure."}], indent: 1, explanation: "If realloc fails, return an error code." },
            { correct: "  vec->items = new_items;", distractors: [{text: "  vec->items = (void**)new_items;", reason: "The cast is unnecessary since `new_items` is already `void**`."}, {text: "  memcpy(vec->items, new_items, new_capacity);", reason: "We should assign the pointer, not copy memory. `realloc` already handled copying the data."}], indent: 1, explanation: "On success, update the items pointer." },
            { correct: "  vec->capacity = new_capacity;", distractors: [{text: "  vec->size = new_capacity;", reason: "We're updating the capacity (maximum elements), not the size (current elements)."}, {text: "  vec->capacity += new_capacity;", reason: "We want to set the capacity to the new value, not add to it."}], indent: 1, explanation: "Update the capacity." },
            { correct: "  return 0; // Success", distractors: [{text: "  return 1; // Success", reason: "By convention in C, 0 indicates success and non-zero indicates failure."}, {text: "  return new_capacity; // Success", reason: "We established that this function returns 0 for success and -1 for failure."}], indent: 1, explanation: "Return success." },
            { correct: "}", distractors: [{text: "  return 0;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close the resize function." },
            { correct: "VectorHandle vector_create() {", distractors: [{text: "struct Vector* vector_create() {", reason: "Using `VectorHandle` maintains consistency with our public API typedef."}, {text: "Vector* vector_create() {", reason: "`Vector` alone isn't defined - we need either `struct Vector*` or `VectorHandle`."}], indent: 0, explanation: "Implement the 'constructor'." },
            { correct: "  VectorHandle vec = malloc(sizeof(struct Vector));", distractors: [{text: "  VectorHandle vec = malloc(sizeof(Vector));", reason: "`Vector` is only typedef'd as a pointer. We need `sizeof(struct Vector)` for the actual struct size."}, {text: "  VectorHandle vec = calloc(1, sizeof(struct Vector));", reason: "While `calloc` would zero-initialize, we're explicitly setting the fields below, so `malloc` is sufficient."}], indent: 1, explanation: "Allocate memory for the main Vector struct." },
            { correct: "  if (!vec) return NULL;", distractors: [{text: "  if (vec == NULL) return -1;", reason: "We should return NULL to indicate failure for a function that returns a pointer."}, {text: "  assert(vec != NULL);", reason: "Returning NULL on failure is better than asserting - it allows the caller to handle the error gracefully."}], indent: 1, explanation: "Handle allocation failure." },
            { correct: "  vec->items = malloc(INITIAL_CAPACITY * sizeof(void*));", distractors: [{text: "  vec->items = malloc(INITIAL_CAPACITY * sizeof(void));", reason: "Each element is a `void*` (a pointer), so we need `sizeof(void*)`, not `sizeof(void)`."}, {text: "  vec->items = calloc(INITIAL_CAPACITY, sizeof(void*));", reason: "While `calloc` would zero-initialize, we don't need it since we'll set valid pointers when items are added."}], indent: 1, explanation: "Allocate the initial array for the items." },
            { correct: "  if (!vec->items) { free(vec); return NULL; }", distractors: [{text: "  if (!vec->items) return NULL;", reason: "We need to free the `vec` struct we allocated earlier to avoid a memory leak."}, {text: "  if (!vec->items) { vec->items = NULL; return NULL; }", reason: "We should free the allocated `vec` struct, not just set items to NULL."}], indent: 1, explanation: "If item allocation fails, clean up and return NULL." },
            { correct: "  vec->size = 0;", distractors: [{text: "  vec->size = INITIAL_CAPACITY;", reason: "Size represents the current number of elements, which starts at 0. Capacity is what starts at INITIAL_CAPACITY."}, {text: "  vec->size = -1;", reason: "Size should be 0 for an empty vector. Negative sizes don't make sense."}], indent: 1, explanation: "The vector starts empty." },
            { correct: "  vec->capacity = INITIAL_CAPACITY;", distractors: [{text: "  vec->capacity = 0;", reason: "We allocated space for INITIAL_CAPACITY elements, so that's our starting capacity."}, {text: "  vec->capacity = vec->size;", reason: "Capacity (INITIAL_CAPACITY) is different from size (0). Capacity is how many we *can* store."}], indent: 1, explanation: "Set the initial capacity." },
            { correct: "  return vec;", distractors: [{text: "  return 0;", reason: "We should return the vector handle we just created, not 0."}, {text: "  return &vec;", reason: "`vec` is already a pointer (VectorHandle), so we don't need the address-of operator."}], indent: 1, explanation: "Return the newly created vector handle." },
            { correct: "}", distractors: [{text: "  return vec;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close `vector_create`." },
            { correct: "void vector_destroy(VectorHandle vec) {", distractors: [{text: "void vector_destroy(VectorHandle* vec) {", reason: "We pass the handle by value, not by pointer. The handle itself is already a pointer."}, {text: "int vector_destroy(VectorHandle vec) {", reason: "For a destructor, `void` is appropriate since cleanup operations typically always succeed."}], indent: 0, explanation: "Implement the 'destructor'." },
            { correct: "  if (!vec) return;", distractors: [{text: "  if (vec == NULL) exit(1);", reason: "Returning silently is safer than exiting the program. Destructors should be defensive."}, {text: "  assert(vec != NULL);", reason: "Checking and returning gracefully is better than asserting, which would crash the program."}], indent: 1, explanation: "Safety check for a NULL handle." },
            { correct: "  free(vec->items); // Free the array of items first.", distractors: [{text: "  free(vec->items[0]); // Free the first item.", reason: "We need to free the entire items array, not individual elements. The caller is responsible for the pointed-to data."}, {text: "  delete vec->items; // Free the array.", reason: "`delete` is C++. In C, we use `free()` for memory allocated with `malloc()`."}], indent: 1, explanation: "Free the dynamically allocated array of pointers." },
            { correct: "  free(vec);      // Then free the struct itself.", distractors: [{text: "  free(*vec);      // Free the vector.", reason: "`vec` is already a pointer to the struct, so we free `vec`, not `*vec`."}, {text: "  delete vec;      // Free the struct.", reason: "`delete` is C++. In C, we use `free()` for `malloc()`'d memory."}], indent: 1, explanation: "Free the main vector management struct." },
            { correct: "}", distractors: [{text: "  vec = NULL;\n}", reason: "Setting `vec` to NULL here doesn't help since `vec` is passed by value - the caller's copy won't change."}, {text: "  return 0;\n}", reason: "This function is declared to return `void`, so we shouldn't return a value."}], indent: 0, explanation: "Close `vector_destroy`." },
            { correct: "size_t vector_size(const VectorHandle vec) { return vec ? vec->size : 0; }", distractors: [{text: "int vector_size(const VectorHandle vec) { return vec ? vec->size : 0; }", reason: "`size_t` is the standard return type for size functions in C."}, {text: "size_t vector_size(const VectorHandle vec) { return vec->size; }", reason: "Adding the null check `vec ?` makes the function more robust against invalid input."}], indent: 0, explanation: "Implement the size getter with a safety check." },
            { correct: "void vector_push_back(VectorHandle vec, void* item) {", distractors: [{text: "void vector_push_back(VectorHandle* vec, void* item) {", reason: "The handle is already a pointer, so we don't need a pointer to a pointer."}, {text: "void vector_push_back(VectorHandle vec, int item) {", reason: "Using `void*` keeps the vector generic - it can store pointers to any type."}], indent: 0, explanation: "Implement the function to add an item." },
            { correct: "  if (!vec) return;", distractors: [{text: "  if (!vec) return -1;", reason: "This function returns `void`, so we can't return -1. We just return early."}, {text: "  assert(vec != NULL);", reason: "Checking and returning is more defensive than asserting, which would crash the program."}], indent: 1, explanation: "Safety check." },
            { correct: "  if (vec->size == vec->capacity) {", distractors: [{text: "  if (vec->size >= vec->capacity) {", reason: "We only need to resize when size equals capacity. Using >= would work but is unnecessarily frequent."}, {text: "  if (vec->size > vec->capacity) {", reason: "We should resize before we exceed capacity, not after. This condition should never be true in a well-designed vector."}], indent: 1, explanation: "Check if the vector is full." },
            { correct: "    // Double the capacity when resizing.", distractors: [{text: "    // Increase capacity by one when resizing.", reason: "Doubling capacity is more efficient than increasing by one, as it reduces the frequency of reallocations."}, {text: "    // Triple the capacity when resizing.", reason: "Doubling is the standard growth strategy - it balances memory usage with performance."}], indent: 2, explanation: "A common growth strategy." },
            { correct: "    int success = vector_resize(vec, vec->capacity * 2);", distractors: [{text: "    vector_resize(vec, vec->capacity * 2);", reason: "We should check the return value to see if the resize succeeded."}, {text: "    int success = vector_resize(vec, vec->capacity + 1);", reason: "Doubling capacity is more efficient than growing by just one element."}], indent: 2, explanation: "Call the internal resize function." },
            { correct: "    if (success != 0) { return; } // Abort push on resize failure.", distractors: [{text: "    if (success == 0) { return; } // Abort push on resize failure.", reason: "Our resize function returns 0 for success and -1 for failure, so we check for != 0."}, {text: "    if (!success) { return; } // Abort push on resize failure.", reason: "Success is 0, failure is -1. So `!success` would be true when success is 0 (successful)."}], indent: 2, explanation: "Handle resize failure." },
            { correct: "  }", distractors: [{text: "  } else { return; }", reason: "If we don't need to resize, we should continue with the push operation, not return."}, {text: "  } while (vec->size == vec->capacity);", reason: "This is an `if` statement, not a loop. We only need to check once."}], indent: 1, explanation: "Close the capacity check." },
            { correct: "  vec->items[vec->size] = item;", distractors: [{text: "  vec->items[vec->size + 1] = item;", reason: "Array indices are 0-based. If size is 3, the next available index is 3, not 4."}, {text: "  vec->items[vec->capacity] = item;", reason: "We should add at the current size index, not the capacity index."}], indent: 1, explanation: "Place the new item at the end of the array." },
            { correct: "  vec->size++;", distractors: [{text: "  vec->capacity++;", reason: "We increment the size (number of elements), not the capacity (maximum elements)."}, {text: "  ++vec->size;", reason: "Both `vec->size++` and `++vec->size` work here, but post-increment is more common in this context."}], indent: 1, explanation: "Increment the size." },
            { correct: "}", distractors: [{text: "  return vec;\n}", reason: "This function is declared to return `void`, not `VectorHandle`."}, {text: "  return 0;\n}", reason: "This function returns `void`, so no return value is needed."}], indent: 0, explanation: "Close `vector_push_back`." },
            { correct: "void* vector_get(const VectorHandle vec, size_t index) {", distractors: [{text: "int vector_get(const VectorHandle vec, size_t index) {", reason: "We return `void*` to maintain the generic nature of our vector."}, {text: "void* vector_get(VectorHandle vec, int index) {", reason: "The `const` qualifier and `size_t` type are better choices for a read-only accessor function."}], indent: 0, explanation: "Implement the item getter." },
            { correct: "  if (!vec || index >= vec->size) {", distractors: [{text: "  if (!vec || index > vec->size) {", reason: "We use `>=` because valid indices are 0 to size-1. An index equal to size is out of bounds."}, {text: "  if (!vec || index >= vec->capacity) {", reason: "We check against size (current elements), not capacity (maximum elements)."}], indent: 1, explanation: "Perform bounds checking." },
            { correct: "    return NULL; // Out of bounds", distractors: [{text: "    return -1; // Out of bounds", reason: "We return NULL for pointer functions to indicate failure, not -1."}, {text: "    exit(1); // Out of bounds", reason: "Returning NULL is better than exiting - it lets the caller handle the error."}], indent: 2, explanation: "Return NULL if the index is invalid." },
            { correct: "  }", distractors: [{text: "  } else {", reason: "The else is unnecessary since we return from the if block."}, {text: "  }\n  assert(index < vec->size);", reason: "We already checked this condition above."}], indent: 1, explanation: "Close bounds check." },
            { correct: "  return vec->items[index];", distractors: [{text: "  return &vec->items[index];", reason: "We want to return the stored pointer, not a pointer to the array element."}, {text: "  return *vec->items[index];", reason: "This would dereference the stored pointer, but we want to return the pointer itself."}], indent: 1, explanation: "Return the void pointer at the specified index." },
            { correct: "}", distractors: [{text: "  return NULL;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close `vector_get`." },
            { correct: "void* vector_pop_back(VectorHandle vec) {", distractors: [{text: "void vector_pop_back(VectorHandle vec) {", reason: "We want to return the popped item, not just remove it silently."}, {text: "int vector_pop_back(VectorHandle vec) {", reason: "Returning `void*` maintains the generic nature and allows the caller to get the popped item."}], indent: 0, explanation: "Implement popping the last element." },
            { correct: "  if (!vec || vec->size == 0) return NULL;", distractors: [{text: "  if (!vec || vec->size <= 0) return NULL;", reason: "Size is `size_t` (unsigned), so it can't be negative. Checking `== 0` is sufficient."}, {text: "  if (!vec) return NULL; if (vec->size == 0) return -1;", reason: "We should return NULL consistently for error cases in a pointer-returning function."}], indent: 1, explanation: "Check if the vector is valid and not empty." },
            { correct: "  vec->size--;", distractors: [{text: "  --vec->size;", reason: "Both work, but post-decrement is more common. The key is to decrement before accessing the array."}, {text: "  vec->capacity--;", reason: "We decrement the size (current count), not the capacity (maximum count)."}], indent: 1, explanation: "Decrement the size first." },
            { correct: "  return vec->items[vec->size];", distractors: [{text: "  return vec->items[vec->size - 1];", reason: "We already decremented size, so `vec->size` now points to what was the last element."}, {text: "  return vec->items[vec->capacity - 1];", reason: "We want the item at the new size index, not at the capacity index."}], indent: 1, explanation: "Return the item that is now at the new (decremented) size index." },
            { correct: "}", distractors: [{text: "  vec->items[vec->size] = NULL;\n  return vec->items[vec->size];\n}", reason: "This would set the item to NULL and then return NULL, losing the original value."}, {text: "  return 0;\n}", reason: "This function should return the popped item, not 0."}], indent: 0, explanation: "Close `vector_pop_back`." },
            { correct: "void vector_sort(VectorHandle vec, int (*compare_func)(const void*, const void*)) {", distractors: [{text: "void vector_sort(VectorHandle vec, void* compare_func) {", reason: "The function pointer type should be explicit to ensure type safety."}, {text: "void vector_sort(VectorHandle vec, int (*compare_func)(void*, void*)) {", reason: "The parameters should be `const void*` since the comparison function shouldn't modify the elements."}], indent: 0, explanation: "Implement the generic sort function." },
            { correct: "  if (!vec || !compare_func) return;", distractors: [{text: "  if (!vec) return;", reason: "We should also check that the comparison function pointer is not NULL."}, {text: "  assert(vec && compare_func);", reason: "Returning silently is more defensive than asserting, which would crash the program."}], indent: 1, explanation: "Check for valid arguments." },
            { correct: "  qsort(vec->items, vec->size, sizeof(void*), compare_func);", distractors: [{text: "  qsort(vec->items, vec->capacity, sizeof(void*), compare_func);", reason: "We sort based on the current size (number of elements), not the capacity."}, {text: "  qsort(vec->items, vec->size, sizeof(void), compare_func);", reason: "Each element is a `void*` (pointer), so we need `sizeof(void*)`, not `sizeof(void)`."}], indent: 1, explanation: "Call the standard library `qsort` on our internal item array." },
            { correct: "}", distractors: [{text: "  return 0;\n}", reason: "This function returns `void`, so no return value is needed."}, {text: "  return vec;\n}", reason: "This function modifies the vector in place and returns void."}], indent: 0, explanation: "Close `vector_sort`." },
            { correct: "// === Stage 3: The Main Program to Demonstrate the Vector Library ===", distractors: [{text: "// === Stage 3: Test Cases ===", reason: "This is more than just test cases - it's a complete demonstration program."}, {text: "// === Stage 3: Vector Usage Examples ===", reason: "Calling it 'The Main Program to Demonstrate' is more comprehensive and descriptive."}], indent: 0, explanation: "A `main` function to test our new vector library." },
            { correct: "// A comparison function for qsort to compare strings.", distractors: [{text: "// A function to sort strings.", reason: "This is specifically a comparison function that qsort will use, not a sorting function itself."}, {text: "// String comparison helper.", reason: "More specific to mention this is for qsort and string comparison."}], indent: 0, explanation: "Helper function for sorting." },
            { correct: "int strcmp_qsort(const void* a, const void* b) {", distractors: [{text: "int strcmp_qsort(char* a, char* b) {", reason: "qsort passes `void*` pointers to the elements, so our function must accept `const void*` parameters."}, {text: "int strcmp_qsort(void* a, void* b) {", reason: "The parameters should be `const void*` since we're not modifying the strings being compared."}], indent: 0, explanation: "Define the string comparator." },
            { correct: "  const char* str_a = *(const char**)a;", distractors: [{text: "  const char* str_a = (const char*)a;", reason: "Our vector stores `char*` pointers, so `a` is a pointer to a `char*`, requiring a double dereference."}, {text: "  const char* str_a = a;", reason: "`a` is `const void*`, but we need to cast and dereference it to get the actual string pointer."}], indent: 1, explanation: "`qsort` passes pointers to the elements. Our elements are `char*`, so `a` is a `char**`. We dereference it once." },
            { correct: "  const char* str_b = *(const char**)b;", distractors: [{text: "  const char* str_b = (const char*)b;", reason: "Like with `str_a`, we need to cast to `char**` and then dereference."}, {text: "  const char* str_b = b;", reason: "We need to properly cast and dereference `b` to get the string."}], indent: 1, explanation: "Dereference the second argument." },
            { correct: "  return strcmp(str_a, str_b);", distractors: [{text: "  return str_a - str_b;", reason: "Pointer arithmetic doesn't give meaningful string comparison. We need `strcmp()` for lexicographic ordering."}, {text: "  return strcasecmp(str_a, str_b);", reason: "While `strcasecmp` works, `strcmp` is more standard and portable for case-sensitive comparison."}], indent: 1, explanation: "Use the standard `strcmp` to perform the comparison." },
            { correct: "}", distractors: [{text: "  return 0;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close the comparator." },
            { correct: "int main() {", distractors: [{text: "void main() {", reason: "Standard C requires `main` to return `int`."}, {text: "int main(void) {", reason: "While `main(void)` is valid, `main()` is more common and equally correct in C."}], indent: 0, explanation: "Start main." },
            { correct: "  printf(\"Creating a vector for strings...\\n\");", distractors: [{text: "  printf(\"Creating a vector for strings...\");", reason: "Adding `\\n` provides better formatting and ensures the output is flushed."}, {text: "  puts(\"Creating a vector for strings...\");", reason: "While `puts` would work, `printf` is more consistent with the rest of the code."}], indent: 1, explanation: "Informational message." },
            { correct: "  VectorHandle my_vec = vector_create();", distractors: [{text: "  Vector my_vec = vector_create();", reason: "`Vector` alone isn't a valid type - we need `VectorHandle` which is our typedef for the pointer."}, {text: "  struct Vector* my_vec = vector_create();", reason: "While this would work, using `VectorHandle` maintains consistency with our API design."}], indent: 1, explanation: "Create the vector." },
            { correct: "  // Push items onto the vector.", distractors: [{text: "  // Add items to the vector.", reason: "Using 'push' terminology is consistent with our function name `vector_push_back`."}, {text: "  // Insert strings.", reason: "More descriptive to say 'Push items onto the vector' to match the API terminology."}], indent: 1, explanation: "Comment on adding items." },
            { correct: "  vector_push_back(my_vec, \"Charlie\");", distractors: [{text: "  vector_push_back(my_vec, 'Charlie');", reason: "String literals use double quotes, not single quotes. Single quotes are for character literals."}, {text: "  vector_push_back(my_vec, &\"Charlie\");", reason: "String literals are already pointers to their first character, so no & operator is needed."}], indent: 1, explanation: "Add the first string. A string literal is a `char*`, which becomes a `void*`." },
            { correct: "  vector_push_back(my_vec, \"Alice\");", distractors: [{text: "  vector_push_back(my_vec, \"Alice\\0\");", reason: "String literals are automatically null-terminated, so adding \\0 is redundant."}, {text: "  vector_push_back(&my_vec, \"Alice\");", reason: "We pass the vector handle by value, not by pointer."}], indent: 1, explanation: "Add the second string." },
            { correct: "  vector_push_back(my_vec, \"David\");", distractors: [{text: "  vector_push_back(my_vec, \"David\", 5);", reason: "Our `vector_push_back` function only takes two parameters: the vector and the item."}, {text: "  vector_add(my_vec, \"David\");", reason: "The function name is `vector_push_back`, not `vector_add`."}], indent: 1, explanation: "Add the third string." },
            { correct: "  vector_push_back(my_vec, \"Bob\");", distractors: [{text: "  vector_push_back(my_vec, Bob);", reason: "Without quotes, this would look for a variable named `Bob`. We want the string literal \"Bob\"."}, {text: "  vector_insert(my_vec, \"Bob\");", reason: "Our function is called `vector_push_back`, not `vector_insert`."}], indent: 1, explanation: "Add the fourth string." },
            { correct: "  printf(\"Vector size: %zu\\n\", vector_size(my_vec));", distractors: [{text: "  printf(\"Vector size: %d\\n\", vector_size(my_vec));", reason: "`vector_size` returns `size_t`, which should be printed with `%zu`, not `%d`."}, {text: "  printf(\"Vector size: %lu\\n\", vector_size(my_vec));", reason: "While `%lu` might work on some systems, `%zu` is the correct format specifier for `size_t`."}], indent: 1, explanation: "Check the size." },
            { correct: "  printf(\"Vector contents:\\n\");", distractors: [{text: "  printf(\"Vector contents:\");", reason: "Adding `\\n` provides better formatting for the output that follows."}, {text: "  printf(\"Contents: \\n\");", reason: "Being more specific with 'Vector contents' is clearer."}], indent: 1, explanation: "Header for printing." },
            { correct: "  for (size_t i = 0; i < vector_size(my_vec); i++) {", distractors: [{text: "  for (int i = 0; i < vector_size(my_vec); i++) {", reason: "`size_t` is the appropriate type for array indices and matches what `vector_size` returns."}, {text: "  for (size_t i = 1; i <= vector_size(my_vec); i++) {", reason: "Array indices are 0-based, so we start from 0 and use `<`, not `<=`."}], indent: 1, explanation: "Loop through the vector." },
            { correct: "    char* item = (char*)vector_get(my_vec, i);", distractors: [{text: "    char* item = vector_get(my_vec, i);", reason: "While this might work with some compilers, explicitly casting from `void*` to `char*` is more explicit and portable."}, {text: "    void* item = vector_get(my_vec, i);", reason: "We want to work with the item as a string, so casting to `char*` is more appropriate."}], indent: 2, explanation: "Get the `void*` item and cast it back to a `char*`." },
            { correct: "    printf(\"  - %s\\n\", item);", distractors: [{text: "    printf(\"%s\\n\", item);", reason: "Adding the `  - ` prefix creates a nicer bullet-point format."}, {text: "    printf(\"  - %d\\n\", item);", reason: "We're printing strings, so we need `%s`, not `%d`."}], indent: 2, explanation: "Print the string." },
            { correct: "  }", distractors: [{text: "  }\n  printf(\"\\n\");", reason: "The loop structure is complete with just the closing brace."}, {text: "  } while (i < vector_size(my_vec));", reason: "This is a `for` loop, not a `do-while` loop."}], indent: 1, explanation: "Close loop." },
            { correct: "  printf(\"\\nSorting the vector...\\n\");", distractors: [{text: "  printf(\"Sorting the vector...\\n\");", reason: "Adding the leading `\\n` provides better visual separation from the previous output."}, {text: "  printf(\"\\nSorting...\\n\");", reason: "Being more descriptive with 'Sorting the vector' is clearer."}], indent: 1, explanation: "Informational message." },
            { correct: "  vector_sort(my_vec, strcmp_qsort);", distractors: [{text: "  vector_sort(my_vec, strcmp);", reason: "`strcmp` has the wrong signature for qsort. We need our wrapper function `strcmp_qsort`."}, {text: "  vector_sort(my_vec, &strcmp_qsort);", reason: "Function names are already pointers, so the `&` is unnecessary (though not wrong)."}], indent: 1, explanation: "Call our sort function, passing our string comparator." },
            { correct: "  printf(\"Sorted vector contents:\\n\");", distractors: [{text: "  printf(\"Sorted contents:\\n\");", reason: "Being more specific with 'Sorted vector contents' maintains consistency."}, {text: "  printf(\"After sorting:\\n\");", reason: "The current phrasing is more descriptive about what we're about to show."}], indent: 1, explanation: "Header for printing sorted." },
            { correct: "  for (size_t i = 0; i < vector_size(my_vec); i++) {", distractors: [{text: "  for (int i = 0; i < vector_size(my_vec); i++) {", reason: "`size_t` is the appropriate type for indices and matches the return type of `vector_size`."}, {text: "  for (size_t i = 0; i <= vector_size(my_vec); i++) {", reason: "Using `<=` would try to access one element beyond the vector, causing out-of-bounds access."}], indent: 1, explanation: "Loop through again." },
            { correct: "    printf(\"  - %s\\n\", (char*)vector_get(my_vec, i));", distractors: [{text: "    printf(\"%s\\n\", (char*)vector_get(my_vec, i));", reason: "Adding the `  - ` prefix maintains consistent formatting with the previous loop."}, {text: "    printf(\"  - %s\\n\", vector_get(my_vec, i));", reason: "Casting to `char*` is more explicit, though some compilers might allow this."}], indent: 2, explanation: "Print the now-sorted items." },
            { correct: "  }", distractors: [{text: "  }\n  break;", reason: "There's no loop to break out of here - this is just the end of the for loop."}, {text: "  continue;\n}", reason: "`continue` doesn't make sense outside of a loop body."}], indent: 1, explanation: "Close loop." },
            { correct: "  printf(\"\\nPopping last item: %s\\n\", (char*)vector_pop_back(my_vec));", distractors: [{text: "  printf(\"\\nPopping last item: %s\\n\", vector_pop_back(my_vec));", reason: "Casting to `char*` is more explicit and portable."}, {text: "  vector_pop_back(my_vec); printf(\"Popped an item.\\n\");", reason: "The current version is more informative as it shows what was actually popped."}], indent: 1, explanation: "Demonstrate popping an item." },
            { correct: "  printf(\"Final vector size: %zu\\n\", vector_size(my_vec));", distractors: [{text: "  printf(\"Final vector size: %d\\n\", vector_size(my_vec));", reason: "`size_t` should be printed with `%zu`, not `%d`."}, {text: "  printf(\"Size: %zu\\n\", vector_size(my_vec));", reason: "Being more descriptive with 'Final vector size' makes the output clearer."}], indent: 1, explanation: "Check the new size." },
            { correct: "  printf(\"Destroying vector...\\n\");", distractors: [{text: "  printf(\"Cleaning up...\\n\");", reason: "Using 'Destroying vector' is more specific and matches our function name."}, {text: "  printf(\"Destroying vector...\");", reason: "Adding `\\n` ensures the message is displayed before the cleanup happens."}], indent: 1, explanation: "Informational message." },
            { correct: "  vector_destroy(my_vec);", distractors: [{text: "  vector_free(my_vec);", reason: "Our destructor function is named `vector_destroy`, not `vector_free`."}, {text: "  free(my_vec);", reason: "We should use our library's destructor function, which properly cleans up both the struct and the items array."}], indent: 1, explanation: "Clean up all memory." },
            { correct: "  return 0;", distractors: [{text: "  return 1;", reason: "Returning 0 indicates successful program execution."}, {text: "  exit(0);", reason: "While `exit(0)` would work, `return 0` is more conventional in main()."}], indent: 1, explanation: "Indicate success." },
            { correct: "}", distractors: [{text: "  return 0;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close main." }
        ]
    },
     // Level 76: Time-To-Live (TTL) expiration policy
    {
        "goal": "Build an in-memory key-value cache with a Time-To-Live (TTL) expiration policy.",
        concepts: "Hash tables, time.h, dynamic memory, API design, caching logic",
        sequence: [
            { correct: "// --- Stage 1: Includes and Core Data Structures ---", distractors: [{text: "// --- Stage 1: TTL Cache Implementation ---", reason: "This section is specifically about setting up includes and data structures, not the full implementation."}, {text: "// --- Stage 1: Header Files and Structs ---", reason: "More comprehensive to mention 'Includes and Core Data Structures'."}], indent: 0, explanation: "Define the necessary includes and the structs for our cache." },
            { correct: "#include <stdio.h>", distractors: [{text: "#include <iostream>", reason: "This is C, not C++. We need `stdio.h` for standard I/O functions."}, {text: "#include <cstdio>", reason: "This is the C++ version. In C, we use `stdio.h`."}], indent: 0, explanation: "Standard I/O." },
            { correct: "#include <stdlib.h>", distractors: [{text: "#include <malloc.h>", reason: "While `malloc.h` exists on some systems, `stdlib.h` is the standard header for memory allocation functions."}, {text: "#include <memory.h>", reason: "`stdlib.h` is the standard header for `malloc`, `free`, etc."}], indent: 0, explanation: "Memory management." },
            { correct: "#include <string.h>", distractors: [{text: "#include <strings.h>", reason: "`string.h` is the standard header for string functions. `strings.h` is a different, older header."}, {text: "#include <cstring>", reason: "This is the C++ version. In C, we use `string.h`."}], indent: 0, explanation: "String manipulation." },
            { correct: "#include <time.h>", distractors: [{text: "#include <sys/time.h>", reason: "While `sys/time.h` has time functions, `time.h` is the standard header for basic time functions like `time()`."}, {text: "#include <ctime>", reason: "This is the C++ version. In C, we use `time.h`."}], indent: 0, explanation: "Include for `time()` function to handle expirations." },
            { correct: "#include <unistd.h> // For sleep()", distractors: [{text: "#include <windows.h> // For sleep()", reason: "`unistd.h` is the POSIX header for `sleep()`. `windows.h` is Windows-specific and uses `Sleep()`."}, {text: "#include <thread.h> // For sleep()", reason: "`sleep()` is in `unistd.h`, not `thread.h`."}], indent: 0, explanation: "Include for the `sleep` function to demonstrate TTL." },
            { correct: "#define CACHE_SIZE 256", distractors: [{text: "#define CACHE_SIZE 1", reason: "A cache size of 1 would be inefficient. 256 provides good hash distribution and performance."}, {text: "#define CACHE_SIZE 65536", reason: "While larger caches can be useful, 256 is reasonable for a demonstration and doesn't waste too much memory."}], indent: 0, explanation: "The number of buckets in our cache's hash table." },
            { correct: "// A single entry in the cache.", distractors: [{text: "// The main cache structure.", reason: "This comment describes a single entry, not the main cache structure."}, {text: "// Cache node definition.", reason: "'A single entry in the cache' is more descriptive and clear."}], indent: 0, explanation: "Comment on the CacheEntry struct." },
            { correct: "typedef struct CacheEntry {", distractors: [{text: "struct CacheEntry {", reason: "Using `typedef struct` allows us to use `CacheEntry` as a type name without the `struct` keyword."}, {text: "typedef struct Cache {", reason: "This is defining a `CacheEntry`, not a `Cache`."}], indent: 0, explanation: "Begin CacheEntry definition." },
            { correct: "  char* key;", distractors: [{text: "  int key;", reason: "Using string keys is more flexible and realistic for a cache implementation."}, {text: "  const char* key;", reason: "Since we'll be dynamically allocating and freeing keys, `char*` is more appropriate than `const char*`."}], indent: 1, explanation: "The key for this cache entry." },
            { correct: "  char* value;", distractors: [{text: "  void* value;", reason: "While `void*` would be more generic, using `char*` keeps this example focused on string values."}, {text: "  int value;", reason: "String values are more realistic for demonstrating a cache system."}], indent: 1, explanation: "The value associated with the key." },
            { correct: "  time_t expiration_time;", distractors: [{text: "  int expiration_time;", reason: "`time_t` is the standard type for representing time values in C."}, {text: "  long expiration_time;", reason: "While `long` might work, `time_t` is the proper type for time values and is more portable."}], indent: 1, explanation: "The UNIX timestamp when this entry becomes invalid." },
            { correct: "  struct CacheEntry* next;", distractors: [{text: "  CacheEntry* next;", reason: "Inside the struct definition, we need to use `struct CacheEntry*` since the typedef isn't complete yet."}, {text: "  struct CacheEntry next;", reason: "We need a pointer to the next entry, not the entire struct."}], indent: 1, explanation: "Pointer to the next entry in case of hash collision." },
            { correct: "} CacheEntry;", distractors: [{text: "};", reason: "We're using `typedef struct`, so we need to provide the type name `CacheEntry`."}, {text: "} Cache;", reason: "This struct represents a single entry, so `CacheEntry` is the correct name."}], indent: 0, explanation: "Close the CacheEntry typedef." },
            { correct: "// The main cache structure, which is a hash table.", distractors: [{text: "// A single cache entry structure.", reason: "This comment describes the main cache structure, not a single entry."}, {text: "// Hash table implementation.", reason: "More specific to mention this is 'The main cache structure, which is a hash table'."}], indent: 0, explanation: "Comment on the main Cache struct." },
            { correct: "typedef struct {", distractors: [{text: "struct Cache {", reason: "Using `typedef struct` is consistent with our `CacheEntry` definition."}, {text: "typedef struct Cache {", reason: "Since we're not self-referencing, the simpler `typedef struct {` form is fine."}], indent: 0, explanation: "Begin Cache definition." },
            { correct: "  CacheEntry* buckets[CACHE_SIZE];", distractors: [{text: "  CacheEntry buckets[CACHE_SIZE];", reason: "Each bucket should be a pointer to the head of a linked list, not a full struct."}, {text: "  struct CacheEntry* buckets[CACHE_SIZE];", reason: "We can use `CacheEntry*` here since the typedef is already complete."}], indent: 1, explanation: "The array of buckets, each pointing to the head of a linked list." },
            { correct: "} Cache;", distractors: [{text: "};", reason: "We need to provide the typedef name `Cache`."}, {text: "} CacheTable;", reason: "We're calling this structure `Cache`, not `CacheTable`."}], indent: 0, explanation: "Close the Cache typedef." },
            { correct: "// --- Stage 2: Hash Function and Cache API Implementation ---", distractors: [{text: "// --- Stage 2: Function Implementations ---", reason: "More specific to mention 'Hash Function and Cache API Implementation'."}, {text: "// --- Stage 2: Cache Operations ---", reason: "Including 'Hash Function and Cache API Implementation' is more comprehensive."}], indent: 0, explanation: "Implement the core logic for creating, managing, and accessing the cache." },
            { correct: "unsigned long hash_function(const char* str) {", distractors: [{text: "int hash_function(const char* str) {", reason: "`unsigned long` provides a larger range and avoids negative hash values."}, {text: "size_t hash_function(const char* str) {", reason: "While `size_t` would work, `unsigned long` is more traditional for hash functions."}], indent: 0, explanation: "The djb2 hash function, which is good for string keys." },
            { correct: "  unsigned long hash = 5381; int c; while ((c = *str++)) { hash = ((hash << 5) + hash) + c; } return hash % CACHE_SIZE;", distractors: [{text: "  unsigned long hash = 0; int c; while ((c = *str++)) { hash = hash + c; } return hash % CACHE_SIZE;", reason: "The djb2 algorithm with 5381 and bit shifting provides better distribution than simple addition."}, {text: "  return strlen(str) % CACHE_SIZE;", reason: "Using string length as a hash would cause many collisions. The djb2 algorithm provides much better distribution."}], indent: 1, explanation: "The compact implementation of the djb2 algorithm." },
            { correct: "}", distractors: [{text: "  return hash;\n}", reason: "We need to use modulo to constrain the hash to our table size."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close the hash function." },
            { correct: "Cache* cache_create() {", distractors: [{text: "Cache cache_create() {", reason: "Returning a pointer allows for dynamic allocation and better memory management."}, {text: "void cache_create(Cache* cache) {", reason: "Returning the pointer is more conventional for constructor-style functions."}], indent: 0, explanation: "A 'constructor' to create and initialize a new cache." },
            { correct: "  Cache* cache = malloc(sizeof(Cache));", distractors: [{text: "  Cache* cache = calloc(1, sizeof(Cache));", reason: "While `calloc` would zero-initialize, we're explicitly zeroing with `memset` below."}, {text: "  Cache cache = malloc(sizeof(Cache));", reason: "We want to allocate a pointer to a Cache struct, not a Cache struct directly."}], indent: 1, explanation: "Allocate memory for the cache structure." },
            { correct: "  if (!cache) return NULL;", distractors: [{text: "  if (cache == NULL) return -1;", reason: "For a function returning a pointer, NULL is the appropriate error return value."}, {text: "  assert(cache != NULL);", reason: "Returning NULL on failure is better than asserting, as it allows graceful error handling."}], indent: 1, explanation: "Handle allocation failure." },
            { correct: "  memset(cache->buckets, 0, sizeof(cache->buckets));", distractors: [{text: "  memset(cache, 0, sizeof(Cache));", reason: "While this would work, explicitly zeroing just the buckets array is more precise."}, {text: "  for(int i = 0; i < CACHE_SIZE; i++) cache->buckets[i] = NULL;", reason: "Using `memset` is more efficient than a loop for initializing to zero."}], indent: 1, explanation: "Initialize all bucket pointers to NULL." },
            { correct: "  return cache;", distractors: [{text: "  return 0;", reason: "We should return the newly created cache pointer, not 0."}, {text: "  return 1;", reason: "This function should return the cache pointer for the caller to use."}], indent: 1, explanation: "Return the new cache." },
            { correct: "}", distractors: [{text: "  return cache;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close `cache_create`." },
            { correct: "void cache_set(Cache* cache, const char* key, const char* value, int ttl_seconds) {", distractors: [{text: "void cache_set(Cache* cache, char* key, char* value, int ttl_seconds) {", reason: "Using `const char*` indicates these strings won't be modified by this function."}, {text: "int cache_set(Cache* cache, const char* key, const char* value, int ttl_seconds) {", reason: "For this example, `void` is simpler. Returning an error code would add complexity."}], indent: 0, explanation: "Function to set a key-value pair with a specific Time-To-Live." },
            { correct: "  unsigned long index = hash_function(key);", distractors: [{text: "  int index = hash_function(key);", reason: "The hash function returns `unsigned long`, so we should use the same type."}, {text: "  size_t index = hash_function(key);", reason: "While `size_t` could work, matching the hash function's return type is more consistent."}], indent: 1, explanation: "Calculate the bucket index for this key." },
            { correct: "  // First, check if the key already exists to update it in-place.", distractors: [{text: "// Check if we need to resize the cache.", reason: "This comment is about updating existing keys, not resizing."}, {text: "// Add a new entry to the cache.", reason: "We first check for existing keys before adding new ones."}], indent: 1, explanation: "Comment on the update-or-insert logic." },
            { correct: "  CacheEntry* current = cache->buckets[index];", distractors: [{text: "  CacheEntry current = cache->buckets[index];", reason: "We need a pointer to traverse the linked list, not a copy of the struct."}, {text: "  CacheEntry* current = &cache->buckets[index];", reason: "buckets[index] is already a pointer, so we don't need the address-of operator."}], indent: 1, explanation: "Get the head of the list for this bucket." },
            { correct: "  while (current) {", distractors: [{text: "  while (current != NULL) {", reason: "Both forms are equivalent, but `while (current)` is more concise."}, {text: "  if (current) {", reason: "We need a loop to traverse the entire linked list, not just check the first entry."}], indent: 1, explanation: "Traverse the linked list." },
            { correct: "    if (strcmp(current->key, key) == 0) {", distractors: [{text: "    if (current->key == key) {", reason: "Comparing pointer addresses doesn't compare string contents. We need `strcmp()` for string comparison."}, {text: "    if (strcasecmp(current->key, key) == 0) {", reason: "While `strcasecmp` does case-insensitive comparison, `strcmp` is more standard and portable."}], indent: 2, explanation: "If the key is found..." },
            { correct: "      free(current->value); // Free the old value", distractors: [{text: "      delete current->value; // Free the old value", reason: "`delete` is C++. In C, we use `free()` for memory allocated with `malloc()`."}, {text: "      // Don't free - reuse the memory", reason: "Freeing the old value is important to prevent memory leaks, especially if the new value is a different size."}], indent: 3, explanation: "Free the old value string to prevent a memory leak." },
            { correct: "      current->value = strdup(value); // Set the new value", distractors: [{text: "      current->value = value; // Set the new value", reason: "We need to copy the string with `strdup()`, not just copy the pointer."}, {text: "      strcpy(current->value, value); // Set the new value", reason: "`strcpy` requires the destination to be pre-allocated. `strdup()` handles allocation for us."}], indent: 3, explanation: "Allocate and copy the new value string." },
            { correct: "      current->expiration_time = (ttl_seconds > 0) ? (time(NULL) + ttl_seconds) : 0;", distractors: [{text: "      current->expiration_time = time(NULL) + ttl_seconds;", reason: "We should handle the case where ttl_seconds <= 0 means never expires (represented by 0)."}, {text: "      current->expiration_time = ttl_seconds;", reason: "We need to add the TTL to the current time to get the actual expiration timestamp."}], indent: 3, explanation: "Update the expiration time. A TTL of 0 or less means it never expires." },
            { correct: "      return; // Update complete", distractors: [{text: "      break; // Update complete", reason: "`return` exits the function entirely, which is what we want after updating."}, {text: "      continue; // Update complete", reason: "`continue` would continue the loop, but we want to exit after updating."}], indent: 3, explanation: "Exit the function." },
            { correct: "    }", distractors: [{text: "    } else {", reason: "The else is unnecessary since we return from the if block."}, {text: "    }\n    break;", reason: "We need to continue searching through the list if this isn't the right key."}], indent: 2, explanation: "Close string compare." },
            { correct: "    current = current->next;", distractors: [{text: "    current++;", reason: "This is a linked list, not an array. We follow the `next` pointer to traverse."}, {text: "    current = current + 1;", reason: "Pointer arithmetic doesn't work for linked lists. We use `current->next`."}], indent: 2, explanation: "Move to the next entry." },
            { correct: "  }", distractors: [{text: "  }\n  return;", reason: "We'll continue to the new entry creation code below."}, {text: "  } while (current);", reason: "This is a `while` loop, not a `do-while` loop."}], indent: 1, explanation: "Close the update search loop." },
            { correct: "  // If key not found, create a new entry.", distractors: [{text: "  // Key was found, update it.", reason: "This comment is for the case where the key was NOT found."}, {text: "  // Resize the hash table.", reason: "This is about creating a new entry, not resizing."}], indent: 1, explanation: "Comment on the new entry logic." },
            { correct: "  CacheEntry* new_entry = malloc(sizeof(CacheEntry));", distractors: [{text: "  CacheEntry new_entry = malloc(sizeof(CacheEntry));", reason: "We need to allocate a pointer to a CacheEntry, not a CacheEntry directly."}, {text: "  CacheEntry* new_entry = calloc(1, sizeof(CacheEntry));", reason: "While `calloc` would zero-initialize, we're setting all fields explicitly below."}], indent: 1, explanation: "Allocate a new CacheEntry struct." },
            { correct: "  new_entry->key = strdup(key);", distractors: [{text: "  new_entry->key = key;", reason: "We need to copy the string with `strdup()`, not just copy the pointer."}, {text: "  strcpy(new_entry->key, key);", reason: "`strcpy` requires pre-allocated memory. `strdup()` handles the allocation."}], indent: 1, explanation: "Allocate and copy the key." },
            { correct: "  new_entry->value = strdup(value);", distractors: [{text: "  new_entry->value = value;", reason: "We need to copy the string, not just the pointer."}, {text: "  new_entry->value = malloc(strlen(value) + 1); strcpy(new_entry->value, value);", reason: "While this would work, `strdup()` is simpler and does the same thing."}], indent: 1, explanation: "Allocate and copy the value." },
            { correct: "  new_entry->expiration_time = (ttl_seconds > 0) ? (time(NULL) + ttl_seconds) : 0;", distractors: [{text: "  new_entry->expiration_time = time(NULL) + ttl_seconds;", reason: "We should handle the special case where ttl_seconds <= 0 means never expires."}, {text: "  new_entry->expiration_time = ttl_seconds;", reason: "We need to add the TTL to the current time to get the expiration timestamp."}], indent: 1, explanation: "Calculate the expiration timestamp." },
            { correct: "  new_entry->next = cache->buckets[index];", distractors: [{text: "  new_entry->next = NULL;", reason: "We need to link to the existing list head to handle hash collisions."}, {text: "  cache->buckets[index]->next = new_entry;", reason: "We insert at the head of the list, not at the tail."}], indent: 1, explanation: "Insert the new entry at the head of the list." },
            { correct: "  cache->buckets[index] = new_entry;", distractors: [{text: "  cache->buckets[index]->next = new_entry;", reason: "The new entry becomes the new head of the list."}, {text: "  cache->buckets[index] = &new_entry;", reason: "`new_entry` is already a pointer, so we don't need the address-of operator."}], indent: 1, explanation: "The new entry becomes the new head." },
            { correct: "}", distractors: [{text: "  return new_entry;\n}", reason: "This function is declared to return `void`, not a pointer."}, {text: "  return 0;\n}", reason: "This function returns `void`."}], indent: 0, explanation: "Close `cache_set`." },
            { correct: "const char* cache_get(Cache* cache, const char* key) {", distractors: [{text: "char* cache_get(Cache* cache, const char* key) {", reason: "Returning `const char*` indicates the caller shouldn't modify the returned string."}, {text: "void* cache_get(Cache* cache, const char* key) {", reason: "Returning `const char*` is more type-safe for string values."}], indent: 0, explanation: "Function to get a value from the cache, checking for expiration." },
            { correct: "  unsigned long index = hash_function(key);", distractors: [{text: "  int index = hash_function(key);", reason: "Should match the return type of the hash function."}, {text: "  size_t index = hash_function(key) % CACHE_SIZE;", reason: "The hash function already applies the modulo operation."}], indent: 1, explanation: "Calculate the bucket index." },
            { correct: "  CacheEntry* current = cache->buckets[index];", distractors: [{text: "  CacheEntry current = cache->buckets[index];", reason: "We need a pointer to traverse the linked list."}, {text: "  CacheEntry* current = &cache->buckets[index];", reason: "`buckets[index]` is already a pointer."}], indent: 1, explanation: "Get the head of the list." },
            { correct: "  while (current) {", distractors: [{text: "  if (current) {", reason: "We need to traverse the entire list to find the key, not just check the first entry."}, {text: "  for (current; current; current = current->next) {", reason: "The while loop form is more conventional for linked list traversal."}], indent: 1, explanation: "Traverse the list." },
            { correct: "    if (strcmp(current->key, key) == 0) {", distractors: [{text: "    if (current->key == key) {", reason: "We need `strcmp()` to compare string contents, not pointer addresses."}, {text: "    if (strncmp(current->key, key, strlen(key)) == 0) {", reason: "`strcmp()` is simpler and more appropriate when we want exact string matches."}], indent: 2, explanation: "If the key matches..." },
            { correct: "      // Check for expiration. A 0 expiration time means it never expires.", distractors: [{text: "      // Return the value immediately.", reason: "We need to check expiration first before returning the value."}, {text: "      // Update the access time.", reason: "This comment is about expiration checking, not access time updates."}], indent: 3, explanation: "Comment on the expiration check." },
            { correct: "      if (current->expiration_time != 0 && time(NULL) > current->expiration_time) {", distractors: [{text: "      if (current->expiration_time > 0 && time(NULL) > current->expiration_time) {", reason: "Using `!= 0` is more explicit about the 'never expires' condition."}, {text: "      if (time(NULL) > current->expiration_time) {", reason: "We need to check that expiration_time != 0 first, since 0 means 'never expires'."}], indent: 3, explanation: "Check if the entry has a TTL and if the current time has passed it." },
            { correct: "        // Entry is expired. We should ideally remove it here (lazy deletion).", distractors: [{text: "        // Entry is valid.", reason: "This comment is for the expired case, not the valid case."}, {text: "        // Update the expiration time.", reason: "The comment is about removing expired entries, not updating times."}], indent: 4, explanation: "Comment on lazy deletion." },
            { correct: "        printf(\" (Cache MISS: key '%s' found but is expired) \", key);", distractors: [{text: "        printf(\" (Cache HIT: key '%s' found) \", key);", reason: "This is a miss because the entry is expired, not a hit."}, {text: "        fprintf(stderr, \" (Cache MISS: key '%s' found but is expired) \", key);", reason: "While stderr could be used, stdout with printf is fine for this demo."}], indent: 4, explanation: "Log that the item expired." },
            { correct: "        return NULL;", distractors: [{text: "        return current->value;", reason: "We shouldn't return expired values - they should be treated as cache misses."}, {text: "        return \"\";", reason: "Returning NULL is the standard way to indicate a cache miss."}], indent: 4, explanation: "Return NULL as if the item was not found." },
            { correct: "      }", distractors: [{text: "      } else {", reason: "The else clause will come naturally from the structure without explicitly writing it."}, {text: "      }\n      // Entry is valid", reason: "The comment would come before the next block of code."}], indent: 3, explanation: "Close expiration check." },
            { correct: "      printf(\" (Cache HIT: key '%s' found) \", key);", distractors: [{text: "      printf(\" (Cache MISS: key '%s' not found) \", key);", reason: "This is a hit since we found a valid (non-expired) entry."}, {text: "      printf(\" (Cache HIT: key '%s' found but expired) \", key);", reason: "If we reach this line, the entry is not expired."}], indent: 3, explanation: "Log a successful cache hit." },
            { correct: "      return current->value;", distractors: [{text: "      return &current->value;", reason: "We want to return the string pointer, not a pointer to the pointer."}, {text: "      return strdup(current->value);", reason: "Returning the original pointer is fine since we're returning `const char*`."}], indent: 3, explanation: "Return the valid value." },
            { correct: "    }", distractors: [{text: "    } else {", reason: "The else is unnecessary since we continue the loop anyway."}, {text: "    }\n    break;", reason: "We should continue searching if this isn't the right key."}], indent: 2, explanation: "Close key compare." },
            { correct: "    current = current->next;", distractors: [{text: "    current++;", reason: "This is a linked list; we follow the next pointer, not increment."}, {text: "    current = current + 1;", reason: "Pointer arithmetic doesn't work for linked list traversal."}], indent: 2, explanation: "Move to the next entry." },
            { correct: "  }", distractors: [{text: "  }\n  // Key not found", reason: "The comment and code will come next."}, {text: "  } while (current != NULL);", reason: "This is a while loop, not a do-while."}], indent: 1, explanation: "Close traversal loop." },
            { correct: "  printf(\" (Cache MISS: key '%s' not found) \", key);", distractors: [{text: "  printf(\" (Cache HIT: key '%s' found) \", key);", reason: "This is a miss since we didn't find the key in the cache."}, {text: "  fprintf(stderr, \" (Cache MISS: key '%s' not found) \", key);", reason: "Using printf for demo output is fine."}], indent: 1, explanation: "Log a cache miss if the key was never found." },
            { correct: "  return NULL;", distractors: [{text: "  return \"\";", reason: "NULL is the standard return value to indicate failure for pointer-returning functions."}, {text: "  return -1;", reason: "This function returns a pointer, so NULL is the appropriate failure value."}], indent: 1, explanation: "Return NULL for a miss." },
            { correct: "}", distractors: [{text: "  return NULL;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close `cache_get`." },
            { correct: "void cache_destroy(Cache* cache) { /* ... similar to previous ht_free ... */ }", distractors: [{text: "void cache_destroy(Cache* cache) { free(cache); }", reason: "We need to free all the individual entries and their strings, not just the main cache structure."}, {text: "int cache_destroy(Cache* cache) { /* ... similar to previous ht_free ... */ }", reason: "A destructor typically returns void since cleanup usually succeeds."}], indent: 0, explanation: "The destroy function would be nearly identical to the hash table free function in the last level." },
            { correct: "// --- Stage 3: Main Program to Demonstrate the Cache ---", distractors: [{text: "// --- Stage 3: Test Functions ---", reason: "This is a complete demonstration program, not just test functions."}, {text: "// --- Stage 3: Cache Demo ---", reason: "More descriptive to say 'Main Program to Demonstrate the Cache'."}], indent: 0, explanation: "A `main` function to test our cache's functionality." },
            { correct: "int main() {", distractors: [{text: "void main() {", reason: "Standard C requires main to return int."}, {text: "int main(void) {", reason: "While main(void) is valid, main() is more common and equally correct."}], indent: 0, explanation: "Start main." },
            { correct: "  Cache* my_cache = cache_create();", distractors: [{text: "  Cache my_cache = cache_create();", reason: "cache_create() returns a pointer, so we need a pointer variable."}, {text: "  Cache* my_cache = malloc(sizeof(Cache));", reason: "We should use our constructor function cache_create() rather than malloc directly."}], indent: 1, explanation: "Create a new cache instance." },
            { correct: "  printf(\"Setting cache entries...\\n\");", distractors: [{text: "  printf(\"Setting cache entries...\");", reason: "Adding \\n ensures the output is flushed and properly formatted."}, {text: "  puts(\"Setting cache entries...\");", reason: "While puts would work, printf is consistent with the rest of the code."}], indent: 1, explanation: "Informational message." },
            { correct: "  cache_set(my_cache, \"user:1\", \"Alice\", 2); // Expires in 2 seconds.", distractors: [{text: "  cache_set(my_cache, \"user:1\", \"Alice\", 0); // Never expires.", reason: "We want to demonstrate TTL expiration, so using 2 seconds shows the feature."}, {text: "  cache_set(my_cache, \"user:1\", \"Alice\", -1); // Expires immediately.", reason: "Negative TTL means never expires in our implementation, not immediate expiration."}], indent: 1, explanation: "Set an entry with a short TTL." },
            { correct: "  cache_set(my_cache, \"user:2\", \"Bob\", 0); // Never expires.", distractors: [{text: "  cache_set(my_cache, \"user:2\", \"Bob\", 10); // Expires in 10 seconds.", reason: "Having one entry that never expires provides a good contrast to the expiring entry."}, {text: "  cache_set(my_cache, \"user:2\", \"Bob\", 2); // Same expiration as user:1.", reason: "Different TTLs demonstrate the feature better."}], indent: 1, explanation: "Set a persistent entry." },
            { correct: "  printf(\"\\n--- Initial Get ---\\n\");", distractors: [{text: "  printf(\"--- Initial Get ---\\n\");", reason: "Adding the leading \\n provides better visual separation."}, {text: "  printf(\"\\nTesting cache retrieval:\\n\");", reason: "The current phrasing is more concise."}], indent: 1, explanation: "Header for the first retrieval attempt." },
            { correct: "  const char* val1 = cache_get(my_cache, \"user:1\");", distractors: [{text: "  char* val1 = cache_get(my_cache, \"user:1\");", reason: "Using const char* matches our function's return type and indicates we won't modify the string."}, {text: "  void* val1 = cache_get(my_cache, \"user:1\");", reason: "Our function returns const char*, so that's the appropriate type to use."}], indent: 1, explanation: "Get the first user." },
            { correct: "  printf(\"-> Value for user:1 is %s\\n\", val1 ? val1 : \"NULL\");", distractors: [{text: "  printf(\"-> Value for user:1 is %s\\n\", val1);", reason: "We need to check for NULL to avoid segmentation faults when printing."}, {text: "  if (val1) printf(\"-> Value for user:1 is %s\\n\", val1);", reason: "The ternary operator handles both cases in one line."}], indent: 1, explanation: "Print the result." },
            { correct: "  const char* val2 = cache_get(my_cache, \"user:2\");", distractors: [{text: "  char* val2 = cache_get(my_cache, \"user:2\");", reason: "const char* matches the return type and indicates we won't modify the string."}, {text: "  const char* val2 = cache_get(my_cache, \"user:1\");", reason: "We want to get user:2, not user:1 again."}], indent: 1, explanation: "Get the second user." },
            { correct: "  printf(\"-> Value for user:2 is %s\\n\", val2 ? val2 : \"NULL\");", distractors: [{text: "  printf(\"-> Value for user:2 is %s\\n\", val2);", reason: "Need to check for NULL to avoid potential crashes."}, {text: "  printf(\"-> Value for user:2 is %d\\n\", val2 ? val2 : \"NULL\");", reason: "We're printing strings, so %s is correct, not %d."}], indent: 1, explanation: "Print the result." },
            { correct: "  printf(\"\\nSleeping for 3 seconds to allow user:1 to expire...\\n\");", distractors: [{text: "  printf(\"\\nSleeping for 1 second...\\n\");", reason: "3 seconds ensures user:1 (with 2-second TTL) will definitely expire."}, {text: "  printf(\"Sleeping for 3 seconds to allow user:1 to expire...\\n\");", reason: "Adding the leading \\n provides better visual separation."}], indent: 1, explanation: "Informational message about the delay." },
            { correct: "  sleep(3);", distractors: [{text: "  sleep(1);", reason: "3 seconds ensures the 2-second TTL entry will expire."}, {text: "  usleep(3000000);", reason: "While usleep would work, sleep(3) is simpler for whole seconds."}], indent: 1, explanation: "Pause the program for 3 seconds." },
            { correct: "  printf(\"\\n--- Get After Expiration ---\\n\");", distractors: [{text: "  printf(\"--- Get After Expiration ---\\n\");", reason: "The leading \\n provides better visual separation."}, {text: "  printf(\"\\nTesting expired entries:\\n\");", reason: "The current phrasing is more concise and clear."}], indent: 1, explanation: "Header for the second retrieval attempt." },
            { correct: "  val1 = cache_get(my_cache, \"user:1\");", distractors: [{text: "  const char* val1 = cache_get(my_cache, \"user:1\");", reason: "val1 is already declared above, so we just assign to it."}, {text: "  val1 = cache_get(my_cache, \"user:2\");", reason: "We want to test user:1 again to see if it expired."}], indent: 1, explanation: "Attempt to get the first user again." },
            { correct: "  printf(\"-> Value for user:1 is %s\\n\", val1 ? val1 : \"NULL\");", distractors: [{text: "  printf(\"-> Value for user:1 is %s\\n\", val1);", reason: "We need the NULL check since val1 should be NULL due to expiration."}, {text: "  printf(\"-> user:1 is %s\\n\", val1 ? \"found\" : \"expired\");", reason: "Showing the actual value (or NULL) is more informative."}], indent: 1, explanation: "Print the result, which should now be NULL." },
            { correct: "  val2 = cache_get(my_cache, \"user:2\");", distractors: [{text: "  const char* val2 = cache_get(my_cache, \"user:2\");", reason: "val2 is already declared above."}, {text: "  val2 = cache_get(my_cache, \"user:1\");", reason: "We want to check user:2 to show it's still valid."}], indent: 1, explanation: "Get the second user again." },
            { correct: "  printf(\"-> Value for user:2 is %s\\n\", val2 ? val2 : \"NULL\");", distractors: [{text: "  printf(\"-> Value for user:2 is %s\\n\", val2);", reason: "The NULL check is good defensive programming practice."}, {text: "  printf(\"-> user:2 is %s\\n\", val2 ? \"valid\" : \"expired\");", reason: "Showing the actual value is more informative than just saying 'valid'."}], indent: 1, explanation: "Print the result, which should still be valid." },
            { correct: "  // cache_destroy(my_cache); // Cleanup would happen here.", distractors: [{text: "  cache_destroy(my_cache); // Cleanup", reason: "For a demo, commenting it out is fine. In a real program, this would be uncommented."}, {text: "  free(my_cache); // Cleanup", reason: "We should use our destructor function cache_destroy(), not free() directly."}], indent: 1, explanation: "Comment on where final cleanup would occur." },
            { correct: "  return 0;", distractors: [{text: "  return 1;", reason: "Return 0 to indicate successful program execution."}, {text: "  exit(0);", reason: "return 0 is more conventional than exit(0) in main()."}], indent: 1, explanation: "Indicate success." },
            { correct: "}", distractors: [{text: "  return 0;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close main." }
        ]
    },
    // Level 77: integer arithmetic to avoid floating-point errors
{
    "goal": "Build a library for high-precision monetary calculations using integer arithmetic to avoid floating-point errors.",
    "concepts": "Integer arithmetic, opaque pointers, API design, string parsing, rounding",
    "sequence": [
        { correct: "// === Stage 1: The Public API Header File ('money.h') ===", distractors: [{text: "// === Stage 1: Money Library Implementation ===", reason: "This section is specifically about the header file that defines the public API."}, {text: "// === Stage 1: Monetary Calculations Setup ===", reason: "More specific to mention this is 'The Public API Header File'."}], indent: 0, explanation: "We define the public interface for our high-precision money library." },
        { correct: "#include <stdio.h>", distractors: [{text: "#include <iostream>", reason: "This is C, not C++. We need stdio.h for standard I/O."}, {text: "#include <cstdio>", reason: "This is the C++ version. In C, we use stdio.h."}], indent: 0, explanation: "Standard includes." },
        { correct: "#include <stdlib.h>", distractors: [{text: "#include <stdlibrary.h>", reason: "The correct header name is stdlib.h, not stdlibrary.h."}, {text: "#include <malloc.h>", reason: "While malloc.h exists on some systems, stdlib.h is the standard header for memory allocation."}], indent: 0, explanation: "Standard includes." },
        { correct: "// 1. Opaque declaration of the Money struct.", distractors: [{text: "// 1. Public declaration of the Money struct.", reason: "This is an opaque declaration - we're hiding the implementation details from users."}, {text: "// 1. Forward declaration of Money.", reason: "While technically a forward declaration, 'opaque declaration' better conveys the design intent."}], indent: 0, explanation: "Hide the internal representation of money from the user." },
        { correct: "struct Money;", distractors: [{text: "typedef struct Money Money;", reason: "We want to keep the struct opaque and use a pointer handle instead."}, {text: "struct Money {};", reason: "An empty struct isn't what we want - we need just the forward declaration."}], indent: 0, explanation: "Forward-declare the struct, making it an incomplete type." },
        { correct: "typedef struct Money* MoneyHandle;", distractors: [{text: "typedef struct Money MoneyHandle;", reason: "We want a pointer handle to maintain encapsulation, not direct struct access."}, {text: "typedef Money* MoneyHandle;", reason: "Money hasn't been typedef'd yet - we need struct Money*."}], indent: 0, explanation: "Users of the library will only use this pointer handle." },
        { correct: "// --- Public API Function Prototypes ---", distractors: [{text: "// --- Function Implementations ---", reason: "This is the header file with prototypes, not implementations."}, {text: "// --- Money Operations ---", reason: "More specific to call these 'Public API Function Prototypes'."}], indent: 0, explanation: "Declare the library's functions." },
        { correct: "MoneyHandle money_from_cents(long long cents);", distractors: [{text: "MoneyHandle money_from_cents(int cents);", reason: "long long provides better range for large monetary values."}, {text: "struct Money* money_from_cents(long long cents);", reason: "Using MoneyHandle maintains better abstraction."}], indent: 0, explanation: "Creates a Money object from a raw integer of cents." },
        { correct: "MoneyHandle money_from_string(const char* str);", distractors: [{text: "MoneyHandle money_from_string(char* str);", reason: "const char* indicates we won't modify the input string."}, {text: "MoneyHandle money_parse(const char* str);", reason: "money_from_string is more descriptive of what the function does."}], indent: 0, explanation: "Creates a Money object by parsing a string like \"-123.45\"." },
        { correct: "void money_destroy(MoneyHandle m);", distractors: [{text: "void money_free(MoneyHandle m);", reason: "money_destroy pairs better with money_from_* constructors."}, {text: "int money_destroy(MoneyHandle m);", reason: "For a simple destructor, void is sufficient."}], indent: 0, explanation: "Frees the memory for a Money object." },
        { correct: "char* money_to_string(MoneyHandle m);", distractors: [{text: "const char* money_to_string(MoneyHandle m);", reason: "We return a newly allocated string that the caller owns and must free."}, {text: "void money_to_string(MoneyHandle m, char* buffer);", reason: "Returning a new string is more convenient than requiring a pre-allocated buffer."}], indent: 0, explanation: "Converts a Money object back into a formatted string (e.g., \"$123.45\"). Caller must free the string." },
        { correct: "MoneyHandle money_add(MoneyHandle m1, MoneyHandle m2);", distractors: [{text: "void money_add(MoneyHandle m1, MoneyHandle m2);", reason: "We want to return a new Money object with the result, not modify in place."}, {text: "MoneyHandle money_add(MoneyHandle* m1, MoneyHandle* m2);", reason: "The handles are already pointers, so we don't need pointers to pointers."}], indent: 0, explanation: "Adds two Money objects and returns a new one with the result." },
        { correct: "MoneyHandle money_multiply(MoneyHandle m, double factor);", distractors: [{text: "MoneyHandle money_multiply(MoneyHandle m, int factor);", reason: "Using double allows for fractional multipliers like interest rates."}, {text: "MoneyHandle money_multiply(MoneyHandle m, float factor);", reason: "double provides better precision than float."}], indent: 0, explanation: "Multiplies a Money object by a float/double (e.g., for interest) and returns a new object." },
        { correct: "// === Stage 2: The Private Implementation ('money.c') ===", distractors: [{text: "// === Stage 2: Public Implementation ===", reason: "This is the private implementation file, hidden from library users."}, {text: "// === Stage 2: Money Library Source ===", reason: "More specific to mention 'The Private Implementation'."}], indent: 0, explanation: "Implement the hidden logic of our library." },
        { correct: "#include <string.h>", distractors: [{text: "#include <strings.h>", reason: "string.h is the standard header for string functions."}, {text: "#include <str.h>", reason: "The correct header name is string.h."}], indent: 0, explanation: "Include for string functions." },
        { correct: "#include <math.h> // For round()", distractors: [{text: "#include <mathematics.h> // For round()", reason: "The correct header name is math.h."}, {text: "#include <stdlib.h> // For round()", reason: "round() is in math.h, not stdlib.h."}], indent: 0, explanation: "Include for the rounding function." },
        { correct: "// #include \"money.h\" // In a real project", distractors: [{text: "#include \"money.h\" // Public API", reason: "This is commented out since we're showing everything in one file."}, {text: "// #include <money.h> // System header", reason: "Our custom header would use quotes, not angle brackets."}], indent: 0, explanation: "Link implementation to the public header." },
        { correct: "// 2. Full, private definition of the Money struct.", distractors: [{text: "// 2. Public definition of the Money struct.", reason: "This is the private definition - users can't see this structure."}, {text: "// 2. Forward declaration of Money.", reason: "This is the complete definition, not just a forward declaration."}], indent: 0, explanation: "The internal representation is a 64-bit integer of cents." },
        { correct: "struct Money { long long cents; };", distractors: [{text: "struct Money { double amount; };", reason: "Using double would introduce floating-point precision errors that we're trying to avoid."}, {text: "struct Money { int dollars; int cents; };", reason: "A single long long of total cents is simpler and avoids overflow issues with separate fields."}], indent: 0, explanation: "This stores monetary values like $123.45 as the integer 12345." },
        { correct: "MoneyHandle money_from_cents(long long cents) {", distractors: [{text: "MoneyHandle money_from_cents(int cents) {", reason: "long long provides better range for large monetary amounts."}, {text: "struct Money* money_from_cents(long long cents) {", reason: "Using MoneyHandle maintains consistency with our public API."}], indent: 0, explanation: "Implement the constructor from cents." },
        { correct: "  MoneyHandle m = malloc(sizeof(struct Money));", distractors: [{text: "  MoneyHandle m = malloc(sizeof(Money));", reason: "Money is only typedef'd as a pointer. We need sizeof(struct Money)."}, {text: "  MoneyHandle m = calloc(1, sizeof(struct Money));", reason: "malloc is sufficient since we're setting the cents field explicitly."}], indent: 1, explanation: "Allocate memory for the struct." },
        { correct: "  if (!m) return NULL;", distractors: [{text: "  if (m == NULL) return -1;", reason: "We should return NULL for a function that returns a pointer."}, {text: "  assert(m != NULL);", reason: "Returning NULL allows graceful error handling rather than crashing."}], indent: 1, explanation: "Handle allocation failure." },
        { correct: "  m->cents = cents;", distractors: [{text: "  m->amount = cents;", reason: "Our struct field is named 'cents', not 'amount'."}, {text: "  (*m).cents = cents;", reason: "While correct, m->cents is more conventional than (*m).cents."}], indent: 1, explanation: "Set the internal value." },
        { correct: "  return m;", distractors: [{text: "  return 0;", reason: "We should return the newly created money handle."}, {text: "  return &m;", reason: "m is already a pointer, so we don't need the address-of operator."}], indent: 1, explanation: "Return the new handle." },
        { correct: "}", distractors: [{text: "  return m;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close the function." },
        { correct: "void money_destroy(MoneyHandle m) {", distractors: [{text: "void money_destroy(MoneyHandle* m) {", reason: "The handle is already a pointer, so we don't need a pointer to pointer."}, {text: "int money_destroy(MoneyHandle m) {", reason: "void is appropriate for a simple destructor."}], indent: 0, explanation: "Implement the destructor." },
        { correct: "  free(m);", distractors: [{text: "  delete m;", reason: "delete is C++. In C, we use free() for malloc'd memory."}, {text: "  if (m) free(m);", reason: "While defensive, free(NULL) is safe in C, so the check isn't necessary."}], indent: 1, explanation: "Free the memory associated with the handle." },
        { correct: "}", distractors: [{text: "  m = NULL;\n}", reason: "Setting m to NULL here doesn't help since m is passed by value."}, {text: "  return 0;\n}", reason: "This function returns void."}], indent: 0, explanation: "Close the destructor." },
        { correct: "MoneyHandle money_from_string(const char* str) {", distractors: [{text: "MoneyHandle money_from_string(char* str) {", reason: "const char* indicates we won't modify the input string."}, {text: "MoneyHandle money_parse_string(const char* str) {", reason: "money_from_string is more consistent with our naming convention."}], indent: 0, explanation: "Implement the string parser." },
        { correct: "  double val_double = atof(str);", distractors: [{text: "  float val_float = atof(str);", reason: "atof() returns double, and double provides better precision than float."}, {text: "  int val_int = atoi(str);", reason: "atoi() only parses integers. We need atof() to handle decimal amounts."}], indent: 1, explanation: "Use `atof` to convert the string to a double initially." },
        { correct: "  long long cents = round(val_double * 100.0);", distractors: [{text: "  long long cents = val_double * 100;", reason: "This can introduce precision errors (e.g., 1.29 * 100 might become 128.999...). Using `round()` ensures we get the nearest whole cent."}, {text: "  long long cents = (long long)(val_double * 100.0);", reason: "Casting truncates rather than rounding. round() is more accurate for monetary calculations."}], indent: 1, explanation: "Convert the double value to cents, rounding carefully to handle precision issues." },
        { correct: "  return money_from_cents(cents);", distractors: [{text: "  MoneyHandle m = malloc(sizeof(struct Money)); m->cents = cents; return m;", reason: "We should reuse our existing constructor function for consistency."}, {text: "  return cents;", reason: "We need to return a MoneyHandle, not just the cents value."}], indent: 1, explanation: "Call our other constructor to create the object." },
        { correct: "}", distractors: [{text: "  return money_from_cents(cents);\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close the string parser." },
        { correct: "char* money_to_string(MoneyHandle m) {", distractors: [{text: "const char* money_to_string(MoneyHandle m) {", reason: "We return a newly allocated string that the caller owns and must free."}, {text: "void money_to_string(MoneyHandle m, char* buffer) {", reason: "Returning a new string is more convenient than requiring a buffer."}], indent: 0, explanation: "Implement the formatter." },
        { correct: "  if (!m) return NULL;", distractors: [{text: "  if (m == NULL) return \"\";", reason: "Returning NULL is more consistent for error conditions."}, {text: "  assert(m != NULL);", reason: "Returning NULL allows graceful error handling."}], indent: 1, explanation: "Handle null input." },
        { correct: "  long long dollars = m->cents / 100;", distractors: [{text: "  int dollars = m->cents / 100;", reason: "long long can handle larger amounts than int."}, {text: "  double dollars = m->cents / 100.0;", reason: "We want integer division to get whole dollars."}], indent: 1, explanation: "Calculate the dollar part using integer division." },
        { correct: "  long long cents_part = llabs(m->cents % 100);", distractors: [{text: "  long long cents_part = m->cents % 100;", reason: "llabs() ensures we get the absolute value for proper formatting of negative amounts."}, {text: "  int cents_part = abs(m->cents % 100);", reason: "llabs() is the long long version of abs(). Also, long long is more consistent."}], indent: 1, explanation: "Calculate the cents part using modulo. `llabs` gets the absolute value." },
        { correct: "  char* buffer = malloc(32);", distractors: [{text: "  char buffer[32];", reason: "We need to return this string, so it must be dynamically allocated."}, {text: "  char* buffer = malloc(10);", reason: "32 bytes provides safe space for larger amounts and formatting."}], indent: 1, explanation: "Allocate a buffer for the result string." },
        { correct: "  if (!buffer) return NULL;", distractors: [{text: "  if (!buffer) return \"\";", reason: "Returning NULL is consistent with our error handling pattern."}, {text: "  assert(buffer != NULL);", reason: "Returning NULL allows graceful error handling."}], indent: 1, explanation: "Handle allocation failure." },
        { correct: "  sprintf(buffer, \"%s$%lld.%02lld\", (m->cents < 0 ? \"-\" : \"\"), llabs(dollars), cents_part);", distractors: [{text: "  sprintf(buffer, \"$%lld.%02lld\", dollars, cents_part);", reason: "This doesn't handle negative amounts properly. We need separate sign handling."}, {text: "  sprintf(buffer, \"%s$%d.%02d\", (m->cents < 0 ? \"-\" : \"\"), (int)llabs(dollars), (int)cents_part);", reason: "Using %lld is better for long long values than casting to int."}], indent: 1, explanation: "Use `sprintf` to format the string, handling negative signs and ensuring cents are zero-padded." },
        { correct: "  return buffer;", distractors: [{text: "  return strdup(buffer);", reason: "buffer is already a newly allocated string, so we don't need strdup."}, {text: "  printf(\"%s\", buffer); return buffer;", reason: "This function should just return the string, not print it."}], indent: 1, explanation: "Return the newly created string." },
        { correct: "}", distractors: [{text: "  return buffer;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close the formatter." },
        { correct: "MoneyHandle money_add(MoneyHandle m1, MoneyHandle m2) {", distractors: [{text: "void money_add(MoneyHandle m1, MoneyHandle m2) {", reason: "We want to return a new Money object with the result."}, {text: "MoneyHandle money_add(MoneyHandle* m1, MoneyHandle* m2) {", reason: "The handles are already pointers."}], indent: 0, explanation: "Implement the addition function." },
        { correct: "  if (!m1 || !m2) return NULL;", distractors: [{text: "  if (!m1 || !m2) return 0;", reason: "We should return NULL for error conditions in pointer-returning functions."}, {text: "  assert(m1 && m2);", reason: "Returning NULL allows graceful error handling."}], indent: 1, explanation: "Handle null inputs." },
        { correct: "  long long result_cents = m1->cents + m2->cents;", distractors: [{text: "  double result = (m1->cents + m2->cents) / 100.0;", reason: "We want to keep everything as integer arithmetic to avoid precision issues."}, {text: "  int result_cents = m1->cents + m2->cents;", reason: "long long provides better range than int for the result."}], indent: 1, explanation: "The core logic is a simple integer addition." },
        { correct: "  return money_from_cents(result_cents);", distractors: [{text: "  MoneyHandle result = malloc(sizeof(struct Money)); result->cents = result_cents; return result;", reason: "We should reuse our constructor function for consistency."}, {text: "  return result_cents;", reason: "We need to return a MoneyHandle, not just the cents value."}], indent: 1, explanation: "Return a new Money object with the result." },
        { correct: "}", distractors: [{text: "  return money_from_cents(result_cents);\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close `money_add`." },
        { correct: "MoneyHandle money_multiply(MoneyHandle m, double factor) {", distractors: [{text: "MoneyHandle money_multiply(MoneyHandle m, int factor) {", reason: "double allows for fractional multipliers like interest rates."}, {text: "MoneyHandle money_multiply(MoneyHandle m, float factor) {", reason: "double provides better precision than float."}], indent: 0, explanation: "Implement multiplication by a factor." },
        { correct: "  if (!m) return NULL;", distractors: [{text: "  if (!m) return 0;", reason: "NULL is the appropriate error return for pointer-returning functions."}, {text: "  assert(m != NULL);", reason: "Returning NULL allows graceful error handling."}], indent: 1, explanation: "Handle null input." },
        { correct: "  double result_as_double = (double)m->cents * factor;", distractors: [{text: "  long long result_cents = m->cents * factor;", reason: "Multiplying long long by double requires careful handling. Converting to double first is safer."}, {text: "  float result_as_float = (float)m->cents * factor;", reason: "double provides better precision than float for intermediate calculations."}], indent: 1, explanation: "Perform the multiplication using floating-point math." },
        { correct: "  long long result_cents = round(result_as_double);", distractors: [{text: "  long long result_cents = (long long)result_as_double;", reason: "Casting truncates. round() ensures we get the nearest cent, which is more accurate."}, {text: "  long long result_cents = result_as_double;", reason: "Explicit rounding is better than implicit conversion for monetary calculations."}], indent: 1, explanation: "Round the result back to the nearest cent to maintain precision." },
        { correct: "  return money_from_cents(result_cents);", distractors: [{text: "  MoneyHandle result = malloc(sizeof(struct Money)); result->cents = result_cents; return result;", reason: "We should use our constructor function for consistency."}, {text: "  return result_cents;", reason: "We need to return a MoneyHandle, not the raw cents value."}], indent: 1, explanation: "Return a new Money object." },
        { correct: "}", distractors: [{text: "  return money_from_cents(result_cents);\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close `money_multiply`." },
        { correct: "// === Stage 3: The Main Program to Demonstrate the Library ===", distractors: [{text: "// === Stage 3: Test Cases ===", reason: "This is a complete demonstration program, not just test cases."}, {text: "// === Stage 3: Money Demo ===", reason: "More descriptive to say 'The Main Program to Demonstrate the Library'."}], indent: 0, explanation: "A `main` function to test our high-precision library." },
        { correct: "int main() {", distractors: [{text: "void main() {", reason: "Standard C requires main to return int."}, {text: "int main(void) {", reason: "While main(void) is valid, main() is equally correct and more common."}], indent: 0, explanation: "Start main." },
        { correct: "  printf(\"--- High-Precision Money Demo ---\\n\");", distractors: [{text: "  printf(\"--- Money Demo ---\\n\");", reason: "Emphasizing 'High-Precision' highlights the key feature of our library."}, {text: "  printf(\"--- High-Precision Money Demo ---\");", reason: "Adding \\n ensures proper formatting."}], indent: 1, explanation: "Header." },
        { correct: "  MoneyHandle price = money_from_string(\"199.99\");", distractors: [{text: "  MoneyHandle price = money_from_cents(19999);", reason: "Using money_from_string demonstrates the string parsing functionality."}, {text: "  struct Money* price = money_from_string(\"199.99\");", reason: "Using MoneyHandle maintains consistency with our API design."}], indent: 1, explanation: "Create a `price` object from a string." },
        { correct: "  MoneyHandle tax = money_from_string(\"12.00\");", distractors: [{text: "  MoneyHandle tax = money_from_string(\"12\");", reason: "Using \"12.00\" demonstrates parsing of decimal notation."}, {text: "  MoneyHandle tax = money_from_cents(1200);", reason: "Using money_from_string shows the string parsing feature."}], indent: 1, explanation: "Create a `tax` object." },
        { correct: "  char* price_str = money_to_string(price);", distractors: [{text: "  const char* price_str = money_to_string(price);", reason: "money_to_string returns a newly allocated string that we must free, so char* is correct."}, {text: "  char price_str[32]; money_to_string(price, price_str);", reason: "Our money_to_string function returns a new string, it doesn't fill a buffer."}], indent: 1, explanation: "Convert price back to a string for printing." },
        { correct: "  char* tax_str = money_to_string(tax);", distractors: [{text: "  const char* tax_str = money_to_string(tax);", reason: "We need char* since we must free the returned string."}, {text: "  char* tax_str = strdup(money_to_string(tax));", reason: "money_to_string already returns a new string, so strdup is unnecessary."}], indent: 1, explanation: "Convert tax back to a string." },
        { correct: "  printf(\"Initial Price: %s\\nTax: %s\\n\", price_str, tax_str);", distractors: [{text: "  printf(\"Initial Price: %s, Tax: %s\\n\", price_str, tax_str);", reason: "Using \\n between values provides better formatting."}, {text: "  printf(\"Price: %d, Tax: %d\\n\", price_str, tax_str);", reason: "We're printing strings, so %s is correct, not %d."}], indent: 1, explanation: "Print initial values." },
        { correct: "  free(price_str); free(tax_str);", distractors: [{text: "  // No need to free - strings are stack allocated", reason: "money_to_string returns malloc'd strings that must be freed."}, {text: "  delete price_str; delete tax_str;", reason: "delete is C++. In C, we use free() for malloc'd memory."}], indent: 1, explanation: "Free the strings returned by `money_to_string`." },
        { correct: "  MoneyHandle total = money_add(price, tax);", distractors: [{text: "  MoneyHandle total = price + tax;", reason: "We need to use our money_add function, not direct pointer arithmetic."}, {text: "  money_add(price, tax, &total);", reason: "Our money_add function returns a new MoneyHandle, it doesn't use output parameters."}], indent: 1, explanation: "Calculate the total price." },
        { correct: "  char* total_str = money_to_string(total);", distractors: [{text: "  const char* total_str = money_to_string(total);", reason: "We need char* since we must free the returned string."}, {text: "  char total_str[50]; sprintf(total_str, \"%s\", money_to_string(total));", reason: "This would leak memory. We should directly use the returned string and free it."}], indent: 1, explanation: "Convert total to a string." },
        { correct: "  printf(\"Total after addition: %s\\n\", total_str);", distractors: [{text: "  printf(\"Total: %s\\n\", total_str);", reason: "Being specific with 'Total after addition' shows what operation was performed."}, {text: "  printf(\"Total after addition: %d\\n\", total_str);", reason: "We're printing a string, so %s is correct."}], indent: 1, explanation: "Print the total." },
        { correct: "  free(total_str);", distractors: [{text: "  // total_str will be cleaned up automatically", reason: "Strings returned by money_to_string must be explicitly freed."}, {text: "  delete total_str;", reason: "delete is C++. In C, we use free()."}], indent: 1, explanation: "Free the total string." },
        { correct: "  printf(\"\\nCalculating with 5.5%% interest rate...\\n\");", distractors: [{text: "  printf(\"Calculating with 5.5% interest rate...\\n\");", reason: "In printf format strings, %% is needed to print a literal % character."}, {text: "  printf(\"\\nCalculating with interest...\\n\");", reason: "Being specific about the 5.5% rate is more informative."}], indent: 1, explanation: "Informational message." },
        { correct: "  MoneyHandle total_with_interest = money_multiply(total, 1.055);", distractors: [{text: "  MoneyHandle total_with_interest = money_multiply(total, 0.055);", reason: "1.055 means 100% + 5.5%, while 0.055 would be just 5.5% of the original."}, {text: "  MoneyHandle total_with_interest = total * 1.055;", reason: "We need to use our money_multiply function, not direct arithmetic."}], indent: 1, explanation: "Apply an interest rate." },
        { correct: "  char* interest_str = money_to_string(total_with_interest);", distractors: [{text: "  const char* interest_str = money_to_string(total_with_interest);", reason: "We need char* since we must free the returned string."}, {text: "  char* interest_str = strdup(money_to_string(total_with_interest));", reason: "money_to_string already returns a new string."}], indent: 1, explanation: "Convert the new total to a string." },
        { correct: "  printf(\"Total with interest: %s\\n\", interest_str);", distractors: [{text: "  printf(\"Final total: %s\\n\", interest_str);", reason: "Being specific with 'Total with interest' shows what calculation was performed."}, {text: "  printf(\"Total with interest: %f\\n\", interest_str);", reason: "We're printing a string, so %s is correct."}], indent: 1, explanation: "Print the final value." },
        { correct: "  free(interest_str);", distractors: [{text: "  // String will be freed automatically", reason: "All strings returned by money_to_string must be explicitly freed."}, {text: "  delete interest_str;", reason: "delete is C++. In C, we use free()."}], indent: 1, explanation: "Free the final string." },
        { correct: "  // Cleanup all money objects", distractors: [{text: "  // Money objects are stack allocated", reason: "Our money objects are heap-allocated and must be freed."}, {text: "  // Cleanup is automatic", reason: "We need to explicitly destroy all MoneyHandle objects."}], indent: 1, explanation: "Comment on cleanup." },
        { correct: "  money_destroy(price);", distractors: [{text: "  free(price);", reason: "We should use our destructor function money_destroy()."}, {text: "  delete price;", reason: "delete is C++. We use money_destroy() in our C library."}], indent: 1, explanation: "Free the price object." },
        { correct: "  money_destroy(tax);", distractors: [{text: "  free(tax);", reason: "We should use our destructor function."}, {text: "  money_destroy(&tax);", reason: "tax is already a pointer (MoneyHandle), so we don't need &."}], indent: 1, explanation: "Free the tax object." },
        { correct: "  money_destroy(total);", distractors: [{text: "  money_destroy(total_str);", reason: "total is the MoneyHandle object, not the string."}, {text: "  free(total);", reason: "We should use our destructor function."}], indent: 1, explanation: "Free the total object." },
        { correct: "  money_destroy(total_with_interest);", distractors: [{text: "  money_destroy(interest_str);", reason: "total_with_interest is the MoneyHandle object."}, {text: "  free(total_with_interest);", reason: "We should use our destructor function."}], indent: 1, explanation: "Free the last object." },
        { correct: "  return 0;", distractors: [{text: "  return 1;", reason: "Return 0 to indicate successful program execution."}, {text: "  exit(0);", reason: "return 0 is more conventional than exit(0) in main()."}], indent: 1, explanation: "Indicate success." },
        { correct: "}", distractors: [{text: "  return 0;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close main." }
    ]

    },
 // Level 78: generate a per-account summary report
{
    "goal": "Process a CSV file of financial transactions to generate a per-account summary report.",
    "concepts": "Hash tables, `fgets`, `strtok`, data aggregation, file I/O, reporting",
    "sequence": [
        { correct: "// === Stage 1: Setup and Data Structures ===", distractors: [{text: "// === Stage 1: CSV Processing Setup ===", reason: "This section covers both data structures and setup, not just CSV processing."}, {text: "// === Stage 1: File I/O Implementation ===", reason: "More comprehensive to mention 'Setup and Data Structures' as it includes the hash table design."}], indent: 0, explanation: "Define the necessary includes and the data structures for storing our aggregated results." },
        { correct: "#include <stdio.h>", distractors: [{text: "#include <iostream>", reason: "This is C, not C++. We need stdio.h for standard I/O functions like printf and fopen."}, {text: "#include <cstdio>", reason: "This is the C++ version. In C, we use stdio.h."}], indent: 0, explanation: "Standard I/O." },
        { correct: "#include <stdlib.h>", distractors: [{text: "#include <malloc.h>", reason: "While malloc.h exists on some systems, stdlib.h is the standard header for memory allocation and atof()."}, {text: "#include <stdlibrary.h>", reason: "The correct header name is stdlib.h, not stdlibrary.h."}], indent: 0, explanation: "Memory management and `atof`." },
        { correct: "#include <string.h>", distractors: [{text: "#include <strings.h>", reason: "string.h is the standard header for string functions like strcmp and strncpy."}, {text: "#include <cstring>", reason: "This is the C++ version. In C, we use string.h."}], indent: 0, explanation: "String manipulation." },
        { correct: "#define HASH_TABLE_SIZE 512", distractors: [{text: "#define HASH_TABLE_SIZE 1", reason: "A hash table size of 1 would essentially be a linked list, defeating the purpose of hashing."}, {text: "#define HASH_TABLE_SIZE 1000000", reason: "While larger tables can reduce collisions, 512 is reasonable for most applications and doesn't waste memory."}], indent: 0, explanation: "The number of buckets in our hash table for accounts." },
        { correct: "#define MAX_ID_LEN 64", distractors: [{text: "#define MAX_ID_LEN 8", reason: "8 characters is too short for realistic account IDs which might include prefixes, numbers, and suffixes."}, {text: "#define MAX_ID_LEN 1", reason: "1 character is far too short for any meaningful account identifier."}], indent: 0, explanation: "The maximum length of an account ID string." },
        { correct: "// A struct to hold the aggregated data for a single account.", distractors: [{text: "// The main hash table structure.", reason: "This comment describes a single account's data, not the overall hash table."}, {text: "// A struct for CSV parsing.", reason: "This struct holds aggregated results, not parsing data."}], indent: 0, explanation: "Comment on the AccountData struct." },
        { correct: "typedef struct AccountData {", distractors: [{text: "struct AccountData {", reason: "Using typedef struct allows us to use AccountData as a type name without the struct keyword."}, {text: "typedef struct Account {", reason: "We're calling this AccountData to emphasize it holds aggregated data, not just basic account info."}], indent: 0, explanation: "Begin AccountData definition." },
        { correct: "  char id[MAX_ID_LEN];", distractors: [{text: "  char* id;", reason: "Using a fixed-size array is simpler and avoids dynamic allocation for the ID string."}, {text: "  int id;", reason: "Account IDs are typically strings (like 'ACCT001') rather than simple integers."}], indent: 1, explanation: "The account ID string." },
        { correct: "  long long total_credit_cents;", distractors: [{text: "  double total_credit;", reason: "Using integer cents avoids floating-point precision errors in financial calculations."}, {text: "  int total_credit_cents;", reason: "long long provides much larger range than int for financial totals."}], indent: 1, explanation: "Sum of all credits for this account, in cents." },
        { correct: "  long long total_debit_cents;", distractors: [{text: "  float total_debit;", reason: "Integer cents arithmetic avoids floating-point precision issues."}, {text: "  int total_debit_cents;", reason: "long long can handle much larger financial amounts than int."}], indent: 1, explanation: "Sum of all debits for this account, in cents." },
        { correct: "  int transaction_count;", distractors: [{text: "  long long transaction_count;", reason: "While long long would work, int is sufficient for transaction counts in most applications."}, {text: "  char transaction_count;", reason: "char can only hold values 0-255, which is far too small for transaction counts."}], indent: 1, explanation: "Total number of transactions for this account." },
        { correct: "  struct AccountData* next;", distractors: [{text: "  AccountData* next;", reason: "Inside the struct definition, we need struct AccountData* since the typedef isn't complete yet."}, {text: "  struct AccountData next;", reason: "We need a pointer to the next entry, not the entire struct."}], indent: 1, explanation: "Pointer for hash collision linked list." },
        { correct: "} AccountData;", distractors: [{text: "};", reason: "We're using typedef struct, so we need to provide the type name AccountData."}, {text: "} Account;", reason: "We're calling this AccountData to emphasize it holds aggregated data."}], indent: 0, explanation: "Close the AccountData typedef." },
        { correct: "typedef struct { AccountData* buckets[HASH_TABLE_SIZE]; } HashTable;", distractors: [{text: "typedef struct { AccountData buckets[HASH_TABLE_SIZE]; } HashTable;", reason: "Each bucket should be a pointer to the head of a linked list, not a full struct."}, {text: "struct HashTable { AccountData* buckets[HASH_TABLE_SIZE]; };", reason: "Using typedef struct is consistent with our AccountData definition."}], indent: 0, explanation: "Define the hash table structure." },
        { correct: "// --- Stage 2: Hash Table and Parser Implementation ---", distractors: [{text: "// --- Stage 2: Function Implementations ---", reason: "More specific to mention 'Hash Table and Parser Implementation'."}, {text: "// --- Stage 2: CSV File Processing ---", reason: "This section includes hash table operations, not just CSV processing."}], indent: 0, explanation: "Implement the core logic." },
        { correct: "unsigned long hash_function(const char* str) {", distractors: [{text: "int hash_function(const char* str) {", reason: "unsigned long provides better range and avoids negative hash values."}, {text: "size_t hash_function(const char* str) {", reason: "While size_t would work, unsigned long is more traditional for hash functions."}], indent: 0, explanation: "The djb2 hash function for string keys." },
        { correct: "  unsigned long hash = 5381; int c; while((c = *str++)) hash = ((hash << 5) + hash) + c;", distractors: [{text: "  unsigned long hash = 0; int c; while((c = *str++)) hash = hash + c;", reason: "The djb2 algorithm with 5381 and bit shifting provides much better distribution than simple addition."}, {text: "  return strlen(str) % HASH_TABLE_SIZE;", reason: "Using string length would cause many collisions. A proper hash algorithm like djb2 distributes values much better."}], indent: 1, explanation: "Compact implementation of the hashing algorithm." },
        { correct: "  return hash % HASH_TABLE_SIZE;", distractors: [{text: "  return hash;", reason: "We need to use modulo to constrain the hash to our table size."}, {text: "  return hash & (HASH_TABLE_SIZE - 1);", reason: "While bitwise AND works when table size is a power of 2, modulo is more general and clear."}], indent: 1, explanation: "Constrain the hash to the table size." },
        { correct: "}", distractors: [{text: "  return hash % HASH_TABLE_SIZE;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close the hash function." },
        { correct: "HashTable* ht_create() {", distractors: [{text: "HashTable ht_create() {", reason: "Returning a pointer allows for dynamic allocation and better memory management."}, {text: "void ht_create(HashTable* ht) {", reason: "Returning the pointer is more conventional for constructor-style functions."}], indent: 0, explanation: "The constructor for our hash table." },
        { correct: "  HashTable* ht = malloc(sizeof(HashTable));", distractors: [{text: "  HashTable ht = malloc(sizeof(HashTable));", reason: "We want to allocate a pointer to a HashTable, not a HashTable directly."}, {text: "  HashTable* ht = calloc(1, sizeof(HashTable));", reason: "While calloc would zero-initialize, we're using memset below for clarity."}], indent: 1, explanation: "Allocate memory for the table." },
        { correct: "  memset(ht->buckets, 0, sizeof(ht->buckets));", distractors: [{text: "  for(int i = 0; i < HASH_TABLE_SIZE; i++) ht->buckets[i] = NULL;", reason: "memset is more efficient than a loop for initializing to zero."}, {text: "  memset(ht, 0, sizeof(HashTable));", reason: "While this would work, specifically zeroing the buckets array is more precise."}], indent: 1, explanation: "Initialize all buckets to NULL." },
        { correct: "  return ht;", distractors: [{text: "  return 0;", reason: "We should return the newly created hash table pointer."}, {text: "  return 1;", reason: "This function should return the hash table for the caller to use."}], indent: 1, explanation: "Return the new table." },
        { correct: "}", distractors: [{text: "  return ht;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close the constructor." },
        { correct: "AccountData* ht_get_or_create_account(HashTable* ht, const char* account_id) {", distractors: [{text: "AccountData* ht_get_account(HashTable* ht, const char* account_id) {", reason: "This function both gets existing accounts and creates new ones, so 'get_or_create' is more accurate."}, {text: "void ht_get_or_create_account(HashTable* ht, const char* account_id, AccountData** result) {", reason: "Returning the pointer directly is more convenient than using an output parameter."}], indent: 0, explanation: "A key function to find an existing account entry or create a new one." },
        { correct: "  unsigned long index = hash_function(account_id);", distractors: [{text: "  int index = hash_function(account_id);", reason: "Should match the return type of the hash function."}, {text: "  size_t index = hash_function(account_id) % HASH_TABLE_SIZE;", reason: "The hash function already applies the modulo operation."}], indent: 1, explanation: "Calculate the index for this account ID." },
        { correct: "  AccountData* current = ht->buckets[index];", distractors: [{text: "  AccountData current = ht->buckets[index];", reason: "We need a pointer to traverse the linked list."}, {text: "  AccountData* current = &ht->buckets[index];", reason: "buckets[index] is already a pointer."}], indent: 1, explanation: "Get the head of the list for this bucket." },
        { correct: "  while (current) {", distractors: [{text: "  if (current) {", reason: "We need to traverse the entire list to find the account, not just check the first entry."}, {text: "  for (; current; current = current->next) {", reason: "The while loop form is more conventional for this pattern."}], indent: 1, explanation: "Traverse the list to find an existing entry." },
        { correct: "    if (strcmp(current->id, account_id) == 0) return current;", distractors: [{text: "    if (current->id == account_id) return current;", reason: "We need strcmp() to compare string contents, not pointer addresses."}, {text: "    if (strncmp(current->id, account_id, strlen(account_id)) == 0) return current;", reason: "strcmp() is simpler and more appropriate for exact string matches."}], indent: 2, explanation: "If the account is found, return a pointer to it immediately." },
        { correct: "    current = current->next;", distractors: [{text: "    current++;", reason: "This is a linked list, not an array. We follow the next pointer."}, {text: "    current = current + 1;", reason: "Pointer arithmetic doesn't work for linked list traversal."}], indent: 2, explanation: "Move to the next entry." },
        { correct: "  }", distractors: [{text: "  }\n  return NULL;", reason: "We'll continue to the creation logic below if not found."}, {text: "  } while (current != NULL);", reason: "This is a while loop, not a do-while."}], indent: 1, explanation: "Close the search loop." },
        { correct: "  // If we get here, the account is new. Create and insert it.", distractors: [{text: "  // Account was found.", reason: "This comment is for when the account was NOT found."}, {text: "  // Return NULL for not found.", reason: "We're going to create a new account, not return NULL."}], indent: 1, explanation: "Comment on the creation logic." },
        { correct: "  AccountData* new_account = malloc(sizeof(AccountData));", distractors: [{text: "  AccountData new_account = malloc(sizeof(AccountData));", reason: "We need to allocate a pointer to AccountData."}, {text: "  AccountData* new_account = calloc(1, sizeof(AccountData));", reason: "While calloc would zero-initialize, we're setting all fields explicitly."}], indent: 1, explanation: "Allocate memory for the new account data struct." },
        { correct: "  strncpy(new_account->id, account_id, MAX_ID_LEN - 1);", distractors: [{text: "  strcpy(new_account->id, account_id);", reason: "strncpy is safer as it prevents buffer overflow if account_id is too long."}, {text: "  new_account->id = account_id;", reason: "We need to copy the string contents, not just the pointer."}], indent: 1, explanation: "Copy the account ID." },
        { correct: "  new_account->id[MAX_ID_LEN - 1] = '\\0';", distractors: [{text: "  new_account->id[MAX_ID_LEN] = '\\0';", reason: "Array indices go from 0 to MAX_ID_LEN-1. MAX_ID_LEN would be out of bounds."}, {text: "  // No need to null terminate", reason: "strncpy doesn't guarantee null termination if the string is truncated, so we must ensure it."}], indent: 1, explanation: "Ensure null termination." },
        { correct: "  new_account->total_credit_cents = 0;", distractors: [{text: "  new_account->total_credit_cents = -1;", reason: "0 is the appropriate initial value for a sum that will be added to."}, {text: "  // Fields are automatically initialized to 0", reason: "malloc doesn't initialize memory, so we must explicitly set the values."}], indent: 1, explanation: "Initialize credit total to zero." },
        { correct: "  new_account->total_debit_cents = 0;", distractors: [{text: "  new_account->total_debit_cents = NULL;", reason: "NULL is for pointers. For integers, 0 is the appropriate initial value."}, {text: "  new_account->total_debit_cents = 1;", reason: "0 is the correct initial value for a sum."}], indent: 1, explanation: "Initialize debit total to zero." },
        { correct: "  new_account->transaction_count = 0;", distractors: [{text: "  new_account->transaction_count = 1;", reason: "0 is the correct initial count - we'll increment it as transactions are processed."}, {text: "  new_account->transaction_count = -1;", reason: "0 is the appropriate initial value for a count."}], indent: 1, explanation: "Initialize transaction count to zero." },
        { correct: "  new_account->next = ht->buckets[index];", distractors: [{text: "  new_account->next = NULL;", reason: "We need to link to the existing list head to handle hash collisions."}, {text: "  ht->buckets[index]->next = new_account;", reason: "We insert at the head of the list for efficiency."}], indent: 1, explanation: "Link the new account to the front of the list." },
        { correct: "  ht->buckets[index] = new_account;", distractors: [{text: "  ht->buckets[index] = &new_account;", reason: "new_account is already a pointer, so we don't need the address-of operator."}, {text: "  ht->buckets[index]->next = new_account;", reason: "The new account becomes the new head of the list."}], indent: 1, explanation: "The new account becomes the new head of the list." },
        { correct: "  return new_account;", distractors: [{text: "  return ht->buckets[index];", reason: "While this would work since new_account is now the head, returning new_account is clearer."}, {text: "  return 0;", reason: "We should return the pointer to the newly created account."}], indent: 1, explanation: "Return the pointer to the newly created account." },
        { correct: "}", distractors: [{text: "  return new_account;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close the get/create function." },
        { correct: "void process_transactions(const char* filename, HashTable* ht) {", distractors: [{text: "int process_transactions(const char* filename, HashTable* ht) {", reason: "For this example, void is simpler. Returning an error code would add complexity."}, {text: "void process_transactions(char* filename, HashTable* ht) {", reason: "const char* indicates we won't modify the filename string."}], indent: 0, explanation: "The main file processing and data aggregation function." },
        { correct: "  FILE* fp = fopen(filename, \"r\");", distractors: [{text: "  FILE* fp = fopen(filename, \"w\");", reason: "We want to read the file, not write to it, so \"r\" is correct."}, {text: "  int fp = fopen(filename, \"r\");", reason: "fopen returns a FILE*, not an int."}], indent: 1, explanation: "Open the CSV file." },
        { correct: "  if (!fp) { perror(\"Error opening transactions file\"); return; }", distractors: [{text: "  if (!fp) { printf(\"Error\\n\"); return; }", reason: "perror() provides more detailed error information including the system error message."}, {text: "  if (fp == NULL) exit(1);", reason: "Returning from the function is better than exiting the entire program."}], indent: 1, explanation: "Handle file open errors." },
        { correct: "  char line_buffer[512];", distractors: [{text: "  char line_buffer[10];", reason: "512 bytes provides reasonable space for CSV lines. 10 bytes is far too small."}, {text: "  char* line_buffer = malloc(512);", reason: "A fixed-size buffer on the stack is simpler for this use case."}], indent: 1, explanation: "A buffer to read each line." },
        { correct: "  fgets(line_buffer, sizeof(line_buffer), fp); // Skip header row", distractors: [{text: "  // CSV files don't have headers", reason: "Many CSV files have header rows that describe the columns, which we need to skip."}, {text: "  fscanf(fp, \"%s\", line_buffer); // Skip header row", reason: "fgets is better for reading entire lines, while fscanf stops at whitespace."}], indent: 1, explanation: "Read and discard the first line (CSV header)." },
        { correct: "  while(fgets(line_buffer, sizeof(line_buffer), fp)) {", distractors: [{text: "  while(!feof(fp)) {", reason: "Using fgets() as the loop condition is more reliable than checking feof()."}, {text: "  for(;;) { if (!fgets(line_buffer, sizeof(line_buffer), fp)) break;", reason: "The while form is more concise and idiomatic."}], indent: 1, explanation: "Loop, reading one transaction line at a time." },
        { correct: "    // Parse the line: txn_id,acct_id,type,amount", distractors: [{text: "    // Parse the line: amount,type,acct_id,txn_id", reason: "The comment should match the actual expected CSV format."}, {text: "    // This line contains account data", reason: "More specific to describe the expected CSV format."}], indent: 2, explanation: "Comment on the expected format." },
        { correct: "    char* txn_id_str = strtok(line_buffer, \",\");", distractors: [{text: "    char* txn_id_str = strtok(line_buffer, \" \");", reason: "CSV files use commas as delimiters, not spaces."}, {text: "    char txn_id_str = strtok(line_buffer, \",\");", reason: "strtok returns a char*, not a char."}], indent: 2, explanation: "Get the transaction ID token (we'll ignore it)." },
        { correct: "    char* acct_id_str = strtok(NULL, \",\");", distractors: [{text: "    char* acct_id_str = strtok(line_buffer, \",\");", reason: "After the first call, strtok requires NULL to continue parsing the same string."}, {text: "    char* acct_id_str = strtok(NULL, \" \");", reason: "CSV uses commas, not spaces."}], indent: 2, explanation: "Get the account ID token." },
        { correct: "    char* type_str = strtok(NULL, \",\");", distractors: [{text: "    char* type_str = strtok(type_str, \",\");", reason: "We need to pass NULL to continue parsing, and type_str isn't defined yet."}, {text: "    char* type_str = strtok(NULL, \";\");", reason: "CSV files use commas as delimiters."}], indent: 2, explanation: "Get the transaction type token ('credit' or 'debit')." },
        { correct: "    char* amount_str = strtok(NULL, \",\\n\");", distractors: [{text: "    char* amount_str = strtok(NULL, \",\");", reason: "Including \\n handles the case where the amount is the last field in the line."}, {text: "    char* amount_str = strtok(NULL, \"\\n\");", reason: "We should include the comma in case there are more fields after amount."}], indent: 2, explanation: "Get the amount token." },
        { correct: "    if (acct_id_str && type_str && amount_str) {", distractors: [{text: "    if (txn_id_str && acct_id_str && type_str && amount_str) {", reason: "We don't actually use txn_id_str, so checking it isn't necessary."}, {text: "    if (amount_str) {", reason: "We should check all the fields we're going to use."}], indent: 2, explanation: "Check that all necessary tokens were found." },
        { correct: "      AccountData* account = ht_get_or_create_account(ht, acct_id_str);", distractors: [{text: "      AccountData account = ht_get_or_create_account(ht, acct_id_str);", reason: "The function returns a pointer, so we need a pointer variable."}, {text: "      AccountData* account = malloc(sizeof(AccountData));", reason: "We should use our hash table function to get or create the account."}], indent: 3, explanation: "Get the data bucket for this account." },
        { correct: "      long long amount_cents = round(atof(amount_str) * 100);", distractors: [{text: "      int amount_cents = atoi(amount_str) * 100;", reason: "atoi only handles integers. We need atof for decimal amounts, and long long for the result."}, {text: "      long long amount_cents = atof(amount_str) * 100;", reason: "Without round(), floating-point precision errors can cause issues (e.g., 1.23 * 100 might be 122.999...)."}], indent: 3, explanation: "Convert the amount string to a precise integer of cents." },
        { correct: "      if (strcmp(type_str, \"credit\") == 0) {", distractors: [{text: "      if (type_str == \"credit\") {", reason: "We need strcmp() to compare string contents, not pointer addresses."}, {text: "      if (strcasecmp(type_str, \"credit\") == 0) {", reason: "While strcasecmp does case-insensitive comparison, strcmp is more standard and our data should be consistent."}], indent: 3, explanation: "If the type is 'credit'..." },
        { correct: "        account->total_credit_cents += amount_cents;", distractors: [{text: "        account->total_credit_cents = amount_cents;", reason: "We want to add to the total, not replace it."}, {text: "        account->total_credit_cents++;", reason: "We want to add the amount, not just increment by 1."}], indent: 4, explanation: "Add to the credit total." },
        { correct: "      } else if (strcmp(type_str, \"debit\") == 0) {", distractors: [{text: "      } else {", reason: "It's safer to explicitly check for 'debit' in case there are other transaction types in the data."}, {text: "      } else if (type_str == \"debit\") {", reason: "We need strcmp() for string comparison."}], indent: 3, explanation: "If the type is 'debit'..." },
        { correct: "        account->total_debit_cents += amount_cents;", distractors: [{text: "        account->total_debit_cents = amount_cents;", reason: "We want to add to the total, not replace it."}, {text: "        account->total_credit_cents -= amount_cents;", reason: "Debits should be added to the debit total, not subtracted from credits."}], indent: 4, explanation: "Add to the debit total." },
        { correct: "      }", distractors: [{text: "      } else { printf(\"Unknown type: %s\\n\", type_str); }", reason: "For this example, we're keeping it simple. In production code, error handling would be good."}, {text: "      } else if (strcmp(type_str, \"transfer\") == 0) {", reason: "We're only handling credit and debit types in this example."}], indent: 3, explanation: "Close type check." },
        { correct: "      account->transaction_count++;", distractors: [{text: "      account->transaction_count = 1;", reason: "We want to increment the count, not set it to 1."}, {text: "      account->transaction_count += amount_cents;", reason: "We're counting transactions, not summing amounts."}], indent: 3, explanation: "Increment the transaction count for this account." },
        { correct: "    }", distractors: [{text: "    } else { printf(\"Malformed line\\n\"); }", reason: "For this example, we're silently skipping malformed lines."}, {text: "    }\n    break;", reason: "We want to process all lines, not just the first one."}], indent: 2, explanation: "Close token check." },
        { correct: "  }", distractors: [{text: "  }\n  printf(\"Processing complete\\n\");", reason: "The loop structure is complete with just the closing brace."}, {text: "  } while (!feof(fp));", reason: "This is a while loop, not a do-while."}], indent: 1, explanation: "Close the file reading loop." },
        { correct: "  fclose(fp);", distractors: [{text: "  // File will close automatically", reason: "We should explicitly close files when we're done with them."}, {text: "  free(fp);", reason: "File pointers are closed with fclose(), not freed with free()."}], indent: 1, explanation: "Close the file." },
        { correct: "}", distractors: [{text: "  fclose(fp);\n}", reason: "The fclose statement is already included above."}, {text: "  return 0;\n}", reason: "This function returns void."}], indent: 0, explanation: "Close the processing function." },
        { correct: "void print_report(HashTable* ht) {", distractors: [{text: "void print_report(HashTable ht) {", reason: "We should pass the hash table by pointer, not by value."}, {text: "char* print_report(HashTable* ht) {", reason: "This function prints directly, it doesn't return a string."}], indent: 0, explanation: "A function to generate and print the final report." },
        { correct: "  printf(\"\\n--- Transaction Summary Report ---\\n\");", distractors: [{text: "  printf(\"--- Transaction Summary Report ---\\n\");", reason: "Adding the leading \\n provides better visual separation."}, {text: "  printf(\"Report:\\n\");", reason: "A more descriptive header is more professional."}], indent: 1, explanation: "Print a report header." },
        { correct: "  printf(\"%-15s | %-10s | %-15s | %-15s | %-15s\\n\", \"Account ID\", \"Txn Count\", \"Total Debit\", \"Total Credit\", \"Net Balance\");", distractors: [{text: "  printf(\"%s | %s | %s | %s | %s\\n\", \"Account ID\", \"Txn Count\", \"Total Debit\", \"Total Credit\", \"Net Balance\");", reason: "Using %-15s creates nicely aligned columns by left-justifying and padding to 15 characters."}, {text: "  printf(\"Account ID, Txn Count, Total Debit, Total Credit, Net Balance\\n\");", reason: "Using | separators and padding creates a more readable table format."}], indent: 1, explanation: "Print the table column headers with formatting." },
        { correct: "  printf(\"--------------------------------------------------------------------------------\\n\");", distractors: [{text: "  printf(\"---\\n\");", reason: "A longer separator line matches the width of the header and looks more professional."}, {text: "  printf(\"================================================================================\\n\");", reason: "Dashes are more conventional than equals signs for table separators."}], indent: 1, explanation: "Print a separator line." },
        { correct: "  for (int i = 0; i < HASH_TABLE_SIZE; i++) {", distractors: [{text: "  for (int i = 0; i <= HASH_TABLE_SIZE; i++) {", reason: "Array indices go from 0 to HASH_TABLE_SIZE-1. Using <= would access out of bounds."}, {text: "  for (int i = 1; i < HASH_TABLE_SIZE; i++) {", reason: "Array indices start at 0, not 1."}], indent: 1, explanation: "Iterate through every bucket in the hash table." },
        { correct: "    for (AccountData* current = ht->buckets[i]; current != NULL; current = current->next) {", distractors: [{text: "    AccountData* current = ht->buckets[i]; if (current) {", reason: "We need to iterate through the entire linked list in each bucket, not just check the first entry."}, {text: "    for (AccountData current = ht->buckets[i]; current != NULL; current = current.next) {", reason: "We need a pointer to traverse the linked list, and use -> for pointer access."}], indent: 2, explanation: "Iterate through every account in the bucket's linked list." },
        { correct: "      long long net_cents = current->total_credit_cents - current->total_debit_cents;", distractors: [{text: "      long long net_cents = current->total_debit_cents - current->total_credit_cents;", reason: "Net balance is credits minus debits, not the other way around."}, {text: "      double net_balance = (current->total_credit_cents - current->total_debit_cents) / 100.0;", reason: "It's better to keep calculations in integer cents until we display them."}], indent: 3, explanation: "Calculate the net balance in cents." },
        { correct: "      // Print formatted data for the current account.", distractors: [{text: "      // Calculate the running total.", reason: "This comment is about printing the account data, not calculating totals."}, {text: "      // Update the hash table.", reason: "We're reading from the hash table, not updating it."}], indent: 3, explanation: "Comment on printing the row." },
        { correct: "      printf(\"%-15s | %-10d | $%8.2f   | $%13.2f   | $%13.2f\\n\",", distractors: [{text: "      printf(\"%s | %d | %.2f | %.2f | %.2f\\n\",", reason: "Using field width specifiers creates aligned columns for better readability."}, {text: "      printf(\"%-15s | %-10d | %8.2f   | %13.2f   | %13.2f\\n\",", reason: "Adding $ symbols makes it clear these are monetary amounts."}], indent: 3, explanation: "Use a formatted `printf` to create a clean table row." },
        { correct: "             current->id, ", distractors: [{text: "             &current->id, ", reason: "current->id is already a string (char array), so we don't need the address-of operator."}, {text: "             current->account_id, ", reason: "The field name is 'id', not 'account_id'."}], indent: 15, explanation: "Print the account ID." },
        { correct: "             current->transaction_count,", distractors: [{text: "             &current->transaction_count,", reason: "For %d format, we pass the integer value directly, not its address."}, {text: "             current->total_transaction_count,", reason: "The field name is 'transaction_count'."}], indent: 15, explanation: "Print the transaction count." },
        { correct: "             (double)current->total_debit_cents / 100.0,", distractors: [{text: "             current->total_debit_cents,", reason: "We need to convert cents to dollars by dividing by 100."}, {text: "             current->total_debit_cents / 100,", reason: "Using double division ensures we get decimal places in the result."}], indent: 15, explanation: "Calculate and print total debits in dollars." },
        { correct: "             (double)current->total_credit_cents / 100.0,", distractors: [{text: "             current->total_credit_cents / 100,", reason: "We need floating-point division to show decimal places."}, {text: "             (float)current->total_credit_cents / 100.0,", reason: "double provides better precision than float."}], indent: 15, explanation: "Calculate and print total credits in dollars." },
        { correct: "             (double)net_cents / 100.0);", distractors: [{text: "             net_cents / 100;", reason: "We need floating-point division to show decimal places, and don't forget the closing parenthesis."}, {text: "             (double)net_cents);", reason: "We need to divide by 100 to convert cents to dollars."}], indent: 15, explanation: "Calculate and print the net balance in dollars." },
        { correct: "    }", distractors: [{text: "    }\n    printf(\"\\n\");", reason: "Each account prints its own line, so we don't need extra newlines."}, {text: "    } while (current != NULL);", reason: "This is a for loop, not a do-while."}], indent: 2, explanation: "Close the inner loop." },
        { correct: "  }", distractors: [{text: "  }\n  printf(\"End of report\\n\");", reason: "The loop structure is complete with just the closing brace."}, {text: "  } while (i < HASH_TABLE_SIZE);", reason: "This is a for loop, not a do-while."}], indent: 1, explanation: "Close the outer loop." },
        { correct: "}", distractors: [{text: "  printf(\"\\n\");\n}", reason: "The function is complete without additional formatting."}, {text: "  return 0;\n}", reason: "This function returns void."}], indent: 0, explanation: "Close the report function." },
        { correct: "// --- Main Program Driver ---", distractors: [{text: "// --- Main Function ---", reason: "Calling it 'Main Program Driver' emphasizes its role in tying everything together."}, {text: "// --- Test Function ---", reason: "This is the main program driver, not just a test function."}], indent: 0, explanation: "The main function to tie it all together." },
        { correct: "int main(int argc, char* argv[]) {", distractors: [{text: "int main() {", reason: "We need command line arguments to get the CSV filename."}, {text: "void main(int argc, char* argv[]) {", reason: "Standard C requires main to return int."}], indent: 0, explanation: "Start main." },
        { correct: "  if (argc != 2) { printf(\"Usage: %s <transactions.csv>\\n\", argv[0]); return 1; }", distractors: [{text: "  if (argc < 2) { printf(\"Error\\n\"); return 1; }", reason: "Providing usage information is more helpful than just printing 'Error'."}, {text: "  if (argc == 1) { printf(\"Need filename\\n\"); return 1; }", reason: "Checking for exactly 2 arguments (program name + filename) is more precise."}], indent: 1, explanation: "Check for the CSV filename argument." },
        { correct: "  HashTable* account_data = ht_create();", distractors: [{text: "  HashTable account_data = ht_create();", reason: "ht_create() returns a pointer, so we need a pointer variable."}, {text: "  HashTable* account_data = malloc(sizeof(HashTable));", reason: "We should use our constructor function rather than malloc directly."}], indent: 1, explanation: "Create the hash table." },
        { correct: "  printf(\"Processing file: %s\\n\", argv[1]);", distractors: [{text: "  printf(\"Processing file: %s\\n\", argv[0]);", reason: "argv[0] is the program name, argv[1] is the first argument (filename)."}, {text: "  printf(\"Processing file...\\n\");", reason: "Showing the actual filename being processed is more informative."}], indent: 1, explanation: "Informational message." },
        { correct: "  process_transactions(argv[1], account_data);", distractors: [{text: "  process_transactions(argv[0], account_data);", reason: "argv[1] is the filename argument, argv[0] is the program name."}, {text: "  process_transactions(\"transactions.csv\", account_data);", reason: "We should use the filename provided as a command line argument."}], indent: 1, explanation: "Call the main processing function." },
        { correct: "  print_report(account_data);", distractors: [{text: "  print_report(&account_data);", reason: "account_data is already a pointer, so we don't need the address-of operator."}, {text: "  printf(\"Report complete\\n\");", reason: "We want to actually generate and print the report, not just print a message."}], indent: 1, explanation: "Generate and print the final report." },
        { correct: "  // ht_destroy(account_data); // A full implementation would free all memory here.", distractors: [{text: "  ht_destroy(account_data); // Free memory", reason: "For a demo, commenting it out is fine. In production, this would be uncommented."}, {text: "  free(account_data); // Cleanup", reason: "We should use a proper destructor function that frees all the linked lists, not just the main structure."}], indent: 1, explanation: "Comment on where final cleanup would occur." },
        { correct: "  return 0;", distractors: [{text: "  return 1;", reason: "Return 0 to indicate successful program execution."}, {text: "  exit(0);", reason: "return 0 is more conventional than exit(0) in main()."}], indent: 1, explanation: "Indicate success." },
        { correct: "}", distractors: [{text: "  return 0;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close main." }
    ]
},
    // Level 79: load world data from external files
{
    "goal": "Build a text adventure engine that loads its world data from external files.",
    "concepts": "Data-driven design, file I/O, `sscanf`, `strtok`, structs, dynamic arrays, game loops",
    "sequence": [
        { correct: "// === Stage 1: Setup and Core Data Structures ===", distractors: [{text: "// === Stage 1: Game Engine Implementation ===", reason: "This section is specifically about setting up data structures, not the full implementation."}, {text: "// === Stage 1: File Loading System ===", reason: "More comprehensive to mention 'Setup and Core Data Structures'."}], indent: 0, explanation: "Define the necessary includes and the data structures for our game world." },
        { correct: "#include <stdio.h>", distractors: [{text: "#include <iostream>", reason: "This is C, not C++. We need stdio.h for file I/O and printf functions."}, {text: "#include <cstdio>", reason: "This is the C++ version. In C, we use stdio.h."}], indent: 0, explanation: "Standard I/O for `printf`, file functions, etc." },
        { correct: "#include <stdlib.h>", distractors: [{text: "#include <malloc.h>", reason: "While malloc.h exists on some systems, stdlib.h is the standard header for memory allocation functions."}, {text: "#include <stdlibrary.h>", reason: "The correct header name is stdlib.h."}], indent: 0, explanation: "For memory allocation (`malloc`, `realloc`, `free`)." },
        { correct: "#include <string.h>", distractors: [{text: "#include <strings.h>", reason: "string.h is the standard header for string functions like strcmp, strcpy, and strtok."}, {text: "#include <cstring>", reason: "This is the C++ version. In C, we use string.h."}], indent: 0, explanation: "For string manipulation (`strcmp`, `strcpy`, `strtok`)." },
        { correct: "#define MAX_DESC_LEN 256", distractors: [{text: "#define MAX_DESC_LEN 10", reason: "10 characters is far too short for meaningful room and object descriptions."}, {text: "#define MAX_DESC_LEN 1", reason: "1 character cannot hold any useful description text."}], indent: 0, explanation: "Define max length for room and object descriptions." },
        { correct: "#define MAX_NAME_LEN 64", distractors: [{text: "#define MAX_NAME_LEN 5", reason: "5 characters is too short for descriptive room and object names."}, {text: "#define MAX_NAME_LEN 1000", reason: "1000 characters is unnecessarily large for names and wastes memory."}], indent: 0, explanation: "Define max length for room and object names." },
        { correct: "// --- Data Structures ---", distractors: [{text: "// --- Function Prototypes ---", reason: "This section defines data structures, not function prototypes."}, {text: "// --- Game Logic ---", reason: "We're defining data structures here, not implementing game logic."}], indent: 0, explanation: "Defining the blueprints for our game world entities." },
        { correct: "typedef struct {", distractors: [{text: "struct Room {", reason: "Using typedef struct allows us to use Room as a type name without the struct keyword."}, {text: "typedef struct Room {", reason: "Since we're not self-referencing here, the simpler typedef struct form is fine."}], indent: 0, explanation: "A structure to represent a single Room in the game." },
        { correct: "  int id;", distractors: [{text: "  char id;", reason: "char can only hold values 0-255, which limits the number of rooms. int provides much more range."}, {text: "  char* id;", reason: "Using an integer ID is more efficient than string IDs for internal references."}], indent: 1, explanation: "A unique ID for this room." },
        { correct: "  char name[MAX_NAME_LEN];", distractors: [{text: "  char* name;", reason: "Using a fixed-size array avoids the need for dynamic allocation and is simpler for this example."}, {text: "  int name;", reason: "Room names should be descriptive strings, not integers."}], indent: 1, explanation: "The name of the room (e.g., \"A dark cave\")." },
        { correct: "  char description[MAX_DESC_LEN];", distractors: [{text: "  char* description;", reason: "Fixed-size arrays are simpler and avoid memory management complexity."}, {text: "  char description[10];", reason: "10 characters is far too short for meaningful room descriptions."}], indent: 1, explanation: "The longer description of the room." },
        { correct: "  int north, south, east, west;", distractors: [{text: "  char* north, *south, *east, *west;", reason: "Using integer IDs is more efficient than string references for room connections."}, {text: "  int direction[4];", reason: "While an array would work, named fields (north, south, east, west) are more readable."}], indent: 1, explanation: "IDs of the rooms connected in each direction. -1 means no exit." },
        { correct: "} Room;", distractors: [{text: "};", reason: "We're using typedef struct, so we need to provide the type name Room."}, {text: "} GameRoom;", reason: "We're calling this type Room for simplicity."}], indent: 0, explanation: "Close the Room struct typedef." },
        { correct: "typedef struct {", distractors: [{text: "struct Object {", reason: "Using typedef struct is consistent with our Room definition."}, {text: "typedef struct Item {", reason: "We're calling this Object to match the comment and be consistent."}], indent: 0, explanation: "A structure to represent a single Object (or Item)." },
        { correct: "  int id;", distractors: [{text: "  char* id;", reason: "Integer IDs are more efficient for internal references than strings."}, {text: "  float id;", reason: "IDs should be integers, not floating-point numbers."}], indent: 1, explanation: "A unique ID for this object." },
        { correct: "  char name[MAX_NAME_LEN];", distractors: [{text: "  char* name;", reason: "Fixed-size arrays avoid memory management complexity."}, {text: "  char name[5];", reason: "5 characters is too short for meaningful object names."}], indent: 1, explanation: "The name of the object (e.g., \"rusty key\")." },
        { correct: "  char description[MAX_DESC_LEN];", distractors: [{text: "  char* description;", reason: "Using fixed-size arrays is simpler for this example."}, {text: "  char description[20];", reason: "20 characters may be too short for detailed object descriptions."}], indent: 1, explanation: "The description when a player 'looks' at it." },
        { correct: "  int location_id; // Room ID, or -1 for player's inventory", distractors: [{text: "  char* location; // Room name", reason: "Using integer IDs is more efficient than string names for references."}, {text: "  Room* location; // Pointer to room", reason: "Using IDs avoids circular reference issues and is simpler."}], indent: 1, explanation: "The ID of the room where the object is located." },
        { correct: "} Object;", distractors: [{text: "};", reason: "We need to provide the typedef name Object."}, {text: "} Item;", reason: "We're calling this type Object to match our comments."}], indent: 0, explanation: "Close the Object struct typedef." },
        { correct: "// --- Global Game State ---", distractors: [{text: "// --- Local Variables ---", reason: "These are global variables that hold the entire game state."}, {text: "// --- Function Definitions ---", reason: "This section declares global variables, not functions."}], indent: 0, explanation: "Global variables to hold all loaded game data and the player's state." },
        { correct: "Room* rooms = NULL;", distractors: [{text: "Room rooms[100];", reason: "Using a dynamic array allows for any number of rooms, not just a fixed 100."}, {text: "struct Room* rooms = NULL;", reason: "We can use the typedef Room instead of struct Room."}], indent: 0, explanation: "Dynamic array to store all room data." },
        { correct: "int room_count = 0;", distractors: [{text: "size_t room_count = 0;", reason: "While size_t would work, int is simpler for this example."}, {text: "int room_count = -1;", reason: "0 is the appropriate initial value for a count."}], indent: 0, explanation: "Number of rooms loaded." },
        { correct: "Object* objects = NULL;", distractors: [{text: "Object objects[50];", reason: "Dynamic allocation is more flexible than a fixed-size array."}, {text: "struct Object* objects = NULL;", reason: "We can use the typedef Object."}], indent: 0, explanation: "Dynamic array to store all object data." },
        { correct: "int object_count = 0;", distractors: [{text: "int object_count = 1;", reason: "0 is the correct initial value for a count."}, {text: "long object_count = 0;", reason: "int is sufficient for object counts in most games."}], indent: 0, explanation: "Number of objects loaded." },
        { correct: "int player_location_id = 0;", distractors: [{text: "Room* player_location = NULL;", reason: "Using an integer ID is simpler than maintaining a room pointer."}, {text: "int player_location_id = -1;", reason: "0 is a reasonable starting room ID. -1 typically means 'no room'."}], indent: 0, explanation: "The ID of the room the player is currently in." },
        { correct: "// --- Function Prototypes ---", distractors: [{text: "// --- Function Implementations ---", reason: "This section declares prototypes, not implementations."}, {text: "// --- Global Functions ---", reason: "More specific to call these 'Function Prototypes'."}], indent: 0, explanation: "Declare our functions before they are used." },
        { correct: "void load_data();", distractors: [{text: "int load_data();", reason: "For this example, void is simpler. Error handling could be added later."}, {text: "void load_data(char* filename);", reason: "This function handles the file creation and loading internally."}], indent: 0, explanation: "Main function to load all game data from files." },
        { correct: "void game_loop();", distractors: [{text: "int game_loop();", reason: "The game loop runs until the player quits, so void is appropriate."}, {text: "void main_loop();", reason: "game_loop is more specific about what kind of loop this is."}], indent: 0, explanation: "The main loop that waits for and processes player input." },
        { correct: "void do_look();", distractors: [{text: "void look_around();", reason: "do_look follows the naming convention of the other command functions."}, {text: "char* do_look();", reason: "This function prints directly rather than returning a string."}], indent: 0, explanation: "Handles the 'look' command." },
        { correct: "void do_move(const char* direction);", distractors: [{text: "void do_move(char* direction);", reason: "const char* indicates we won't modify the direction string."}, {text: "int do_move(const char* direction);", reason: "For this example, void is simpler than returning success/failure codes."}], indent: 0, explanation: "Handles movement commands like 'north', 'south'." },
        { correct: "void do_take(const char* object_name);", distractors: [{text: "void do_take(char* object_name);", reason: "const char* indicates we won't modify the object name string."}, {text: "Object* do_take(const char* object_name);", reason: "This function handles the taking action rather than returning the object."}], indent: 0, explanation: "Handles the 'take' command." },
        { correct: "void do_inventory();", distractors: [{text: "void show_inventory();", reason: "do_inventory follows the naming convention of the other command functions."}, {text: "Object* do_inventory();", reason: "This function displays the inventory rather than returning objects."}], indent: 0, explanation: "Handles the 'inventory' command." },
        { correct: "// --- Main Function ---", distractors: [{text: "// --- Program Entry Point ---", reason: "While accurate, 'Main Function' is more concise."}, {text: "// --- Game Startup ---", reason: "More general to say 'Main Function'."}], indent: 0, explanation: "Program entry point." },
        { correct: "int main() {", distractors: [{text: "void main() {", reason: "Standard C requires main to return int."}, {text: "int main(void) {", reason: "While main(void) is valid, main() is equally correct and more common."}], indent: 0, explanation: "Start main." },
        { correct: "  load_data();", distractors: [{text: "  load_data(\"world.dat\");", reason: "Our load_data function handles file creation internally."}, {text: "  if (!load_data()) exit(1);", reason: "Our load_data function returns void, not a success code."}], indent: 1, explanation: "Load all game world data from files." },
        { correct: "  if (room_count == 0) {", distractors: [{text: "  if (room_count < 0) {", reason: "room_count is initialized to 0, so checking == 0 is appropriate for 'no rooms loaded'."}, {text: "  if (!rooms) {", reason: "Checking room_count is more explicit about the condition we're testing."}], indent: 1, explanation: "Check if any rooms were loaded." },
        { correct: "    printf(\"Error: No rooms loaded. Cannot start game.\\n\");", distractors: [{text: "    printf(\"Error\\n\");", reason: "A descriptive error message is more helpful than just 'Error'."}, {text: "    fprintf(stderr, \"Error: No rooms loaded. Cannot start game.\\n\");", reason: "While stderr would be appropriate, printf to stdout is fine for this demo."}], indent: 2, explanation: "If no rooms, the game can't run." },
        { correct: "    return 1;", distractors: [{text: "    exit(1);", reason: "return 1 is more conventional than exit(1) in main()."}, {text: "    return 0;", reason: "1 indicates an error condition, 0 indicates success."}], indent: 2, explanation: "Exit with an error." },
        { correct: "  }", distractors: [{text: "  } else {", reason: "The else is unnecessary since we return from the if block."}, {text: "  }\n  printf(\"Rooms loaded successfully\\n\");", reason: "We don't need a success message here."}], indent: 1, explanation: "Close the check." },
        { correct: "  game_loop();", distractors: [{text: "  start_game();", reason: "We've defined this function as game_loop()."}, {text: "  while(1) { /* game logic */ }", reason: "We have a separate game_loop() function to handle this."}], indent: 1, explanation: "Start the main interactive game loop." },
        { correct: "  free(rooms);", distractors: [{text: "  delete rooms;", reason: "delete is C++. In C, we use free() for malloc'd memory."}, {text: "  // rooms will be freed automatically", reason: "We must explicitly free dynamically allocated memory."}], indent: 1, explanation: "After the game loop exits, free the rooms data." },
        { correct: "  free(objects);", distractors: [{text: "  delete objects;", reason: "delete is C++. In C, we use free()."}, {text: "  free(object_count);", reason: "We free the objects array, not the count variable."}], indent: 1, explanation: "Free the objects data." },
        { correct: "  printf(\"Thanks for playing!\\n\");", distractors: [{text: "  printf(\"Game over\\n\");", reason: "A friendly farewell message is more pleasant than 'Game over'."}, {text: "  printf(\"Thanks for playing!\");", reason: "Adding \\n ensures proper formatting."}], indent: 1, explanation: "A parting message." },
        { correct: "  return 0;", distractors: [{text: "  return 1;", reason: "0 indicates successful program execution."}, {text: "  exit(0);", reason: "return 0 is more conventional than exit(0) in main()."}], indent: 1, explanation: "Indicate success." },
        { correct: "}", distractors: [{text: "  return 0;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close main." },
        { correct: "// === Stage 2: Data Loading Implementation ===", distractors: [{text: "// === Stage 2: File Processing ===", reason: "More comprehensive to mention 'Data Loading Implementation'."}, {text: "// === Stage 2: Game Data Setup ===", reason: "This section implements the data loading functions specifically."}], indent: 0, explanation: "Implement the functions that read from our data files." },
        { correct: "void load_data() {", distractors: [{text: "int load_data() {", reason: "For this example, void is simpler than returning error codes."}, {text: "void load_world_data() {", reason: "load_data is more concise and matches our prototype."}], indent: 0, explanation: "Start the main data loading function." },
        { correct: "  // In a real project, these files would be separate. We simulate them here.", distractors: [{text: "  // Load data from external files", reason: "The current comment better explains why we're creating files in the code."}, {text: "  // Create demo data", reason: "More specific to explain that real projects would have separate files."}], indent: 1, explanation: "Comment on the simulated files." },
        { correct: "  FILE* f_rooms = fopen(\"rooms.dat\", \"w\");", distractors: [{text: "  FILE* f_rooms = fopen(\"rooms.dat\", \"r\");", reason: "We're creating the file first, so we need write mode, not read mode."}, {text: "  int f_rooms = fopen(\"rooms.dat\", \"w\");", reason: "fopen returns a FILE*, not an int."}], indent: 1, explanation: "Create a dummy rooms.dat file for the demo." },
        { correct: "  fprintf(f_rooms, \"0,Cave Entrance,You are at the mouth of a dark cave. A cold wind blows from within.,1,-1,-1,-1\\n\");", distractors: [{text: "  fprintf(f_rooms, \"0 Cave Entrance You are at the mouth of a dark cave\\n\");", reason: "CSV format uses commas to separate fields, and we need all the connection data."}, {text: "  printf(\"0,Cave Entrance,You are at the mouth of a dark cave. A cold wind blows from within.,1,-1,-1,-1\\n\");", reason: "We want to write to the file, not print to the console."}], indent: 1, explanation: "Write data for the first room." },
        { correct: "  fprintf(f_rooms, \"1,Inner Chamber,It is pitch black. You hear dripping water.,-1,0,-1,-1\\n\");", distractors: [{text: "  fprintf(f_rooms, \"1,Inner Chamber,Dark room\\n\");", reason: "We need the full CSV format with all connection data."}, {text: "  fputs(\"1,Inner Chamber,It is pitch black. You hear dripping water.,-1,0,-1,-1\\n\", f_rooms);", reason: "While fputs would work, fprintf is consistent with the line above."}], indent: 1, explanation: "Write data for the second room." },
        { correct: "  fclose(f_rooms);", distractors: [{text: "  // File will close automatically", reason: "We should explicitly close files when we're done writing to them."}, {text: "  free(f_rooms);", reason: "File pointers are closed with fclose(), not freed with free()."}], indent: 1, explanation: "Close the dummy file." },
        { correct: "  FILE* f_objects = fopen(\"objects.dat\", \"w\");", distractors: [{text: "  FILE* f_objects = fopen(\"items.dat\", \"w\");", reason: "We're calling our data file objects.dat to match our Object struct."}, {text: "  FILE* f_objects = fopen(\"objects.dat\", \"r\");", reason: "We're creating the file, so we need write mode."}], indent: 1, explanation: "Create a dummy objects.dat file." },
        { correct: "  fprintf(f_objects, \"0,lamp,A battered brass lamp.,0\\n\");", distractors: [{text: "  fprintf(f_objects, \"0 lamp A battered brass lamp 0\\n\");", reason: "CSV format uses commas as delimiters."}, {text: "  fprintf(f_objects, \"0,lamp,A lamp,0\\n\");", reason: "A more detailed description makes the game more immersive."}], indent: 1, explanation: "Write data for an object." },
        { correct: "  fprintf(f_objects, \"1,stone,A smooth, grey stone.,1\\n\");", distractors: [{text: "  fprintf(f_objects, \"1,stone,A stone.,1\\n\");", reason: "More descriptive text makes the game more engaging."}, {text: "  printf(\"1,stone,A smooth, grey stone.,1\\n\");", reason: "We want to write to the file, not print to console."}], indent: 1, explanation: "Write data for another object." },
        { correct: "  fclose(f_objects);", distractors: [{text: "  free(f_objects);", reason: "File pointers are closed with fclose(), not freed."}, {text: "  delete f_objects;", reason: "delete is C++. We use fclose() in C."}], indent: 1, explanation: "Close the dummy file." },
        { correct: "  // Now, actually load the data.", distractors: [{text: "  // Files created successfully", reason: "This comment introduces the actual loading phase."}, {text: "  // Start reading files", reason: "The current comment better explains the transition from writing to reading."}], indent: 1, explanation: "Comment on the loading process." },
        { correct: "  FILE* fp = fopen(\"rooms.dat\", \"r\");", distractors: [{text: "  FILE* fp = fopen(\"rooms.dat\", \"w\");", reason: "Now we're reading the file, so we need read mode."}, {text: "  int fp = fopen(\"rooms.dat\", \"r\");", reason: "fopen returns a FILE*, not an int."}], indent: 1, explanation: "Open the rooms file for reading." },
        { correct: "  if (!fp) { perror(\"Could not open rooms.dat\"); return; }", distractors: [{text: "  if (!fp) { printf(\"Error\\n\"); return; }", reason: "perror() provides more detailed error information."}, {text: "  if (fp == NULL) exit(1);", reason: "Returning is better than exiting the entire program."}], indent: 1, explanation: "Handle file open error." },
        { correct: "  char line[1024];", distractors: [{text: "  char line[10];", reason: "1024 bytes provides reasonable space for CSV lines. 10 bytes is far too small."}, {text: "  char* line = malloc(1024);", reason: "A stack-allocated buffer is simpler for this use case."}], indent: 1, explanation: "A buffer for reading lines." },
        { correct: "  while (fgets(line, sizeof(line), fp)) {", distractors: [{text: "  while (!feof(fp)) {", reason: "Using fgets() as the loop condition is more reliable than checking feof()."}, {text: "  for (;;) { fgets(line, sizeof(line), fp);", reason: "The while form with fgets is more idiomatic."}], indent: 1, explanation: "Read the rooms file line by line." },
        { correct: "    room_count++;", distractors: [{text: "    room_count = 1;", reason: "We want to increment the count for each room, not set it to 1."}, {text: "    object_count++;", reason: "We're counting rooms, not objects."}], indent: 2, explanation: "Increment room count." },
        { correct: "    rooms = realloc(rooms, room_count * sizeof(Room));", distractors: [{text: "    rooms = malloc(room_count * sizeof(Room));", reason: "realloc preserves existing data when growing the array."}, {text: "    rooms = realloc(rooms, room_count);", reason: "We need to multiply by sizeof(Room) to get the correct byte size."}], indent: 2, explanation: "Resize the dynamic array for rooms." },
        { correct: "    sscanf(line, \"%d,%[^,],\\\"%[^\"]\\\",%d,%d,%d,%d\",", distractors: [{text: "    sscanf(line, \"%d %s %s %d %d %d %d\",", reason: "CSV format uses commas, and we need the special format specifiers for quoted strings."}, {text: "    scanf(\"%d,%[^,],\\\"%[^\"]\\\",%d,%d,%d,%d\",", reason: "We want to scan from the line string, not from stdin."}], indent: 2, explanation: "Use `sscanf` to parse the structured line. `%[^,]` reads until a comma, `\\\"%[^\"]\\\"` reads a quoted string." },
        { correct: "           &rooms[room_count-1].id, rooms[room_count-1].name, rooms[room_count-1].description,", distractors: [{text: "           &rooms[room_count].id, rooms[room_count].name, rooms[room_count].description,", reason: "Array indices are 0-based. The new room is at index room_count-1."}, {text: "           rooms[room_count-1].id, &rooms[room_count-1].name, &rooms[room_count-1].description,", reason: "For %d we need &, but for %s the array name is already a pointer."}], indent: 11, explanation: "Provide the destination variables for `sscanf`." },
        { correct: "           &rooms[room_count-1].north, &rooms[room_count-1].south, &rooms[room_count-1].east, &rooms[room_count-1].west);", distractors: [{text: "           rooms[room_count-1].north, rooms[room_count-1].south, rooms[room_count-1].east, rooms[room_count-1].west);", reason: "For %d format specifiers, we need to pass the address of the variables."}, {text: "           &rooms[room_count].north, &rooms[room_count].south, &rooms[room_count].east, &rooms[room_count].west);", reason: "The new room is at index room_count-1, not room_count."}], indent: 11, explanation: "Continue providing destination variables." },
        { correct: "  }", distractors: [{text: "  }\n  printf(\"Loaded %d rooms\\n\", room_count);", reason: "The loop structure is complete with just the closing brace."}, {text: "  } while (!feof(fp));", reason: "This is a while loop, not a do-while."}], indent: 1, explanation: "Close the rooms reading loop." },
        { correct: "  fclose(fp);", distractors: [{text: "  free(fp);", reason: "File pointers are closed with fclose(), not freed."}, {text: "  // File will close automatically", reason: "We should explicitly close files."}], indent: 1, explanation: "Close the rooms file." },
        { correct: "  fp = fopen(\"objects.dat\", \"r\");", distractors: [{text: "  FILE* fp2 = fopen(\"objects.dat\", \"r\");", reason: "We can reuse the fp variable since we closed the previous file."}, {text: "  fp = fopen(\"objects.dat\", \"w\");", reason: "We want to read the objects file, not write to it."}], indent: 1, explanation: "Open the objects file for reading." },
        { correct: "  if (!fp) { perror(\"Could not open objects.dat\"); return; }", distractors: [{text: "  if (!fp) { printf(\"Error with objects file\\n\"); return; }", reason: "perror() provides more detailed system error information."}, {text: "  if (fp == NULL) exit(1);", reason: "Returning is more graceful than exiting the program."}], indent: 1, explanation: "Handle file open error." },
        { correct: "  while (fgets(line, sizeof(line), fp)) {", distractors: [{text: "  while (fscanf(fp, \"%s\", line) == 1) {", reason: "fgets is better for reading entire lines, while fscanf stops at whitespace."}, {text: "  while (!feof(fp)) { fgets(line, sizeof(line), fp);", reason: "Using fgets as the loop condition is more reliable."}], indent: 1, explanation: "Read the objects file line by line." },
        { correct: "    object_count++;", distractors: [{text: "    room_count++;", reason: "We're processing objects now, not rooms."}, {text: "    object_count = object_count + 1;", reason: "While correct, ++ is more concise."}], indent: 2, explanation: "Increment object count." },
        { correct: "    objects = realloc(objects, object_count * sizeof(Object));", distractors: [{text: "    objects = malloc(object_count * sizeof(Object));", reason: "realloc preserves existing data when growing the array."}, {text: "    objects = realloc(objects, object_count);", reason: "We need to multiply by sizeof(Object) to get the correct byte size."}], indent: 2, explanation: "Resize the dynamic array for objects." },
        { correct: "    sscanf(line, \"%d,\\\"%[^\"]\\\",\\\"%[^\"]\\\",%d\", &objects[object_count-1].id, objects[object_count-1].name, objects[object_count-1].description, &objects[object_count-1].location_id);", distractors: [{text: "    sscanf(line, \"%d %s %s %d\", &objects[object_count-1].id, objects[object_count-1].name, objects[object_count-1].description, &objects[object_count-1].location_id);", reason: "CSV format uses commas, and we need proper format specifiers for quoted strings."}, {text: "    sscanf(line, \"%d,\\\"%[^\"]\\\",\\\"%[^\"]\\\",%d\", &objects[object_count].id, objects[object_count].name, objects[object_count].description, &objects[object_count].location_id);", reason: "The new object is at index object_count-1, not object_count."}], indent: 2, explanation: "Use `sscanf` to parse the object data line." },
        { correct: "  }", distractors: [{text: "  }\n  printf(\"Loaded %d objects\\n\", object_count);", reason: "The loop structure is complete."}, {text: "  } while (fgets(line, sizeof(line), fp));", reason: "This is a while loop, not a do-while."}], indent: 1, explanation: "Close the objects reading loop." },
        { correct: "  fclose(fp);", distractors: [{text: "  free(fp);", reason: "File pointers are closed, not freed."}, {text: "  delete fp;", reason: "delete is C++. We use fclose() in C."}], indent: 1, explanation: "Close the objects file." },
        { correct: "  printf(\"Loaded %d rooms and %d objects.\\n\", room_count, object_count);", distractors: [{text: "  printf(\"Loading complete.\\n\");", reason: "Showing the actual counts is more informative."}, {text: "  printf(\"Loaded %d rooms and %d objects.\", room_count, object_count);", reason: "Adding \\n ensures proper formatting."}], indent: 1, explanation: "Print a summary of what was loaded." },
        { correct: "}", distractors: [{text: "  printf(\"Loaded %d rooms and %d objects.\\n\", room_count, object_count);\n}", reason: "The printf statement is already included above."}, {text: "  return 0;\n}", reason: "This function returns void."}], indent: 0, explanation: "Close the `load_data` function." },
        { correct: "// === Stage 3: Game Logic Implementation ===", distractors: [{text: "// === Stage 3: User Interface ===", reason: "This section implements the core game logic, not just the UI."}, {text: "// === Stage 3: Command Processing ===", reason: "More comprehensive to mention 'Game Logic Implementation'."}], indent: 0, explanation: "Implement the functions that control the gameplay." },
        { correct: "void game_loop() {", distractors: [{text: "int game_loop() {", reason: "This function runs until the player quits, so void is appropriate."}, {text: "void main_game_loop() {", reason: "game_loop is more concise and matches our prototype."}], indent: 0, explanation: "Start the main game loop." },
        { correct: "  char input[100];", distractors: [{text: "  char input[5];", reason: "100 characters provides reasonable space for player commands. 5 is too small."}, {text: "  char* input = malloc(100);", reason: "A stack-allocated buffer is simpler for this use case."}], indent: 1, explanation: "A buffer to hold the player's command." },
        { correct: "  printf(\"\\n--------------------\\n\");", distractors: [{text: "  printf(\"Game started\\n\");", reason: "A visual separator is more effective than just text."}, {text: "  printf(\"--------------------\\n\");", reason: "Adding the leading \\n provides better visual separation."}], indent: 1, explanation: "Print a separator." },
        { correct: "  do_look(); // Look around when the game starts", distractors: [{text: "  printf(\"Welcome to the game\\n\");", reason: "Calling do_look() immediately shows the player their environment."}, {text: "  // Game starts here", reason: "Actually calling do_look() is more useful than just a comment."}], indent: 1, explanation: "Give the player an initial description of their surroundings." },
        { correct: "  while (1) { // Loop forever until 'quit'", distractors: [{text: "  for(;;) { // Loop forever until 'quit'", reason: "while(1) is more readable than for(;;)."}, {text: "  while (game_running) { // Loop until quit", reason: "while(1) with a break is simpler than maintaining a separate boolean variable."}], indent: 1, explanation: "The main game loop." },
        { correct: "    printf(\"\\n> \");", distractors: [{text: "    printf(\"> \");", reason: "Adding \\n provides better spacing between the room description and the prompt."}, {text: "    printf(\"Enter command: \");", reason: "> is a more concise and traditional prompt."}], indent: 2, explanation: "Print the command prompt." },
        { correct: "    fgets(input, sizeof(input), stdin);", distractors: [{text: "    scanf(\"%s\", input);", reason: "fgets reads the entire line including spaces, while scanf stops at the first space."}, {text: "    gets(input);", reason: "gets() is unsafe and deprecated. fgets() is the secure alternative."}], indent: 2, explanation: "Read a full line of input from the player." },
        { correct: "    input[strcspn(input, \"\\n\")] = 0; // Remove trailing newline", distractors: [{text: "    input[strlen(input)-1] = 0; // Remove trailing newline", reason: "strcspn is safer than strlen-1 in case the input doesn't contain a newline."}, {text: "    strtok(input, \"\\n\"); // Remove trailing newline", reason: "While strtok would work, the direct assignment is simpler."}], indent: 2, explanation: "Safely remove the newline character that `fgets` reads." },
        { correct: "    char* command = strtok(input, \" \");", distractors: [{text: "    char* command = strtok(input, \"\\n\");", reason: "We want to split on spaces to separate the command from arguments."}, {text: "    char command = strtok(input, \" \");", reason: "strtok returns a char*, not a char."}], indent: 2, explanation: "Get the first word of the input as the command." },
        { correct: "    char* argument = strtok(NULL, \"\"); // Get the rest as the argument", distractors: [{text: "    char* argument = strtok(NULL, \" \"); // Get the next word", reason: "Using \"\" gets the entire rest of the string, allowing for multi-word arguments."}, {text: "    char* argument = strtok(input, \" \"); // Get the argument", reason: "We need to pass NULL to continue parsing the same string."}], indent: 2, explanation: "Get the second part of the input (if any)." },
        { correct: "    if (command == NULL) continue;", distractors: [{text: "    if (!command) return;", reason: "continue goes to the next iteration, while return would exit the function."}, {text: "    if (command == NULL) break;", reason: "continue is better than break - we want to prompt again, not exit."}], indent: 2, explanation: "If the user just pressed Enter, loop again." },
        { correct: "    if (strcmp(command, \"quit\") == 0) break;", distractors: [{text: "    if (command == \"quit\") break;", reason: "We need strcmp() to compare string contents, not pointer addresses."}, {text: "    if (strcmp(command, \"quit\") == 0) return;", reason: "break exits the loop, while return would exit the function immediately."}], indent: 2, explanation: "Check for the 'quit' command to exit the loop." },
        { correct: "    else if (strcmp(command, \"look\") == 0) do_look();", distractors: [{text: "    else if (command == \"look\") do_look();", reason: "We need strcmp() for string comparison."}, {text: "    else if (strcasecmp(command, \"look\") == 0) do_look();", reason: "While strcasecmp does case-insensitive comparison, strcmp is simpler and more standard."}], indent: 2, explanation: "Handle the 'look' command." },
        { correct: "    else if (strcmp(command, \"north\") == 0) do_move(\"north\");", distractors: [{text: "    else if (strcmp(command, \"n\") == 0) do_move(\"north\");", reason: "Using the full word 'north' is clearer than abbreviations."}, {text: "    else if (strcmp(command, \"north\") == 0) do_move(command);", reason: "Passing the literal \"north\" is clearer than passing the variable."}], indent: 2, explanation: "Handle the 'north' command." },
        { correct: "    else if (strcmp(command, \"south\") == 0) do_move(\"south\");", distractors: [{text: "    else if (strcmp(command, \"south\") == 0) do_move(\"s\");", reason: "Passing \"south\" maintains consistency with the command parsing."}, {text: "    else if (command[0] == 's') do_move(\"south\");", reason: "Full string comparison is more precise than just checking the first character."}], indent: 2, explanation: "Handle the 'south' command." },
        { correct: "    else if (strcmp(command, \"take\") == 0) do_take(argument);", distractors: [{text: "    else if (strcmp(command, \"take\") == 0) do_take(command);", reason: "We want to pass the argument (object name), not the command itself."}, {text: "    else if (strcmp(command, \"get\") == 0) do_take(argument);", reason: "We defined the command as 'take' in our game design."}], indent: 2, explanation: "Handle the 'take' command." },
        { correct: "    else if (strcmp(command, \"inventory\") == 0) do_inventory();", distractors: [{text: "    else if (strcmp(command, \"inv\") == 0) do_inventory();", reason: "Using the full word 'inventory' is clearer."}, {text: "    else if (strcmp(command, \"inventory\") == 0) do_take(argument);", reason: "inventory should call do_inventory(), not do_take()."}], indent: 2, explanation: "Handle the 'inventory' command." },
        { correct: "    else printf(\"I don't understand that command.\\n\");", distractors: [{text: "    else printf(\"Error\\n\");", reason: "A friendly message is better than just 'Error'."}, {text: "    else continue;", reason: "Providing feedback to the player is better than silently ignoring unknown commands."}], indent: 2, explanation: "Handle unknown commands." },
        { correct: "  }", distractors: [{text: "  }\n  printf(\"Game ended\\n\");", reason: "The loop structure is complete with just the closing brace."}, {text: "  } while (1);", reason: "This is a while loop, not a do-while."}], indent: 1, explanation: "Close the `while` loop." },
        { correct: "}", distractors: [{text: "  printf(\"Goodbye!\\n\");\n}", reason: "The farewell message is printed in main(), not here."}, {text: "  return 0;\n}", reason: "This function returns void."}], indent: 0, explanation: "Close `game_loop`." },
        { correct: "void do_look() {", distractors: [{text: "void look_command() {", reason: "do_look follows the naming convention of the other command functions."}, {text: "char* do_look() {", reason: "This function prints directly rather than returning a string."}], indent: 0, explanation: "Implement the look command." },
        { correct: "  Room current_room = rooms[player_location_id];", distractors: [{text: "  Room* current_room = &rooms[player_location_id];", reason: "Copying the struct is simpler than using a pointer for this read-only operation."}, {text: "  Room current_room = rooms[0];", reason: "We want the room at the player's current location, not always room 0."}], indent: 1, explanation: "Get the current room's data." },
        { correct: "  printf(\"\\n%s\\n\", current_room.name);", distractors: [{text: "  printf(\"%s\\n\", current_room.name);", reason: "Adding \\n provides better visual separation."}, {text: "  printf(\"\\n%s\\n\", current_room.description);", reason: "We want to print the name first, then the description."}], indent: 1, explanation: "Print the room's name." },
        { correct: "  printf(\"%s\\n\", current_room.description);", distractors: [{text: "  printf(\"%s\", current_room.description);", reason: "Adding \\n ensures proper line formatting."}, {text: "  printf(\"%s\\n\", current_room.name);", reason: "We want the description here, not the name (which was already printed)."}], indent: 1, explanation: "Print the room's description." },
        { correct: "  printf(\"Objects here: \");", distractors: [{text: "  printf(\"\\nObjects here: \");", reason: "We don't need the extra newline before the objects list."}, {text: "  printf(\"Items: \");", reason: "Objects here is more descriptive."}], indent: 1, explanation: "Header for objects." },
        { correct: "  int objects_found = 0;", distractors: [{text: "  bool objects_found = false;", reason: "Using int as a flag is simpler than including stdbool.h for bool."}, {text: "  int objects_found = 1;", reason: "0 is the correct initial value for 'nothing found yet'."}], indent: 1, explanation: "A flag to see if any objects are in the room." },
        { correct: "  for(int i=0; i<object_count; i++) {", distractors: [{text: "  for(int i=1; i<=object_count; i++) {", reason: "Array indices are 0-based, so we start from 0 and use <."}, {text: "  for(int i=0; i<room_count; i++) {", reason: "We're iterating through objects, not rooms."}], indent: 1, explanation: "Loop through all objects to see which are in the current room." },
        { correct: "    if (objects[i].location_id == player_location_id) {", distractors: [{text: "    if (objects[i].location_id == current_room.id) {", reason: "While current_room.id would work, player_location_id is more direct."}, {text: "    if (objects[i].id == player_location_id) {", reason: "We want to check the object's location_id, not its id."}], indent: 2, explanation: "Check if the object's location matches the player's." },
        { correct: "      printf(\"%s \", objects[i].name);", distractors: [{text: "      printf(\"%s\\n\", objects[i].name);", reason: "Using a space allows multiple objects to be listed on one line."}, {text: "      printf(\"%s \", objects[i].description);", reason: "We want the object's name in the list, not its full description."}], indent: 3, explanation: "Print the name of the object." },
        { correct: "      objects_found = 1;", distractors: [{text: "      objects_found++;", reason: "We're using this as a boolean flag, so setting it to 1 is sufficient."}, {text: "      objects_found = objects[i].id;", reason: "We just need to set the flag to indicate we found something."}], indent: 3, explanation: "Set the flag." },
        { correct: "    }", distractors: [{text: "    } else { objects_found = 0; }", reason: "We don't want to reset the flag if one object doesn't match."}, {text: "    }\n    break;", reason: "We want to check all objects, not just the first one."}], indent: 2, explanation: "Close the if." },
        { correct: "  }", distractors: [{text: "  }\n  printf(\"\\n\");", reason: "We'll handle the final newline after the if statement below."}, {text: "  } while (objects_found == 0);", reason: "This is a for loop, not a do-while."}], indent: 1, explanation: "Close the loop." },
        { correct: "  if (!objects_found) { printf(\"nothing.\"); }", distractors: [{text: "  if (objects_found == 0) { printf(\"none.\"); }", reason: "While functionally equivalent, 'nothing' is more natural than 'none'."}, {text: "  if (!objects_found) { printf(\"\\nNo objects here.\"); }", reason: "Keeping it on the same line maintains the 'Objects here: nothing.' format."}], indent: 1, explanation: "If no objects were found, say so." },
        { correct: "  printf(\"\\n\");", distractors: [{text: "  printf(\"\\n\\n\");", reason: "One newline is sufficient for formatting."}, {text: "  // Newline printed above", reason: "We need this newline to complete the objects line."}], indent: 1, explanation: "Final newline." },
        { correct: "}", distractors: [{text: "  printf(\"\\n\");\n}", reason: "The printf statement is already included above."}, {text: "  return current_room;\n}", reason: "This function returns void."}], indent: 0, explanation: "Close `do_look`." },
        { correct: "void do_move(const char* direction) {", distractors: [{text: "void do_move(char* direction) {", reason: "const char* indicates we won't modify the direction string."}, {text: "int do_move(const char* direction) {", reason: "For this example, void is simpler than returning success codes."}], indent: 0, explanation: "Implement movement." },
        { correct: "  Room current_room = rooms[player_location_id];", distractors: [{text: "  Room* current_room = &rooms[player_location_id];", reason: "Copying the struct is simpler for this read-only access."}, {text: "  Room current_room = rooms[0];", reason: "We want the current room based on player_location_id, not always room 0."}], indent: 1, explanation: "Get the current room." },
        { correct: "  int next_room_id = -1;", distractors: [{text: "  int next_room_id = 0;", reason: "-1 is used to indicate 'no exit' in our room connection system."}, {text: "  Room* next_room = NULL;", reason: "Using an ID is simpler than maintaining room pointers."}], indent: 1, explanation: "Initialize the next room ID to -1 (no exit)." },
        { correct: "  if (strcmp(direction, \"north\") == 0) next_room_id = current_room.north;", distractors: [{text: "  if (direction == \"north\") next_room_id = current_room.north;", reason: "We need strcmp() to compare string contents."}, {text: "  if (strcmp(direction, \"north\") == 0) next_room_id = current_room.south;", reason: "For 'north' direction, we want the north connection."}], indent: 1, explanation: "Check for north direction." },
        { correct: "  if (strcmp(direction, \"south\") == 0) next_room_id = current_room.south;", distractors: [{text: "  else if (strcmp(direction, \"south\") == 0) next_room_id = current_room.south;", reason: "Using separate if statements allows for easier extension to more directions."}, {text: "  if (strcmp(direction, \"south\") == 0) next_room_id = current_room.north;", reason: "For 'south' direction, we want the south connection."}], indent: 1, explanation: "Check for south direction." },
        { correct: "  if (next_room_id != -1) {", distractors: [{text: "  if (next_room_id >= 0) {", reason: "While >= 0 would work, != -1 is more explicit about our 'no exit' convention."}, {text: "  if (next_room_id) {", reason: "Explicitly checking != -1 is clearer than relying on truthiness."}], indent: 1, explanation: "If an exit exists in that direction..." },
        { correct: "    player_location_id = next_room_id;", distractors: [{text: "    player_location_id++;", reason: "We want to set the location to the specific next room ID, not just increment."}, {text: "    current_room.id = next_room_id;", reason: "We update the player's location, not the room's ID."}], indent: 2, explanation: "Update the player's location." },
        { correct: "    do_look();", distractors: [{text: "    printf(\"You moved %s\\n\", direction);", reason: "Automatically showing the new room is more immersive than just confirming movement."}, {text: "    look_around();", reason: "We defined this function as do_look()."}], indent: 2, explanation: "Automatically look around the new room." },
        { correct: "  } else {", distractors: [{text: "  } else if (next_room_id == -1) {", reason: "The simple else is sufficient since we already checked != -1."}, {text: "  }\n  if (next_room_id == -1) {", reason: "Using else is more efficient than a separate if statement."}], indent: 1, explanation: "If there's no exit..." },
        { correct: "    printf(\"You can't go that way.\\n\");", distractors: [{text: "    printf(\"Invalid direction\\n\");", reason: "A more natural message is friendlier to players."}, {text: "    printf(\"No exit in that direction.\\n\");", reason: "While accurate, the current message is more conversational."}], indent: 2, explanation: "Print an error message." },
        { correct: "  }", distractors: [{text: "  }\n  return next_room_id;", reason: "This function returns void, not an int."}, {text: "  }\n}", reason: "We need the closing brace for the else block."}], indent: 1, explanation: "Close the if/else." },
        { correct: "}", distractors: [{text: "  }\n}", reason: "The closing brace for the else is already included above."}, {text: "  return 0;\n}", reason: "This function returns void."}], indent: 0, explanation: "Close `do_move`." }
    ]
},
    // Level 80: architecture of an Entity Component System
{
    "goal": "Implement the basic architecture of an Entity Component System (ECS) to manage game entities.",
    "concepts": "Data-oriented design, structs, arrays, enums, bitmasks, game loops",
    "sequence": [
        { correct: "// === Stage 1: Setup and Core ECS Definitions ===", distractors: [{text: "// === Stage 1: Entity Component System Implementation ===", reason: "This section focuses on setup and definitions, not the full implementation."}, {text: "// === Stage 1: Game Entity Management ===", reason: "More specific to mention 'Setup and Core ECS Definitions'."}], indent: 0, explanation: "Define the constants, data structures (components), and entity management system." },
        { correct: "#include <stdio.h>", distractors: [{text: "#include <iostream>", reason: "This is C, not C++. We need stdio.h for printf and other I/O functions."}, {text: "#include <cstdio>", reason: "This is the C++ version. In C, we use stdio.h."}], indent: 0, explanation: "Standard I/O." },
        { correct: "#include <string.h>", distractors: [{text: "#include <strings.h>", reason: "string.h is the standard header for string functions like memset."}, {text: "#include <cstring>", reason: "This is the C++ version. In C, we use string.h."}], indent: 0, explanation: "For `memset`." },
        { correct: "#define MAX_ENTITIES 100", distractors: [{text: "#define MAX_ENTITIES 1", reason: "1 entity would be extremely limiting for any practical game."}, {text: "#define MAX_ENTITIES 1000000", reason: "While more entities can be useful, 100 is reasonable for a demonstration without excessive memory usage."}], indent: 0, explanation: "The maximum number of entities our simple game can have." },
        { correct: "// --- Components: Plain Old Data Structs ---", distractors: [{text: "// --- Components: Object-Oriented Classes ---", reason: "In ECS, components are data-only structs, not classes with methods."}, {text: "// --- Game Objects ---", reason: "These are components (data), not complete game objects. In ECS, entities are composed of components."}], indent: 0, explanation: "Components hold data, and nothing else. They have no logic." },
        { correct: "typedef struct { int x, y; } Position;", distractors: [{text: "typedef struct { float x, y; } Position;", reason: "While float would work, int is simpler for this demo and avoids precision issues."}, {text: "typedef struct { int x, y, z; } Position;", reason: "For a 2D game demo, x and y coordinates are sufficient."}], indent: 0, explanation: "A component to store an entity's position." },
        { correct: "typedef struct { int dx, dy; } Velocity;", distractors: [{text: "typedef struct { int speed; } Velocity;", reason: "Velocity should include direction (dx, dy), not just speed magnitude."}, {text: "typedef struct { float dx, dy; } Velocity;", reason: "Int is simpler for this demo, though float would work too."}], indent: 0, explanation: "A component to store an entity's velocity." },
        { correct: "typedef struct { int hp; int max_hp; } Health;", distractors: [{text: "typedef struct { int hp; } Health;", reason: "Including max_hp allows for healing mechanics and percentage calculations."}, {text: "typedef struct { float health_percentage; } Health;", reason: "Storing actual hp and max_hp values is more flexible than just a percentage."}], indent: 0, explanation: "A component to store an entity's health points." },
        { correct: "// --- Component Masks using Bitwise Flags ---", distractors: [{text: "// --- Component Lists ---", reason: "We're using bitmasks for efficient component checking, not lists."}, {text: "// --- Component IDs ---", reason: "These are bitmasks (flags), not simple IDs."}], indent: 0, explanation: "We use bitmasks to track which components an entity has." },
        { correct: "typedef enum {", distractors: [{text: "enum ComponentMask {", reason: "Using typedef enum allows us to use ComponentMask as a type name."}, {text: "typedef struct {", reason: "We want an enum for named constants, not a struct."}], indent: 0, explanation: "Use an enum for readable flag names." },
        { correct: "  COMPONENT_NONE     = 0,", distractors: [{text: "  COMPONENT_NONE     = 1,", reason: "0 represents no components, which is the natural empty state."}, {text: "  COMPONENT_NONE     = -1,", reason: "0 is the standard representation for 'no flags set'."}], indent: 1, explanation: "Represents an entity with no components." },
        { correct: "  COMPONENT_POSITION = 1 << 0, // 1", distractors: [{text: "  COMPONENT_POSITION = 1, // 1", reason: "Using bit shifting (1 << 0) makes the pattern clear and consistent with other flags."}, {text: "  COMPONENT_POSITION = 0, // 0", reason: "Position component should have its own unique bit flag, not 0."}], indent: 1, explanation: "The bit for the Position component." },
        { correct: "  COMPONENT_VELOCITY = 1 << 1, // 2", distractors: [{text: "  COMPONENT_VELOCITY = 2, // 2", reason: "While the result is the same, using bit shifting shows the intentional pattern."}, {text: "  COMPONENT_VELOCITY = 1 << 0, // 1", reason: "Each component needs its own unique bit. Velocity should be bit 1, not bit 0."}], indent: 1, explanation: "The bit for the Velocity component." },
        { correct: "  COMPONENT_HEALTH   = 1 << 2  // 4", distractors: [{text: "  COMPONENT_HEALTH   = 4  // 4", reason: "Using bit shifting maintains the pattern and makes it clear this is bit 2."}, {text: "  COMPONENT_HEALTH   = 1 << 1  // 2", reason: "Health should be bit 2 (value 4), not bit 1 (value 2)."}], indent: 1, explanation: "The bit for the Health component." },
        { correct: "} ComponentMask;", distractors: [{text: "};", reason: "We're using typedef enum, so we need to provide the type name ComponentMask."}, {text: "} ComponentFlags;", reason: "We're calling this type ComponentMask to match our comment."}], indent: 0, explanation: "Close the enum definition." },
        { correct: "// --- The World: A struct to hold all our component arrays ---", distractors: [{text: "// --- The Game: A struct to hold game state ---", reason: "In ECS terminology, the 'World' specifically refers to the container for all component data."}, {text: "// --- The Scene: A struct for scene data ---", reason: "'World' is the conventional ECS term for the main data container."}], indent: 0, explanation: "The 'World' is the main container for all ECS data." },
        { correct: "typedef struct {", distractors: [{text: "struct World {", reason: "Using typedef struct is consistent with our other type definitions."}, {text: "typedef class {", reason: "C doesn't have classes. We use struct."}], indent: 0, explanation: "Begin the World definition." },
        { correct: "  int masks[MAX_ENTITIES]; // masks[i] stores the component mask for entity i", distractors: [{text: "  ComponentMask masks[MAX_ENTITIES]; // masks[i] stores the component mask for entity i", reason: "While ComponentMask would work, int is more explicit about the underlying storage."}, {text: "  bool masks[MAX_ENTITIES]; // masks[i] stores whether entity i exists", reason: "We need bitmasks to track which components each entity has, not just existence."}], indent: 1, explanation: "An array to track which components each entity has." },
        { correct: "  Position positions[MAX_ENTITIES];", distractors: [{text: "  Position* positions[MAX_ENTITIES];", reason: "We want an array of Position structs, not an array of pointers to Position."}, {text: "  int positions[MAX_ENTITIES];", reason: "We need Position structs, not simple integers."}], indent: 1, explanation: "A tightly packed array of all Position components." },
        { correct: "  Velocity velocities[MAX_ENTITIES];", distractors: [{text: "  Velocity* velocities;", reason: "We want a fixed-size array matching MAX_ENTITIES, not a dynamic array."}, {text: "  int velocities[MAX_ENTITIES];", reason: "We need Velocity structs with dx and dy, not simple integers."}], indent: 1, explanation: "A tightly packed array of all Velocity components." },
        { correct: "  Health healths[MAX_ENTITIES];", distractors: [{text: "  Health* healths[MAX_ENTITIES];", reason: "We want an array of Health structs, not pointers."}, {text: "  int health[MAX_ENTITIES];", reason: "We need Health structs with hp and max_hp, not simple integers."}], indent: 1, explanation: "A tightly packed array of all Health components." },
        { correct: "} World;", distractors: [{text: "};", reason: "We need to provide the typedef name World."}, {text: "} GameWorld;", reason: "We're calling this type World for simplicity."}], indent: 0, explanation: "Close the World definition." },
        { correct: "// --- Stage 2: Entity and System Implementations ---", distractors: [{text: "// --- Stage 2: Game Logic Implementation ---", reason: "More specific to mention 'Entity and System Implementations' for ECS context."}, {text: "// --- Stage 2: Function Definitions ---", reason: "This section specifically implements ECS entities and systems."}], indent: 0, explanation: "Create functions to manage entities and the systems that operate on them." },
        { correct: "World world; // A global world object for simplicity.", distractors: [{text: "World* world; // A global world pointer.", reason: "Using a global struct is simpler than managing a pointer for this demo."}, {text: "static World world; // A static world object.", reason: "Global scope is fine for this demo. Static would limit it to this file."}], indent: 0, explanation: "Instantiate our game world." },
        { correct: "int next_entity_id = 0;", distractors: [{text: "int next_entity_id = 1;", reason: "Starting from 0 is conventional for array indices in C."}, {text: "static int entity_count = 0;", reason: "next_entity_id clearly indicates this is for generating new IDs."}], indent: 0, explanation: "A simple counter to create new, unique entity IDs." },
        { correct: "void world_init() {", distractors: [{text: "void init_world() {", reason: "world_init follows a consistent naming convention with the world prefix."}, {text: "World* world_init() {", reason: "This function initializes the global world, it doesn't create and return a new one."}], indent: 0, explanation: "A function to initialize the world state." },
        { correct: "  memset(&world, 0, sizeof(World));", distractors: [{text: "  world = {0};", reason: "memset is more explicit and works reliably for zeroing the entire structure."}, {text: "  world.masks[0] = 0;", reason: "We need to zero the entire world structure, not just one element."}], indent: 1, explanation: "Use `memset` to zero out all component arrays and masks." },
        { correct: "}", distractors: [{text: "  next_entity_id = 0;\n}", reason: "next_entity_id is already initialized to 0 globally."}, {text: "  return &world;\n}", reason: "This function returns void and operates on the global world."}], indent: 0, explanation: "Close `world_init`." },
        { correct: "int create_entity() {", distractors: [{text: "Entity create_entity() {", reason: "We're using simple integer IDs for entities, not a separate Entity type."}, {text: "void create_entity() {", reason: "We need to return the entity ID so the caller can use it."}], indent: 0, explanation: "A function to create a new, empty entity." },
        { correct: "  if (next_entity_id >= MAX_ENTITIES) return -1; // Error, out of entities", distractors: [{text: "  if (next_entity_id > MAX_ENTITIES) return -1; // Error, out of entities", reason: "Since arrays are 0-indexed, we check >= MAX_ENTITIES, not > MAX_ENTITIES."}, {text: "  if (next_entity_id >= MAX_ENTITIES) exit(1); // Error, out of entities", reason: "Returning an error code is better than exiting the program."}], indent: 1, explanation: "Check if we've exceeded our maximum entity count." },
        { correct: "  world.masks[next_entity_id] = COMPONENT_NONE;", distractors: [{text: "  world.masks[next_entity_id] = 0;", reason: "Using COMPONENT_NONE is more explicit than the magic number 0."}, {text: "  world.masks[next_entity_id] = COMPONENT_POSITION;", reason: "New entities start with no components, not with a Position component."}], indent: 1, explanation: "Initialize the mask for the new entity to NONE." },
        { correct: "  return next_entity_id++;", distractors: [{text: "  next_entity_id++; return next_entity_id;", reason: "The post-increment returns the current value then increments, which is what we want."}, {text: "  return ++next_entity_id;", reason: "Pre-increment would return the incremented value, but we want the current value as the entity ID."}], indent: 1, explanation: "Return the new ID and then increment the global counter for the next one." },
        { correct: "}", distractors: [{text: "  return next_entity_id++;\n}", reason: "The return statement is already included above."}, {text: "  return 0;\n}", reason: "We want to return the actual entity ID, not 0."}], indent: 0, explanation: "Close `create_entity`." },
        { correct: "// --- System Functions ---", distractors: [{text: "// --- Game Logic Functions ---", reason: "In ECS terminology, these are specifically called 'systems'."}, {text: "// --- Component Functions ---", reason: "These are systems that operate on components, not component functions themselves."}], indent: 0, explanation: "Systems are functions that iterate over entities with specific components." },
        { correct: "void movement_system() {", distractors: [{text: "void update_movement() {", reason: "movement_system follows ECS naming conventions where systems are named with '_system' suffix."}, {text: "void move_entities() {", reason: "While descriptive, movement_system is more consistent with ECS terminology."}], indent: 0, explanation: "This system updates the position of any entity that can move." },
        { correct: "  printf(\"-> Running Movement System...\\n\");", distractors: [{text: "  printf(\"Updating positions...\\n\");", reason: "Mentioning 'Movement System' reinforces the ECS concept."}, {text: "  // printf(\"-> Running Movement System...\\n\");", reason: "The trace message helps understand the system execution order."}], indent: 1, explanation: "Trace message." },
        { correct: "  // Define the mask for entities this system cares about.", distractors: [{text: "  // Loop through all entities.", reason: "This comment is about defining the component requirements, not the loop."}, {text: "  // Update entity positions.", reason: "The comment explains the mask definition that comes next."}], indent: 1, explanation: "Comment on the system's component requirements." },
        { correct: "  const int required_mask = COMPONENT_POSITION | COMPONENT_VELOCITY;", distractors: [{text: "  const int required_mask = COMPONENT_POSITION & COMPONENT_VELOCITY;", reason: "We use bitwise OR (|) to combine flags, not AND (&)."}, {text: "  const int required_mask = COMPONENT_POSITION + COMPONENT_VELOCITY;", reason: "Bitwise OR (|) is the correct operation for combining bit flags, not addition."}], indent: 1, explanation: "This system needs entities with BOTH a Position and a Velocity." },
        { correct: "  for (int i = 0; i < next_entity_id; i++) {", distractors: [{text: "  for (int i = 0; i < MAX_ENTITIES; i++) {", reason: "We only need to check up to next_entity_id since that's how many entities we've created."}, {text: "  for (int i = 1; i <= next_entity_id; i++) {", reason: "Entity IDs start from 0, not 1."}], indent: 1, explanation: "Iterate through all created entities." },
        { correct: "    if ((world.masks[i] & required_mask) == required_mask) {", distractors: [{text: "    if (world.masks[i] == required_mask) {", reason: "Using & checks if the entity has AT LEAST the required components. == would require EXACTLY those components and no others."}, {text: "    if ((world.masks[i] | required_mask) == required_mask) {", reason: "We use & to check if flags are set, not |."}], indent: 2, explanation: "Use a bitwise AND to check if the entity has all the required components." },
        { correct: "      // This entity is affected by the movement system.", distractors: [{text: "      // This entity has a position component.", reason: "More comprehensive to mention this entity is affected by the movement system."}, {text: "      // Move this entity.", reason: "The comment explains why we're processing this entity."}], indent: 3, explanation: "Comment on the system's logic." },
        { correct: "      world.positions[i].x += world.velocities[i].dx;", distractors: [{text: "      world.positions[i].x = world.velocities[i].dx;", reason: "We want to add the velocity to the position, not replace the position."}, {text: "      world.positions[i].dx += world.velocities[i].x;", reason: "Positions have x,y while velocities have dx,dy. We add dx to x."}], indent: 3, explanation: "Update the x position using the x velocity." },
        { correct: "      world.positions[i].y += world.velocities[i].dy;", distractors: [{text: "      world.positions[i].y = world.velocities[i].dy;", reason: "We want to add the velocity to position, not replace it."}, {text: "      world.positions[i].x += world.velocities[i].dy;", reason: "dy (delta y) should be added to the y position, not x."}], indent: 3, explanation: "Update the y position using the y velocity." },
        { correct: "    }", distractors: [{text: "    } else { continue; }", reason: "The else and continue are unnecessary since the loop naturally continues."}, {text: "    }\n    break;", reason: "We want to process all entities, not just the first one."}], indent: 2, explanation: "Close the mask check." },
        { correct: "  }", distractors: [{text: "  }\n  printf(\"Movement complete\\n\");", reason: "The loop structure is complete with just the closing brace."}, {text: "  } while (i < next_entity_id);", reason: "This is a for loop, not a do-while."}], indent: 1, explanation: "Close the entity loop." },
        { correct: "}", distractors: [{text: "  }\n}", reason: "The entity loop closing brace is already included above."}, {text: "  return 0;\n}", reason: "This function returns void."}], indent: 0, explanation: "Close the movement system." },
        { correct: "void health_system() {", distractors: [{text: "void update_health() {", reason: "health_system follows ECS naming conventions."}, {text: "void check_health() {", reason: "While descriptive, health_system is more consistent with ECS terminology."}], indent: 0, explanation: "A system to report the health of entities that have it." },
        { correct: "  printf(\"-> Running Health System...\\n\");", distractors: [{text: "  printf(\"Checking health...\\n\");", reason: "Mentioning 'Health System' reinforces the ECS concept."}, {text: "  // Health system trace", reason: "A printf statement is more informative than just a comment."}], indent: 1, explanation: "Trace message." },
        { correct: "  for (int i = 0; i < next_entity_id; i++) {", distractors: [{text: "  for (int i = 0; i < MAX_ENTITIES; i++) {", reason: "We only need to check created entities up to next_entity_id."}, {text: "  for (int i = 1; i < next_entity_id; i++) {", reason: "Entity IDs start from 0."}], indent: 1, explanation: "Iterate through all entities." },
        { correct: "    if ((world.masks[i] & COMPONENT_HEALTH) != 0) {", distractors: [{text: "    if ((world.masks[i] & COMPONENT_HEALTH) == COMPONENT_HEALTH) {", reason: "While this would work, != 0 is a more general pattern for checking if any flag is set."}, {text: "    if (world.masks[i] == COMPONENT_HEALTH) {", reason: "== would require the entity to have ONLY health component. & checks if it has health among others."}], indent: 2, explanation: "Check if the entity has a Health component." },
        { correct: "      printf(\"  - Entity %d has %d/%d HP.\\n\", i, world.healths[i].hp, world.healths[i].max_hp);", distractors: [{text: "      printf(\"Entity %d has health.\\n\", i);", reason: "Showing the actual HP values is more informative than just saying 'has health'."}, {text: "      printf(\"  - Entity %d has %d HP.\\n\", i, world.healths[i].hp);", reason: "Including max_hp shows the full health status (e.g., 75/100 HP)."}], indent: 3, explanation: "Print the entity's health status." },
        { correct: "    }", distractors: [{text: "    } else { printf(\"  - Entity %d has no health.\\n\", i); }", reason: "For this demo, we only report on entities that DO have health."}, {text: "    }\n    break;", reason: "We want to check all entities, not just the first one."}], indent: 2, explanation: "Close the mask check." },
        { correct: "  }", distractors: [{text: "  }\n  printf(\"Health check complete\\n\");", reason: "The loop structure is complete."}, {text: "  } while (i < next_entity_id);", reason: "This is a for loop, not a do-while."}], indent: 1, explanation: "Close the entity loop." },
        { correct: "}", distractors: [{text: "  }\n}", reason: "The entity loop closing brace is already included above."}, {text: "  return;\n}", reason: "Explicit return is unnecessary for void functions."}], indent: 0, explanation: "Close the health system." },
        { correct: "// --- Stage 3: Main Program to Demonstrate the ECS ---", distractors: [{text: "// --- Stage 3: Game Demo ---", reason: "More specific to mention 'Main Program to Demonstrate the ECS'."}, {text: "// --- Stage 3: Test Program ---", reason: "This is a demonstration of the ECS architecture, not just a test."}], indent: 0, explanation: "Set up entities and run the systems." },
        { correct: "int main() {", distractors: [{text: "void main() {", reason: "Standard C requires main to return int."}, {text: "int main(void) {", reason: "While main(void) is valid, main() is equally correct and more common."}], indent: 0, explanation: "Start main." },
        { correct: "  world_init();", distractors: [{text: "  init_world();", reason: "We defined this function as world_init()."}, {text: "  memset(&world, 0, sizeof(World));", reason: "We have a dedicated initialization function that's more descriptive."}], indent: 1, explanation: "Initialize the game world." },
        { correct: "  printf(\"--- Creating Entities ---\\n\");", distractors: [{text: "  printf(\"Creating entities...\\n\");", reason: "The formatting with --- makes it clearer as a section header."}, {text: "  printf(\"Starting ECS demo\\n\");", reason: "Being specific about 'Creating Entities' shows what phase we're in."}], indent: 1, explanation: "Header for entity creation." },
        { correct: "  // Create a 'Player' entity that can move and has health.", distractors: [{text: "  // Create the first entity.", reason: "More descriptive to explain this represents a player."}, {text: "  // Create an entity with all components.", reason: "Being specific about what the entity represents is more informative."}], indent: 1, explanation: "Comment on the player entity." },
        { correct: "  int player = create_entity();", distractors: [{text: "  Entity player = create_entity();", reason: "We're using int for entity IDs, not a separate Entity type."}, {text: "  int player = 0;", reason: "We should use the create_entity() function to properly allocate entity IDs."}], indent: 1, explanation: "Create the first entity, with ID 0." },
        { correct: "  world.masks[player] = COMPONENT_POSITION | COMPONENT_VELOCITY | COMPONENT_HEALTH;", distractors: [{text: "  world.masks[player] = COMPONENT_POSITION + COMPONENT_VELOCITY + COMPONENT_HEALTH;", reason: "Use bitwise OR (|) to combine flags, not addition."}, {text: "  world.masks[player] = COMPONENT_POSITION & COMPONENT_VELOCITY & COMPONENT_HEALTH;", reason: "Use bitwise OR (|) to combine flags, not AND (&)."}], indent: 1, explanation: "Assign multiple components to the player using bitwise OR." },
        { correct: "  world.positions[player] = (Position){ .x = 10, .y = 20 };", distractors: [{text: "  world.positions[player].x = 10; world.positions[player].y = 20;", reason: "While this would work, the compound literal syntax is more concise."}, {text: "  world.positions[player] = {10, 20};", reason: "The designated initializer syntax with .x and .y is more explicit."}], indent: 1, explanation: "Set the player's initial position component data." },
        { correct: "  world.velocities[player] = (Velocity){ .dx = 1, .dy = -1 };", distractors: [{text: "  world.velocities[player] = (Velocity){ .x = 1, .y = -1 };", reason: "Velocity fields are dx and dy, not x and y."}, {text: "  world.velocities[player] = (Velocity){ 1, -1 };", reason: "Using designated initializers (.dx, .dy) is more explicit."}], indent: 1, explanation: "Set the player's velocity component data." },
        { correct: "  world.healths[player] = (Health){ .hp = 100, .max_hp = 100 };", distractors: [{text: "  world.healths[player] = (Health){ .hp = 100 };", reason: "We should set both hp and max_hp for complete initialization."}, {text: "  world.healths[player] = (Health){ 100, 100 };", reason: "Using designated initializers is more explicit about which field is which."}], indent: 1, explanation: "Set the player's health component data." },
        { correct: "  // Create a 'Boulder' entity that can only move.", distractors: [{text: "  // Create the second entity.", reason: "More descriptive to explain this represents a boulder."}, {text: "  // Create an entity without health.", reason: "Being specific about what the entity represents is clearer."}], indent: 1, explanation: "Comment on the boulder entity." },
        { correct: "  int boulder = create_entity();", distractors: [{text: "  int boulder = 1;", reason: "We should use create_entity() to properly allocate IDs."}, {text: "  Entity boulder = create_entity();", reason: "We're using int for entity IDs."}], indent: 1, explanation: "Create the second entity, with ID 1." },
        { correct: "  world.masks[boulder] = COMPONENT_POSITION | COMPONENT_VELOCITY;", distractors: [{text: "  world.masks[boulder] = COMPONENT_POSITION + COMPONENT_VELOCITY;", reason: "Use bitwise OR (|) to combine component flags."}, {text: "  world.masks[boulder] = COMPONENT_POSITION;", reason: "The boulder needs both position and velocity to move."}], indent: 1, explanation: "Assign Position and Velocity components." },
        { correct: "  world.positions[boulder] = (Position){ .x = 50, .y = 50 };", distractors: [{text: "  world.positions[boulder] = (Position){ .x = 10, .y = 20 };", reason: "Different entities should have different starting positions."}, {text: "  world.positions[boulder] = world.positions[player];", reason: "Each entity should have its own unique position."}], indent: 1, explanation: "Set the boulder's position." },
        { correct: "  world.velocities[boulder] = (Velocity){ .dx = -2, .dy = 0 };", distractors: [{text: "  world.velocities[boulder] = (Velocity){ .dx = 1, .dy = -1 };", reason: "Different entities should have different velocities to show the system working."}, {text: "  world.velocities[boulder] = world.velocities[player];", reason: "Each entity should have its own unique velocity."}], indent: 1, explanation: "Set the boulder's velocity." },
        { correct: "  // Create a 'Tree' entity that only has a position.", distractors: [{text: "  // Create a static entity.", reason: "More descriptive to explain this represents a tree."}, {text: "  // Create the third entity.", reason: "Being specific about what the entity represents is clearer."}], indent: 1, explanation: "Comment on the tree entity." },
        { correct: "  int tree = create_entity();", distractors: [{text: "  int tree = 2;", reason: "We should use create_entity() for proper ID allocation."}, {text: "  Entity tree = create_entity();", reason: "We're using int for entity IDs."}], indent: 1, explanation: "Create the third entity, with ID 2." },
        { correct: "  world.masks[tree] = COMPONENT_POSITION;", distractors: [{text: "  world.masks[tree] = COMPONENT_NONE;", reason: "The tree should have a position component so it exists in the world."}, {text: "  world.masks[tree] = COMPONENT_POSITION | COMPONENT_VELOCITY;", reason: "Trees don't move, so they don't need velocity."}], indent: 1, explanation: "Assign only the Position component." },
        { correct: "  world.positions[tree] = (Position){ .x = 80, .y = 10 };", distractors: [{text: "  world.positions[tree] = (Position){ .x = 50, .y = 50 };", reason: "Each entity should have a unique position."}, {text: "  // Trees don't need positions", reason: "Even static objects need positions to exist in the world."}], indent: 1, explanation: "Set the tree's position." },
        { correct: "  printf(\"Entities created.\\n\");", distractors: [{text: "  printf(\"Setup complete.\\n\");", reason: "Being specific about 'Entities created' is more informative."}, {text: "  // Entities created", reason: "A printf statement provides better feedback than just a comment."}], indent: 1, explanation: "Confirmation message." },
        { correct: "  // --- Main Game Loop Simulation ---", distractors: [{text: "  // --- System Execution ---", reason: "Calling it 'Main Game Loop Simulation' shows this represents how a real game would work."}, {text: "  // --- Testing Phase ---", reason: "This simulates an actual game loop, not just testing."}], indent: 1, explanation: "Simulate a few ticks of the game loop." },
        { correct: "  for (int frame = 1; frame <= 3; frame++) {", distractors: [{text: "  for (int frame = 0; frame < 3; frame++) {", reason: "Starting from 1 makes the output more natural ('Frame 1', 'Frame 2', etc.)."}, {text: "  for (int i = 1; i <= 3; i++) {", reason: "'frame' is more descriptive than 'i' for this loop variable."}], indent: 1, explanation: "Loop for 3 frames." },
        { correct: "    printf(\"\\n--- Game Frame %d ---\\n\", frame);", distractors: [{text: "    printf(\"Frame %d\\n\", frame);", reason: "The formatting with --- makes it clearer as a section header."}, {text: "    printf(\"\\n--- Update %d ---\\n\", frame);", reason: "'Game Frame' is more specific to game development terminology."}], indent: 2, explanation: "Print the current frame number." },
        { correct: "    // In a real game, you would also handle input and rendering here.", distractors: [{text: "    // This is the complete game loop.", reason: "The comment explains that real games have additional phases."}, {text: "    // Systems execute here.", reason: "More informative to mention what else happens in real game loops."}], indent: 2, explanation: "Comment on other game loop parts." },
        { correct: "    movement_system();", distractors: [{text: "    update_movement();", reason: "We defined this function as movement_system()."}, {text: "    move_entities();", reason: "We're using ECS terminology with movement_system()."}], indent: 2, explanation: "Run the movement system to update all positions." },
        { correct: "    health_system();", distractors: [{text: "    check_health();", reason: "We defined this function as health_system()."}, {text: "    update_health();", reason: "We're using ECS terminology with health_system()."}], indent: 2, explanation: "Run the health system to report on health." },
        { correct: "    // Print the state of entities that moved", distractors: [{text: "    // Show results", reason: "More specific to mention 'entities that moved'."}, {text: "    // Display output", reason: "The current comment better describes what we're about to show."}], indent: 2, explanation: "Comment on state reporting." },
        { correct: "    printf(\"Updated Positions:\\n\");", distractors: [{text: "    printf(\"Positions:\\n\");", reason: "'Updated Positions' emphasizes that movement has occurred."}, {text: "    printf(\"Entity positions:\\n\");", reason: "While accurate, 'Updated Positions' shows the result of the movement system."}], indent: 2, explanation: "Header." },
        { correct: "    printf(\"  - Player at (%d, %d)\\n\", world.positions[player].x, world.positions[player].y);", distractors: [{text: "    printf(\"  - Entity %d at (%d, %d)\\n\", player, world.positions[player].x, world.positions[player].y);", reason: "Using 'Player' is more descriptive than just the entity ID."}, {text: "    printf(\"  - Player position: %d, %d\\n\", world.positions[player].x, world.positions[player].y);", reason: "The (x, y) format is more conventional for coordinates."}], indent: 2, explanation: "Print player's new position." },
        { correct: "    printf(\"  - Boulder at (%d, %d)\\n\", world.positions[boulder].x, world.positions[boulder].y);", distractors: [{text: "    printf(\"  - Entity %d at (%d, %d)\\n\", boulder, world.positions[boulder].x, world.positions[boulder].y);", reason: "Using 'Boulder' is more descriptive than the entity ID."}, {text: "    printf(\"  - Boulder: x=%d, y=%d\\n\", world.positions[boulder].x, world.positions[boulder].y);", reason: "The (x, y) format is more conventional."}], indent: 2, explanation: "Print boulder's new position." },
        { correct: "  }", distractors: [{text: "  }\n  printf(\"Simulation complete\\n\");", reason: "The loop structure is complete."}, {text: "  } while (frame <= 3);", reason: "This is a for loop, not a do-while."}], indent: 1, explanation: "Close the game loop." },
        { correct: "  printf(\"\\nGame simulation finished.\\n\");", distractors: [{text: "  printf(\"Demo complete.\\n\");", reason: "Adding \\n provides better formatting, and 'Game simulation finished' is more descriptive."}, {text: "  printf(\"\\nECS demo finished.\\n\");", reason: "While accurate, 'Game simulation finished' relates to the game loop concept."}], indent: 1, explanation: "Final message." },
        { correct: "  return 0;", distractors: [{text: "  return 1;", reason: "Return 0 to indicate successful program execution."}, {text: "  exit(0);", reason: "return 0 is more conventional than exit(0) in main()."}], indent: 1, explanation: "Indicate success." },
        { correct: "}", distractors: [{text: "  return 0;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close main." }
    ]
},
    // Level 81: Build an asset manager
    {
        "goal": "Build an asset manager to load game resources by name, using a hash table to prevent duplicate loads.",
        concepts: "Hash tables, resource management, file I/O, `strdup`, data-driven design",
        sequence: [
    { "correct": "// === Stage 1: Setup and Data Structures ===", distractors: [{"text":"// === Stage 1: The Main Program ===", reason:"Good design practice is to define the data structures and the API (in a header) before writing the main program that uses them."}], indent: 0, explanation: "Define includes and the structures for our assets and asset manager." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"The I/O function `printf` is part of the Standard I/O library, `<stdio.h>`."}], indent: 0, explanation: "Standard I/O." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <memory.h>", reason:"Standard memory management functions like `malloc` and `free` are prototyped in `<stdlib.h>`."}], indent: 0, explanation: "Memory management." },
    { "correct": "#include <string.h>", distractors: [{"text":"#include <strings.h>", reason:"The standard C header for string functions like `strcmp` and `strdup` is `<string.h>`."}], indent: 0, explanation: "String manipulation." },
    { "correct": "#define HASH_TABLE_SIZE 256", distractors: [{"text":"const int HASH_TABLE_SIZE = 256;", reason:"Using a `const int` is also a valid way to create a constant. A `#define` is a preprocessor macro that replaces text before compilation and is often used for array sizes."}], indent: 0, explanation: "The number of buckets in our asset hash table." },
    { "correct": "// A generic Asset struct. In a real engine, this might be a union or have a type enum.", distractors: [{"text":"// A struct just for textures.", reason:"This comment is too specific. The design of this struct is intentionally generic to handle any type of asset, not just textures."}], indent: 0, explanation: "Comment on the base Asset struct." },
    { "correct": "typedef struct Asset {", distractors: [{"text":"struct Asset {", reason:"Without `typedef`, we would have to write `struct Asset* next;` within the struct, which is more verbose."}], indent: 0, explanation: "Begin Asset definition. All assets share these properties." },
    { "correct": "  char* name;", distractors: [{"text":"  char name[64];", reason:"A fixed-size array is simpler but less flexible. Using `char*` with dynamic allocation allows asset names of any length."}], indent: 1, explanation: "The name of the asset (e.g., \"player_sprite.png\"), used as the key." },
    { "correct": "  void* data; // Pointer to the actual asset data (e.g., a Texture or Model struct).", distractors: [{"text":"  Texture* data;", reason:"This would lock our `Asset` struct into only holding `Texture` data. Using `void*` makes it generic, allowing it to point to any type of data."}], indent: 1, explanation: "A void pointer to hold any kind of asset data." },
    { "correct": "  struct Asset* next;", distractors: [{"text":"  Asset next;", reason:"A struct cannot contain a full instance of itself, as this would require infinite memory. It must be a pointer to its own type to form a linked list."}], indent: 1, explanation: "Pointer for the hash table's collision-handling linked list." },
    { "correct": "} Asset;", distractors: [{"text":"};", reason:"When using `typedef` with a struct definition, the new type alias (`Asset`) must be provided before the final semicolon."}], indent: 0, explanation: "Close the Asset typedef." },
    { "correct": "// A simple struct for a Texture asset.", distractors: [{"text":"// A generic struct for all assets.", reason:"This is incorrect. This struct is specific to texture data, while the `Asset` struct is the generic container."}], indent: 0, explanation: "Example of a specific asset type." },
    { "correct": "typedef struct { int width, height, channels; } Texture;", distractors: [{"text":"typedef struct { int width; int height; int channels; } Texture;", reason:"In a struct definition, you can declare multiple members of the same type on one line, separated by commas."}], indent: 0, explanation: "Represents a loaded texture's metadata." },
    { "correct": "// The AssetManager, which is a hash table.", distractors: [{"text":"// The AssetManager, which is a linked list.", reason:"This is an oversimplification. The manager is a hash table (an array) where each element is the head of a linked list."}], indent: 0, explanation: "Comment on the main manager struct." },
    { "correct": "typedef struct {", distractors: [{"text":"struct AssetManager {", reason:"Using `typedef` allows us to declare manager variables as `AssetManager am;` instead of `struct AssetManager am;`."}], indent: 0, explanation: "Begin AssetManager definition." },
    { "correct": "  Asset* buckets[HASH_TABLE_SIZE];", distractors: [{"text":"  Asset buckets[HASH_TABLE_SIZE];", reason:"This is a critical error. This creates an array of full `Asset` structs, not pointers. This would prevent us from creating linked lists to handle hash collisions."}], indent: 1, explanation: "An array of pointers to Assets, forming the hash table." },
    { "correct": "} AssetManager;", distractors: [{"text":"} AssetManager", reason:"A `typedef` statement must end with a semicolon."}], indent: 0, explanation: "Close the AssetManager typedef." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text":"// --- Function Implementations ---", reason:"This is the public API declaration (prototypes), not the private implementation."}], indent: 0, explanation: "Declare the public API of our asset manager." },
    { "correct": "AssetManager* asset_manager_create();", distractors: [{"text":"void asset_manager_create();", reason:"This function must return a pointer to the newly created manager, so its return type cannot be `void`."}], indent: 0, explanation: "Initializes the asset manager." },
    { "correct": "Asset* asset_load(AssetManager* am, const char* name);", distractors: [{"text":"Asset asset_load(AssetManager am, const char* name);", reason:"The function should work with pointers to avoid making expensive copies of the manager struct. It also returns a pointer to the asset, not the asset itself."}], indent: 0, explanation: "Loads an asset by name, preventing duplicates." },
    { "correct": "Asset* asset_get(AssetManager* am, const char* name);", distractors: [{"text":"int asset_get(AssetManager* am, const char* name);", reason:"This function should return a pointer to the found asset (`Asset*`) or `NULL` if not found. Returning an `int` would not allow access to the asset data."}], indent: 0, explanation: "Retrieves an already loaded asset." },
    { "correct": "void asset_manager_destroy(AssetManager* am);", distractors: [{"text":"void asset_manager_destroy();", reason:"The function needs to know *which* asset manager to destroy, so it must accept the manager's handle as a parameter."}], indent: 0, explanation: "Frees all loaded assets and the manager itself." },
    { "correct": "// --- Stage 2: Hash and Asset Manager Implementation ---", distractors: [{"text":"// --- Stage 2: The Main Program ---", reason:"This is the implementation of the library itself, not the main program that will use it."}], indent: 0, explanation: "Implement the core logic." },
    { "correct": "unsigned long hash_function(const char* str) {", distractors: [{"text":"int hash_function(char* str) {", reason:"`unsigned long` is a better return type for a hash to avoid overflow. The input string is not modified, so it should be `const char*`."}], indent: 0, explanation: "The djb2 hash function, good for string keys." },
    { "correct": "  unsigned long hash = 5381; int c; while((c = *str++)) hash = ((hash << 5) + hash) + c;", distractors: [{"text":"  unsigned long hash = 0; for(int i=0; str[i]; i++) { hash += str[i]; }", reason:"This is a much simpler but less effective hash function that would lead to many more collisions for different strings."}], indent: 1, explanation: "A compact implementation of the hashing algorithm." },
    { "correct": "  return hash % HASH_TABLE_SIZE;", distractors: [{"text":"  return hash;", reason:"This is a bug. The raw hash value must be constrained by the modulo operator (`%`) to be a valid index into the `buckets` array."}], indent: 1, explanation: "Constrain the hash to the table size." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "Close the hash function." },
    { "correct": "AssetManager* asset_manager_create() {", distractors: [{"text":"AssetManager asset_manager_create() {", reason:"This function must return a pointer (`AssetManager*`) to the dynamically allocated manager, not the manager struct itself by value."}], indent: 0, explanation: "The constructor for the asset manager." },
    { "correct": "  AssetManager* am = malloc(sizeof(AssetManager));", distractors: [{"text":"  AssetManager* am = malloc(sizeof(am));", reason:"This is a bug. `sizeof(am)` gives the size of a pointer (e.g., 8 bytes), not the size of the `AssetManager` struct it points to."}], indent: 1, explanation: "Allocate memory for the manager." },
    { "correct": "  if (!am) return NULL;", distractors: [{"text":"  // No error check needed", reason:"This is unsafe. `malloc` can fail if the system is out of memory. You must always check its return value."}], indent: 1, explanation: "Handle allocation failure." },
    { "correct": "  memset(am->buckets, 0, sizeof(am->buckets));", distractors: [{"text":"  // No need to initialize buckets", reason:"This is a critical error. The buckets would contain garbage pointers, and any attempt to use them would lead to a crash."}], indent: 1, explanation: "Initialize all buckets to NULL." },
    { "correct": "  return am;", distractors: [{"text":"  return *am;", reason:"This is a type mismatch. The function returns a pointer (`AssetManager*`), but this attempts to dereference it and return the struct by value."}], indent: 1, explanation: "Return the new manager." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "Close the constructor." },
    { "correct": "Asset* asset_get(AssetManager* am, const char* name) {", distractors: [{"text":"const Asset* asset_get(...)", reason:"Returning a non-const `Asset*` is a valid design choice here, as the user might need to interact with the asset data in a modifiable way."}], indent: 0, explanation: "Function to retrieve an asset from the manager." },
    { "correct": "  unsigned long index = hash_function(name);", distractors: [{"text":"  unsigned long index = strlen(name);", reason:"Using string length as a hash function is very poor, as many different asset names would hash to the same index, degrading performance."}], indent: 1, explanation: "Calculate the index for the asset name." },
    { "correct": "  for (Asset* asset = am->buckets[index]; asset != NULL; asset = asset->next) {", distractors: [{"text":"  Asset* asset = am->buckets[index]; if (asset) { ... }", reason:"An `if` statement would only check the first asset in the bucket. A loop is required to traverse the entire linked list in case of hash collisions."}], indent: 1, explanation: "Traverse the linked list at the calculated index." },
    { "correct": "    if (strcmp(asset->name, name) == 0) {", distractors: [{"text":"    if (asset->name == name) {", reason:"This is a critical error. `==` compares pointer addresses, not string content. You must use `strcmp` to see if the names are identical."}], indent: 2, explanation: "If the names match..." },
    { "correct": "      return asset; // Found it", distractors: [{"text":"      return asset->data;", reason:"The API should return a pointer to the `Asset` container, which includes the name and other metadata, not just the raw `data` pointer."}], indent: 3, explanation: "Return the pointer to the asset." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon does not follow an `if` block's closing brace."}], indent: 2, explanation: "Close the string compare." },
    { "correct": "  }", distractors: [{"text":"end for;", reason:"This is not valid C syntax."}], indent: 1, explanation: "Close the traversal loop." },
    { "correct": "  return NULL; // Not found in cache", distractors: [{"text":"  return 0;", reason:"The function's return type is a pointer (`Asset*`). The standard way to indicate 'not found' for a pointer is to return `NULL`, not the integer 0."}], indent: 1, explanation: "Return NULL if the asset is not loaded." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon does not follow a function's closing brace."}], indent: 0, explanation: "Close `asset_get`." },
    { "correct": "Asset* asset_load(AssetManager* am, const char* name) {", distractors: [{"text":"Asset asset_load(...)", reason:"The function returns a pointer to a dynamically allocated asset, so its return type must be `Asset*`."}], indent: 0, explanation: "The main loading function." },
    { "correct": "  // First, check if the asset is already loaded to prevent duplicate work.", distractors: [{"text":"  // First, load the asset from disk.", reason:"This is inefficient. The primary purpose of an asset manager is to *avoid* loading from disk if the asset is already in memory."}], indent: 1, explanation: "This is the core caching logic." },
    { "correct": "  Asset* existing_asset = asset_get(am, name);", distractors: [{"text":"  Asset* existing_asset = NULL;", reason:"This would make the subsequent `if` check useless and would cause the program to load assets from disk every time."}], indent: 1, explanation: "Use our get function to check the cache." },
    { "correct": "  if (existing_asset) {", distractors: [{"text":"  if (existing_asset != NULL) {", reason:"This is an equally valid and often clearer way to check if the pointer returned by `asset_get` is not NULL."}], indent: 1, explanation: "If the asset was found..." },
    { "correct": "    printf(\"INFO: Asset '%s' already loaded. Returning cached version.\\n\", name);", distractors: [{"text":"    return NULL;", reason:"This would be a bug. If the asset is found in the cache, the function should return the pointer to it, not `NULL`."}], indent: 2, explanation: "Print an informational message." },
    { "correct": "    return existing_asset;", distractors: [{"text":"    return *existing_asset;", reason:"This would be a type mismatch. The function must return a pointer (`Asset*`), not the asset struct itself (`Asset`)."}], indent: 2, explanation: "Return the existing asset handle." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block's closing brace."}], indent: 1, explanation: "Close the check." },
    { "correct": "  // If not found, load it from disk (simulation).", distractors: [{"text":"  // If not found, return an error.", reason:"The purpose of `asset_load` is to load the asset if it's not found, not to return an error."}], indent: 1, explanation: "Comment on the loading from disk part." },
    { "correct": "  printf(\"INFO: Loading asset '%s' from disk...\\n\", name);", distractors: [{"text":"  fprintf(stderr, \"Loading asset...\\n\");", reason:"`stderr` is for error messages. Informational messages like this should be printed to standard output (`stdout`) using `printf`."}], indent: 1, explanation: "Simulate a disk read." },
    { "correct": "  // In a real engine, you'd fopen(name, \"rb\") and read data.", distractors: [{"text":"  // In a real engine, you'd fopen(name, \"r\")", reason:"Game assets are almost always binary data, so they should be opened in binary read mode (`\"rb\"`), not text mode (`\"r\"`)."}], indent: 1, explanation: "Comment on real-world implementation." },
    { "correct": "  Texture* tex_data = malloc(sizeof(Texture));", distractors: [{"text":"  Texture tex_data;", reason:"This creates a local stack variable. When `asset_load` returns, its memory will be invalid. The data must be dynamically allocated on the heap with `malloc`."}], indent: 1, explanation: "Simulate loading by allocating a Texture struct." },
    { "correct": "  tex_data->width = 64; tex_data->height = 64; tex_data->channels = 4;", distractors: [{"text":"  tex_data.width = 64;", reason:"`tex_data` is a pointer, so you must use the arrow operator `->` to access its members, not the dot operator `.`."}], indent: 1, explanation: "Populate the simulated texture data." },
    { "correct": "  // Now, create the main Asset handle for it.", distractors: [{"text":"  // Now, return the texture data.", reason:"This is incorrect. We need to wrap the specific `Texture` data in our generic `Asset` container before adding it to the manager."}], indent: 1, explanation: "Comment on creating the asset handle." },
    { "correct": "  Asset* new_asset = malloc(sizeof(Asset));", distractors: [{"text":"  Asset* new_asset = malloc(sizeof(Asset*));", reason:"This would only allocate memory for a pointer, not the entire `Asset` struct. This is a common and serious `sizeof` bug."}], indent: 1, explanation: "Allocate memory for the asset container." },
    { "correct": "  new_asset->name = strdup(name);", distractors: [{"text":"  new_asset->name = name;", reason:"This is a bug. It only copies the pointer, not the string content. The `name` pointer might point to temporary memory. `strdup` makes a safe, permanent copy."}], indent: 1, explanation: "Allocate and copy the asset name." },
    { "correct": "  new_asset->data = tex_data;", distractors: [{"text":"  new_asset->data = &tex_data;", reason:"`tex_data` is already a pointer (`Texture*`). Taking its address would give a `Texture**`, which is the wrong type for the `void*`."}], indent: 1, explanation: "Point the generic data pointer to our specific Texture data." },
    { "correct": "  // Insert the new asset into the hash table.", distractors: [{"text":"  // Return the asset.", reason:"We must insert the newly loaded asset into the hash table so that future calls to `asset_load` can find it in the cache."}], indent: 1, explanation: "Comment on inserting into the hash table." },
    { "correct": "  unsigned long index = hash_function(name);", distractors: [{"text":"  unsigned long index = hash_function(new_asset->name);", reason:"This is also correct, as `new_asset->name` now holds a copy of `name`."}], indent: 1, explanation: "Calculate the index." },
    { "correct": "  new_asset->next = am->buckets[index];", distractors: [{"text":"  am->buckets[index] = new_asset;", reason:"This must happen *after* setting `new_asset->next`. Doing it first would lose the rest of the collision chain."}], indent: 1, explanation: "Insert at the head of the collision list." },
    { "correct": "  am->buckets[index] = new_asset;", distractors: [{"text":"  new_asset->next = NULL;", reason:"This would make the new asset the only one in its bucket, overwriting any previous assets that had the same hash index."}], indent: 1, explanation: "The new asset becomes the new head." },
    { "correct": "  return new_asset;", distractors: [{"text":"  return am->buckets[index];", reason:"This is also correct, as `new_asset` was just assigned to `am->buckets[index]`."}], indent: 1, explanation: "Return the newly loaded asset." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "Close `asset_load`." },
    { "correct": "void asset_manager_destroy(AssetManager* am) {", distractors: [{"text":"void asset_manager_destroy(AssetManager am) {", reason:"To free the dynamically allocated manager, the function must accept a pointer to it, not a copy."}], indent: 0, explanation: "The 'destructor' for the entire manager." },
    { "correct": "  printf(\"INFO: Shutting down asset manager and freeing all assets.\\n\");", distractors: [{"text":"  free(am);", reason:"This is a massive memory leak. You must iterate through the hash table and free all the individual assets *before* freeing the manager structure itself."}], indent: 1, explanation: "Informational message." },
    { "correct": "  for (int i = 0; i < HASH_TABLE_SIZE; i++) {", distractors: [{"text":"  for (int i = 0; i <= HASH_TABLE_SIZE - 1; i++) {", reason:"This is a logically equivalent and correct way to write the loop condition."}], indent: 1, explanation: "Loop through every bucket." },
    { "correct": "    Asset* asset = am->buckets[i];", distractors: [{"text":"    free(am->buckets[i]);", reason:"This would only free the first asset in the bucket's linked list, leaking all the others."}], indent: 2, explanation: "Get the head of the current list." },
    { "correct": "    while (asset) {", distractors: [{"text":"    if (asset) {", reason:"An `if` would only free the first asset in the collision chain. A `while` loop is necessary to traverse the list and free all of them."}], indent: 2, explanation: "Traverse the list." },
    { "correct": "      Asset* next = asset->next;", distractors: [{"text":"      free(asset);", reason:"This is a classic use-after-free bug. If you free `asset` first, you can no longer access `asset->next` to move to the next node."}], indent: 3, explanation: "Save the next pointer." },
    { "correct": "      printf(\"  - Freeing asset: %s\\n\", asset->name);", distractors: [{"text":"      printf(\"  - Freeing asset.\\n\");", reason:"Logging the name of the specific asset being freed is very useful for debugging memory issues."}], indent: 3, explanation: "Log which asset is being freed." },
    { "correct": "      free(asset->data); // Free the specific asset data (the Texture).", distractors: [{"text":"      // No need to free `data`", reason:"This is a memory leak. The `Texture` struct was allocated with `malloc` and must be freed."}], indent: 3, explanation: "Free the `data` payload." },
    { "correct": "      free(asset->name); // Free the name string.", distractors: [{"text":"      // No need to free `name`", reason:"This is a memory leak. The `name` was allocated with `strdup` (which uses `malloc`), so it must be freed."}], indent: 3, explanation: "Free the key." },
    { "correct": "      free(asset);       // Free the container struct.", distractors: [{"text":"      asset = next;", reason:"This would leak the memory for the `Asset` struct itself before moving to the next one."}], indent: 3, explanation: "Free the `Asset` node." },
    { "correct": "      asset = next;", distractors: [{"text":"      // No need to update pointer", reason:"This would cause an infinite loop, as `asset` would never change and the `while` condition would always be true."}], indent: 3, explanation: "Move to the next asset." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after a `while` loop."}], indent: 2, explanation: "Close inner loop." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "Close outer loop." },
    { "correct": "  free(am);", distractors: [{"text":"  // No need to free manager", reason:"This is false. The asset manager itself was allocated with `malloc` and must be freed to prevent a memory leak."}], indent: 1, explanation: "Finally, free the manager itself." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "Close `asset_manager_destroy`." },
    { "correct": "// === Stage 3: Main Program to Demonstrate the Asset Manager ===", distractors: [{"text":"// === Stage 3: The Library Implementation ===", reason:"This is the main program that *uses* the library, not the library itself."}], indent: 0, explanation: "A `main` function to test our asset manager." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid, and often preferred, way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start main." },
    { "correct": "  AssetManager* am = asset_manager_create();", distractors: [{"text":"  AssetManager am = asset_manager_create();", reason:"The create function returns a pointer (`AssetManager*`), not a struct by value."}], indent: 1, explanation: "Initialize the asset manager." },
    { "correct": "  printf(\"--- Asset Loading Simulation ---\\n\");", distractors: [{"text":"  puts(\"--- Asset Loading Simulation ---\");", reason:"`puts` is a valid alternative for printing this header."}], indent: 1, explanation: "Header." },
    { "correct": "  // Request assets. The manager will load them from 'disk'.", distractors: [{"text":"  // Get assets from cache.", reason:"This is the first time these assets are requested, so they will be loaded from 'disk', not from the cache."}], indent: 1, explanation: "Comment on the first loading phase." },
    { "correct": "  Asset* player_sprite = asset_load(am, \"player.png\");", distractors: [{"text":"  asset_load(am, \"player.png\");", reason:"The `asset_load` function returns a pointer to the loaded asset. If you don't store this pointer in a variable, you won't be able to use the asset later."}], indent: 1, explanation: "Load the player sprite. This will read from 'disk'." },
    { "correct": "  Asset* enemy_sprite = asset_load(am, \"enemy.png\");", distractors: [{"text":"  Asset* enemy_sprite = asset_get(am, \"enemy.png\");", reason:"`asset_get` would return `NULL` here because the enemy sprite hasn't been loaded yet. You must use `asset_load`."}], indent: 1, explanation: "Load the enemy sprite. Also reads from 'disk'." },
    { "correct": "  Asset* background_music = asset_load(am, \"music.ogg\");", distractors: [{"text":"  Texture* background_music = asset_load(am, \"music.ogg\");", reason:"The `asset_load` function always returns a generic `Asset*`. You would cast the `data` member later to get the specific `Texture*`."}], indent: 1, explanation: "Load the music. Also reads from 'disk'." },
    { "correct": "  printf(\"\\n--- Requesting Assets Again ---\\n\");", distractors: [{"text":"  puts(\"\\n--- Requesting Assets Again ---\");", reason:"`puts` adds its own newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Header for the second phase." },
    { "correct": "  // Requesting the same asset again should be fast and use the cache.", distractors: [{"text":"  // This will load the asset from disk again.", reason:"This is false. The entire purpose of the asset manager is to find the already-loaded asset in the hash table and return it, avoiding a slow disk read."}], indent: 1, explanation: "Demonstrate the caching behavior." },
    { "correct": "  Asset* player_sprite_again = asset_load(am, \"player.png\");", distractors: [{"text":"  Asset* player_sprite_again = asset_get(am, \"player.png\");", reason:"Using `asset_get` here would also work and would be slightly more efficient, as it doesn't have the 'load if not found' logic."}], indent: 1, explanation: "Request 'player.png' again. This time it will be found in the hash table and returned immediately." },
    { "correct": "  if (player_sprite == player_sprite_again) {", distractors: [{"text":"  if (strcmp(player_sprite->name, player_sprite_again->name) == 0) {", reason:"While their names are the same, this check is weaker. Comparing the pointers with `==` proves that it is the *exact same object in memory*, confirming our caching works."}], indent: 1, explanation: "Check if the pointers are the same." },
    { "correct": "    printf(\"SUCCESS: Pointers for original and cached 'player.png' are identical.\\n\");", distractors: [{"text":"    printf(\"SUCCESS: The assets have the same name.\\n\");", reason:"The original message is better because it explains *why* it's a success: the pointers are identical, proving no new memory was allocated."}], indent: 2, explanation: "Confirm that no new memory was allocated." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 1, explanation: "Close the check." },
    { "correct": "  // Use a retrieved asset.", distractors: [{"text":"  // Load a new asset.", reason:"This is incorrect. We are retrieving an *already loaded* asset using the `asset_get` function."}], indent: 1, explanation: "Comment on using an asset." },
    { "correct": "  Asset* found_asset = asset_get(am, \"enemy.png\");", distractors: [{"text":"  Asset* found_asset = asset_load(am, \"enemy.png\");", reason:"Since we know the asset is already loaded, using `asset_get` is more direct than `asset_load`."}], indent: 1, explanation: "Get an asset using the `get` function." },
    { "correct": "  if (found_asset) {", distractors: [{"text":"  if (found_asset != NULL) {", reason:"This is an equally valid and often clearer way to check that the pointer is not NULL."}], indent: 1, explanation: "If found..." },
    { "correct": "    Texture* tex = (Texture*)found_asset->data;", distractors: [{"text":"    Texture* tex = found_asset->data;", reason:"This is a bug. `found_asset->data` is a `void*`. You must explicitly cast it to the specific type (`Texture*`) you know it is before you can access its members."}], indent: 2, explanation: "Cast the generic `void*` data back to its specific `Texture*` type." },
    { "correct": "    printf(\"Retrieved enemy texture data: %dx%d, %d channels.\\n\", tex->width, tex->height, tex->channels);", distractors: [{"text":"    printf(\"Retrieved data: %p\\n\", tex);", reason:"This would just print the memory address of the texture data, not the meaningful metadata inside the struct."}], indent: 2, explanation: "Use the specific texture data." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block's closing brace."}], indent: 1, explanation: "Close the check." },
    { "correct": "  printf(\"\\n--- System Shutdown ---\\n\");", distractors: [{"text":"  puts(\"\\n--- System Shutdown ---\");", reason:"`puts` automatically adds a newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Header for cleanup." },
    { "correct": "  asset_manager_destroy(am);", distractors: [{"text":"  free(am);", reason:"This is a massive memory leak. `free(am)` only frees the manager struct itself, not all the assets it contains. You must use the custom `destroy` function to clean up everything."}], indent: 1, explanation: "Free all loaded assets and the manager itself." },
    { "correct": "  printf(\"Configuration freed successfully.\\n\");", distractors: [{"text":"  puts(\"Memory freed successfully.\");", reason:"`puts` is a valid and simpler way to print this message."}], indent: 1, explanation: "Confirmation message." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 signals an error. Since the program completed successfully, it should return 0."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 82: Implement a Finite State Machine
    {
        "goal": "Implement a Finite State Machine (FSM) to control the behavior of a simple game AI.",
        concepts: "Finite State Machine (FSM), `enum`, `switch`, state transitions, game AI",
        sequence: [
    { "correct": "// === Stage 1: Setup and Core FSM Structures ===", distractors: [{"text":"// === Stage 1: The Main Game Loop ===", reason:"Good design dictates that we should define our data structures (`Player`, `Monster`, `MonsterState`) before we write the main loop logic that uses them."}], indent: 0, explanation: "Define the states, and the data structures for our player and monster." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"The I/O function `printf` is part of the Standard I/O library, `<stdio.h>`."}], indent: 0, explanation: "Standard I/O." },
    { "correct": "#include <stdlib.h> // For abs()", distractors: [{"text":"#include <math.h>", reason:"While `<math.h>` has many math functions, `abs()` for integers is located in the main standard library, `<stdlib.h>`."}], indent: 0, explanation: "Include for the absolute value function." },
    { "correct": "// 1. Define the possible states for our monster AI using an enum.", distractors: [{"text":"// 1. Define state variables.", reason:"This is less precise. An `enum` is a distinct type that defines a set of named integer constants, which is the perfect tool for representing states."}], indent: 0, explanation: "Enums are perfect for defining a fixed set of states." },
    { "correct": "typedef enum {", distractors: [{"text":"enum MonsterState {", reason:"This is also a valid way to declare an enum, but you would have to use `enum MonsterState` every time you declare a variable. `typedef` creates a simpler alias."}], indent: 0, explanation: "Begin State enum." },
    { "correct": "  STATE_IDLE,", distractors: [{"text":"  STATE_IDLE = 1,", reason:"While you can assign explicit values, it's standard practice to let the compiler assign them automatically (starting from 0) unless you have a specific reason not to."}], indent: 1, explanation: "The monster is waiting and doing nothing." },
    { "correct": "  STATE_PATROLLING,", distractors: [{"text":"  STATE_PATROLLING", reason:"Each enumerator in the list (except the last one) must be followed by a comma."}], indent: 1, explanation: "The monster is moving back and forth between two points." },
    { "correct": "  STATE_CHASING,", distractors: [{"text":"  STATE_CHASING = STATE_PATROLLING + 1,", reason:"This is valid but overly complex and unnecessary. The compiler automatically assigns the next sequential value."}], indent: 1, explanation: "The monster has detected the player and is moving towards them." },
    { "correct": "  STATE_ATTACKING", distractors: [{"text":"  STATE_ATTACKING,", reason:"A comma after the last enumerator is allowed in modern C (C99 and later) but is not required."}], indent: 1, explanation: "The monster is close enough to the player to attack." },
    { "correct": "} MonsterState;", distractors: [{"text":"};", reason:"Because this is a `typedef`, you must provide the new type alias (`MonsterState`) before the final semicolon."}], indent: 0, explanation: "Close the enum typedef." },
    { "correct": "// 2. Define data structures for our game entities.", distractors: [{"text":"// 2. Define classes for our game entities.", reason:"C does not have classes; that is a C++ feature. C uses `struct` (structures) to group related data."}], indent: 0, explanation: "Structs to hold the data for the player and monster." },
    { "correct": "typedef struct { int x, y; } Player;", distractors: [{"text":"typedef struct { int x; int y; };", reason:"This would be an anonymous struct, and you cannot create a `typedef` for it this way. You must provide the name (`Player`) before the semicolon."}], indent: 0, explanation: "A simple struct for the player's position." },
    { "correct": "typedef struct {", distractors: [{"text":"struct Monster {", reason:"Using `typedef` is a convenience that allows us to declare monster variables as `Monster m;` instead of `struct Monster m;`."}], indent: 0, explanation: "The main struct for our AI-controlled monster." },
    { "correct": "  int x, y;", distractors: [{"text":"  int x; y;", reason:"To declare multiple variables of the same type on one line, they must be separated by commas, not semicolons."}], indent: 1, explanation: "The monster's current position." },
    { "correct": "  MonsterState current_state;", distractors: [{"text":"  int current_state;", reason:"While an `enum` is technically an integer, using the specific `MonsterState` type is much clearer and provides better type safety."}], indent: 1, explanation: "The current state of the monster's FSM." },
    { "correct": "  int patrol_start_x; // The start point for its patrol route.", distractors: [{"text":"  int patrol_points[2];", reason:"Using two named variables (`patrol_start_x`, `patrol_end_x`) is often clearer than using an array with magic index numbers like `patrol_points[0]`."}], indent: 1, explanation: "Data specific to the patrolling state." },
    { "correct": "  int patrol_end_x;   // The end point for its patrol route.", distractors: [{"text":"  int patrol_route;", reason:"This name is too vague. `patrol_end_x` clearly indicates what the variable represents."}], indent: 1, explanation: "More patrolling data." },
    { "correct": "  int patrol_dir;", distractors: [{"text":"  char patrol_dir;", reason:"While a `char` could store 1 and -1, `int` is the more natural and standard type for directional vectors or numerical calculations."}], indent: 1, explanation: "Current patrol direction (1 for right, -1 for left)." },
    { "correct": "} Monster;", distractors: [{"text":"};", reason:"To complete the `typedef`, the new type name (`Monster`) must be placed before the final semicolon."}], indent: 0, explanation: "Close the Monster struct typedef." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text":"// --- Function Implementations ---", reason:"These are just the forward declarations (prototypes), not the full function bodies (implementations)."}], indent: 0, explanation: "Declare the functions for our state machine logic." },
    { "correct": "void monster_init(Monster* m, int start_x, int patrol_end);", distractors: [{"text":"Monster monster_init(int start_x, int patrol_end);", reason:"This function modifies an existing `Monster` struct; it doesn't create and return a new one. Therefore, it should accept a pointer and have a `void` return type."}], indent: 0, explanation: "Initializes a monster's state." },
    { "correct": "void monster_update(Monster* m, const Player* p);", distractors: [{"text":"void monster_update(Monster m, Player p);", reason:"Passing structs by value creates copies, which is inefficient. Pointers (`*`) should be used to pass references to the original structs."}], indent: 0, explanation: "The main FSM update function, called each game tick." },
    { "correct": "void monster_print_status(const Monster* m);", distractors: [{"text":"void monster_print_status(Monster* m);", reason:"Since this function only reads data from the monster and doesn't modify it, the parameter should be `const Monster*` to enforce read-only access."}], indent: 0, explanation: "A helper to print the monster's status." },
    { "correct": "// --- Stage 2: FSM and Logic Implementation ---", distractors: [{"text":"// --- Stage 2: Data Structures ---", reason:"The data structures were defined in Stage 1. This stage is for the logic that operates on them."}], indent: 0, explanation: "Implement the functions that control the AI's behavior." },
    { "correct": "void monster_init(Monster* m, int start_x, int patrol_end) {", distractors: [{"text":"void monster_init(Monster m, ...)", reason:"The function definition must match the prototype. It must accept a pointer (`Monster*`)."}], indent: 0, explanation: "Start the monster initializer function." },
    { "correct": "  m->x = start_x;", distractors: [{"text":"  m.x = start_x;", reason:"`m` is a pointer to a struct. You must use the arrow operator `->` to access its members, not the dot operator `.`."}], indent: 1, explanation: "Set initial X position." },
    { "correct": "  m->y = 10;", distractors: [{"text":"  m->y = \"10\";", reason:"`y` is an integer member, so it must be assigned an integer value, not a string literal."}], indent: 1, explanation: "Set a fixed Y position." },
    { "correct": "  m->current_state = STATE_IDLE;", distractors: [{"text":"  m->current_state = 0;", reason:"While `STATE_IDLE` is likely 0, it is much clearer and safer to use the named enumerator instead of a 'magic number'."}], indent: 1, explanation: "The monster always starts in the IDLE state." },
    { "correct": "  m->patrol_start_x = start_x;", distractors: [{"text":"  patrol_start_x = start_x;", reason:"You must specify which struct instance you are modifying by using `m->`."}], indent: 1, explanation: "Set the left boundary for its patrol." },
    { "correct": "  m->patrol_end_x = patrol_end;", distractors: [{"text":"  m->patrol_end_x = m->patrol_start_x + 10;", reason:"The patrol endpoint should be set from the function parameter (`patrol_end`), not calculated from another value."}], indent: 1, explanation: "Set the right boundary for its patrol." },
    { "correct": "  m->patrol_dir = 1;", distractors: [{"text":"  m->patrol_dir = 0;", reason:"A direction of 0 would cause the monster to stand still when patrolling."}], indent: 1, explanation: "It starts by patrolling to the right." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "Close the init function." },
    { "correct": "const char* state_to_string(MonsterState state) {", distractors: [{"text":"char* state_to_string(MonsterState state) {", reason:"This function returns pointers to read-only string literals. The return type should be `const char*` to reflect this."}], indent: 0, explanation: "A helper function to convert a state enum to a printable string." },
    { "correct": "  switch(state) {", distractors: [{"text":"  if (state == STATE_IDLE) ... else if ...", reason:"A chain of `if/else if` statements would also work, but a `switch` is often cleaner and more efficient for comparing one variable against multiple constant values."}], indent: 1, explanation: "Use a switch statement for the conversion." },
    { "correct": "    case STATE_IDLE: return \"IDLE\";", distractors: [{"text":"    case 0: return \"IDLE\";", reason:"Using the named enum constant `STATE_IDLE` is much more readable and robust than using a magic number like 0."}], indent: 2, explanation: "Return string for IDLE." },
    { "correct": "    case STATE_PATROLLING: return \"PATROLLING\";", distractors: [{"text":"    STATE_PATROLLING: return \"PATROLLING\";", reason:"Each case in a `switch` statement must begin with the `case` keyword."}], indent: 2, explanation: "Return string for PATROLLING." },
    { "correct": "    case STATE_CHASING: return \"CHASING\";", distractors: [{"text":"    case STATE_CHASING; return \"CHASING\";", reason:"The value for a case must be followed by a colon `:`, not a semicolon `;`."}], indent: 2, explanation: "Return string for CHASING." },
    { "correct": "    case STATE_ATTACKING: return \"ATTACKING\";", distractors: [{"text":"    case STATE_ATTACKING: printf(\"ATTACKING\");", reason:"This function needs to `return` the string, not print it."}], indent: 2, explanation: "Return string for ATTACKING." },
    { "correct": "  }", distractors: [{"text": "};", reason:"A semicolon is not used after a `switch` statement's closing brace."}], indent: 1, explanation: "Close the switch." },
    { "correct": "  return \"UNKNOWN\";", distractors: [{"text":"  default: return \"UNKNOWN\";", reason:"Using a `default` case is a good practice, but since all possible enum values are handled and each `case` returns, this final `return` serves the same purpose."}], indent: 1, explanation: "Return a default string." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "Close the helper function." },
    { "correct": "void monster_print_status(const Monster* m) {", distractors: [{"text":"void monster_print_status(Monster m) {", reason:"Passing the large monster struct by value is inefficient. A pointer is better, and `const` is used because we are only reading from it."}], indent: 0, explanation: "Implementation of the status printing function." },
    { "correct": "  printf(\"Monster is at (%d, %d) in state: %s\\n\", m->x, m->y, state_to_string(m->current_state));", distractors: [{"text":"  printf(\"Monster state is %s\\n\", m->current_state);", reason:"An `enum` value cannot be printed directly with `%s`. You must first convert it to a string, which is what the `state_to_string` helper function does."}] , indent: 1, explanation: "Print the monster's position and current state." },
    { "correct": "}", distractors: [{"text":"};", reason:"Semicolons are not used after a function definition."}], indent: 0, explanation: "Close `monster_print_status`." },
    { "correct": "void monster_update(Monster* m, const Player* p) {", distractors: [{"text":"void monster_update(Monster* m, Player* p) {", reason:"The player's data is only being read, not modified, so it should be passed as a pointer-to-const (`const Player*`)."}], indent: 0, explanation: "The main FSM logic function." },
    { "correct": "  int distance_to_player = abs(p->x - m->x);", distractors: [{"text":"  int distance_to_player = p->x - m->x;", reason:"This could result in a negative distance. `abs()` is required to get the absolute magnitude of the distance."}], indent: 1, explanation: "Calculate the horizontal distance to the player." },
    { "correct": "  // The switch statement forms the core of the FSM.", distractors: [{"text":"  // This is a complex if/else chain.", reason:"This is incorrect. The code uses a `switch` statement, which is often a cleaner way to implement an FSM than many nested `if/else` blocks."}], indent: 1, explanation: "Comment on the FSM's structure." },
    { "correct": "  switch (m->current_state) {", distractors: [{"text":"  switch (m) {", reason:"You must switch on a specific integral value, in this case, the `current_state` member of the struct, not the entire struct pointer."}], indent: 1, explanation: "Switch on the monster's current state." },
    { "correct": "    case STATE_IDLE:", distractors: [{"text":"    if (m->current_state == STATE_IDLE)", reason:"`if` is not the correct syntax for a case within a `switch` statement. You must use `case`."}], indent: 2, explanation: "Logic for when the monster is IDLE." },
    { "correct": "      printf(\"  IDLE: Monster is waiting...\\n\");", distractors: [{"text":"      m->current_state = STATE_IDLE;", reason:"This is an action, not a transition. The monster is already in the IDLE state; setting it again is redundant."}], indent: 3, explanation: "Action: Print a message." },
    { "correct": "      // Transition logic: If player gets close, start chasing.", distractors: [{"text":"      // Action logic: Do nothing.", reason:"This part of the code is not about the action within the IDLE state, but about checking the conditions to *transition* to a new state."}], indent: 3, explanation: "Comment on state transition." },
    { "correct": "      if (distance_to_player < 10) {", distractors: [{"text":"      if (distance_to_player = 10) {", reason:"This is a classic bug. `=` is the assignment operator. For comparison, you must use `==`, `<`, `>`, etc."}], indent: 3, explanation: "Check for transition condition." },
    { "correct": "        m->current_state = STATE_CHASING;", distractors: [{"text":"        m->current_state = STATE_ATTACKING;", reason:"This is a poor FSM design. The monster should transition to CHASING first, and only transition to ATTACKING once it's close enough."}], indent: 4, explanation: "Change the state to CHASING." },
    { "correct": "      } else {", distractors: [{"text":"      }", reason:"Without an `else`, an idle monster that doesn't see a player would stay idle forever. The FSM design requires it to start patrolling if nothing is happening."}], indent: 3, explanation: "If no transition..." },
    { "correct": "        m->current_state = STATE_PATROLLING;", distractors: [{"text":"        m->current_state = STATE_IDLE;", reason:"This would keep the monster stuck in the IDLE state indefinitely."}], indent: 4, explanation: "Transition to PATROLLING after one turn of being idle." },
    { "correct": "      }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if/else` block's closing brace."}], indent: 3, explanation: "Close else." },
    { "correct": "      break;", distractors: [{"text":"      // No break needed.", reason:"This is a critical error. Without `break`, the code would 'fall through' and immediately execute the code in the `STATE_PATROLLING` case, which is a bug."}], indent: 3, explanation: "Exit the switch statement for this state." },
    { "correct": "    case STATE_PATROLLING:", distractors: [{"text":"    case STATE_IDLE:", reason:"This would cause a 'duplicate case' compiler error, as `STATE_IDLE` has already been handled."}], indent: 2, explanation: "Logic for when the monster is PATROLLING." },
    { "correct": "      printf(\"  PATROL: Monster is moving...\\n\");", distractors: [{"text":"      // No action needed.", reason:"The action for the patrol state is to actually move. Without the next line, the monster would be stuck in the patrol state without going anywhere."}], indent: 3, explanation: "Action: Print a message." },
    { "correct": "      m->x += m->patrol_dir;", distractors: [{"text":"      m->x = m->patrol_dir;", reason:"This would make the monster teleport to position 1 or -1, not move incrementally."}], indent: 3, explanation: "Action: Move the monster in its current patrol direction." },
    { "correct": "      if (m->x >= m->patrol_end_x || m->x <= m->patrol_start_x) {", distractors: [{"text":"      if (m->x == m->patrol_end_x && m->x == m->patrol_start_x) {", reason:"This condition can never be true, as `x` cannot be in two different places at once. The logical OR `||` is correct."}], indent: 3, explanation: "Check if the monster has reached the end of its patrol route." },
    { "correct": "        m->patrol_dir *= -1; // Reverse direction", distractors: [{"text":"        m->patrol_dir = -1;", reason:"This would work once (to go left), but when it hits the left boundary, it would be set to -1 again instead of reversing back to 1."}], indent: 4, explanation: "If so, reverse its patrol direction." },
    { "correct": "      }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 3, explanation: "Close patrol boundary check." },
    { "correct": "      // Transition logic: If player gets close, start chasing.", distractors: [{"text":"      // No transitions from this state.", reason:"A state must always check for transitions. If the player comes close, the monster must stop patrolling and start chasing."}], indent: 3, explanation: "Comment on state transition." },
    { "correct": "      if (distance_to_player < 10) {", distractors: [{"text":"      if (distance_to_player > 10) {", reason:"This logic is reversed. The monster should start chasing when the player is close (`< 10`), not far away."}], indent: 3, explanation: "Check transition condition." },
    { "correct": "        m->current_state = STATE_CHASING;", distractors: [{"text":"        m->current_state = STATE_PATROLLING;", reason:"This would cause the monster to ignore the player and continue patrolling, which is incorrect AI behavior."}], indent: 4, explanation: "Change the state to CHASING." },
    { "correct": "      }", distractors: [{"text": "};", reason:"Semicolons do not follow `if` statements."}], indent: 3, explanation: "Close check." },
    { "correct": "      break;", distractors: [{"text":"      return;", reason:"`return` would exit the entire `monster_update` function. `break` correctly exits just the `switch` statement."}], indent: 3, explanation: "Exit the switch." },
    { "correct": "    case STATE_CHASING:", distractors: [{"text":"    case 2:", reason:"Using the named constant `STATE_CHASING` is much more readable and maintainable than using its underlying integer value."}], indent: 2, explanation: "Logic for when the monster is CHASING." },
    { "correct": "      printf(\"  CHASE: Monster sees player!\\n\");", distractors: [{"text":"      monster_print_status(m);", reason:"While this would print a status, it's better for each state to have a unique action message for clarity."}], indent: 3, explanation: "Action: Print a message." },
    { "correct": "      // Action: Move towards the player.", distractors: [{"text":"      // Transition: Move towards the player.", reason:"Moving is the *action* performed during this state. A transition is a *change* to a different state."}], indent: 3, explanation: "Comment on action." },
    { "correct": "      if (p->x > m->x) m->x++;", distractors: [{"text":"      if (p->x > m->x) m->x--;", reason:"This logic is reversed. If the player is to the right (greater x), the monster should also move right (increment x)."}], indent: 3, explanation: "If player is to the right, move right." },
    { "correct": "      else if (p->x < m->x) m->x--;", distractors: [{"text":"      if (p->x < m->x) m->x--;", reason:"Using `else if` is more efficient. If the first `if` was true, there is no need to check the second one."}], indent: 3, explanation: "If player is to the left, move left." },
    { "correct": "      // Transition logic: If close enough, attack. If too far, go back to patrolling.", distractors: [{"text":"      // Action logic: Check distance.", reason:"This logic is for deciding whether to *change* state, making it transition logic, not action logic."}], indent: 3, explanation: "Comment on transitions." },
    { "correct": "      if (distance_to_player < 2) {", distractors: [{"text":"      if (distance_to_player == 0) {", reason:"This is too strict. The monster should be able to attack when it's near the player, not only when it's on the exact same spot."}], indent: 3, explanation: "Check for attack range." },
    { "correct": "        m->current_state = STATE_ATTACKING;", distractors: [{"text":"        m->current_state = STATE_IDLE;", reason:"This is illogical. If the monster catches the player, it should attack, not become idle."}], indent: 4, explanation: "Transition to ATTACKING state." },
    { "correct": "      } else if (distance_to_player > 15) {", distractors: [{"text":"      } if (distance_to_player > 15) {", reason:"Without `else`, a monster could potentially transition to ATTACKING and then immediately transition back to PATROLLING in the same tick if the player is far away, which is a bug."}], indent: 3, explanation: "Check if player has escaped." },
    { "correct": "        m->current_state = STATE_PATROLLING;", distractors: [{"text":"        m->current_state = STATE_CHASING;", reason:"This would cause the monster to be stuck in the chasing state forever, even if the player gets away."}], indent: 4, explanation: "Transition back to PATROLLING." },
    { "correct": "      }", distractors: [{"text": "};", reason:"Semicolons are not used after an `if-else` block."}], indent: 3, explanation: "Close else-if." },
    { "correct": "      break;", distractors: [{"text":"      continue;", reason:"`continue` is for loops, not `switch` statements. `break` is required to exit the switch."}], indent: 3, explanation: "Exit the switch." },
    { "correct": "    case STATE_ATTACKING:", distractors: [{"text":"    default:", reason:"It's better to explicitly handle every state case. A `default` case can hide bugs if a new state is added and not handled."}], indent: 2, explanation: "Logic for when the monster is ATTACKING." },
    { "correct": "      printf(\"  ATTACK: Monster is attacking the player!\\n\");", distractors: [{"text":"      m->x = p->x; m->y = p->y;", reason:"This is an action, but it's not attacking. This moves the monster onto the player. The action is simply to be in the 'attacking' state."}], indent: 3, explanation: "Action: Print attack message." },
    { "correct": "      // Transition logic: If player moves away, go back to chasing.", distractors: [{"text":"      // Action logic: Check if player moved.", reason:"This check leads to a state change, making it transition logic."}], indent: 3, explanation: "Comment on transition." },
    { "correct": "      if (distance_to_player >= 2) {", distractors: [{"text":"      if (distance_to_player < 2) {", reason:"This condition is the opposite of what's needed. The monster should stop attacking only when the player moves *away*."}], indent: 3, explanation: "Check if player has moved out of attack range." },
    { "correct": "        m->current_state = STATE_CHASING;", distractors: [{"text":"        m->current_state = STATE_PATROLLING;", reason:"This would be a bug. If the player is still close (but just outside attack range), the monster should continue chasing, not give up and go back to patrolling."}], indent: 4, explanation: "Transition back to CHASING." },
    { "correct": "      }", distractors: [{"text": "};", reason:"Semicolons are not used here."}], indent: 3, explanation: "Close check." },
    { "correct": "      break;", distractors: [{"text":"      // Last case, no break needed.", reason:"This is a common misconception. Even the last case in a `switch` should have a `break` for consistency and to prevent bugs if a new case is added later."}], indent: 3, explanation: "Exit the switch." },
    { "correct": "  }", distractors: [{"text":"end switch;", reason:"This is not valid C syntax."}], indent: 1, explanation: "Close the `switch` statement." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "Close `monster_update`." },
    { "correct": "// === Stage 3: Main Game Loop Simulation ===", distractors: [{"text":"// === Stage 3: The FSM Implementation ===", reason:"The FSM was implemented in Stage 2. This stage is the main program that *uses* the FSM to simulate a game."}], indent: 0, explanation: "A `main` function to simulate the game and test the FSM." },
    { "correct": "int main() {", distractors: [{"text":"void main() {", reason:"Standard C requires `main` to return an `int` to signal its exit status to the operating system."}], indent: 0, explanation: "Start main." },
    { "correct": "  Player player = { .x = 0, .y = 10 };", distractors: [{"text":"  Player player = { 0, 10 };", reason:"This positional initializer also works. Designated initializers (`.x = ...`) are often preferred as they are order-independent and more readable."}], indent: 1, explanation: "Create the player at position 0." },
    { "correct": "  Monster monster;", distractors: [{"text":"  Monster* monster = malloc(sizeof(Monster));", reason:"Dynamic allocation is not necessary here. A simple stack-allocated struct is sufficient for this simulation."}], indent: 1, explanation: "Declare a monster." },
    { "correct": "  monster_init(&monster, 30, 40);", distractors: [{"text":"  monster_init(monster, 30, 40);", reason:"The `monster_init` function expects a pointer to a `Monster` struct, so we must pass the address of our monster using the `&` operator."}], indent: 1, explanation: "Initialize the monster with a patrol route from x=30 to x=40." },
    { "correct": "  printf(\"--- Game Simulation Starting ---\\n\");", distractors: [{"text":"  puts(\"--- Game Simulation Starting ---\");", reason:"`puts` is a valid and simpler alternative for printing a fixed string followed by a newline."}], indent: 1, explanation: "Header." },
    { "correct": "  printf(\"Player starts at: %d\\n\", player.x);", distractors: [{"text":"  printf(\"Player starts at: %d\\n\", player->x);", reason:"`player` is a struct, not a pointer to one. The dot operator `.` must be used to access its members."}], indent: 1, explanation: "Print initial player position." },
    { "correct": "  monster_print_status(&monster);", distractors: [{"text":"  monster_print_status(monster);", reason:"This function expects a pointer (`const Monster*`), so we must pass the address of our `monster` struct with the `&` operator."}], indent: 1, explanation: "Print initial monster status." },
    { "correct": "  // Simulate 20 ticks of the game loop.", distractors: [{"text":"  // Run the game forever.", reason:"This comment is inaccurate. The `for` loop is explicitly set to run for 20 iterations."}], indent: 1, explanation: "Comment on the simulation loop." },
    { "correct": "  for (int tick = 1; tick <= 20; tick++) {", distractors: [{"text":"  while (tick <= 20) { tick++; ... }", reason:"A `while` loop would also be a perfectly valid way to structure this simulation loop."}], indent: 1, explanation: "Loop for 20 game ticks." },
    { "correct": "    printf(\"\\n--- Tick %d ---\\n\", tick);", distractors: [{"text":"    printf(\"\\n--- Tick %d ---\\n\");", reason:"The `%d` format specifier requires an integer argument. Forgetting to pass `tick` would result in printing a garbage value."}], indent: 2, explanation: "Print the current tick number." },
    { "correct": "    // Move the player slowly towards the monster.", distractors: [{"text":"    // Let the player attack.", reason:"The logic in this part of the simulation only moves the player; it doesn't include any attack actions."}], indent: 2, explanation: "Simulate player movement." },
    { "correct": "    if (tick < 18) player.x++;", distractors: [{"text":"    player.x++;", reason:"This would cause the player to keep moving right past the monster, which would not test all the FSM transitions as effectively."}], indent: 2, explanation: "The player moves right for most of the simulation." },
    { "correct": "    printf(\"Player moved to: %d\\n\", player.x);", distractors: [{"text":"    printf(\"Player moved.\\n\");", reason:"This is less useful. Printing the player's new position makes the simulation log much easier to follow and debug."}], indent: 2, explanation: "Announce player's new position." },
    { "correct": "    monster_update(&monster, &player);", distractors: [{"text":"    // monster moves on its own", reason:"This is false. The monster's AI logic is not running in a separate thread; it must be explicitly called via `monster_update` on each tick of the game loop."}], indent: 2, explanation: "Update the monster's FSM based on the player's new position." },
    { "correct": "    monster_print_status(&monster);", distractors: [{"text":"    monster_print_status(monster);", reason:"This would be a compiler error, as the function expects a pointer, not a struct passed by value."}], indent: 2, explanation: "Print the monster's resulting status." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "Close the game loop." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 conventionally signals that an error occurred. The program should return 0 to indicate a successful run."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 83: foundational library for matrix mathematics
    {
        "goal": "Build a foundational library for matrix mathematics, including creation, destruction, and multiplication.",
        concepts: "structs, dynamic memory, 2D data in 1D arrays, API design, linear algebra algorithms",
        sequence: [
    { "correct": "// === Stage 1: The Public API Header File ('matrix.h') ===", distractors: [{"text":"// === Stage 1: The Main Program ('main.c') ===", reason:"Good library design starts with defining the public interface (the `.h` header file) before the implementation or the main program that uses it."}], indent: 0, explanation: "Define the public interface for our matrix library." },
    { "correct": "#include <stdlib.h> // For size_t", distractors: [{"text":"#include <stdio.h>", reason:"While `<stdio.h>` is needed for printing, the definition of the `size_t` type is in the standard library header, `<stdlib.h>`."}], indent: 0, explanation: "Include for the `size_t` type." },
    { "correct": "// Opaque declaration of the Matrix struct.", distractors: [{"text":"// Full definition of the Matrix struct.", reason:"This comment is incorrect. We are intentionally hiding the full definition from the user by only forward-declaring it."}], indent: 0, explanation: "Hide the internal structure from the user." },
    { "correct": "struct Matrix;", distractors: [{"text":"struct Matrix { double* data; };", reason:"This reveals internal details of the struct, violating the opaque pointer pattern. The header should only declare that the type exists."}], indent: 0, explanation: "Forward-declare the struct, making it an incomplete type." },
    { "correct": "typedef struct Matrix* MatrixHandle;", distractors: [{"text":"typedef struct Matrix MatrixHandle;", reason:"This creates an alias for the struct itself, not a pointer. The user would then have to manage pointers (`MatrixHandle*`), which is less clean than providing a simple handle."}], indent: 0, explanation: "Create a handle that users will interact with." },
    { "correct": "// --- Public API Function Prototypes ---", distractors: [{"text":"// --- Private Helper Functions ---", reason:"These functions are intended for public use, so 'Public API' is the correct description."}], indent: 0, explanation: "Declare the library's functions." },
    { "correct": "MatrixHandle matrix_create(size_t rows, size_t cols);", distractors: [{"text":"void matrix_create(MatrixHandle mat, size_t rows, size_t cols);", reason:"This design would require the user to allocate the `Matrix` struct themselves. A 'constructor' function should handle all allocation and return a ready-to-use handle."}], indent: 0, explanation: "Creates a new matrix of a given size, initialized to zero." },
    { "correct": "void matrix_destroy(MatrixHandle mat);", distractors: [{"text":"MatrixHandle matrix_destroy(MatrixHandle mat);", reason:"A 'destructor' function's job is to clean up memory; it doesn't need to return anything, so its return type should be `void`."}], indent: 0, explanation: "Frees all memory associated with a matrix." },
    { "correct": "double matrix_get(const MatrixHandle mat, size_t row, size_t col);", distractors: [{"text":"double matrix_get(MatrixHandle mat, size_t row, size_t col);", reason:"Since this function only reads from the matrix, the handle should be `const` to enforce that the function does not modify it."}], indent: 0, explanation: "Gets the value at a specific row and column." },
    { "correct": "void matrix_set(MatrixHandle mat, size_t row, size_t col, double value);", distractors: [{"text":"double matrix_set(...);", reason:"This function modifies the matrix state and doesn't need to return the value it just set, so `void` is the appropriate return type."}], indent: 0, explanation: "Sets the value at a specific row and column." },
    { "correct": "void matrix_print(const MatrixHandle mat);", distractors: [{"text":"void matrix_print(MatrixHandle mat);", reason:"A print function should not modify the data it's printing. Using `const` makes this guarantee clear to the user."}], indent: 0, explanation: "Prints the matrix to the console in a readable format." },
    { "correct": "MatrixHandle matrix_multiply(const MatrixHandle m1, const MatrixHandle m2);", distractors: [{"text":"void matrix_multiply(MatrixHandle result, const MatrixHandle m1, ...);", reason:"This is a valid alternative design (passing in the result matrix). However, returning a new matrix is often a cleaner API, as it doesn't require the user to pre-allocate the result."}], indent: 0, explanation: "Multiplies two matrices and returns a new matrix with the result." },
    { "correct": "// === Stage 2: The Private Implementation ('matrix.c') ===", distractors: [{"text":"// === Stage 2: The Public Header ('matrix.h') ===", reason:"This is incorrect. This is the private source file containing the function bodies and hidden struct definitions."}], indent: 0, explanation: "Implement the hidden logic of our matrix library." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"The `printf` function used for printing the matrix is declared in `<stdio.h>`."}], indent: 0, explanation: "Include for `printf`." },
    { "correct": "#include <string.h>", distractors: [{"text":"#include <strings.h>", reason:"The standard C header for `memset` is `<string.h>`."}], indent: 0, explanation: "Include for `memset`." },
    { "correct": "// #include \"matrix.h\" // In a real project", distractors: [{"text":"// No need to include our own header.", reason:"This is a bad practice. Including your own header allows the compiler to check that your function implementations match the prototypes you declared, catching errors early."}], indent: 0, explanation: "Link implementation to the public header." },
    { "correct": "// Full, private definition of the Matrix struct.", distractors: [{"text":"// This should be in the .h file.", reason:"No, the entire point of the opaque pointer pattern is to keep this full definition private to the `.c` file, hiding the implementation from the user."}], indent: 0, explanation: "Complete the opaque type definition." },
    { "correct": "struct Matrix {", distractors: [{"text":"typedef struct Matrix {", reason:"We already created the `MatrixHandle` typedef. Here we just need to provide the implementation for the forward-declared `struct Matrix`."}], indent: 0, explanation: "Begin the struct definition." },
    { "correct": "  size_t rows;", distractors: [{"text":"  int rows;", reason:"`size_t` is the proper type for sizes and counts in C. It's guaranteed to be large enough to represent the size of any object, which is not true for `int`."}], indent: 1, explanation: "The number of rows in the matrix." },
    { "correct": "  size_t cols;", distractors: [{"text":"  int cols;", reason:"Using `size_t` for dimensions and loop counters is standard practice and avoids potential issues with very large matrices."}], indent: 1, explanation: "The number of columns in the matrix." },
    { "correct": "  double* data; // Data stored in a flat, 1D array in row-major order.", distractors: [{"text":"  double** data;", reason:"Using a pointer-to-a-pointer (`double**`) requires a separate `malloc` for each row, which is less memory efficient and slower due to poor cache locality. A single flat array is often higher performance."}], indent: 1, explanation: "The matrix elements, stored contiguously in memory for performance." },
    { "correct": "};", distractors: [{"text":"}", reason:"The definition of a `struct`, `union`, or `enum` must be followed by a semicolon."}], indent: 0, explanation: "Close the struct definition." },
    { "correct": "MatrixHandle matrix_create(size_t rows, size_t cols) {", distractors: [{"text":"Matrix* matrix_create(...)", reason:"It's better to use the `MatrixHandle` typedef we created for consistency throughout the API."}], indent: 0, explanation: "Implement the 'constructor'." },
    { "correct": "  MatrixHandle mat = malloc(sizeof(struct Matrix));", distractors: [{"text":"  MatrixHandle mat = malloc(sizeof(MatrixHandle));", reason:"This is a critical bug. It allocates space for a pointer (`MatrixHandle`), not the full `struct Matrix`. This would not be enough memory for the rows, cols, and data pointer."}], indent: 1, explanation: "Allocate memory for the main Matrix struct." },
    { "correct": "  if (!mat) return NULL;", distractors: [{"text":"  // No need for error checking.", reason:"This is very unsafe. `malloc` can fail if the system runs out of memory, and you must always check for a `NULL` return."}], indent: 1, explanation: "Handle allocation failure." },
    { "correct": "  mat->rows = rows;", distractors: [{"text":"  mat.rows = rows;", reason:"`mat` is a pointer, so you must use the arrow operator `->` to access its members, not the dot operator `.`."}], indent: 1, explanation: "Set the number of rows." },
    { "correct": "  mat->cols = cols;", distractors: [{"text":"  mat->cols = rows;", reason:"This is a logic error. This should set the number of columns, not rows."}], indent: 1, explanation: "Set the number of columns." },
    { "correct": "  mat->data = malloc(rows * cols * sizeof(double));", distractors: [{"text":"  mat->data = malloc(rows * cols);", reason:"This is a bug. `malloc` needs the total size in *bytes*. You must multiply the number of elements by the size of each element (`sizeof(double)`)."}], indent: 1, explanation: "Allocate memory for the actual matrix data." },
    { "correct": "  if (!mat->data) { free(mat); return NULL; }", distractors: [{"text":"  if (!mat->data) { return NULL; }", reason:"This is a memory leak. If the data allocation fails, you must `free` the `Matrix` struct itself before returning, otherwise it's orphaned."}], indent: 1, explanation: "If data allocation fails, clean up the struct and return NULL." },
    { "correct": "  memset(mat->data, 0, rows * cols * sizeof(double));", distractors: [{"text":"  for (int i=0; i<rows*cols; i++) { mat->data[i] = 0.0; }", reason:"A `for` loop is a perfectly valid way to initialize the data to zero, but `memset` is a faster, single function call to zero out a raw block of memory."}], indent: 1, explanation: "Initialize all elements of the matrix to zero." },
    { "correct": "  return mat;", distractors: [{"text":"  return mat->data;", reason:"The public API must return the `MatrixHandle` (a pointer to the struct), not just a pointer to its internal data array."}], indent: 1, explanation: "Return the new matrix handle." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "Close `matrix_create`." },
    { "correct": "void matrix_destroy(MatrixHandle mat) {", distractors: [{"text":"void matrix_destroy(const MatrixHandle mat) {", reason:"A `destroy` function conceptually 'modifies' the state by freeing memory, so the handle should not be `const`."}], indent: 0, explanation: "Implement the 'destructor'." },
    { "correct": "  if (!mat) return;", distractors: [{"text":"  if (mat == NULL) return;", reason:"This is an equally valid way to check for a `NULL` handle. It's good practice to allow `free`/`destroy` functions to be called safely on `NULL`."}], indent: 1, explanation: "Safety check for a NULL handle." },
    { "correct": "  free(mat->data);", distractors: [{"text":"  free(mat);", reason:"This is a memory leak. You must free the `data` array *before* you free the `mat` struct that contains the pointer to it."}], indent: 1, explanation: "Free the data array first." },
    { "correct": "  free(mat);", distractors: [{"text":"  mat = NULL;", reason:"Setting the local pointer `mat` to `NULL` has no effect on the caller's pointer after this function returns."}], indent: 1, explanation: "Then free the struct itself." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "Close `matrix_destroy`." },
    { "correct": "// Helper macro for converting 2D index to 1D index.", distractors: [{"text":"// Helper function for converting 2D index...", reason:"A macro is used here because it's slightly more performant than a function call, as it's a direct text replacement. A static inline function would be another good alternative."}], indent: 0, explanation: "This macro simplifies accessing elements in the flat data array." },
    { "correct": "#define IDX(mat, r, c) ((r) * (mat)->cols + (c))", distractors: [{"text":"#define IDX(mat, r, c) r * mat->cols + c", reason:"Macro arguments should always be enclosed in parentheses to avoid operator precedence errors when the macro is expanded."}], indent: 0, explanation: "Defines the row-major order indexing formula." },
    { "correct": "double matrix_get(const MatrixHandle mat, size_t row, size_t col) {", distractors: [{"text":"double matrix_get(MatrixHandle mat, int row, int col) {", reason:"The definition must match the prototype. Using `size_t` for rows/columns is better practice than `int`."}], indent: 0, explanation: "Implement the getter function." },
    { "correct": "  if (!mat || row >= mat->rows || col >= mat->cols) return 0.0; // Return 0 on error/out of bounds", distractors: [{"text":"  // No bounds checking needed.", reason:"This is very unsafe. Without bounds checking, providing an invalid row or column would cause the program to read from an invalid memory location, leading to a crash or garbage data."}], indent: 1, explanation: "Perform bounds checking." },
    { "correct": "  return mat->data[IDX(mat, row, col)];", distractors: [{"text":"  return mat->data[row][col];", reason:"This would fail to compile. `mat->data` is a 1D array (`double*`), not a 2D array. The `IDX` macro is required to calculate the correct 1D index."}], indent: 1, explanation: "Use the IDX macro to get the value from the 1D array." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "Close `matrix_get`." },
    { "correct": "void matrix_set(MatrixHandle mat, size_t row, size_t col, double value) {", distractors: [{"text":"double matrix_set(...)", reason:"The definition must match the `void` return type from the prototype."}], indent: 0, explanation: "Implement the setter function." },
    { "correct": "  if (!mat || row >= mat->rows || col >= mat->cols) return;", distractors: [{"text":"  if (!mat && row < mat->rows && col < mat->cols) return;", reason:"This logic is reversed. It would incorrectly `return` on a valid index and proceed on an invalid one."}], indent: 1, explanation: "Perform bounds checking." },
    { "correct": "  mat->data[IDX(mat, row, col)] = value;", distractors: [{"text":"  mat->data[row * mat->cols + col] = value;", reason:"This is also correct, but using the `IDX` macro makes the code more readable and less prone to copy-paste errors."}], indent: 1, explanation: "Use the IDX macro to set the value in the 1D array." },
    { "correct": "}", distractors: [{"text":"};", reason:"Semicolons are not used after function definitions."}], indent: 0, explanation: "Close `matrix_set`." },
    { "correct": "void matrix_print(const MatrixHandle mat) {", distractors: [{"text":"void matrix_print(MatrixHandle mat) {", reason:"The implementation must match the prototype, which used `const` to indicate it doesn't modify the matrix."}], indent: 0, explanation: "Implement the print function." },
    { "correct": "  if (!mat) return;", distractors: [{"text":"  if (mat == NULL) return;", reason:"This is an equally valid and often clearer way to check for a NULL pointer."}], indent: 1, explanation: "Safety check." },
    { "correct": "  printf(\"Matrix (%zu x %zu):\\n\", mat->rows, mat->cols);", distractors: [{"text":"  printf(\"Matrix (%d x %d):\\n\", mat->rows, mat->cols);", reason:"The correct format specifier for `size_t` is `%zu`. Using `%d` may fail on systems where `size_t` is larger than `int`."}], indent: 1, explanation: "Print the dimensions of the matrix." },
    { "correct": "  for (size_t r = 0; r < mat->rows; r++) {", distractors: [{"text":"  for (size_t c = 0; c < mat->cols; c++) {", reason:"This would iterate through columns in the outer loop, printing the matrix in a transposed orientation."}], indent: 1, explanation: "Loop through each row." },
    { "correct": "    printf(\"  [ \");", distractors: [{"text":"    printf(\"\\n\");", reason:"This would print each element on a new line, not in a grid format."}], indent: 2, explanation: "Print an opening bracket for the row." },
    { "correct": "    for (size_t c = 0; c < mat->cols; c++) {", distractors: [{"text":"    for (size_t c = 0; c <= mat->cols - 1; c++) {", reason:"This is a logically equivalent and correct way to write the loop condition."}], indent: 2, explanation: "Loop through each column in the row." },
    { "correct": "      printf(\"%8.2f \", matrix_get(mat, r, c));", distractors: [{"text":"      printf(\"%f \", mat->data[IDX(mat, r, c)]);", reason:"This also works, but calling the public `matrix_get` function is good practice, as it respects the API boundary and includes bounds checking."}], indent: 3, explanation: "Print each element with fixed formatting." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 2, explanation: "Close the column loop." },
    { "correct": "    printf(\"]\\n\");", distractors: [{"text":"    printf(\"]\");", reason:"Forgetting the newline `\\n` would cause all the rows of the matrix to be printed on a single line."}], indent: 2, explanation: "Print a closing bracket and a newline." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "Close the row loop." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "Close `matrix_print`." },
    { "correct": "MatrixHandle matrix_multiply(const MatrixHandle m1, const MatrixHandle m2) {", distractors: [{"text":"MatrixHandle matrix_multiply(MatrixHandle m1, MatrixHandle m2) {", reason:"The definition must match the prototype. This function should not modify the input matrices, so they should be `const`."}], indent: 0, explanation: "Implement matrix multiplication (C = A * B)." },
    { "correct": "  // The number of columns in m1 must equal the number of rows in m2.", distractors: [{"text":"  // The dimensions must be identical.", reason:"This is incorrect. That rule is for matrix addition, not multiplication."}], indent: 1, explanation: "State the rule for matrix multiplication compatibility." },
    { "correct": "  if (!m1 || !m2 || m1->cols != m2->rows) return NULL;", distractors: [{"text":"  if (m1->cols == m2->rows) { ... }", reason:"This logic is reversed. The multiplication should only proceed if the dimensions are compatible. The function should return `NULL` if they are not."}], indent: 1, explanation: "Check if the matrices are compatible." },
    { "correct": "  // The result matrix has the dimensions (rows of m1, cols of m2).", distractors: [{"text":"  // The result matrix has dimensions (rows of m1, cols of m1).", reason:"This is the wrong dimension rule. The result's dimensions are determined by the 'outer' dimensions of the input matrices."}], indent: 1, explanation: "Define the dimensions of the result matrix." },
    { "correct": "  MatrixHandle result = matrix_create(m1->rows, m2->cols);", distractors: [{"text":"  MatrixHandle result = matrix_create(m2->rows, m1->cols);", reason:"This uses the wrong dimensions. The result should have the number of rows from the first matrix and columns from the second."}], indent: 1, explanation: "Create the result matrix." },
    { "correct": "  if (!result) return NULL;", distractors: [{"text":"  // Assume creation is successful.", reason:"This is unsafe. `matrix_create` involves `malloc`, which can fail. You must check the return value."}], indent: 1, explanation: "Handle creation failure." },
    { "correct": "  // Perform the multiplication using three nested loops.", distractors: [{"text":"  // Perform the multiplication using two loops.", reason:"Standard matrix multiplication is an O(n^3) algorithm and requires three nested loops to implement directly."}], indent: 1, explanation: "Comment on the algorithm." },
    { "correct": "  for (size_t i = 0; i < m1->rows; i++) {", distractors: [{"text":"  for (size_t i = 0; i < m1->cols; i++) {", reason:"This would iterate the wrong number of times, leading to out-of-bounds access."}], indent: 1, explanation: "Loop through each row of the first matrix (m1)." },
    { "correct": "    for (size_t j = 0; j < m2->cols; j++) {", distractors: [{"text":"    for (size_t j = 0; j < m2->rows; j++) {", reason:"This would iterate the wrong number of times if the matrix isn't square."}], indent: 2, explanation: "Loop through each column of the second matrix (m2)." },
    { "correct": "      double sum = 0.0;", distractors: [{"text":"      double sum;", reason:"An accumulator variable like `sum` must be initialized to zero before you start adding to it. An uninitialized variable holds a garbage value."}], indent: 3, explanation: "Initialize the sum for the dot product." },
    { "correct": "      for (size_t k = 0; k < m1->cols; k++) {", distractors: [{"text":"      for (size_t k = 0; k < m2->rows; k++) {", reason:"This is also correct, since the compatibility check `m1->cols == m2->rows` has already passed."}], indent: 3, explanation: "Loop through the elements of the row/column." },
    { "correct": "        sum += matrix_get(m1, i, k) * matrix_get(m2, k, j);", distractors: [{"text":"        sum += matrix_get(m1, i, k) * matrix_get(m2, i, k);", reason:"This is a bug. To calculate the dot product, you must iterate through row `i` of m1 and column `j` of m2. The second index should be `(k, j)`."}], indent: 4, explanation: "Calculate the dot product of m1's row `i` and m2's column `j`." },
    { "correct": "      }", distractors: [{"text":"};", reason:"Semicolons are not used after a `for` loop."}], indent: 3, explanation: "Close the inner dot product loop." },
    { "correct": "      matrix_set(result, i, j, sum);", distractors: [{"text":"      matrix_set(result, j, i, sum);", reason:"This would place the result in the transposed position, giving an incorrect final matrix."}], indent: 3, explanation: "Set the calculated sum into the result matrix." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 2, explanation: "Close the column loop." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 1, explanation: "Close the row loop." },
    { "correct": "  return result;", distractors: [{"text":"  return m1;", reason:"This would incorrectly return one of the input matrices instead of the newly computed result matrix."}], indent: 1, explanation: "Return the final result matrix." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "Close `matrix_multiply`." },
    { "correct": "// === Stage 3: The Main Program to Demonstrate the Library ===", distractors: [{"text":"// === Stage 3: The Library Implementation ===", reason:"This section is for a program that *uses* our library, not the library itself."}], indent: 0, explanation: "A `main` function to test our matrix library." },
    { "correct": "int main() {", distractors: [{"text":"void main() {", reason:"Standard C requires `main` to return an `int` to signal its exit status."}], indent: 0, explanation: "Start main." },
    { "correct": "  MatrixHandle A = matrix_create(2, 3);", distractors: [{"text":"  Matrix A;", reason:"This creates a stack variable. Our API is designed to work with handles (`MatrixHandle` pointers) to dynamically allocated matrices."}], indent: 1, explanation: "Create a 2x3 matrix." },
    { "correct": "  matrix_set(A, 0, 0, 1); matrix_set(A, 0, 1, 2); matrix_set(A, 0, 2, 3);", distractors: [{"text":"  matrix_set(A, 0, 3, 1);", reason:"This would be an out-of-bounds access, as the valid column indices are 0, 1, and 2."}], indent: 1, explanation: "Populate the first row of matrix A." },
    { "correct": "  matrix_set(A, 1, 0, 4); matrix_set(A, 1, 1, 5); matrix_set(A, 1, 2, 6);", distractors: [{"text":"  matrix_set(A, 2, 0, 4);", reason:"This would be an out-of-bounds access. Matrix A only has rows 0 and 1."}], indent: 1, explanation: "Populate the second row of matrix A." },
    { "correct": "  MatrixHandle B = matrix_create(3, 2);", distractors: [{"text":"  MatrixHandle B = matrix_create(2, 3);", reason:"For the multiplication `A * B` to be valid, the number of columns in A (3) must match the number of rows in B (3)."}], indent: 1, explanation: "Create a 3x2 matrix." },
    { "correct": "  matrix_set(B, 0, 0, 7); matrix_set(B, 0, 1, 8);", distractors: [{"text":"  A->data[0] = 7;", reason:"This is breaking the abstraction. You should never access the internal `data` member directly from the main program. Always use the public API functions like `matrix_set`."}], indent: 1, explanation: "Populate the first row of matrix B." },
    { "correct": "  matrix_set(B, 1, 0, 9); matrix_set(B, 1, 1, 10);", distractors: [{"text":"  matrix_set(B, 1, 2, 10);", reason:"This is out-of-bounds. Matrix B only has columns 0 and 1."}], indent: 1, explanation: "Populate the second row of matrix B." },
    { "correct": "  matrix_set(B, 2, 0, 11); matrix_set(B, 2, 1, 12);", distractors: [{"text":"  matrix_get(B, 2, 0, 11);", reason:"`matrix_get` is for retrieving a value, not for setting one."}], indent: 1, explanation: "Populate the third row of matrix B." },
    { "correct": "  printf(\"--- Input Matrices ---\\n\");", distractors: [{"text":"  puts(\"--- Input Matrices ---\");", reason:"`puts` is a valid and simpler alternative for printing a fixed string followed by a newline."}], indent: 1, explanation: "Header." },
    { "correct": "  matrix_print(A);", distractors: [{"text":"  matrix_print(&A);", reason:"`A` is already a pointer (`MatrixHandle`). Passing its address (`&A`) would be a type mismatch (`MatrixHandle*` vs `const MatrixHandle`)."}], indent: 1, explanation: "Print matrix A." },
    { "correct": "  matrix_print(B);", distractors: [{"text":"  printf(\"%f\\n\", B);", reason:"You cannot print a complex struct like this. You must use the dedicated `matrix_print` function that knows how to format it."}], indent: 1, explanation: "Print matrix B." },
    { "correct": "  printf(\"\\n--- Multiplying A * B ---\\n\");", distractors: [{"text":"  puts(\"\\n--- Multiplying A * B ---\");", reason:"`puts` automatically adds its own newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Informational message." },
    { "correct": "  MatrixHandle C = matrix_multiply(A, B);", distractors: [{"text":"  MatrixHandle C = matrix_multiply(B, A);", reason:"Matrix multiplication is not commutative (`B * A` is not the same as `A * B`). In this case, `B * A` is not even a valid operation because the inner dimensions (2 and 2) do not match."}], indent: 1, explanation: "Perform the multiplication." },
    { "correct": "  if (C) {", distractors: [{"text":"  if (C != NULL) {", reason:"This is an equally valid and often clearer way to check if the pointer returned by the function is not `NULL`."}], indent: 1, explanation: "If the multiplication was successful..." },
    { "correct": "    matrix_print(C);", distractors: [{"text":"    matrix_print(A);", reason:"This would incorrectly print matrix A again instead of the result C."}], indent: 2, explanation: "Print the resulting 2x2 matrix." },
    { "correct": "  }", distractors: [{"text": "};", reason:"Semicolons are not used after `if` blocks."}], indent: 1, explanation: "Close the if." },
    { "correct": "  // Cleanup", distractors: [{"text":"  // No cleanup needed", reason:"This is false. All three matrices were dynamically allocated with `matrix_create` (which uses `malloc`), and must be explicitly freed to prevent memory leaks."}], indent: 1, explanation: "Comment on cleanup." },
    { "correct": "  matrix_destroy(A);", distractors: [{"text":"  free(A);", reason:"This is a memory leak. `free(A)` would only free the `Matrix` struct itself, but not the `data` array inside it. You must use the custom `matrix_destroy` function."}], indent: 1, explanation: "Free matrix A." },
    { "correct": "  matrix_destroy(B);", distractors: [{"text":"  // B is automatically freed.", reason:"This is false. Memory allocated with `malloc` is never automatically freed in C."}], indent: 1, explanation: "Free matrix B." },
    { "correct": "  matrix_destroy(C);", distractors: [{"text":"  matrix_destroy(NULL);", reason:"While our `destroy` function can safely handle `NULL`, this would fail to free the memory associated with matrix C."}], indent: 1, explanation: "Free matrix C." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 conventionally signals that an error occurred. Since the program ran successfully, it should return 0."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "Close main." }
]
    },
    // Level 84: Implement the K-Nearest Neighbors
    {
        "goal": "Implement the K-Nearest Neighbors (KNN) machine learning algorithm to classify new data points.",
        concepts: "structs, dynamic arrays, file I/O, qsort, `sqrt`, implementing ML algorithms",
        sequence: [
    { "correct": "// === Stage 1: Setup and Data Structures ===", distractors: [{"text":"// === Stage 1: The KNN Algorithm ===", reason:"Before implementing the algorithm, we must first define the data structures that the algorithm will operate on."}], indent: 0, explanation: "Define includes and the structures for our data points." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"`printf` and file operations like `fopen` are part of the Standard I/O library, `<stdio.h>`."}], indent: 0, explanation: "Standard I/O." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <math.h>", reason:"Memory management (`realloc`), sorting (`qsort`), and string conversion (`atof`) are all part of the Standard Library, `<stdlib.h>`."}], indent: 0, explanation: "Memory management, `qsort`, `atof`." },
    { "correct": "#include <string.h>", distractors: [{"text":"#include <strings.h>", reason:"The standard C header for string functions like `strcpy` and `strcmp` is `<string.h>`."}], indent: 0, explanation: "String manipulation." },
    { "correct": "#include <math.h>", distractors: [{"text":"#include <stdlib.h>", reason:"Mathematical functions like `sqrt` (square root) and `pow` (power) are located in the math library header, `<math.h>`."}], indent: 0, explanation: "For `sqrt` and `pow` to calculate distance." },
    { "correct": "#define MAX_LABEL_LEN 32", distractors: [{"text":"const int MAX_LABEL_LEN = 32;", reason:"Using a `const int` is also a valid way to create a constant. A `#define` is a preprocessor macro that is a common C idiom for defining fixed sizes."}], indent: 0, explanation: "Max length of a class label (e.g., \"Cat\", \"Dog\")." },
    { "correct": "// A struct to represent a single labeled data point in our dataset.", distractors: [{"text":"// A class for a data point.", reason:"C uses `struct` to group data. The term `class` is from object-oriented languages like C++."}], indent: 0, explanation: "Comment on the DataPoint struct." },
    { "correct": "typedef struct {", distractors: [{"text":"struct DataPoint {", reason:"This also works, but requires you to declare variables as `struct DataPoint p;`. Using `typedef` allows the simpler `DataPoint p;`."}], indent: 0, explanation: "Begin DataPoint definition." },
    { "correct": "  double x, y; // The features of our data point (e.g., coordinates).", distractors: [{"text":"  int x, y;", reason:"Features are often real numbers. Using `double` allows for floating-point precision, which is more flexible than `int`."}], indent: 1, explanation: "The two features for our 2D data." },
    { "correct": "  char label[MAX_LABEL_LEN]; // The class label for this data point.", distractors: [{"text":"  char* label;", reason:"Using `char*` would require an extra dynamic memory allocation for every single label, complicating memory management. A fixed-size array is simpler for this problem."}], indent: 1, explanation: "The correct classification for this point." },
    { "correct": "} DataPoint;", distractors: [{"text":"};", reason:"To complete the `typedef`, you must provide the new type alias name (`DataPoint`) before the final semicolon."}], indent: 0, explanation: "Close the DataPoint typedef." },
    { "correct": "// A helper struct to store a point and its distance to the query point.", distractors: [{"text":"// A struct to store the final prediction.", reason:"This struct isn't for the final prediction; it's a temporary helper used during the sorting step of the algorithm."}], indent: 0, explanation: "This struct will be used for sorting." },
    { "correct": "typedef struct {", distractors: [{"text":"struct DistanceEntry {", reason:"Using `typedef` is a convenience that lets us use the type name `DistanceEntry` directly."}], indent: 0, explanation: "Begin DistanceEntry definition." },
    { "correct": "  DataPoint point;", distractors: [{"text":"  DataPoint* point;", reason:"Using a pointer would be slightly more memory efficient, but storing a direct copy of the `DataPoint` is simpler to manage for this temporary array."}], indent: 1, explanation: "A copy of the original data point." },
    { "correct": "  double distance;", distractors: [{"text":"  int distance;", reason:"Distance is calculated using `sqrt` and is a floating-point value. It must be a `double` to maintain precision."}], indent: 1, explanation: "The calculated distance." },
    { "correct": "} DistanceEntry;", distractors: [{"text":"} DistanceEntry", reason:"A `typedef` statement must always end with a semicolon."}], indent: 0, explanation: "Close the DistanceEntry typedef." },
    { "correct": "// --- Global Dataset ---", distractors: [{"text":"// --- Local Variables ---", reason:"These are declared outside of any function, making them global variables accessible throughout the file."}], indent: 0, explanation: "Global variables to hold the loaded training data." },
    { "correct": "DataPoint* training_data = NULL;", distractors: [{"text":"DataPoint* training_data;", reason:"It's critical to initialize pointers to `NULL`. An uninitialized global pointer is set to zero, but being explicit is much safer and clearer."}], indent: 0, explanation: "A dynamic array to store the dataset." },
    { "correct": "int data_count = 0;", distractors: [{"text":"int data_count;", reason:"Like pointers, it's best practice to explicitly initialize counters to 0, even though uninitialized globals are zeroed out by the compiler."}], indent: 0, explanation: "The number of records in the dataset." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text":"// --- Function Implementations ---", reason:"These are just forward declarations (prototypes). The full implementations (bodies) of the functions come later."}], indent: 0, explanation: "Declare our functions before use." },
    { "correct": "void load_dataset(const char* filename);", distractors: [{"text":"int load_dataset(const char* filename);", reason:"This function modifies global state directly and doesn't need to return a value, so `void` is an appropriate return type."}], indent: 0, explanation: "Loads the training data from a CSV file." },
    { "correct": "double euclidean_distance(DataPoint p1, DataPoint p2);", distractors: [{"text":"void euclidean_distance(DataPoint p1, DataPoint p2);", reason:"This function's purpose is to calculate and return the distance, so its return type must be `double`."}], indent: 0, explanation: "Calculates the distance between two points." },
    { "correct": "int compare_distances(const void* a, const void* b);", distractors: [{"text":"int compare_distances(DistanceEntry* a, DistanceEntry* b);", reason:"A comparator function for `qsort` MUST have the exact signature `int func(const void*, const void*)` to be generic."}], indent: 0, explanation: "A `qsort` comparator to sort entries by distance." },
    { "correct": "const char* classify_point(DataPoint query_point, int k);", distractors: [{"text":"char* classify_point(DataPoint query_point, int k);", reason:"The function returns a pointer to a label within our dataset. It should be `const char*` to signal that this string should not be modified by the caller."}], indent: 0, explanation: "The main KNN prediction function." },
    { "correct": "// --- Stage 2: Core Logic Implementation ---", distractors: [{"text":"// --- Stage 2: Data Structures ---", reason:"The data structures were defined in Stage 1. This stage implements the logic that uses those structures."}], indent: 0, explanation: "Implement the functions for loading, distance calculation, and classification." },
    { "correct": "void load_dataset(const char* filename) {", distractors: [{"text":"void load_dataset(char* filename) {", reason:"The definition must match the prototype. Using `const` is good practice as the function only reads the filename, it doesn't change it."}], indent: 0, explanation: "Start the dataset loading function." },
    { "correct": "  FILE* fp = fopen(filename, \"r\");", distractors: [{"text":"  FILE* fp = fopen(filename, \"rb\");", reason:"CSV files are text files, not binary. They must be opened in text read mode (`\"r\"`)."}], indent: 1, explanation: "Open the CSV file." },
    { "correct": "  if (!fp) { perror(\"Failed to open dataset\"); exit(1); }", distractors: [{"text":"  if (fp == NULL) { return; }", reason:"Failing to open the dataset is a critical error for this program. It should `exit` rather than just returning and trying to proceed with no data."}], indent: 1, explanation: "Handle file open error." },
    { "correct": "  char line[128];", distractors: [{"text":"  char* line = malloc(128);", reason:"For a temporary buffer within a function, a stack-allocated array is simpler and is automatically deallocated. `malloc` is not necessary here."}], indent: 1, explanation: "A buffer to read each line." },
    { "correct": "  fgets(line, sizeof(line), fp); // Skip header row", distractors: [{"text":"  // No need to skip header", reason:"If we don't skip the header, `sscanf` will fail to parse \"x,y,label\" as numbers and the first data point will be garbage."}], indent: 1, explanation: "Assume a header row and discard it." },
    { "correct": "  while (fgets(line, sizeof(line), fp)) {", distractors: [{"text":"  while (!feof(fp)) { fgets(...); }", reason:"This is a common C anti-pattern. You must loop on the return value of the read function (`fgets` here), not `feof`, to correctly handle the end of file."}], indent: 1, explanation: "Loop, reading one data point at a time." },
    { "correct": "    data_count++;", distractors: [{"text":"    data_count += 1;", reason:"This is also correct, but the post-increment operator `++` is the more common and concise C idiom."}], indent: 2, explanation: "Increment the data point counter." },
    { "correct": "    training_data = realloc(training_data, data_count * sizeof(DataPoint));", distractors: [{"text":"    DataPoint* temp = realloc(...);", reason:"Using a temporary pointer is a safer pattern in case `realloc` fails. Direct assignment is used here for brevity."}], indent: 2, explanation: "Resize the dynamic array to fit the new point." },
    { "correct": "    sscanf(line, \"%lf,%lf,%s\", &training_data[data_count-1].x, &training_data[data_count-1].y, training_data[data_count-1].label);", distractors: [{"text":"    fscanf(fp, \"%lf,%lf,%s\", ...);", reason:"`fscanf` reads directly from the file, but we have already read the whole line into a buffer with `fgets`. `sscanf` is the correct function to parse a string that's already in memory."}] , indent: 2, explanation: "Use `sscanf` to parse the X, Y, and Label from the CSV line. `%lf` is for doubles." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used after the closing brace of a `while` loop."}], indent: 1, explanation: "Close the reading loop." },
    { "correct": "  fclose(fp);", distractors: [{"text":"  free(fp);", reason:"`fp` is a `FILE` handle, not a memory block from `malloc`. It must be closed with `fclose`."}], indent: 1, explanation: "Close the file." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "Close `load_dataset`." },
    { "correct": "double euclidean_distance(DataPoint p1, DataPoint p2) {", distractors: [{"text":"double euclidean_distance(DataPoint* p1, DataPoint* p2) {", reason:"Since the structs are small, passing them by value (making a copy) is simple and clear. Passing by pointer would also work."}], indent: 0, explanation: "Implement the distance formula." },
    { "correct": "  double dx = p1.x - p2.x;", distractors: [{"text":"  double dx = p1.x + p2.x;", reason:"The distance formula requires the *difference* between the coordinates, not the sum."}], indent: 1, explanation: "Calculate the difference in x coordinates." },
    { "correct": "  double dy = p1.y - p2.y;", distractors: [{"text":"  double dy = p2.y - p1.y;", reason:"The order of subtraction doesn't matter here, because the result will be squared, making it positive anyway."}], indent: 1, explanation: "Calculate the difference in y coordinates." },
    { "correct": "  return sqrt(pow(dx, 2) + pow(dy, 2));", distractors: [{"text":"  return sqrt(dx*dx + dy*dy);", reason:"Multiplying a variable by itself is a common and often faster alternative to calling `pow(variable, 2)`."}, {"text":"  return pow(dx, 2) + pow(dy, 2);", reason:"This is a bug. This calculates the squared distance. You must take the `sqrt` to get the actual Euclidean distance."}] , indent: 1, explanation: "Return the square root of the sum of squares." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "Close `euclidean_distance`." },
    { "correct": "int compare_distances(const void* a, const void* b) {", distractors: [{"text":"int compare_distances(const DistanceEntry* a, const DistanceEntry* b) {", reason:"This is a critical error. A `qsort` comparator MUST accept `const void*` to be generic. The casting to the specific type happens inside the function."}], indent: 0, explanation: "Implement the `qsort` comparator." },
    { "correct": "  DistanceEntry* entryA = (DistanceEntry*)a;", distractors: [{"text":"  DistanceEntry entryA = *(DistanceEntry*)a;", reason:"This creates a copy of the struct, which is less efficient. It's better to work with pointers directly."}], indent: 1, explanation: "Cast the void pointers to our helper struct type." },
    { "correct": "  DistanceEntry* entryB = (DistanceEntry*)b;", distractors: [{"text":"  const DistanceEntry* entryB = (const DistanceEntry*)b;", reason:"Using `const` here is also correct and good practice, since we are only reading from the entries."}], indent: 1, explanation: "Cast the second argument." },
    { "correct": "  if (entryA->distance < entryB->distance) return -1;", distractors: [{"text":"  if (entryA->distance > entryB->distance) return 1;", reason:"This would be the first step in sorting in descending order, not ascending."}], indent: 1, explanation: "Return -1 if A is closer." },
    { "correct": "  if (entryA->distance > entryB->distance) return 1;", distractors: [{"text":"  return entryA->distance - entryB->distance;", reason:"This is a bug for floating-point numbers. The result of the subtraction might be a fraction between -1 and 1, which `qsort` would interpret as 0 (equal)."}] , indent: 1, explanation: "Return 1 if B is closer." },
    { "correct": "  return 0;", distractors: [{"text":"  return -1;", reason:"If the distances are equal, the function must return 0 to indicate their order doesn't matter. Returning -1 would be incorrect."}], indent: 1, explanation: "Return 0 if distances are equal." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon does not follow a function definition."}], indent: 0, explanation: "Close the comparator." },
    { "correct": "const char* classify_point(DataPoint query_point, int k) {", distractors: [{"text":"char* classify_point(...)", reason:"The definition must match the prototype. The return type should be `const char*` as it points to a label that should not be modified."}], indent: 0, explanation: "The main KNN prediction logic." },
    { "correct": "  // 1. Calculate distance from the query point to all training points.", distractors: [{"text":"  // 1. Sort the training points first.", reason:"This is incorrect. KNN does not require the training set to be pre-sorted. The first step is always to calculate distances to the new point."}], indent: 1, explanation: "First step of KNN." },
    { "correct": "  DistanceEntry* distances = malloc(data_count * sizeof(DistanceEntry));", distractors: [{"text":"  DistanceEntry distances[data_count];", reason:"If `data_count` is very large, this could cause a stack overflow. For large arrays, dynamic allocation on the heap with `malloc` is required."}], indent: 1, explanation: "Create a temporary array to hold all distances." },
    { "correct": "  for (int i=0; i < data_count; i++) {", distractors: [{"text":"  for (int i=0; i <= data_count - 1; i++) {", reason:"This is a logically equivalent and correct way to write the loop's condition."}], indent: 1, explanation: "Loop through the entire training set." },
    { "correct": "    distances[i].point = training_data[i];", distractors: [{"text":"    distances[i].point = &training_data[i];", reason:"This would be a type mismatch. The `point` member is a `DataPoint` struct, not a pointer to one."}], indent: 2, explanation: "Copy the data point." },
    { "correct": "    distances[i].distance = euclidean_distance(query_point, training_data[i]);", distractors: [{"text":"    distances[i].distance = euclidean_distance(&query_point, &training_data[i]);", reason:"Our `euclidean_distance` function was designed to take structs by value, not by pointer."}], indent: 2, explanation: "Calculate and store its distance from the query point." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop's closing brace."}], indent: 1, explanation: "Close the distance calculation loop." },
    { "correct": "  // 2. Sort the distances in ascending order.", distractors: [{"text":"  // 2. Find the average distance.", reason:"This is not part of the KNN algorithm. The next step is to sort the points by distance to find the nearest ones."}], indent: 1, explanation: "Second step of KNN." },
    { "correct": "  qsort(distances, data_count, sizeof(DistanceEntry), compare_distances);", distractors: [{"text":"  qsort(distances, data_count, sizeof(DistanceEntry*), compare_distances);", reason:"This is a bug. The array contains `DistanceEntry` structs, so the size argument must be `sizeof(DistanceEntry)`, not the size of a pointer."}], indent: 1, explanation: "Use `qsort` to sort the helper array by distance." },
    { "correct": "  // 3. Find the most common label among the first 'k' neighbors.", distractors: [{"text":"  // 3. Find the closest neighbor.", reason:"This would be a 1-Nearest Neighbor classifier. KNN is more robust because it considers the 'K' nearest neighbors."}], indent: 1, explanation: "Third step of KNN: Voting." },
    { "correct": "  // (This is a simplified voting implementation for demonstration).", distractors: [{"text":"  // (This is the most efficient voting implementation).", reason:"This is false. This O(k^2) voting loop is simple to understand but inefficient. A more advanced solution would use a hash map or another sort for O(k) or O(k log k) performance."}], indent: 1, explanation: "Note on the simple voting logic." },
    { "correct": "  int max_votes = 0;", distractors: [{"text":"  int max_votes = 1;", reason:"The vote counter should start at 0, otherwise the logic for finding the max could fail if the top item only has 1 vote."}], indent: 1, explanation: "A counter for the winning vote count." },
    { "correct": "  char* prediction = \"Unknown\";", distractors: [{"text":"  char* prediction = NULL;", reason:"Initializing to \"Unknown\" provides a safe default value. Initializing to `NULL` could be risky if the rest of the code doesn't handle it."}], indent: 1, explanation: "A pointer to hold the predicted label." },
    { "correct": "  for (int i = 0; i < k; i++) {", distractors: [{"text":"  for (int i = 0; i < data_count; i++) {", reason:"This is a bug. The voting process should only consider the `k` nearest neighbors, not the entire dataset."}], indent: 1, explanation: "Outer loop: Iterate through the top K neighbors." },
    { "correct": "    int current_votes = 0;", distractors: [{"text":"    int current_votes = 1;", reason:"The vote count for each label must start at 0 for an accurate tally."}], indent: 2, explanation: "Counter for the votes of the current neighbor's label." },
    { "correct": "    for (int j = 0; j < k; j++) {", distractors: [{"text":"    for (int j = i; j < k; j++) {", reason:"This would be an optimization, but the current simpler logic correctly recounts all votes for each of the k neighbors."}], indent: 2, explanation: "Inner loop: Compare the current neighbor with all other K neighbors." },
    { "correct": "      if (strcmp(distances[j].point.label, distances[i].point.label) == 0) {", distractors: [{"text":"      if (distances[j].point.label == distances[i].point.label) {", reason:"This is a critical error. Strings must be compared with `strcmp`. `==` compares pointer addresses, which will likely be different even if the labels are the same."}], indent: 3, explanation: "If the labels match..." },
    { "correct": "        current_votes++;", distractors: [{"text":"        current_votes += 1;", reason:"This is also correct, but `++` is the more common C idiom."}], indent: 4, explanation: "Increment the vote count for this label." },
    { "correct": "      }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 3, explanation: "Close string compare." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used after a `for` loop."}], indent: 2, explanation: "Close inner loop." },
    { "correct": "    if (current_votes > max_votes) {", distractors: [{"text":"    if (current_votes >= max_votes) {", reason:"Using `>=` could cause the prediction to change in the case of a tie, which might be undesirable. `>` correctly keeps the first winner in a tie."}], indent: 2, explanation: "If this label has more votes than the previous winner..." },
    { "correct": "      max_votes = current_votes;", distractors: [{"text":"      max_votes++;", reason:"This is a bug. `max_votes` should be set to the new `current_votes` count, not just incremented."}], indent: 3, explanation: "Update the max vote count." },
    { "correct": "      prediction = distances[i].point.label;", distractors: [{"text":"      strcpy(prediction, distances[i].point.label);", reason:"This is a bug. `prediction` points to a string literal (\"Unknown\") which is read-only and cannot be modified. We must reassign the pointer itself."}], indent: 3, explanation: "This label is now the leading prediction." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 2, explanation: "Close max votes check." },
    { "correct": "  }", distractors: [{"text":"end for;", reason:"This is not valid C syntax."}], indent: 1, explanation: "Close the voting loop." },
    { "correct": "  free(distances);", distractors: [{"text":"  // No need to free", reason:"This is a memory leak. The `distances` array was created with `malloc` and its memory must be returned to the system with `free`."}], indent: 1, explanation: "Free the temporary distances array." },
    { "correct": "  return prediction;", distractors: [{"text":"  return strdup(prediction);", reason:"This would return a *copy* of the label string, forcing the user to `free` it. The current API is simpler, returning a non-owned pointer to a label."}], indent: 1, explanation: "Return the final predicted label." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to end a function block."}], indent: 0, explanation: "Close `classify_point`." },
    { "correct": "// === Stage 3: Main Program to Run the Classifier ===", distractors: [{"text":"// === Stage 3: The KNN Library ===", reason:"This section is the main program that *uses* our KNN functions to solve a problem. The 'library' was implemented in Stage 2."}], indent: 0, explanation: "A `main` function to test our KNN implementation." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid and often preferred way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start main." },
    { "correct": "  // Create a dummy CSV file for the demo.", distractors: [{"text":"  // Read the CSV file.", reason:"This comment is inaccurate. The following code *writes* a new CSV file for testing purposes."}], indent: 1, explanation: "Simulate the training data file." },
    { "correct": "  FILE* f = fopen(\"dataset.csv\", \"w\");", distractors: [{"text":"  FILE* f = fopen(\"dataset.csv\", \"r\");", reason:"This would fail if the file doesn't exist. We need to open it in write mode (`\"w\"`) to create it."}], indent: 1, explanation: "Create the file." },
    { "correct": "  fprintf(f, \"x,y,label\\n1.0,1.1,ClassA\\n1.2,1.0,ClassA\\n0.0,0.1,ClassB\\n0.2,0.3,ClassB\\n\");", distractors: [{"text":"  fputs(\"x,y,label\\n...\", f);", reason:"`fputs` is another valid way to write a string to a file."}], indent: 1, explanation: "Write four data points, two for each class." },
    { "correct": "  fclose(f);", distractors: [{"text":"  // No need to close", reason:"This is false. If you don't `fclose` a file opened for writing, its contents may not be fully flushed to the disk."}], indent: 1, explanation: "Close the dummy file." },
    { "correct": "  load_dataset(\"dataset.csv\");", distractors: [{"text":"  // No need to load, we have the data", reason:"The data written to the file is not yet in our program's memory. We must call `load_dataset` to parse it into our `training_data` array."}], indent: 1, explanation: "Load the training data." },
    { "correct": "  printf(\"Loaded %d data points.\\n\", data_count);", distractors: [{"text":"  printf(\"Dataset loaded.\\n\");", reason:"This is okay, but printing the number of records loaded is better confirmation that the parsing worked correctly."}], indent: 1, explanation: "Confirmation message." },
    { "correct": "  // Create a new point we want to classify.", distractors: [{"text":"  // Get a point from the user.", reason:"This is a valid alternative, but for a simple test, creating a hardcoded point is easier."}], indent: 1, explanation: "Comment on the query point." },
    { "correct": "  DataPoint new_point = { .x = 1.1, .y = 1.1 };", distractors: [{"text":"  DataPoint new_point = { 1.1, 1.1 };", reason:"This positional initializer also works. Designated initializers (`.x = ...`) are often preferred as they are order-independent and clearer."}], indent: 1, explanation: "This point is visually close to 'ClassA'." },
    { "correct": "  int k = 3;", distractors: [{"text":"  int k = 2;", reason:"Using an even `k` can lead to ties in the voting process. It's common practice to use an odd `k` for a two-class problem to avoid this."}], indent: 1, explanation: "Set the K value (number of neighbors to check)." },
    { "correct": "  printf(\"\\nClassifying new point (%.1f, %.1f) with K=%d...\\n\", new_point.x, new_point.y, k);", distractors: [{"text":"  printf(\"\\nClassifying...\\n\");", reason:"This is less informative. Printing the point being classified and the K value makes the output much easier to understand."}], indent: 1, explanation: "Informational message." },
    { "correct": "  const char* result = classify_point(new_point, k);", distractors: [{"text":"  char* result = classify_point(new_point, k);", reason:"The `classify_point` function returns a `const char*`, so the variable should also be `const` for type correctness."}], indent: 1, explanation: "Run the classifier." },
    { "correct": "  printf(\"Prediction: The new point belongs to %s\\n\", result);", distractors: [{"text":"  printf(\"Prediction: %s\\n\", result ? result : \"Unknown\");", reason:"This is a good safety check, but in our case `classify_point` is guaranteed to return a valid string."}], indent: 1, explanation: "Print the final prediction." },
    { "correct": "  free(training_data);", distractors: [{"text":"  // No free needed for globals.", reason:"This is false. Any memory allocated with `malloc`/`realloc` must be freed, regardless of whether the pointer is global or local."}], indent: 1, explanation: "Free the global dataset array." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 signals an error. This program should return 0 to indicate it ran successfully."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "Close main." }
]
    },
   // Level 85: custom file format for ML datasets
{
    "goal": "Design and implement a custom binary file format for storing ML datasets efficiently.",
    "concepts": "Binary file I/O, fwrite, fread, structs, data serialization, performance",
    "sequence": [
        { correct: "// === Stage 1: Setup and File Format Definition ===", distractors: [{text: "// === Stage 1: CSV File Processing ===", reason: "This section is about defining a binary file format, not processing CSV files."}, {text: "// === Stage 1: Machine Learning Implementation ===", reason: "We're focusing on file format design, not ML algorithms."}], indent: 0, explanation: "Define the necessary includes and the structures that will define our binary file layout." },
        { correct: "#include <stdio.h>", distractors: [{text: "#include <iostream>", reason: "This is C, not C++. We need stdio.h for file I/O functions like fopen, fread, and fwrite."}, {text: "#include <cstdio>", reason: "This is the C++ version. In C, we use stdio.h."}], indent: 0, explanation: "Standard I/O for file operations and printing." },
        { correct: "#include <stdlib.h>", distractors: [{text: "#include <malloc.h>", reason: "While malloc.h exists on some systems, stdlib.h is the standard header for memory allocation and atof/atoi functions."}, {text: "#include <stdlibrary.h>", reason: "The correct header name is stdlib.h."}], indent: 0, explanation: "For memory management and string-to-number conversion." },
        { correct: "#include <string.h>", distractors: [{text: "#include <strings.h>", reason: "string.h is the standard header for string functions like strtok."}, {text: "#include <cstring>", reason: "This is the C++ version. In C, we use string.h."}], indent: 0, explanation: "For string tokenizing." },
        { correct: "#include <stdint.h>", distractors: [{text: "#include <inttypes.h>", reason: "While inttypes.h would work, stdint.h is the standard header specifically for fixed-width integer types."}, {text: "#include <types.h>", reason: "The correct header name is stdint.h for fixed-width integer types."}], indent: 0, explanation: "Include for fixed-width integer types like `uint32_t` for portability." },
        { correct: "// --- Our Custom Binary File Format Definition ---", distractors: [{text: "// --- CSV File Format Definition ---", reason: "We're defining a binary format, not a CSV format."}, {text: "// --- Text File Format Definition ---", reason: "This is specifically about a binary file format, not text."}], indent: 0, explanation: "A good binary format has a header to describe the contents." },
        { correct: "#define MAGIC_NUMBER 0x44415441 // Spells 'DATA' in ASCII", distractors: [{text: "#define MAGIC_NUMBER 1234", reason: "Using a meaningful hex value like 'DATA' in ASCII makes the file format more identifiable and professional."}, {text: "#define MAGIC_NUMBER \"DATA\"", reason: "Magic numbers should be numeric constants, not strings, for efficient binary comparison."}], indent: 0, explanation: "A magic number to identify our file type." },
        { correct: "#define FORMAT_VERSION 1", distractors: [{text: "#define FORMAT_VERSION 0", reason: "Starting with version 1 is more conventional than 0 for file format versioning."}, {text: "#define FORMAT_VERSION \"1.0\"", reason: "Version numbers in binary formats should be integers for efficient storage and comparison."}], indent: 0, explanation: "A version number for our format, allowing for future upgrades." },
        { correct: "// The header that will be at the very beginning of our binary file.", distractors: [{text: "// The data records that will be stored in our file.", reason: "This comment describes the header structure, not the data records."}, {text: "// The footer that will be at the end of our file.", reason: "We're defining a header that goes at the beginning, not a footer."}], indent: 0, explanation: "Comment on the file header struct." },
        { correct: "typedef struct {", distractors: [{text: "struct FileHeader {", reason: "Using typedef struct allows us to use FileHeader as a type name without the struct keyword."}, {text: "typedef class {", reason: "C doesn't have classes. We use struct for data structures."}], indent: 0, explanation: "Begin FileHeader definition." },
        { correct: "  uint32_t magic_number;", distractors: [{text: "  int magic_number;", reason: "uint32_t ensures a consistent 32-bit size across platforms, while int can vary."}, {text: "  char magic_number[4];", reason: "Using uint32_t is more efficient for binary comparison than a character array."}], indent: 1, explanation: "To confirm we're reading the right kind of file." },
        { correct: "  uint32_t version;", distractors: [{text: "  char version;", reason: "uint32_t provides room for future version numbers and maintains alignment."}, {text: "  float version;", reason: "Version numbers should be integers, not floating-point values."}], indent: 1, explanation: "The version of the file format." },
        { correct: "  uint32_t num_records;", distractors: [{text: "  int num_records;", reason: "uint32_t ensures consistent size and prevents negative values which don't make sense for counts."}, {text: "  short num_records;", reason: "uint32_t can handle much larger datasets than short (which is typically 16 bits)."}], indent: 1, explanation: "The total number of data records in the file." },
        { correct: "  uint32_t num_features;", distractors: [{text: "  char num_features;", reason: "uint32_t can handle datasets with more than 255 features, unlike char."}, {text: "  size_t num_features;", reason: "While size_t would work, uint32_t ensures consistent size across platforms for file format compatibility."}], indent: 1, explanation: "The number of features (columns) per record." },
        { correct: "} FileHeader;", distractors: [{text: "};", reason: "We're using typedef struct, so we need to provide the type name FileHeader."}, {text: "} Header;", reason: "FileHeader is more descriptive than just Header."}], indent: 0, explanation: "Close the FileHeader typedef." },
        { correct: "// The struct for a single data record.", distractors: [{text: "// The struct for the file header.", reason: "This comment describes a data record, not the file header."}, {text: "// The struct for multiple records.", reason: "This represents a single record, not multiple records."}], indent: 0, explanation: "Comment on the DataRecord struct." },
        { correct: "typedef struct {", distractors: [{text: "struct DataRecord {", reason: "Using typedef struct is consistent with our FileHeader definition."}, {text: "typedef union {", reason: "We want a struct to hold both features and label together, not a union."}], indent: 0, explanation: "Begin DataRecord definition." },
        { correct: "  float* features;", distractors: [{text: "  double* features;", reason: "float uses half the memory of double and is typically sufficient precision for ML datasets."}, {text: "  int* features;", reason: "ML features are typically floating-point values, not integers."}], indent: 1, explanation: "A dynamic array to hold the numerical features." },
        { correct: "  uint32_t label;", distractors: [{text: "  char* label;", reason: "Using uint32_t for integer class labels is more efficient than string labels."}, {text: "  float label;", reason: "Class labels are typically integers (0, 1, 2, etc.), not floating-point values."}], indent: 1, explanation: "The integer class label for this record." },
        { correct: "} DataRecord;", distractors: [{text: "};", reason: "We need to provide the typedef name DataRecord."}, {text: "} Record;", reason: "DataRecord is more descriptive than just Record."}], indent: 0, explanation: "Close the DataRecord typedef." },
        { correct: "// --- Function Prototypes ---", distractors: [{text: "// --- Function Implementations ---", reason: "This section declares prototypes, not implementations."}, {text: "// --- Global Variables ---", reason: "We're declaring function prototypes here, not variables."}], indent: 0, explanation: "Declare the functions for our conversion tool." },
        { correct: "void convert_csv_to_binary(const char* csv_path, const char* bin_path);", distractors: [{text: "int convert_csv_to_binary(const char* csv_path, const char* bin_path);", reason: "For this example, void is simpler than returning error codes."}, {text: "void convert_csv_to_binary(char* csv_path, char* bin_path);", reason: "const char* indicates we won't modify the path strings."}], indent: 0, explanation: "The main conversion function." },
        { correct: "void verify_binary_file(const char* bin_path);", distractors: [{text: "int verify_binary_file(const char* bin_path);", reason: "void is sufficient for this verification function."}, {text: "void verify_binary_file(char* bin_path);", reason: "const char* indicates we won't modify the path string."}], indent: 0, explanation: "A function to read back and verify the binary file." },
        { correct: "// === Stage 2: The CSV to Binary Converter Tool ===", distractors: [{text: "// === Stage 2: Binary File Reader ===", reason: "This section implements the converter, not just a reader."}, {text: "// === Stage 2: Machine Learning Algorithm ===", reason: "We're implementing file conversion, not ML algorithms."}], indent: 0, explanation: "Implement the logic to read a CSV and write our custom binary format." },
        { correct: "void convert_csv_to_binary(const char* csv_path, const char* bin_path) {", distractors: [{text: "int convert_csv_to_binary(const char* csv_path, const char* bin_path) {", reason: "The function prototype declares void, so the implementation must match."}, {text: "void convert_csv_to_binary(char* csv_path, char* bin_path) {", reason: "Must match the const char* parameters from the prototype."}], indent: 0, explanation: "Start the converter function implementation." },
        { correct: "  printf(\"--- Converting %s to %s ---\\n\", csv_path, bin_path);", distractors: [{text: "  printf(\"Converting files...\\n\");", reason: "Showing the actual filenames being processed is more informative."}, {text: "  printf(\"--- Converting %s to %s ---\", csv_path, bin_path);", reason: "Adding \\n ensures proper formatting."}], indent: 1, explanation: "Informational message." },
        { correct: "  FILE* f_csv = fopen(csv_path, \"r\");", distractors: [{text: "  FILE* f_csv = fopen(csv_path, \"rb\");", reason: "CSV files are text files, so \"r\" mode is correct, not binary \"rb\" mode."}, {text: "  int f_csv = fopen(csv_path, \"r\");", reason: "fopen returns a FILE*, not an int."}], indent: 1, explanation: "Open the source CSV file for reading." },
        { correct: "  if (!f_csv) { perror(\"Failed to open CSV\"); return; }", distractors: [{text: "  if (!f_csv) { printf(\"Error\\n\"); return; }", reason: "perror() provides more detailed system error information than a generic message."}, {text: "  if (f_csv == NULL) exit(1);", reason: "Returning from the function is more graceful than exiting the entire program."}], indent: 1, explanation: "Handle file open error." },
        { correct: "  // First pass over the CSV: count records and features.", distractors: [{text: "  // Read all CSV data into memory.", reason: "We do a counting pass first to determine the file header dimensions."}, {text: "  // Write the binary header immediately.", reason: "We need to count records and features before we can write the header."}], indent: 1, explanation: "We need to know the dimensions before we can write the binary header." },
        { correct: "  uint32_t record_count = 0;", distractors: [{text: "  int record_count = 0;", reason: "uint32_t matches our FileHeader field type and prevents negative values."}, {text: "  size_t record_count = 0;", reason: "uint32_t ensures consistent size for our binary file format."}], indent: 1, explanation: "Initialize record counter." },
        { correct: "  uint32_t feature_count = 0;", distractors: [{text: "  int feature_count = 0;", reason: "uint32_t matches our FileHeader field type."}, {text: "  char feature_count = 0;", reason: "uint32_t can handle datasets with more than 255 features."}], indent: 1, explanation: "Initialize feature counter." },
        { correct: "  char line_buffer[1024];", distractors: [{text: "  char line_buffer[10];", reason: "1024 bytes provides reasonable space for CSV lines. 10 bytes is far too small."}, {text: "  char* line_buffer = malloc(1024);", reason: "A stack-allocated buffer is simpler for this use case."}], indent: 1, explanation: "A buffer to read lines." },
        { correct: "  if (fgets(line_buffer, sizeof(line_buffer), f_csv)) {", distractors: [{text: "  if (fscanf(f_csv, \"%s\", line_buffer)) {", reason: "fgets reads entire lines including commas, while fscanf stops at whitespace."}, {text: "  if (fread(line_buffer, 1024, 1, f_csv)) {", reason: "fgets is designed for reading text lines, while fread is for binary data."}], indent: 1, explanation: "Read the header line to count features." },
        { correct: "    char* token = strtok(line_buffer, \",\\n\");", distractors: [{text: "    char* token = strtok(line_buffer, \" \");", reason: "CSV files use commas as delimiters, not spaces."}, {text: "    char token = strtok(line_buffer, \",\\n\");", reason: "strtok returns a char*, not a char."}], indent: 2, explanation: "Get the first token." },
        { correct: "    while(token) { feature_count++; token = strtok(NULL, \",\\n\"); }", distractors: [{text: "    while(token) { feature_count++; token = strtok(line_buffer, \",\\n\"); }", reason: "After the first call, strtok requires NULL to continue parsing the same string."}, {text: "    for(int i = 0; token; i++) { feature_count++; token = strtok(NULL, \",\\n\"); }", reason: "The while loop is simpler and more direct for this counting operation."}], indent: 2, explanation: "Loop through tokens to count them." },
        { correct: "    feature_count--; // The last column is the label, not a feature.", distractors: [{text: "    // feature_count is correct as-is", reason: "We need to subtract 1 because the last column is the label, not a feature."}, {text: "    feature_count++; // Add one for the label column.", reason: "We subtract because the label is counted as a column but isn't a feature."}], indent: 2, explanation: "Adjust the count to exclude the label column." },
        { correct: "  }", distractors: [{text: "  } else { printf(\"No header found\\n\"); }", reason: "For this example, we assume the CSV has a header."}, {text: "  }\n  printf(\"Found %u features\\n\", feature_count);", reason: "We'll print the summary after counting both features and records."}], indent: 1, explanation: "Close the header processing." },
        { correct: "  while (fgets(line_buffer, sizeof(line_buffer), f_csv)) {", distractors: [{text: "  while (!feof(f_csv)) {", reason: "Using fgets as the loop condition is more reliable than checking feof()."}, {text: "  for (;;) { if (!fgets(line_buffer, sizeof(line_buffer), f_csv)) break;", reason: "The while form is more concise and idiomatic."}], indent: 1, explanation: "Now loop through the rest of the file just to count the lines (records)." },
        { correct: "    record_count++;", distractors: [{text: "    record_count = record_count + 1;", reason: "The ++ operator is more concise."}, {text: "    feature_count++;", reason: "We're counting records here, not features."}], indent: 2, explanation: "Increment the record count for each line." },
        { correct: "  }", distractors: [{text: "  }\n  printf(\"Counted all records\\n\");", reason: "The loop structure is complete with just the closing brace."}, {text: "  } while (!feof(f_csv));", reason: "This is a while loop, not a do-while."}], indent: 1, explanation: "Close the counting loop." },
        { correct: "  printf(\"Found %u records, each with %u features.\\n\", record_count, feature_count);", distractors: [{text: "  printf(\"Found %d records, each with %d features.\\n\", record_count, feature_count);", reason: "uint32_t should be printed with %u, not %d."}, {text: "  printf(\"Counting complete.\\n\");", reason: "Showing the actual counts is more informative than a generic message."}], indent: 1, explanation: "Print the discovered dimensions." },
        { correct: "  rewind(f_csv); // Go back to the start of the CSV file for the second pass.", distractors: [{text: "  fclose(f_csv); f_csv = fopen(csv_path, \"r\"); // Reopen the file", reason: "rewind() is more efficient than closing and reopening the file."}, {text: "  fseek(f_csv, 0, SEEK_SET); // Go to start", reason: "While fseek would work, rewind() is specifically designed for this purpose and is clearer."}], indent: 1, explanation: "Reset the file pointer to the beginning." },
        { correct: "  fgets(line_buffer, sizeof(line_buffer), f_csv); // Skip header again.", distractors: [{text: "  // Header already processed", reason: "We need to skip the header line on the second pass too."}, {text: "  fscanf(f_csv, \"%*[^\\n]\\n\"); // Skip header line", reason: "fgets is simpler and more readable for skipping a line."}], indent: 1, explanation: "Discard the header line on the second pass too." },
        { correct: "  // Now, open the binary file for writing.", distractors: [{text: "  // Continue reading CSV data.", reason: "This comment introduces opening the binary file for writing."}, {text: "  // Process the CSV data in memory.", reason: "We're going to write to a binary file, not process in memory."}], indent: 1, explanation: "Comment on the write step." },
        { correct: "  FILE* f_bin = fopen(bin_path, \"wb\");", distractors: [{text: "  FILE* f_bin = fopen(bin_path, \"w\");", reason: "Binary files must be opened with \"wb\" mode, not text \"w\" mode."}, {text: "  int f_bin = fopen(bin_path, \"wb\");", reason: "fopen returns a FILE*, not an int."}], indent: 1, explanation: "Open the destination file in binary write mode." },
        { correct: "  if (!f_bin) { perror(\"Failed to open binary file for writing\"); fclose(f_csv); return; }", distractors: [{text: "  if (!f_bin) { printf(\"Error\\n\"); return; }", reason: "perror() provides better error information, and we should close f_csv before returning."}, {text: "  if (!f_bin) { perror(\"Failed to open binary file for writing\"); return; }", reason: "We should close the CSV file to avoid resource leaks."}], indent: 1, explanation: "Handle file open error." },
        { correct: "  // Create and write the header.", distractors: [{text: "  // Start writing data records.", reason: "We need to write the header first, before the data records."}, {text: "  // Allocate memory for all data.", reason: "This comment is about writing the header, not memory allocation."}], indent: 1, explanation: "Comment on writing the header." },
        { correct: "  FileHeader header;", distractors: [{text: "  struct FileHeader header;", reason: "We typedef'd FileHeader, so we don't need the struct keyword."}, {text: "  FileHeader* header = malloc(sizeof(FileHeader));", reason: "A stack-allocated struct is simpler for this single header."}], indent: 1, explanation: "Declare a header struct." },
        { correct: "  header.magic_number = MAGIC_NUMBER;", distractors: [{text: "  header.magic_number = 0;", reason: "We should use our defined MAGIC_NUMBER constant."}, {text: "  header.magic_number = \"DATA\";", reason: "magic_number is a uint32_t, not a string."}], indent: 1, explanation: "Set the magic number." },
        { correct: "  header.version = FORMAT_VERSION;", distractors: [{text: "  header.version = 0;", reason: "We should use our defined FORMAT_VERSION constant."}, {text: "  header.version = 1.0;", reason: "version is a uint32_t, not a float."}], indent: 1, explanation: "Set the format version." },
        { correct: "  header.num_records = record_count;", distractors: [{text: "  header.num_records = 0;", reason: "We should use the actual count we calculated."}, {text: "  header.record_count = record_count;", reason: "The field name is num_records, not record_count."}], indent: 1, explanation: "Set the number of records." },
        { correct: "  header.num_features = feature_count;", distractors: [{text: "  header.features = feature_count;", reason: "The field name is num_features, not features."}, {text: "  header.num_features = feature_count + 1;", reason: "feature_count already excludes the label column, so we don't add 1."}], indent: 1, explanation: "Set the number of features." },
        { correct: "  fwrite(&header, sizeof(FileHeader), 1, f_bin);", distractors: [{text: "  fwrite(header, sizeof(FileHeader), 1, f_bin);", reason: "We need the address of the header struct, so we use &header."}, {text: "  fwrite(&header, 1, sizeof(FileHeader), f_bin);", reason: "The correct order is: data pointer, element size, element count, file pointer."}], indent: 1, explanation: "Write the entire header struct to the file." },
        { correct: "  // Second pass: Read CSV data and write to binary file record by record.", distractors: [{text: "  // Read all CSV data into memory first.", reason: "We process record by record for better memory efficiency."}, {text: "  // Write the data records before the header.", reason: "The header must come first in our file format."}], indent: 1, explanation: "Comment on the main conversion loop." },
        { correct: "  float* feature_buffer = malloc(feature_count * sizeof(float));", distractors: [{text: "  float feature_buffer[feature_count];", reason: "Variable-length arrays aren't supported in all C standards. malloc is more portable."}, {text: "  double* feature_buffer = malloc(feature_count * sizeof(double));", reason: "float uses half the memory of double and is sufficient for most ML applications."}], indent: 1, explanation: "Allocate a reusable buffer to hold one record's features." },
        { correct: "  while (fgets(line_buffer, sizeof(line_buffer), f_csv)) {", distractors: [{text: "  while (!feof(f_csv)) {", reason: "Using fgets as the loop condition is more reliable."}, {text: "  for (int i = 0; i < record_count; i++) {", reason: "Using fgets handles variable numbers of actual records more robustly."}], indent: 1, explanation: "Loop through the data lines of the CSV." },
        { correct: "    char* token = strtok(line_buffer, \",\");", distractors: [{text: "    char* token = strtok(line_buffer, \" \");", reason: "CSV files use commas as delimiters."}, {text: "    char token = strtok(line_buffer, \",\");", reason: "strtok returns a char*, not a char."}], indent: 2, explanation: "Get the first token of the line." },
        { correct: "    for (uint32_t i = 0; i < feature_count; i++) {", distractors: [{text: "    for (int i = 0; i < feature_count; i++) {", reason: "uint32_t matches our feature_count type and avoids signed/unsigned comparison warnings."}, {text: "    for (uint32_t i = 0; i <= feature_count; i++) {", reason: "Using < is correct for 0-based indexing. <= would read one too many features."}], indent: 2, explanation: "Loop to read all the feature columns." },
        { correct: "      feature_buffer[i] = atof(token);", distractors: [{text: "      feature_buffer[i] = atoi(token);", reason: "atof() converts to float, while atoi() converts to int. Features are typically floating-point."}, {text: "      feature_buffer[i] = token;", reason: "We need to convert the string token to a float using atof()."}], indent: 3, explanation: "Convert the string token to a float and store it." },
        { correct: "      token = strtok(NULL, \",\");", distractors: [{text: "      token = strtok(line_buffer, \",\");", reason: "After the first call, strtok requires NULL to continue parsing the same string."}, {text: "      token = strtok(NULL, \" \");", reason: "CSV files use commas, not spaces."}], indent: 3, explanation: "Get the next token." },
        { correct: "    }", distractors: [{text: "    }\n    break;", reason: "We want to read all features, not break after the first one."}, {text: "    } while (token);", reason: "This is a for loop, not a do-while."}], indent: 2, explanation: "Close the feature reading loop." },
        { correct: "    uint32_t label = atoi(token); // The last token is the label", distractors: [{text: "    float label = atof(token); // The last token is the label", reason: "Labels are typically integers (class indices), not floating-point values."}, {text: "    char* label = token; // The last token is the label", reason: "We need to convert to uint32_t to match our DataRecord structure."}], indent: 2, explanation: "Convert the final token to an integer label." },
        { correct: "    // Write the features and label for this record to the binary file.", distractors: [{text: "    // Store the record in memory.", reason: "We're writing directly to the binary file, not storing in memory."}, {text: "    // Validate the data values.", reason: "This comment describes the writing operation that follows."}], indent: 2, explanation: "Comment on writing the record." },
        { correct: "    fwrite(feature_buffer, sizeof(float), feature_count, f_bin);", distractors: [{text: "    fwrite(&feature_buffer, sizeof(float), feature_count, f_bin);", reason: "feature_buffer is already a pointer to the array, so we don't need &."}, {text: "    fwrite(feature_buffer, feature_count, sizeof(float), f_bin);", reason: "The correct order is: data pointer, element size, element count, file pointer."}], indent: 2, explanation: "Write the feature data for this record." },
        { correct: "    fwrite(&label, sizeof(uint32_t), 1, f_bin);", distractors: [{text: "    fwrite(label, sizeof(uint32_t), 1, f_bin);", reason: "label is a variable, so we need its address (&label) to write it."}, {text: "    fwrite(&label, 1, sizeof(uint32_t), f_bin);", reason: "The correct order is: data pointer, element size, element count, file pointer."}], indent: 2, explanation: "Write the label for this record." },
        { correct: "  }", distractors: [{text: "  }\n  printf(\"All records written\\n\");", reason: "The loop structure is complete."}, {text: "  } while (fgets(line_buffer, sizeof(line_buffer), f_csv));", reason: "This is a while loop, not a do-while."}], indent: 1, explanation: "Close the main conversion loop." },
        { correct: "  printf(\"Conversion complete.\\n\");", distractors: [{text: "  printf(\"Done.\\n\");", reason: "'Conversion complete' is more descriptive than just 'Done'."}, {text: "  // Conversion finished", reason: "A printf statement provides better user feedback than just a comment."}], indent: 1, explanation: "Confirmation message." },
        { correct: "  // Cleanup.", distractors: [{text: "  // End of function.", reason: "More specific to mention this is cleanup."}, {text: "  // Return to caller.", reason: "This comment describes the cleanup operations that follow."}], indent: 1, explanation: "Comment on cleanup." },
        { correct: "  free(feature_buffer);", distractors: [{text: "  delete feature_buffer;", reason: "delete is C++. In C, we use free() for malloc'd memory."}, {text: "  // feature_buffer will be freed automatically", reason: "We must explicitly free dynamically allocated memory."}], indent: 1, explanation: "Free the temporary buffer." },
        { correct: "  fclose(f_csv);", distractors: [{text: "  free(f_csv);", reason: "File pointers are closed with fclose(), not freed with free()."}, {text: "  delete f_csv;", reason: "delete is C++. In C, we use fclose() for file pointers."}], indent: 1, explanation: "Close the CSV file." },
        { correct: "  fclose(f_bin);", distractors: [{text: "  free(f_bin);", reason: "File pointers are closed with fclose(), not freed with free()."}, {text: "  // File will close automatically", reason: "We should explicitly close files when we're done with them."}], indent: 1, explanation: "Close the binary file." },
        { correct: "}", distractors: [{text: "  return 0;\n}", reason: "This function returns void, not int."}, {text: "  fclose(f_csv);\n  fclose(f_bin);\n}", reason: "The cleanup code is already included above."}], indent: 0, explanation: "Close the converter function." },
        { correct: "// === Stage 3: Verification Function ===", distractors: [{text: "// === Stage 3: Data Processing Function ===", reason: "This section implements verification, not data processing."}, {text: "// === Stage 3: Machine Learning Function ===", reason: "We're implementing file verification, not ML algorithms."}], indent: 0, explanation: "A function to read our custom binary file and prove it worked." },
        { correct: "void verify_binary_file(const char* bin_path) {", distractors: [{text: "int verify_binary_file(const char* bin_path) {", reason: "The function prototype declares void, so the implementation must match."}, {text: "void verify_binary_file(char* bin_path) {", reason: "Must match the const char* parameter from the prototype."}], indent: 0, explanation: "Start the verification function." },
        { correct: "  printf(\"\\n--- Verifying binary file: %s ---\\n\", bin_path);", distractors: [{text: "  printf(\"Verifying file...\\n\");", reason: "Showing the actual filename being verified is more informative."}, {text: "  printf(\"\\n--- Verifying binary file: %s ---\", bin_path);", reason: "Adding \\n ensures proper formatting."}], indent: 1, explanation: "Header message." },
        { correct: "  FILE* fp = fopen(bin_path, \"rb\");", distractors: [{text: "  FILE* fp = fopen(bin_path, \"r\");", reason: "Binary files must be opened with \"rb\" mode, not text \"r\" mode."}, {text: "  int fp = fopen(bin_path, \"rb\");", reason: "fopen returns a FILE*, not an int."}], indent: 1, explanation: "Open the binary file for reading." },
        { correct: "  if (!fp) { perror(\"Failed to open binary file for verification\"); return; }", distractors: [{text: "  if (!fp) { printf(\"Error\\n\"); return; }", reason: "perror() provides more detailed system error information."}, {text: "  if (fp == NULL) exit(1);", reason: "Returning from the function is more graceful than exiting the program."}], indent: 1, explanation: "Handle file open error." },
        { correct: "  // Read and verify the header.", distractors: [{text: "  // Skip the header and read data.", reason: "We need to verify the header first to understand the file format."}, {text: "  // Read all data into memory.", reason: "This comment describes reading and verifying the header specifically."}], indent: 1, explanation: "Comment on header verification." },
        { correct: "  FileHeader header;", distractors: [{text: "  struct FileHeader header;", reason: "We typedef'd FileHeader, so we don't need the struct keyword."}, {text: "  FileHeader* header = malloc(sizeof(FileHeader));", reason: "A stack-allocated struct is simpler for reading a single header."}], indent: 1, explanation: "Declare a struct to hold the read header." },
        { correct: "  if (fread(&header, sizeof(FileHeader), 1, fp) != 1) {", distractors: [{text: "  if (fread(header, sizeof(FileHeader), 1, fp) != 1) {", reason: "We need the address of the header struct, so we use &header."}, {text: "  if (fread(&header, 1, sizeof(FileHeader), fp) != 1) {", reason: "The correct order is: data pointer, element size, element count, file pointer."}], indent: 1, explanation: "Read the header from the file." },
        { correct: "    printf(\"Could not read file header.\\n\"); fclose(fp); return;", distractors: [{text: "    printf(\"Could not read file header.\\n\"); return;", reason: "We should close the file before returning to avoid resource leaks."}, {text: "    perror(\"Read error\"); fclose(fp); return;", reason: "A descriptive message is clearer than a generic perror for this specific case."}], indent: 2, explanation: "Handle read error." },
        { correct: "  }", distractors: [{text: "  } else {", reason: "The else is unnecessary since we return from the if block."}, {text: "  }\n  printf(\"Header read successfully\\n\");", reason: "We'll print header details next."}], indent: 1, explanation: "Close read check." },
        { correct: "  printf(\"Header OK: Magic=0x%X, Version=%u, Records=%u, Features=%u\\n\",", distractors: [{text: "  printf(\"Header read successfully.\\n\");", reason: "Showing the actual header values is more informative than just saying it was read."}, {text: "  printf(\"Header OK: Magic=%d, Version=%d, Records=%d, Features=%d\\n\",", reason: "Hex format (0x%X) is more appropriate for magic numbers, and %u is correct for uint32_t values."}], indent: 1, explanation: "Print the header data." },
        { correct: "         header.magic_number, header.version, header.num_records, header.num_features);", distractors: [{text: "         &header.magic_number, &header.version, &header.num_records, &header.num_features);", reason: "For printf, we pass the values directly, not their addresses."}, {text: "         header.magic_number, header.version, header.record_count, header.feature_count);", reason: "The field names are num_records and num_features."}], indent: 9, explanation: "Continue printing header data." },
        { correct: "  if (header.magic_number != MAGIC_NUMBER) {", distractors: [{text: "  if (header.magic_number == MAGIC_NUMBER) {", reason: "We want to check for the error condition (not equal) to handle invalid files."}, {text: "  if (header.magic_number != 0x44415441) {", reason: "Using the MAGIC_NUMBER constant is more maintainable than hardcoding the hex value."}], indent: 1, explanation: "Validate the magic number." },
        { correct: "    printf(\"Error: Invalid magic number! This is not our file type.\\n\"); fclose(fp); return;", distractors: [{text: "    printf(\"Error: Invalid magic number! This is not our file type.\\n\"); return;", reason: "We should close the file before returning."}, {text: "    printf(\"Magic number is correct.\\n\");", reason: "This is the error case where the magic number is wrong."}], indent: 2, explanation: "Error if magic number is wrong." },
        { correct: "  }", distractors: [{text: "  } else { printf(\"Magic number verified.\\n\"); }", reason: "We'll continue with verification rather than printing intermediate success messages."}, {text: "  }\n  return;", reason: "We want to continue with the verification process."}], indent: 1, explanation: "Close magic number check." },
        { correct: "  // Read and print the first 3 records to verify.", distractors: [{text: "  // Read all records into memory.", reason: "We only read a few records for verification, not all of them."}, {text: "  // Skip the data records.", reason: "We want to read and verify some records, not skip them."}], indent: 1, explanation: "Comment on verifying records." },
        { correct: "  printf(\"Displaying first 3 records...\\n\");", distractors: [{text: "  printf(\"Reading data...\\n\");", reason: "Being specific about displaying the first 3 records is more informative."}, {text: "  printf(\"Displaying first 3 records...\");", reason: "Adding \\n ensures proper formatting."}], indent: 1, explanation: "Informational message." },
        { correct: "  float* feature_buffer = malloc(header.num_features * sizeof(float));", distractors: [{text: "  float feature_buffer[header.num_features];", reason: "Variable-length arrays aren't supported in all C standards. malloc is more portable."}, {text: "  double* feature_buffer = malloc(header.num_features * sizeof(double));", reason: "We should match the float type used when writing the file."}], indent: 1, explanation: "Allocate a buffer to hold features for one record." },
        { correct: "  for (uint32_t i = 0; i < 3 && i < header.num_records; i++) {", distractors: [{text: "  for (int i = 0; i < 3; i++) {", reason: "uint32_t matches our header field types, and we should check we don't exceed the actual number of records."}, {text: "  for (uint32_t i = 0; i < header.num_records; i++) {", reason: "We only want to display the first 3 records for verification, not all records."}], indent: 1, explanation: "Loop to read a few records." },
        { correct: "    uint32_t label;", distractors: [{text: "    int label;", reason: "uint32_t matches the type we used when writing the file."}, {text: "    char* label;", reason: "Labels are stored as uint32_t integers, not strings."}], indent: 2, explanation: "A variable to hold the read label." },
        { correct: "    fread(feature_buffer, sizeof(float), header.num_features, fp);", distractors: [{text: "    fread(&feature_buffer, sizeof(float), header.num_features, fp);", reason: "feature_buffer is already a pointer to the array, so we don't need &."}, {text: "    fread(feature_buffer, header.num_features, sizeof(float), fp);", reason: "The correct order is: data pointer, element size, element count, file pointer."}], indent: 2, explanation: "Read the feature data for one record." },
        { correct: "    fread(&label, sizeof(uint32_t), 1, fp);", distractors: [{text: "    fread(label, sizeof(uint32_t), 1, fp);", reason: "label is a variable, so we need its address (&label) to read into it."}, {text: "    fread(&label, 1, sizeof(uint32_t), fp);", reason: "The correct order is: data pointer, element size, element count, file pointer."}], indent: 2, explanation: "Read the label for that record." },
        { correct: "    printf(\"  Record %u: [ \", i);", distractors: [{text: "    printf(\"  Record %d: [ \", i);", reason: "uint32_t should be printed with %u, not %d."}, {text: "    printf(\"Record %u: \", i);", reason: "The spacing and bracket format makes the output more readable."}], indent: 2, explanation: "Print a record header." },
        { correct: "    for (uint32_t j = 0; j < header.num_features; j++) {", distractors: [{text: "    for (int j = 0; j < header.num_features; j++) {", reason: "uint32_t matches our header field type and avoids signed/unsigned comparison warnings."}, {text: "    for (uint32_t j = 0; j <= header.num_features; j++) {", reason: "Using < is correct for 0-based indexing. <= would print one too many features."}], indent: 2, explanation: "Loop to print the features." },
        { correct: "      printf(\"%.2f \", feature_buffer[j]);", distractors: [{text: "      printf(\"%f \", feature_buffer[j]);", reason: "%.2f limits to 2 decimal places for cleaner output."}, {text: "      printf(\"%d \", feature_buffer[j]);", reason: "Features are floats, so we need %f or %.2f, not %d."}], indent: 3, explanation: "Print each feature." },
        { correct: "    }", distractors: [{text: "    }\n    printf(\"\\n\");", reason: "We'll print the closing bracket and label on the same line."}, {text: "    } while (j < header.num_features);", reason: "This is a for loop, not a do-while."}], indent: 2, explanation: "Close the feature printing loop." },
        { correct: "    printf(\"] Label: %u\\n\", label);", distractors: [{text: "    printf(\"] Label: %d\\n\", label);", reason: "uint32_t should be printed with %u, not %d."}, {text: "    printf(\"Label: %u\\n\", label);", reason: "Including the closing bracket maintains the format started above."}], indent: 2, explanation: "Print the label." },
        { correct: "  }", distractors: [{text: "  }\n  printf(\"Verification complete\\n\");", reason: "The loop structure is complete."}, {text: "  } while (i < 3);", reason: "This is a for loop, not a do-while."}], indent: 1, explanation: "Close the verification loop." },
        { correct: "  free(feature_buffer);", distractors: [{text: "  delete feature_buffer;", reason: "delete is C++. In C, we use free() for malloc'd memory."}, {text: "  // Buffer will be freed automatically", reason: "We must explicitly free dynamically allocated memory."}], indent: 1, explanation: "Free the buffer." },
        { correct: "  fclose(fp);", distractors: [{text: "  free(fp);", reason: "File pointers are closed with fclose(), not freed with free()."}, {text: "  delete fp;", reason: "delete is C++. In C, we use fclose() for file pointers."}], indent: 1, explanation: "Close the file." },
        { correct: "}", distractors: [{text: "  printf(\"Verification complete\\n\");\n}", reason: "The function is complete without additional messages."}, {text: "  return 0;\n}", reason: "This function returns void."}], indent: 0, explanation: "Close the verification function." },
        { correct: "// === Stage 4: Main Program Driver ===", distractors: [{text: "// === Stage 4: Test Functions ===", reason: "This is the main program driver that demonstrates the tool, not just test functions."}, {text: "// === Stage 4: Machine Learning Training ===", reason: "We're implementing a file conversion tool, not ML training."}], indent: 0, explanation: "A `main` function to run our tool." },
        { correct: "int main() {", distractors: [{text: "void main() {", reason: "Standard C requires main to return int."}, {text: "int main(void) {", reason: "While main(void) is valid, main() is equally correct and more common."}], indent: 0, explanation: "Start main." },
        { correct: "  const char* csv_file = \"iris.csv\";", distractors: [{text: "  char* csv_file = \"iris.csv\";", reason: "const char* indicates we won't modify the string literal."}, {text: "  char csv_file[] = \"iris.csv\";", reason: "Using a pointer to string literal is more efficient than copying to an array."}], indent: 1, explanation: "The name of our source CSV file." },
        { correct: "  const char* bin_file = \"iris.bin\";", distractors: [{text: "  char* bin_file = \"iris.bin\";", reason: "const char* indicates we won't modify the string literal."}, {text: "  char bin_file[20];", reason: "Using a string literal is simpler than declaring an array for a fixed filename."}], indent: 1, explanation: "The name of our destination binary file." },
        { correct: "  // Create a dummy CSV file for the demo.", distractors: [{text: "  // Load existing CSV data.", reason: "We're creating dummy data for this demonstration."}, {text: "  // Process machine learning data.", reason: "This comment describes creating test data, not processing ML algorithms."}], indent: 1, explanation: "Comment on creating dummy data." },
        { correct: "  FILE* f = fopen(csv_file, \"w\");", distractors: [{text: "  FILE* f = fopen(csv_file, \"wb\");", reason: "CSV files are text files, so \"w\" mode is correct, not binary \"wb\" mode."}, {text: "  int f = fopen(csv_file, \"w\");", reason: "fopen returns a FILE*, not an int."}], indent: 1, explanation: "Open the CSV for writing." },
        { correct: "  fprintf(f, \"sepal_length,sepal_width,petal_length,petal_width,species\\n\");", distractors: [{text: "  fprintf(f, \"feature1,feature2,feature3,feature4,label\\n\");", reason: "Using descriptive names like the Iris dataset features makes the example more realistic."}, {text: "  printf(\"sepal_length,sepal_width,petal_length,petal_width,species\\n\");", reason: "We want to write to the file, not print to the console."}], indent: 1, explanation: "Write the header." },
        { correct: "  fprintf(f, \"5.1,3.5,1.4,0.2,0\\n\");", distractors: [{text: "  fprintf(f, \"1,2,3,4,0\\n\");", reason: "Using realistic Iris dataset values makes the example more meaningful."}, {text: "  printf(\"5.1,3.5,1.4,0.2,0\\n\");", reason: "We want to write to the file, not print to the console."}], indent: 1, explanation: "Write the first data record (species 0)." },
        { correct: "  fprintf(f, \"7.0,3.2,4.7,1.4,1\\n\");", distractors: [{text: "  fprintf(f, \"5.1,3.5,1.4,0.2,1\\n\");", reason: "Using different feature values shows variety in the dataset."}, {text: "  fprintf(f, \"7.0,3.2,4.7,1.4,0\\n\");", reason: "Using different species labels (0, 1, 2) demonstrates classification."}], indent: 1, explanation: "Write the second data record (species 1)." },
        { correct: "  fprintf(f, \"6.3,3.3,6.0,2.5,2\\n\");", distractors: [{text: "  fprintf(f, \"6.3,3.3,6.0,2.5,1\\n\");", reason: "Using species label 2 shows a third class in the dataset."}, {text: "  fputs(\"6.3,3.3,6.0,2.5,2\\n\", f);", reason: "fprintf is consistent with the other lines and allows easier formatting."}], indent: 1, explanation: "Write the third data record (species 2)." },
        { correct: "  fprintf(f, \"4.9,3.0,1.4,0.2,0\\n\");", distractors: [{text: "  fprintf(f, \"4.9,3.0,1.4,0.2,3\\n\");", reason: "Using species 0 again shows multiple samples per class."}, {text: "  // Only 3 records needed", reason: "Adding a fourth record provides more data for demonstration."}], indent: 1, explanation: "Write a fourth data record." },
        { correct: "  fclose(f);", distractors: [{text: "  free(f);", reason: "File pointers are closed with fclose(), not freed with free()."}, {text: "  // File will close automatically", reason: "We should explicitly close files when we're done writing to them."}], indent: 1, explanation: "Close the dummy CSV." },
        { correct: "  convert_csv_to_binary(csv_file, bin_file);", distractors: [{text: "  convert_csv_to_binary(\"iris.csv\", \"iris.bin\");", reason: "Using the variables is more maintainable than hardcoding strings."}, {text: "  convert_csv_to_binary(bin_file, csv_file);", reason: "The order should be source CSV file first, then destination binary file."}], indent: 1, explanation: "Run the conversion process." },
        { correct: "  verify_binary_file(bin_file);", distractors: [{text: "  verify_binary_file(csv_file);", reason: "We want to verify the binary file we just created, not the CSV file."}, {text: "  verify_binary_file(\"iris.bin\");", reason: "Using the variable is more maintainable than hardcoding the string."}], indent: 1, explanation: "Run the verification process." },
        { correct: "  return 0;", distractors: [{text: "  return 1;", reason: "Return 0 to indicate successful program execution."}, {text: "  exit(0);", reason: "return 0 is more conventional than exit(0) in main()."}], indent: 1, explanation: "Indicate success." },
        { correct: "}", distractors: [{text: "  return 0;\n}", reason: "The return statement is already included above."}, {text: "}\n\n", reason: "One closing brace is sufficient."}], indent: 0, explanation: "Close main." }
    ]
},
    // Level 86: Forward pass predictions
{
    "goal": "Implement the forward pass of a simple, pre-trained neural network to make a prediction.",
    concepts: "Matrix multiplication, activation functions, structs, inference, deep learning fundamentals",
    sequence: [
        { correct: "// === Stage 1: Setup and Prerequisite Matrix Library ===", distractors: [{text: "// === Stage 1: Setup and Prerequisites Matrix Library ===", reason: "Should be 'Prerequisite' (singular) not 'Prerequisites' in this context."}, {text: "// === Step 1: Setup and Prerequisite Matrix Library ===", reason: "Using 'Stage' is more appropriate for major sections than 'Step'."}], indent: 0, explanation: "We need a basic matrix math library. We will include a simplified version here." },
        { correct: "#include <stdio.h>", distractors: [{text: "include <stdio.h>", reason: "Preprocessor directives must begin with '#'."}, {text: "#include \"stdio.h\"", reason: "Standard library headers use angle brackets <>, not quotes."}], indent: 0, explanation: "Standard I/O." },
        { correct: "#include <stdlib.h>", distractors: [{text: "#include <malloc.h>", reason: "While malloc.h exists on some systems, stdlib.h is the standard header for malloc."}, {text: "#include <memory.h>", reason: "memory.h is not standard C; malloc is declared in stdlib.h."}], indent: 0, explanation: "Memory management." },
        { correct: "#include <string.h>", distractors: [{text: "#include <strings.h>", reason: "strings.h is a different header; memset is in string.h."}, {text: "#include <cstring.h>", reason: "cstring.h doesn't exist in C; that's a C++ header without the .h."}], indent: 0, explanation: "For `memset`." },
        { correct: "#include <math.h>", distractors: [{text: "#include <mathematics.h>", reason: "The standard math header is simply math.h, not mathematics.h."}, {text: "#include <cmath.h>", reason: "cmath.h doesn't exist; cmath is C++ without .h extension."}], indent: 0, explanation: "For activation functions like `tanh`." },
        { correct: "typedef struct { size_t rows; size_t cols; float* data; } Matrix;", distractors: [{text: "struct Matrix { size_t rows; size_t cols; float* data; };", reason: "Using typedef creates an alias 'Matrix' so you don't need 'struct Matrix' everywhere."}, {text: "typedef struct { int rows; int cols; float* data; } Matrix;", reason: "size_t is preferred for array indices and sizes as it's guaranteed to be large enough."}], indent: 0, explanation: "A simple struct to represent a matrix." },
        { correct: "#define M_AT(m, r, c) (m).data[(r) * (m).cols + (c)]", distractors: [{text: "#define M_AT(m, r, c) m.data[r * m.cols + c]", reason: "Parentheses around macro parameters prevent operator precedence issues."}, {text: "#define M_AT(m, r, c) (m).data[(r) + (c) * (m).rows]", reason: "This would be column-major order; we want row-major: row * cols + col."}], indent: 0, explanation: "A macro for easy 2D access into the flat data array." },
        { correct: "Matrix matrix_create(size_t rows, size_t cols) {", distractors: [{text: "Matrix* matrix_create(size_t rows, size_t cols) {", reason: "We're returning the struct by value, not a pointer to it."}, {text: "void matrix_create(Matrix* m, size_t rows, size_t cols) {", reason: "This would modify an existing matrix; we want to create and return a new one."}], indent: 0, explanation: "Constructor for a Matrix." },
        { correct: "  Matrix m; m.rows = rows; m.cols = cols;", distractors: [{text: "  Matrix m = {rows, cols, NULL};", reason: "While this works, the separate assignment style is clearer for educational purposes."}, {text: "  Matrix m; m.rows = cols; m.cols = rows;", reason: "This swaps rows and columns, which would cause dimension errors later."}], indent: 1, explanation: "Declare and initialize rows/cols." },
        { correct: "  m.data = malloc(rows * cols * sizeof(float));", distractors: [{text: "  m.data = calloc(rows * cols, sizeof(float));", reason: "calloc would work but we explicitly use memset below for educational purposes."}, {text: "  m.data = malloc(rows * cols * sizeof(int));", reason: "We need space for floats, not ints."}], indent: 1, explanation: "Allocate memory for the data." },
        { correct: "  memset(m.data, 0, rows * cols * sizeof(float));", distractors: [{text: "  memset(m.data, 0, rows * cols);", reason: "Need to multiply by sizeof(float) to get the correct number of bytes."}, {text: "  memset(m.data, NULL, rows * cols * sizeof(float));", reason: "memset takes an int value (0), not NULL."}], indent: 1, explanation: "Initialize the data to zero." },
        { correct: "  return m;", distractors: [{text: "  return &m;", reason: "We're returning the struct by value, not its address."}, {text: "  return *m;", reason: "m is already a struct, not a pointer, so no dereference needed."}], indent: 1, explanation: "Return the new matrix." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "return;", reason: "We already returned the matrix; this would be unreachable code."}], indent: 0, explanation: "Close `matrix_create`." },
        { correct: "void matrix_destroy(Matrix m) { free(m.data); }", distractors: [{text: "void matrix_destroy(Matrix* m) { free(m->data); }", reason: "We're passing the matrix by value to match our create function's return style."}, {text: "void matrix_destroy(Matrix m) { delete m.data; }", reason: "C uses free(), not delete (which is C++)."}], indent: 0, explanation: "Destructor for a Matrix." },
        { correct: "void matrix_print(Matrix m, const char* name) {", distractors: [{text: "void matrix_print(Matrix m, char* name) {", reason: "The name shouldn't be modified, so const char* is more appropriate."}, {text: "void matrix_print(Matrix* m, const char* name) {", reason: "We're consistently passing matrices by value in this simple implementation."}], indent: 0, explanation: "A function to print a matrix." },
        { correct: "  printf(\"%s (%zu x %zu):\\n\", name, m.rows, m.cols);", distractors: [{text: "printf(\"%s (%d x %d):\\n\", name, m.rows, m.cols);", reason: "size_t should use %zu format specifier, not %d."}, {text: "printf(\"%s (%lu x %lu):\\n\", name, m.rows, m.cols);", reason: "%lu is for unsigned long; size_t uses %zu."}], indent: 1, explanation: "Print the name and dimensions." },
        { correct: "  for(size_t r=0; r<m.rows; ++r) {", distractors: [{text: "for(int r=0; r<m.rows; ++r) {", reason: "size_t is more appropriate for array indices than int."}, {text: "for(size_t r=1; r<=m.rows; ++r) {", reason: "Array indices start at 0, not 1."}], indent: 1, explanation: "Loop through rows." },
        { correct: "    printf(\"  [ \");", distractors: [{text: "printf(\"[ \");", reason: "The extra spaces provide better formatting alignment."}, {text: "printf(\"  [\");", reason: "Missing space after bracket makes output less readable."}], indent: 2, explanation: "Print opening bracket." },
        { correct: "    for(size_t c=0; c<m.cols; ++c) printf(\"%6.2f \", M_AT(m, r, c));", distractors: [{text: "for(size_t c=0; c<m.cols; ++c) printf(\"%.2f \", M_AT(m, r, c));", reason: "The %6.2f provides better column alignment than %.2f."}, {text: "for(size_t c=0; c<m.cols; ++c) printf(\"%f \", M_AT(m, r, c));", reason: "%.2f limits decimal places for cleaner output than %f."}], indent: 2, explanation: "Loop through columns and print each element." },
        { correct: "    printf(\"]\\n\");", distractors: [{text: "printf(\"]\\n\\n\");", reason: "Single newline is sufficient; double newline would add extra spacing."}, {text: "printf(\"]\");", reason: "Missing newline would put all rows on the same line."}], indent: 2, explanation: "Print closing bracket." },
        { correct: "  }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "end for;", reason: "C uses } to close blocks, not 'end for'."}], indent: 1, explanation: "Close row loop." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "return;", reason: "void functions don't need explicit return at the end."}], indent: 0, explanation: "Close `matrix_print`." },
        { correct: "Matrix matrix_multiply(Matrix a, Matrix b) {", distractors: [{text: "Matrix matrix_multiply(Matrix* a, Matrix* b) {", reason: "We're consistently passing matrices by value in this implementation."}, {text: "void matrix_multiply(Matrix a, Matrix b, Matrix* result) {", reason: "Our design returns a new matrix rather than modifying an existing one."}], indent: 0, explanation: "Implementation of matrix multiplication." },
        { correct: "  if (a.cols != b.rows) { printf(\"Matrix dimension mismatch!\\n\"); return (Matrix){0}; }", distractors: [{text: "if (a.rows != b.cols) { printf(\"Matrix dimension mismatch!\\n\"); return (Matrix){0}; }", reason: "For A×B, we need A.cols == B.rows, not A.rows == B.cols."}, {text: "if (a.cols != b.rows) { printf(\"Matrix dimension mismatch!\\n\"); return NULL; }", reason: "We're returning a Matrix struct, not a pointer, so use {0} not NULL."}], indent: 1, explanation: "Check for compatible dimensions." },
        { correct: "  Matrix c = matrix_create(a.rows, b.cols);", distractors: [{text: "Matrix c = matrix_create(a.cols, b.rows);", reason: "Result matrix has dimensions A.rows × B.cols, not A.cols × B.rows."}, {text: "Matrix c = matrix_create(b.rows, a.cols);", reason: "This swaps the dimensions; should be A.rows × B.cols."}], indent: 1, explanation: "Create the result matrix." },
        { correct: "  for (size_t i = 0; i < a.rows; i++) {", distractors: [{text: "for (int i = 0; i < a.rows; i++) {", reason: "size_t is more appropriate for array indices than int."}, {text: "for (size_t i = 1; i <= a.rows; i++) {", reason: "Array indices start at 0, not 1."}], indent: 1, explanation: "Loop through rows of A." },
        { correct: "    for (size_t j = 0; j < b.cols; j++) {", distractors: [{text: "for (size_t j = 0; j < a.cols; j++) {", reason: "We're iterating through columns of B, not columns of A."}, {text: "for (size_t j = 0; j < b.rows; j++) {", reason: "We're iterating through columns of B (b.cols), not rows of B."}], indent: 2, explanation: "Loop through columns of B." },
        { correct: "      float sum = 0;", distractors: [{text: "int sum = 0;", reason: "We're working with float matrices, so sum should be float too."}, {text: "float sum;", reason: "sum needs to be initialized to 0 before accumulating values."}], indent: 3, explanation: "Initialize sum for dot product." },
        { correct: "      for (size_t k = 0; k < a.cols; k++) {", distractors: [{text: "for (size_t k = 0; k < a.rows; k++) {", reason: "The inner loop goes through A.cols (which equals B.rows)."}, {text: "for (size_t k = 0; k < b.cols; k++) {", reason: "The inner loop should iterate through the shared dimension: A.cols."}], indent: 3, explanation: "Loop for dot product." },
        { correct: "        sum += M_AT(a, i, k) * M_AT(b, k, j);", distractors: [{text: "sum += M_AT(a, k, i) * M_AT(b, j, k);", reason: "This swaps indices; should be A[i,k] × B[k,j]."}, {text: "sum += M_AT(a, i, j) * M_AT(b, k, j);", reason: "Incorrect indices; matrix multiplication uses A[i,k] × B[k,j]."}], indent: 4, explanation: "Perform the multiplication and add to sum." },
        { correct: "      }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "M_AT(c, i, j) = sum;", reason: "Setting the result should happen after the inner loop completes."}], indent: 3, explanation: "Close dot product loop." },
        { correct: "      M_AT(c, i, j) = sum;", distractors: [{text: "M_AT(c, j, i) = sum;", reason: "This would transpose the result; should be C[i,j]."}, {text: "c.data[i + j] = sum;", reason: "This is incorrect indexing; should use the M_AT macro or proper 2D indexing."}], indent: 3, explanation: "Set the result in the new matrix." },
        { correct: "    }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "continue;", reason: "continue is unnecessary at the end of a loop."}], indent: 2, explanation: "Close column loop." },
        { correct: "  }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "matrix_destroy(c);", reason: "We want to return c, not destroy it."}], indent: 1, explanation: "Close row loop." },
        { correct: "  return c;", distractors: [{text: "return &c;", reason: "We're returning the struct by value, not its address."}, {text: "return c.data;", reason: "We want to return the entire Matrix struct, not just the data pointer."}], indent: 1, explanation: "Return the result." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "return;", reason: "We already returned c; this would be unreachable."}], indent: 0, explanation: "Close `matrix_multiply`." },
        { correct: "Matrix matrix_add(Matrix a, Matrix b) {", distractors: [{text: "Matrix matrix_add(Matrix a, Matrix b, Matrix c) {", reason: "We create and return a new matrix rather than taking a result parameter."}, {text: "void matrix_add(Matrix a, Matrix b) {", reason: "We need to return the result matrix."}], indent: 0, explanation: "Implementation of matrix addition." },
        { correct: "  if (a.rows != b.rows || a.cols != b.cols) { printf(\"Matrix dimension mismatch!\\n\"); return (Matrix){0}; }", distractors: [{text: "if (a.rows != b.cols || a.cols != b.rows) { printf(\"Matrix dimension mismatch!\\n\"); return (Matrix){0}; }", reason: "Matrix addition requires identical dimensions: A.rows == B.rows AND A.cols == B.cols."}, {text: "if (a.rows != b.rows && a.cols != b.cols) { printf(\"Matrix dimension mismatch!\\n\"); return (Matrix){0}; }", reason: "Should use || (OR) not && (AND); both dimensions must match."}], indent: 1, explanation: "Check that dimensions are identical." },
        { correct: "  Matrix c = matrix_create(a.rows, a.cols);", distractors: [{text: "Matrix c = matrix_create(b.rows, b.cols);", reason: "While equivalent (since dimensions must match), using 'a' is more consistent."}, {text: "Matrix c = matrix_create(a.rows + b.rows, a.cols + b.cols);", reason: "Addition doesn't change matrix dimensions; result has same size as inputs."}], indent: 1, explanation: "Create the result matrix." },
        { correct: "  for (size_t i = 0; i < a.rows * a.cols; i++) { c.data[i] = a.data[i] + b.data[i]; }", distractors: [{text: "for (size_t i = 0; i < a.rows * a.cols; i++) { c.data[i] = a.data[i] * b.data[i]; }", reason: "This would be element-wise multiplication, not addition."}, {text: "for (size_t i = 0; i < a.rows; i++) { c.data[i] = a.data[i] + b.data[i]; }", reason: "This only processes the first row; should iterate through all elements."}], indent: 1, explanation: "Add the elements one by one." },
        { correct: "  return c;", distractors: [{text: "return &c;", reason: "We're returning the struct by value, not its address."}, {text: "matrix_destroy(c); return c;", reason: "Destroying c before returning it would cause undefined behavior."}], indent: 1, explanation: "Return the result." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "free(c);", reason: "We want to return c, and freeing it would cause problems."}], indent: 0, explanation: "Close `matrix_add`." },
        { correct: "void matrix_apply_func(Matrix m, float (*func)(float)) {", distractors: [{text: "void matrix_apply_func(Matrix m, float func(float)) {", reason: "Function pointer syntax requires (*func) for clarity."}, {text: "Matrix matrix_apply_func(Matrix m, float (*func)(float)) {", reason: "This function modifies the matrix in-place rather than returning a new one."}], indent: 0, explanation: "A function to apply a function (like an activation function) to every element." },
        { correct: "  for(size_t i=0; i< m.rows * m.cols; i++) m.data[i] = func(m.data[i]);", distractors: [{text: "for(size_t i=0; i< m.rows * m.cols; i++) m.data[i] = func(i);", reason: "Should apply func to the data value, not the index."}, {text: "for(size_t i=0; i< m.rows; i++) m.data[i] = func(m.data[i]);", reason: "This only processes the first row; should process all elements."}], indent: 1, explanation: "Loop through all data and apply the function pointer." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "return m;", reason: "This is a void function that modifies in-place, so no return needed."}], indent: 0, explanation: "Close `matrix_apply_func`." },
        { correct: "// === Stage 2: Neural Network Structures and Functions ===", distractors: [{text: "// === Stage 2: Neural Network Structures and Function ===", reason: "Should be 'Functions' (plural) since we define multiple functions."}, {text: "// === Part 2: Neural Network Structures and Functions ===", reason: "'Stage' is more consistent with Stage 1."}], indent: 0, explanation: "Now, we define the structures for our neural network." },
        { correct: "// --- Activation Functions ---", distractors: [{text: "// --- Activation Function ---", reason: "We're defining multiple activation functions, so plural is correct."}, {text: "// --- Transfer Functions ---", reason: "While technically correct, 'activation functions' is the more common term in neural networks."}], indent: 0, explanation: "Define some common activation functions." },
        { correct: "float activation_relu(float x) { return x > 0 ? x : 0; }", distractors: [{text: "float activation_relu(float x) { return x > 0 ? 1 : 0; }", reason: "ReLU returns the input value when positive, not 1."}, {text: "float activation_relu(float x) { return x >= 0 ? x : 0; }", reason: "Standard ReLU uses > 0, though >= 0 is sometimes used."}], indent: 0, explanation: "The Rectified Linear Unit (ReLU) activation function." },
        { correct: "float activation_tanh(float x) { return tanh(x); }", distractors: [{text: "float activation_tanh(float x) { return tan(x); }", reason: "tanh (hyperbolic tangent) is different from tan (regular tangent)."}, {text: "float activation_tanh(float x) { return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }", reason: "While mathematically correct, using the built-in tanh() is simpler and more efficient."}], indent: 0, explanation: "The Hyperbolic Tangent activation function." },
        { correct: "// --- Layer Structure ---", distractors: [{text: "// --- Layer Structures ---", reason: "We're defining one structure type, so singular is more appropriate."}, {text: "// --- Network Layer ---", reason: "'Layer Structure' is more descriptive of what we're defining."}], indent: 0, explanation: "A struct to represent one dense layer of the network." },
        { correct: "typedef struct {", distractors: [{text: "struct DenseLayer {", reason: "Using typedef allows us to use 'DenseLayer' instead of 'struct DenseLayer'."}, {text: "typedef class {", reason: "C uses struct, not class (which is C++)."}], indent: 0, explanation: "Begin DenseLayer definition." },
        { correct: "  Matrix weights;", distractors: [{text: "Matrix* weights;", reason: "We're storing the Matrix struct directly, not a pointer to it."}, {text: "float* weights;", reason: "We want to use our Matrix struct for better organization, not a raw float pointer."}], indent: 1, explanation: "The weight matrix for this layer." },
        { correct: "  Matrix biases;", distractors: [{text: "float bias;", reason: "Neural networks typically have one bias per neuron, so we need a vector/matrix."}, {text: "Matrix* biases;", reason: "We're storing the Matrix struct directly, not a pointer to it."}], indent: 1, explanation: "The bias vector (represented as a matrix) for this layer." },
        { correct: "  float (*activation)(float);", distractors: [{text: "float activation(float);", reason: "This declares a function, not a function pointer. Need (*activation)."}, {text: "void (*activation)(float);", reason: "Activation functions return float values, not void."}], indent: 1, explanation: "A function pointer to this layer's activation function." },
        { correct: "} DenseLayer;", distractors: [{text: "};", reason: "When using typedef, we need to provide the type name before the semicolon."}, {text: "} DenseLayer", reason: "Missing semicolon after the typedef."}], indent: 0, explanation: "Close the DenseLayer typedef." },
        { correct: "// --- Forward Pass Function ---", distractors: [{text: "// --- Forward Pass Functions ---", reason: "We're defining one main forward pass function here."}, {text: "// --- Forward Propagation Function ---", reason: "'Forward pass' is more commonly used than 'forward propagation' in this context."}], indent: 0, explanation: "This function performs the core logic of inference." },
        { correct: "Matrix layer_forward(DenseLayer layer, Matrix input) {", distractors: [{text: "void layer_forward(DenseLayer layer, Matrix input, Matrix* output) {", reason: "Our design returns a new matrix rather than modifying an existing one."}, {text: "Matrix layer_forward(DenseLayer* layer, Matrix* input) {", reason: "We're passing structs by value for simplicity in this implementation."}], indent: 0, explanation: "Function to compute the output of one layer." },
        { correct: "  // 1. Multiply input by the layer's weights.", distractors: [{text: "// 1. Multiply input by the layer's weights.", reason: "Indentation should match the surrounding code."}, {text: "// 1. Add the layer's biases to input.", reason: "Matrix multiplication comes before adding biases in a dense layer."}], indent: 1, explanation: "First step of a dense layer." },
        { correct: "  Matrix weighted_sum = matrix_multiply(layer.weights, input);", distractors: [{text: "Matrix weighted_sum = matrix_multiply(input, layer.weights);", reason: "For neural networks, we typically do weights × input, not input × weights."}, {text: "Matrix weighted_sum = matrix_add(layer.weights, input);", reason: "This step is multiplication, not addition."}], indent: 1, explanation: "Perform the matrix multiplication." },
        { correct: "  // 2. Add the biases.", distractors: [{text: "// 2. Apply activation function.", reason: "Adding biases comes before applying the activation function."}, {text: "// 2. Add the bias.", reason: "'biases' (plural) is more accurate since there's typically one bias per neuron."}], indent: 1, explanation: "Second step of a dense layer." },
        { correct: "  Matrix with_bias = matrix_add(weighted_sum, layer.biases);", distractors: [{text: "Matrix with_bias = matrix_multiply(weighted_sum, layer.biases);", reason: "Biases are added, not multiplied."}, {text: "Matrix with_bias = matrix_add(layer.biases, weighted_sum);", reason: "While mathematically equivalent, conventional order is weighted_sum + biases."}], indent: 1, explanation: "Perform the matrix addition." },
        { correct: "  // 3. Apply the activation function.", distractors: [{text: "// 3. Apply the transfer function.", reason: "'Activation function' is the more common term in neural networks."}, {text: "// 3. Apply activation functions.", reason: "It's one activation function applied to all elements, so singular is correct."}], indent: 1, explanation: "Third step of a dense layer." },
        { correct: "  matrix_apply_func(with_bias, layer.activation);", distractors: [{text: "with_bias = matrix_apply_func(with_bias, layer.activation);", reason: "Our matrix_apply_func modifies in-place, so no assignment needed."}, {text: "matrix_apply_func(weighted_sum, layer.activation);", reason: "Should apply to with_bias (after adding biases), not weighted_sum."}], indent: 1, explanation: "Apply the layer's activation function to every element." },
        { correct: "  // Cleanup intermediate matrices to prevent memory leaks.", distractors: [{text: "// Cleanup intermediate matrices to prevent memory leaks.", reason: "Indentation should match surrounding code."}, {text: "// Cleanup intermediate matrix to prevent memory leaks.", reason: "'matrices' (plural) is correct since we're cleaning up multiple matrices."}], indent: 1, explanation: "Important memory management step." },
        { correct: "  matrix_destroy(weighted_sum);", distractors: [{text: "matrix_destroy(with_bias);", reason: "We want to return with_bias, so don't destroy it."}, {text: "free(weighted_sum);", reason: "Should use our matrix_destroy function, not raw free()."}], indent: 1, explanation: "Free the temporary matrix from the multiplication." },
        { correct: "  return with_bias;", distractors: [{text: "return weighted_sum;", reason: "We should return the final result (with_bias), not the intermediate result."}, {text: "return input;", reason: "We want to return the processed output, not the original input."}], indent: 1, explanation: "Return the final output of the layer." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "matrix_destroy(with_bias);", reason: "We're returning with_bias, so destroying it would cause problems."}], indent: 0, explanation: "Close `layer_forward`." },
        { correct: "// === Stage 3: Building and Running the Network ===", distractors: [{text: "// === Stage 3: Building and Running the Networks ===", reason: "We're building one network, so singular is correct."}, {text: "// === Step 3: Building and Running the Network ===", reason: "'Stage' is consistent with previous sections."}], indent: 0, explanation: "Now we'll define a simple pre-trained network and pass data through it." },
        { correct: "int main() {", distractors: [{text: "void main() {", reason: "Standard C requires main to return int."}, {text: "int main(void) {", reason: "While correct, empty parentheses are fine for main when no arguments are used."}], indent: 0, explanation: "Start main." },
        { correct: "  printf(\"--- Neural Network Forward Pass Demo ---\\n\");", distractors: [{text: "printf(\"--- Neural Network Forward Pass Demo ---\\n\");", reason: "Should be indented to match the function body."}, {text: "printf(\"--- Neural Network Forward Pass Demo ---\");", reason: "Missing newline character \\n."}], indent: 1, explanation: "Header." },
        { correct: "  // Define a 2-layer network: 2 inputs -> 4 hidden neurons -> 1 output neuron", distractors: [{text: "// Define a 2-layer network: 2 inputs -> 4 hidden neurons -> 1 output neuron", reason: "Should be indented to match surrounding code."}, {text: "// Define a 3-layer network: 2 inputs -> 4 hidden neurons -> 1 output neuron", reason: "This is typically called a 2-layer network (not counting the input as a layer)."}], indent: 1, explanation: "Describe the network architecture." },
        { correct: "  // --- Create Layer 1 (Hidden Layer) ---", distractors: [{text: "// --- Create Layer 1 (Hidden Layer) ---", reason: "Should be indented to match surrounding code."}, {text: "// --- Create Layer 1 (Input Layer) ---", reason: "Layer 1 is the hidden layer; input isn't usually counted as a layer."}], indent: 1, explanation: "Setup for the first layer." },
        { correct: "  DenseLayer layer1;", distractors: [{text: "DenseLayer layer1;", reason: "Should be indented to match function body."}, {text: "DenseLayer* layer1;", reason: "We're declaring a struct variable, not a pointer."}], indent: 1, explanation: "Declare the first layer." },
        { correct: "  layer1.weights = matrix_create(4, 2); // 4 neurons, 2 inputs", distractors: [{text: "layer1.weights = matrix_create(2, 4); // 4 neurons, 2 inputs", reason: "Weight matrix should be (output_size, input_size) = (4, 2)."}, {text: "layer1.weights = matrix_create(4, 4); // 4 neurons, 2 inputs", reason: "Should be 4×2, not 4×4, since there are 2 inputs."}], indent: 1, explanation: "Create the weight matrix (4x2)." },
        { correct: "  layer1.biases = matrix_create(4, 1);  // 4 neurons, 1 bias each", distractors: [{text: "layer1.biases = matrix_create(1, 4);  // 4 neurons, 1 bias each", reason: "Bias vector should be column vector (4×1), not row vector (1×4)."}, {text: "layer1.biases = matrix_create(4, 2);  // 4 neurons, 1 bias each", reason: "Each neuron has one bias, so 4×1, not 4×2."}], indent: 1, explanation: "Create the bias vector (4x1)." },
        { correct: "  layer1.activation = activation_relu;", distractors: [{text: "layer1.activation = activation_relu();", reason: "We want the function pointer, not the result of calling the function."}, {text: "layer1.activation = &activation_relu;", reason: "While technically correct, function names automatically convert to pointers."}], indent: 1, explanation: "Set the activation function to ReLU." },
        { correct: "  // Load pre-trained weights and biases (hardcoded for this demo)", distractors: [{text: "// Load pre-trained weights and biases (hardcoded for this demo)", reason: "Should be indented to match surrounding code."}, {text: "// Load trained weights and biases (hardcoded for this demo)", reason: "'Pre-trained' is more specific and accurate."}], indent: 1, explanation: "Comment on loading weights." },
        { correct: "  float l1_w[] = {0.1, 0.2, -0.3, 0.4, 0.5, -0.6, -0.7, 0.8};", distractors: [{text: "int l1_w[] = {0.1, 0.2, -0.3, 0.4, 0.5, -0.6, -0.7, 0.8};", reason: "Neural network weights are typically floats, not ints."}, {text: "float l1_w[] = {0.1, 0.2, -0.3, 0.4, 0.5, -0.6, -0.7};", reason: "Need 8 values for a 4×2 matrix, not 7."}], indent: 1, explanation: "Define the weight data for layer 1." },
        { correct: "  memcpy(layer1.weights.data, l1_w, sizeof(l1_w));", distractors: [{text: "memcpy(l1_w, layer1.weights.data, sizeof(l1_w));", reason: "Arguments are backwards; should copy from l1_w to layer1.weights.data."}, {text: "memcpy(layer1.weights.data, l1_w, sizeof(layer1.weights.data));", reason: "sizeof on the pointer gives pointer size, not array size; use sizeof(l1_w)."}], indent: 1, explanation: "Copy the data into the matrix." },
        { correct: "  float l1_b[] = {0.1, 0.1, -0.2, -0.2};", distractors: [{text: "float l1_b[] = {0.1, 0.1, -0.2, -0.2, 0.0};", reason: "Need exactly 4 bias values for 4 neurons, not 5."}, {text: "float l1_b[] = {0.1, 0.1, -0.2};", reason: "Need 4 bias values for 4 neurons, not 3."}], indent: 1, explanation: "Define the bias data for layer 1." },
        { correct: "  memcpy(layer1.biases.data, l1_b, sizeof(l1_b));", distractors: [{text: "memcpy(l1_b, layer1.biases.data, sizeof(l1_b));", reason: "Arguments are backwards; should copy from l1_b to layer1.biases.data."}, {text: "strcpy(layer1.biases.data, l1_b);", reason: "strcpy is for strings; use memcpy for numerical data."}], indent: 1, explanation: "Copy the data into the bias matrix." },
        { correct: "  // --- Create Layer 2 (Output Layer) ---", distractors: [{text: "// --- Create Layer 2 (Output Layer) ---", reason: "Should be indented to match surrounding code."}, {text: "// --- Create Layer 2 (Hidden Layer) ---", reason: "Layer 2 is the output layer, not hidden."}], indent: 1, explanation: "Setup for the second layer." },
        { correct: "  DenseLayer layer2;", distractors: [{text: "DenseLayer layer2 = layer1;", reason: "Layer 2 should be independent, not a copy of layer 1."}, {text: "DenseLayer* layer2 = &layer1;", reason: "Layer 2 should be a separate layer, not a pointer to layer 1."}], indent: 1, explanation: "Declare the second layer." },
        { correct: "  layer2.weights = matrix_create(1, 4); // 1 neuron, 4 inputs from prev layer", distractors: [{text: "layer2.weights = matrix_create(4, 1); // 1 neuron, 4 inputs from prev layer", reason: "Should be (output_size, input_size) = (1, 4), not (4, 1)."}, {text: "layer2.weights = matrix_create(1, 1); // 1 neuron, 4 inputs from prev layer", reason: "Should be 1×4 to match the 4 outputs from the previous layer."}], indent: 1, explanation: "Create the weight matrix (1x4)." },
        { correct: "  layer2.biases = matrix_create(1, 1);  // 1 neuron, 1 bias", distractors: [{text: "layer2.biases = matrix_create(1, 4);  // 1 neuron, 1 bias", reason: "One neuron needs one bias, so 1×1, not 1×4."}, {text: "layer2.biases = matrix_create(4, 1);  // 1 neuron, 1 bias", reason: "One neuron needs one bias, so 1×1, not 4×1."}], indent: 1, explanation: "Create the bias vector (1x1)." },
        { correct: "  layer2.activation = activation_tanh;", distractors: [{text: "layer2.activation = activation_relu;", reason: "Using tanh for output provides values between -1 and 1, which is often useful."}, {text: "layer2.activation = tanh;", reason: "Should use our wrapper function activation_tanh for consistency."}], indent: 1, explanation: "Use tanh for the output layer to get a value between -1 and 1." },
        { correct: "  // Load pre-trained weights and biases", distractors: [{text: "// Load pre-trained weights and bias", reason: "Since we have both weights and biases, plural 'biases' is more accurate."}, {text: "// Load trained weights and biases", reason: "'Pre-trained' is more specific about the nature of the weights."}], indent: 1, explanation: "Comment on loading weights." },
        { correct: "  float l2_w[] = {0.9, -0.8, 0.7, -0.6};", distractors: [{text: "float l2_w[] = {0.9, -0.8, 0.7, -0.6, 0.5};", reason: "Need exactly 4 values for a 1×4 matrix, not 5."}, {text: "float l2_w[] = {0.9, -0.8, 0.7};", reason: "Need 4 values for a 1×4 matrix, not 3."}], indent: 1, explanation: "Define the weight data for layer 2." },
        { correct: "  memcpy(layer2.weights.data, l2_w, sizeof(l2_w));", distractors: [{text: "memcpy(l2_w, layer2.weights.data, sizeof(l2_w));", reason: "Arguments are backwards; should copy from l2_w to layer2.weights.data."}, {text: "layer2.weights.data = l2_w;", reason: "This would just copy the pointer; use memcpy to copy the actual data."}], indent: 1, explanation: "Copy the data." },
        { correct: "  float l2_b[] = {0.3};", distractors: [{text: "float l2_b[] = {0.3, 0.0};", reason: "Need exactly 1 bias value for 1 neuron, not 2."}, {text: "float l2_b = 0.3;", reason: "Use array format to be consistent with memcpy usage."}], indent: 1, explanation: "Define the bias data for layer 2." },
        { correct: "  memcpy(layer2.biases.data, l2_b, sizeof(l2_b));", distractors: [{text: "layer2.biases.data[0] = l2_b[0];", reason: "Using memcpy is more consistent with the pattern established above."}, {text: "layer2.biases.data = l2_b;", reason: "This would just copy the pointer; use memcpy to copy the actual data."}], indent: 1, explanation: "Copy the data." },
        { correct: "  // --- Create Input Data ---", distractors: [{text: "// --- Create Input Data ---", reason: "Should be indented to match surrounding code."}, {text: "// --- Create Training Data ---", reason: "We're creating input data for inference, not training data."}], indent: 1, explanation: "Create the input vector to be fed into the network." },
        { correct: "  Matrix input = matrix_create(2, 1);", distractors: [{text: "Matrix input = matrix_create(1, 2);", reason: "Input should be a column vector (2×1), not row vector (1×2)."}, {text: "Matrix input = matrix_create(4, 1);", reason: "Our network has 2 inputs, not 4."}], indent: 1, explanation: "Create a 2x1 input vector." },
        { correct: "  M_AT(input, 0, 0) = 0.5f;", distractors: [{text: "M_AT(input, 0, 1) = 0.5f;", reason: "For a column vector, the column index should be 0."}, {text: "input.data[0] = 0.5f;", reason: "While this works, using M_AT is more consistent with the established pattern."}], indent: 1, explanation: "Set the first input feature." },
        { correct: "  M_AT(input, 1, 0) = -0.5f;", distractors: [{text: "M_AT(input, 1, 1) = -0.5f;", reason: "For a column vector, the column index should be 0."}, {text: "M_AT(input, 0, 1) = -0.5f;", reason: "This should set the second row (index 1), not the second column."}], indent: 1, explanation: "Set the second input feature." },
        { correct: "  matrix_print(input, \"Input Vector\");", distractors: [{text: "matrix_print(input, \"Input Matrix\");", reason: "'Input Vector' is more accurate since it's a 2×1 vector."}, {text: "printf(\"Input Vector\\n\");", reason: "matrix_print will show the actual values, which is more informative."}], indent: 1, explanation: "Print the input data." },
        { correct: "  // --- Run the Forward Pass ---", distractors: [{text: "// --- Run the Forward Pass ---", reason: "Should be indented to match surrounding code."}, {text: "// --- Run the Backward Pass ---", reason: "We're doing forward pass (inference), not backward pass (training)."}], indent: 1, explanation: "Perform the end-to-end inference." },
        { correct: "  printf(\"\\nProcessing through Layer 1...\\n\");", distractors: [{text: "printf(\"Processing through Layer 1...\\n\");", reason: "The \\n at the beginning adds nice spacing from the previous output."}, {text: "printf(\"\\nProcessing through Layer 2...\\n\");", reason: "This line is about processing through Layer 1, not Layer 2."}], indent: 1, explanation: "Informational message." },
        { correct: "  Matrix output1 = layer_forward(layer1, input);", distractors: [{text: "Matrix output1 = layer_forward(input, layer1);", reason: "Arguments are in wrong order; should be (layer, input)."}, {text: "Matrix output1 = layer_forward(layer2, input);", reason: "Should pass through layer1 first, not layer2."}], indent: 1, explanation: "Pass the input through the first layer." },
        { correct: "  matrix_print(output1, \"Output of Layer 1 (after ReLU)\");", distractors: [{text: "matrix_print(output1, \"Output of Layer 1 (after Tanh)\");", reason: "Layer 1 uses ReLU, not Tanh."}, {text: "matrix_print(input, \"Output of Layer 1 (after ReLU)\");", reason: "Should print output1, not input."}], indent: 1, explanation: "Print the intermediate result." },
        { correct: "  printf(\"\\nProcessing through Layer 2...\\n\");", distractors: [{text: "printf(\"Processing through Layer 2...\\n\");", reason: "The \\n at the beginning adds nice spacing."}, {text: "printf(\"\\nProcessing through Layer 1...\\n\");", reason: "This line is about processing through Layer 2, not Layer 1."}], indent: 1, explanation: "Informational message." },
        { correct: "  Matrix final_output = layer_forward(layer2, output1);", distractors: [{text: "Matrix final_output = layer_forward(layer2, input);", reason: "Layer 2 should receive the output from layer 1, not the original input."}, {text: "Matrix final_output = layer_forward(output1, layer2);", reason: "Arguments are in wrong order; should be (layer, input)."}], indent: 1, explanation: "Pass the output of layer 1 into layer 2." },
        { correct: "  matrix_print(final_output, \"Final Output of Network (after Tanh)\");", distractors: [{text: "matrix_print(final_output, \"Final Output of Network (after ReLU)\");", reason: "Layer 2 uses Tanh, not ReLU."}, {text: "matrix_print(output1, \"Final Output of Network (after Tanh)\");", reason: "Should print final_output, not output1."}], indent: 1, explanation: "Print the final prediction." },
        { correct: "  // --- Cleanup ---", distractors: [{text: "// --- Cleanup ---", reason: "Should be indented to match surrounding code."}, {text: "// --- Memory Management ---", reason: "'Cleanup' is more concise and clear."}], indent: 1, explanation: "Free all allocated memory." },
        { correct: "  matrix_destroy(input);", distractors: [{text: "free(input);", reason: "Should use matrix_destroy which properly frees the internal data."}, {text: "matrix_destroy(&input);", reason: "matrix_destroy takes a Matrix by value, not a pointer."}], indent: 1, explanation: "Free input matrix." },
        { correct: "  matrix_destroy(output1);", distractors: [{text: "matrix_destroy(layer1);", reason: "layer1 is a DenseLayer struct, not a Matrix. Destroy its matrices separately."}, {text: "free(output1.data);", reason: "Should use matrix_destroy for consistency and completeness."}], indent: 1, explanation: "Free intermediate output matrix." },
        { correct: "  matrix_destroy(final_output);", distractors: [{text: "matrix_destroy(output1);", reason: "This line should destroy final_output, not output1 (which was already destroyed)."}, {text: "return final_output;", reason: "We want to clean up memory before returning, not return the matrix."}], indent: 1, explanation: "Free final output matrix." },
        { correct: "  matrix_destroy(layer1.weights); matrix_destroy(layer1.biases);", distractors: [{text: "matrix_destroy(layer1);", reason: "layer1 is a struct; we need to destroy its individual Matrix members."}, {text: "free(layer1.weights); free(layer1.biases);", reason: "Should use matrix_destroy to properly free the Matrix structs."}], indent: 1, explanation: "Free layer 1 matrices." },
        { correct: "  matrix_destroy(layer2.weights); matrix_destroy(layer2.biases);", distractors: [{text: "matrix_destroy(layer2);", reason: "layer2 is a struct; we need to destroy its individual Matrix members."}, {text: "matrix_destroy(layer1.weights); matrix_destroy(layer1.biases);", reason: "This line should clean up layer2, not layer1 (which was already cleaned up)."}], indent: 1, explanation: "Free layer 2 matrices." },
        { correct: "  return 0;", distractors: [{text: "return 1;", reason: "Return 0 indicates successful execution; 1 typically indicates an error."}, {text: "return;", reason: "main is declared to return int, so must return an integer value."}], indent: 1, explanation: "Indicate success." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "exit(0);", reason: "We already returned 0; this would be unreachable code."}], indent: 0, explanation: "Close main." }
    ]
},
   // Level 87: gradient descent algorithm
{
    "goal": "Implement the gradient descent algorithm from scratch to find the minimum of a function.",
    concepts: "Function pointers, iterative algorithms, floating-point math, core ML optimization",
    sequence: [
        { correct: "// === Stage 1: Setup and Mathematical Foundation ===", distractors: [{text: "// === Stage 1: Setup and Mathematical Foundations ===", reason: "Should be 'Foundation' (singular) for consistency with neural network level."}, {text: "// === Step 1: Setup and Mathematical Foundation ===", reason: "'Stage' is more appropriate for major sections than 'Step'."}], indent: 0, explanation: "Define includes and the mathematical functions we want to optimize." },
        { correct: "#include <stdio.h>", distractors: [{text: "include <stdio.h>", reason: "Preprocessor directives must begin with '#'."}, {text: "#include \"stdio.h\"", reason: "Standard library headers use angle brackets <>, not quotes."}], indent: 0, explanation: "Standard I/O for printing our progress." },
        { correct: "#include <math.h>", distractors: [{text: "#include <mathematics.h>", reason: "The standard math header is math.h, not mathematics.h."}, {text: "#include <stdlib.h>", reason: "We need math.h for fabs(), not stdlib.h."}], indent: 0, explanation: "For `fabs` to check for convergence." },
        { correct: "// Gradient descent is an iterative optimization algorithm for finding a local minimum of a function.", distractors: [{text: "// Gradient descent is an iterative optimization algorithm for finding a global minimum of a function.", reason: "Gradient descent finds local minima, not necessarily global minima."}, {text: "// Gradient descent is an iterative optimization algorithm for finding a maximum of a function.", reason: "Gradient descent finds minima, not maxima (that would be gradient ascent)."}], indent: 0, explanation: "Explain the purpose of the algorithm." },
        { correct: "// The core idea is to take repeated steps in the opposite direction of the function's gradient.", distractors: [{text: "// The core idea is to take repeated steps in the same direction as the function's gradient.", reason: "We move opposite to the gradient to find minima, not in the same direction."}, {text: "// The core idea is to take one large step in the opposite direction of the function's gradient.", reason: "Gradient descent takes repeated small steps, not one large step."}], indent: 0, explanation: "Describe the core mechanic of gradient descent." },
        { correct: "// --- The Function to Minimize ---", distractors: [{text: "// --- The Function to Maximize ---", reason: "We're implementing gradient descent to find minima, not maxima."}, {text: "// --- The Function to Minimize ---", reason: "We're defining one function, so singular is correct."}], indent: 0, explanation: "We'll find the minimum of the simple quadratic function: f(x) = (x - 5)^2" },
        { correct: "double a_simple_function(double x) {", distractors: [{text: "float a_simple_function(float x) {", reason: "double provides better precision for optimization algorithms than float."}, {text: "int a_simple_function(double x) {", reason: "Mathematical functions typically return floating-point values, not integers."}], indent: 0, explanation: "Define the function we want to minimize." },
        { correct: "  return (x - 5.0) * (x - 5.0);", distractors: [{text: "return (x + 5.0) * (x + 5.0);", reason: "This would have its minimum at x = -5, not x = 5."}, {text: "return pow(x - 5.0, 2);", reason: "While mathematically correct, explicit multiplication is more efficient than pow() for squaring."}], indent: 1, explanation: "The minimum value of this function is 0, which occurs when x = 5." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "return 0;", reason: "We already returned the computed value; this would be unreachable."}], indent: 0, explanation: "Close the function definition." },
        { correct: "// --- The Gradient (Derivative) of the Function ---", distractors: [{text: "// --- The Gradients (Derivatives) of the Function ---", reason: "We're defining one gradient function, so singular is correct."}, {text: "// --- The Slope of the Function ---", reason: "'Gradient' is the more precise mathematical term for multivariable functions."}], indent: 0, explanation: "The gradient tells us the direction of steepest ascent. We want to move in the opposite direction." },
        { correct: "// The derivative of (x - 5)^2 is 2 * (x - 5).", distractors: [{text: "// The derivative of (x - 5)^2 is (x - 5).", reason: "Using the power rule: d/dx[(x-5)²] = 2(x-5), not just (x-5)."}, {text: "// The derivative of (x - 5)^2 is 2 * x - 5.", reason: "Incorrect application of the chain rule; should be 2 * (x - 5)."}], indent: 0, explanation: "State the derivative from calculus." },
        { correct: "double gradient_of_simple_function(double x) {", distractors: [{text: "float gradient_of_simple_function(double x) {", reason: "Return type should match the function's parameter type for consistency."}, {text: "double derivative_of_simple_function(double x) {", reason: "While 'derivative' is correct, 'gradient' is more commonly used in optimization contexts."}], indent: 0, explanation: "Define the function that calculates the gradient (derivative)." },
        { correct: "  return 2.0 * (x - 5.0);", distractors: [{text: "return (x - 5.0);", reason: "Missing the coefficient 2 from the power rule."}, {text: "return -2.0 * (x - 5.0);", reason: "The derivative should be positive when x > 5 and negative when x < 5."}], indent: 1, explanation: "This function tells us the slope at any given point x." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "return 0;", reason: "We already returned the gradient value; this would be unreachable."}], indent: 0, explanation: "Close the gradient function." },
        { correct: "// --- Typedef for a generic gradient function pointer ---", distractors: [{text: "// --- Typedef for a generic gradient function pointers ---", reason: "We're defining one function pointer type, so singular is correct."}, {text: "// --- Define for a generic gradient function pointer ---", reason: "'Typedef' is more specific than 'Define' for creating type aliases."}], indent: 0, explanation: "To make our optimizer generic, we'll use a function pointer." },
        { correct: "typedef double (*GradientFunc)(double);", distractors: [{text: "typedef double *GradientFunc(double);", reason: "Function pointer syntax requires parentheses around *GradientFunc."}, {text: "typedef float (*GradientFunc)(float);", reason: "Should use double for better precision in optimization algorithms."}], indent: 0, explanation: "Create a type `GradientFunc` for any function that takes a double and returns a double." },
        { correct: "// === Stage 2: The Gradient Descent Optimizer Implementation ===", distractors: [{text: "// === Stage 2: The Gradient Ascent Optimizer Implementation ===", reason: "We're implementing gradient descent (to find minima), not gradient ascent."}, {text: "// === Stage 2: The Gradient Descent Optimizers Implementation ===", reason: "We're implementing one optimizer, so singular is correct."}], indent: 0, explanation: "Implement the main optimization function." },
        { correct: "double gradient_descent(double initial_guess, double learning_rate, GradientFunc grad_func, int max_iterations) {", distractors: [{text: "void gradient_descent(double initial_guess, double learning_rate, GradientFunc grad_func, int max_iterations) {", reason: "Function should return the optimized value, not be void."}, {text: "double gradient_descent(double initial_guess, double learning_rate, double grad_func, int max_iterations) {", reason: "grad_func should be a function pointer (GradientFunc), not a double."}], indent: 0, explanation: "Define the optimizer function, taking an initial guess, learning rate, and a pointer to a gradient function." },
        { correct: "  printf(\"--- Starting Gradient Descent ---\\n\");", distractors: [{text: "printf(\"--- Starting Gradient Descent ---\\n\");", reason: "Should be indented to match function body."}, {text: "printf(\"--- Starting Gradient Ascent ---\\n\");", reason: "We're doing gradient descent, not ascent."}], indent: 1, explanation: "Informational message." },
        { correct: "  printf(\"Initial Guess: %.4f, Learning Rate: %.4f\\n\", initial_guess, learning_rate);", distractors: [{text: "printf(\"Initial Guess: %d, Learning Rate: %d\\n\", initial_guess, learning_rate);", reason: "Should use %.4f for double values, not %d (which is for integers)."}, {text: "printf(\"Initial Guess: %.4f, Learning Rate: %.4f\\n\", learning_rate, initial_guess);", reason: "Arguments are in wrong order; should match the format string."}], indent: 1, explanation: "Print the starting parameters." },
        { correct: "  double current_x = initial_guess;", distractors: [{text: "double current_x = 0;", reason: "Should initialize with the provided initial_guess, not hardcode 0."}, {text: "float current_x = initial_guess;", reason: "Should use double for consistency with function parameters."}], indent: 1, explanation: "Initialize our current position with the initial guess." },
        { correct: "  for (int i = 0; i < max_iterations; i++) {", distractors: [{text: "for (int i = 1; i <= max_iterations; i++) {", reason: "Loop indices typically start at 0, not 1."}, {text: "while (i < max_iterations) {", reason: "A for loop is more appropriate when we know the number of iterations."}], indent: 1, explanation: "Start the main optimization loop, which runs for a fixed number of iterations (epochs)." },
        { correct: "    // 1. Calculate the gradient at the current position.", distractors: [{text: "// 1. Calculate the gradient at the current position.", reason: "Should be indented to match the loop body."}, {text: "// 1. Calculate the function value at the current position.", reason: "First step is calculating the gradient, not the function value."}], indent: 2, explanation: "First step inside the loop." },
        { correct: "    double gradient = grad_func(current_x);", distractors: [{text: "double gradient = current_x;", reason: "Should call the gradient function, not just use current_x."}, {text: "double gradient = grad_func();", reason: "The gradient function needs current_x as an argument."}], indent: 2, explanation: "Call the provided gradient function to find the slope at our current x." },
        { correct: "    // 2. Calculate the 'step' to take.", distractors: [{text: "// 2. Calculate the 'step' to take.", reason: "Should be indented to match the loop body."}, {text: "// 2. Update the position directly.", reason: "We calculate the step first, then update the position."}], indent: 2, explanation: "Second step inside the loop." },
        { correct: "    double step = learning_rate * gradient;", distractors: [{text: "double step = gradient / learning_rate;", reason: "Step size should be gradient multiplied by learning rate, not divided."}, {text: "double step = learning_rate + gradient;", reason: "Step is the product of learning rate and gradient, not their sum."}], indent: 2, explanation: "The size of the step is the gradient multiplied by the learning rate." },
        { correct: "    // 3. Update our position by moving in the opposite direction of the gradient.", distractors: [{text: "// 3. Update our position by moving in the same direction as the gradient.", reason: "For minimization, we move opposite to the gradient."}, {text: "// 3. Update our position by moving perpendicular to the gradient.", reason: "We move opposite to the gradient, not perpendicular to it."}], indent: 2, explanation: "The core update rule of gradient descent." },
        { correct: "    current_x = current_x - step;", distractors: [{text: "current_x = current_x + step;", reason: "For gradient descent (minimization), we subtract the step, not add it."}, {text: "current_x = step - current_x;", reason: "This would completely replace current_x; should be current_x - step."}], indent: 2, explanation: "Update our guess for x." },
        { correct: "    if ((i + 1) % 10 == 0) { // Print progress every 10 iterations", distractors: [{text: "if (i % 10 == 0) { // Print progress every 10 iterations", reason: "Using (i + 1) makes the output show iterations 10, 20, 30... instead of 0, 10, 20..."}, {text: "if ((i + 1) % 5 == 0) { // Print progress every 10 iterations", reason: "Comment says every 10 iterations but code checks every 5."}], indent: 2, explanation: "A check to periodically print our progress." },
        { correct: "      printf(\"  Iter %3d: x = %.4f, f(x) = %.4f\\n\", i + 1, current_x, a_simple_function(current_x));", distractors: [{text: "printf(\"  Iter %3d: x = %.4f, f(x) = %.4f\\n\", i, current_x, a_simple_function(current_x));", reason: "Should use i + 1 to show iteration numbers starting from 1, not 0."}, {text: "printf(\"  Iter %3d: x = %.4f, f(x) = %.4f\\n\", i + 1, current_x, gradient);", reason: "Should print the function value, not the gradient value."}], indent: 3, explanation: "Print the current iteration, x value, and the value of the original function at x." },
        { correct: "    }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "break;", reason: "This would exit the loop prematurely; break belongs in the convergence check."}], indent: 2, explanation: "Close the progress-printing block." },
        { correct: "    // Optional: Check for convergence to stop early.", distractors: [{text: "// Optional: Check for convergence to stop early.", reason: "Should be indented to match the loop body."}, {text: "// Required: Check for convergence to stop early.", reason: "This convergence check is optional for a basic implementation."}], indent: 2, explanation: "A more advanced optimizer would stop if the value stops changing." },
        { correct: "    if (fabs(step) < 1e-6) {", distractors: [{text: "if (step < 1e-6) {", reason: "Should use fabs() to check absolute value since step can be negative."}, {text: "if (fabs(gradient) < 1e-6) {", reason: "Checking step size is more appropriate than checking gradient directly."}], indent: 2, explanation: "If the step we are taking is extremely small..." },
        { correct: "      printf(\"Converged early at iteration %d.\\n\", i + 1);", distractors: [{text: "printf(\"Converged early at iteration %d.\\n\", i);", reason: "Should use i + 1 to show human-readable iteration numbers starting from 1."}, {text: "printf(\"Diverged early at iteration %d.\\n\", i + 1);", reason: "Small steps indicate convergence, not divergence."}], indent: 3, explanation: "Announce that we've found the minimum." },
        { correct: "      break; // Exit the loop", distractors: [{text: "continue; // Exit the loop", reason: "break exits the loop; continue would just skip to the next iteration."}, {text: "return current_x; // Exit the loop", reason: "While this would work, break is cleaner; let the function end naturally."}], indent: 3, explanation: "Stop iterating." },
        { correct: "    }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "else { break; }", reason: "No else clause needed; if convergence isn't met, we continue normally."}], indent: 2, explanation: "Close convergence check." },
        { correct: "  }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "return current_x;", reason: "The return statement should come after the loop, not inside it."}], indent: 1, explanation: "Close the main optimization loop." },
        { correct: "  printf(\"--- Gradient Descent Finished ---\\n\");", distractors: [{text: "printf(\"--- Gradient Descent Finished ---\\n\");", reason: "Should be indented to match function body."}, {text: "printf(\"--- Gradient Ascent Finished ---\\n\");", reason: "We implemented gradient descent, not ascent."}], indent: 1, explanation: "Completion message." },
        { correct: "  return current_x;", distractors: [{text: "return initial_guess;", reason: "Should return the optimized value (current_x), not the starting value."}, {text: "return 0;", reason: "Should return the optimized x value, not 0."}], indent: 1, explanation: "Return the final, optimized value of x." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "return current_x;", reason: "We already returned current_x; this would be unreachable."}], indent: 0, explanation: "Close the gradient descent function." },
        { correct: "// === Stage 3: Main Program to Run the Optimizer ===", distractors: [{text: "// === Stage 3: Main Program to Run the Optimizers ===", reason: "We're running one optimizer, so singular is correct."}, {text: "// === Step 3: Main Program to Run the Optimizer ===", reason: "'Stage' is consistent with previous sections."}], indent: 0, explanation: "A `main` function to test our optimizer." },
        { correct: "int main() {", distractors: [{text: "void main() {", reason: "Standard C requires main to return int."}, {text: "double main() {", reason: "main should return int, not double."}], indent: 0, explanation: "Start main." },
        { correct: "  printf(\"Goal: Find the minimum of f(x) = (x - 5)^2, which is at x = 5.\\n\");", distractors: [{text: "printf(\"Goal: Find the minimum of f(x) = (x - 5)^2, which is at x = 5.\\n\");", reason: "Should be indented to match function body."}, {text: "printf(\"Goal: Find the maximum of f(x) = (x - 5)^2, which is at x = 5.\\n\");", reason: "We're finding the minimum, not maximum."}], indent: 1, explanation: "State the problem we are solving." },
        { correct: "  // Set hyperparameters for the optimizer", distractors: [{text: "// Set hyperparameters for the optimizer", reason: "Should be indented to match function body."}, {text: "// Set parameters for the optimizer", reason: "'Hyperparameters' is the more specific ML term."}], indent: 1, explanation: "Comment on hyperparameters." },
        { correct: "  double initial_x = 0.0;", distractors: [{text: "double initial_x = 5.0;", reason: "Starting at the answer (5.0) wouldn't demonstrate the optimization process."}, {text: "int initial_x = 0;", reason: "Should use double for consistency with the optimizer function."}], indent: 1, explanation: "Our initial random guess for x." },
        { correct: "  double learning_rate = 0.1;", distractors: [{text: "double learning_rate = 1.0;", reason: "A learning rate of 1.0 might be too large and cause overshooting."}, {text: "double learning_rate = 0.0;", reason: "A learning rate of 0 would prevent any updates from happening."}], indent: 1, explanation: "The learning rate, which controls how big of a step we take." },
        { correct: "  int iterations = 100;", distractors: [{text: "double iterations = 100.0;", reason: "Number of iterations should be an integer, not a double."}, {text: "int iterations = 1;", reason: "One iteration is insufficient for demonstrating the optimization process."}], indent: 1, explanation: "The maximum number of iterations to run." },
        { correct: "  // Run the optimizer", distractors: [{text: "// Run the optimizer", reason: "Should be indented to match function body."}, {text: "// Run the optimizers", reason: "We're running one optimizer, so singular is correct."}], indent: 1, explanation: "Comment on running the function." },
        { correct: "  double minimum_x = gradient_descent(initial_x, learning_rate, gradient_of_simple_function, iterations);", distractors: [{text: "double minimum_x = gradient_descent(learning_rate, initial_x, gradient_of_simple_function, iterations);", reason: "Parameters are in wrong order; should be (initial_x, learning_rate, ...)."}, {text: "double minimum_x = gradient_descent(initial_x, learning_rate, a_simple_function, iterations);", reason: "Should pass the gradient function, not the original function."}], indent: 1, explanation: "Call the optimizer, passing our specific gradient function as the callback." },
        { correct: "  printf(\"\\nFinal Result:\\n\");", distractors: [{text: "printf(\"Final Result:\\n\");", reason: "The \\n at the beginning adds nice spacing from the optimization output."}, {text: "printf(\"\\nInitial Result:\\n\");", reason: "This is the final result, not initial."}], indent: 1, explanation: "Header for the final result." },
        { correct: "  printf(\"  The minimum of the function is at x = %.6f\\n\", minimum_x);", distractors: [{text: "printf(\"  The maximum of the function is at x = %.6f\\n\", minimum_x);", reason: "We found the minimum, not maximum."}, {text: "printf(\"  The minimum of the function is at x = %.6f\\n\", initial_x);", reason: "Should print the optimized result (minimum_x), not the starting value."}], indent: 1, explanation: "Print the final calculated minimum." },
        { correct: "  return 0;", distractors: [{text: "return 1;", reason: "Return 0 indicates successful execution; 1 typically indicates an error."}, {text: "return minimum_x;", reason: "main should return an integer exit code, not the computed result."}], indent: 1, explanation: "Indicate success." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "exit(0);", reason: "We already returned 0; this would be unreachable code."}], indent: 0, explanation: "Close main." }
    ]
    },
    // Level 88: high-performance C function for python
{
    "goal": "Write a high-performance C function, compile it into a shared library, and call it from Python.",
    concepts: "Shared libraries, `gcc -shared -fPIC`, extern \"C\", Python `ctypes`, Foreign Function Interface (FFI)",
    sequence: [
        { correct: "// === Stage 1, Part A: The C Library Source Code ('process.c') ===", distractors: [{text: "// === Stage 1, Part A: The C Library Source Code ('process.h') ===", reason: "This is the implementation file (.c), not a header file (.h)."}, {text: "// === Stage 1, Part A: The Python Library Source Code ('process.c') ===", reason: "We're writing C code here, not Python code."}], indent: 0, explanation: "First, we write the C code that we want to accelerate." },
        { correct: "#include <stdio.h>", distractors: [{text: "include <stdio.h>", reason: "Preprocessor directives must begin with '#'."}, {text: "#include \"stdio.h\"", reason: "Standard library headers use angle brackets <>, not quotes."}], indent: 0, explanation: "Standard I/O for a simple message." },
        { correct: "#include <stdint.h>", distractors: [{text: "#include <stdlib.h>", reason: "We need stdint.h for fixed-width types like int64_t, not stdlib.h."}, {text: "#include <string.h>", reason: "We need stdint.h for integer types, not string.h for string functions."}], indent: 0, explanation: "Include for fixed-width types like `int64_t` for cross-language compatibility." },
        { correct: "// When compiling C for use by C++ (or other languages), `extern \"C\"`", distractors: [{text: "// When compiling C for use by Python only, `extern \"C\"`", reason: "extern \"C\" is needed for any language that might use C++ compilation, not just Python."}, {text: "// When compiling C++ for use by C (or other languages), `extern \"C\"`", reason: "We're compiling C code, and extern \"C\" prevents C++ name mangling."}], indent: 0, explanation: "Explain the purpose of `extern \"C\"`." },
        { correct: "// prevents the compiler from 'mangling' the function name.", distractors: [{text: "// prevents the compiler from 'optimizing' the function name.", reason: "Name mangling is different from optimization; it's about symbol naming."}, {text: "// prevents the compiler from 'compiling' the function name.", reason: "The function still gets compiled; extern \"C\" affects how the function name is exported."}], indent: 0, explanation: "This ensures Python can find the function by its exact C name." },
        { correct: "#ifdef __cplusplus", distractors: [{text: "#ifdef __python__", reason: "__cplusplus is the standard macro to detect C++ compilation, not __python__."}, {text: "#if __cplusplus", reason: "Should use #ifdef to check if the macro is defined, not #if."}], indent: 0, explanation: "Check if being compiled by a C++ compiler." },
        { correct: "extern \"C\" {", distractors: [{text: "extern \"Python\" {", reason: "The correct syntax is extern \"C\", not extern \"Python\"."}, {text: "extern C {", reason: "The linkage specification requires quotes around \"C\"."}], indent: 0, explanation: "Start the extern block." },
        { correct: "#endif", distractors: [{text: "#end", reason: "The correct preprocessor directive to close #ifdef is #endif, not #end."}, {text: "}", reason: "This preprocessor directive requires #endif, not a curly brace."}], indent: 0, explanation: "End the preprocessor check." },
        { correct: "// --- The C Function to be Exported ---", distractors: [{text: "// --- The C Functions to be Exported ---", reason: "We're defining one function here, so singular is correct."}, {text: "// --- The Python Function to be Exported ---", reason: "This is a C function, not a Python function."}], indent: 0, explanation: "This is the function we will call from Python." },
        { correct: "long long sum_array(const long long* array, int size) {", distractors: [{text: "int sum_array(const int* array, int size) {", reason: "long long provides more range for large sums than int."}, {text: "long long sum_array(long long* array, int size) {", reason: "Should use const since we're not modifying the input array."}], indent: 0, explanation: "A simple but computationally intensive function: summing a large array." },
        { correct: "  printf(\"[C] Hello from the C library! Processing array...\\n\");", distractors: [{text: "print(\"[C] Hello from the C library! Processing array...\")", reason: "This is C code; use printf(), not Python's print()."}, {text: "printf(\"[C] Hello from the C library! Processing array...\");", reason: "Missing newline character \\n for proper formatting."}], indent: 1, explanation: "A message to prove the C code is actually running." },
        { correct: "  long long sum = 0;", distractors: [{text: "int sum = 0;", reason: "Should use long long to match the return type and avoid overflow."}, {text: "long long sum;", reason: "Should initialize sum to 0 before accumulating values."}], indent: 1, explanation: "Initialize the accumulator." },
        { correct: "  for (int i = 0; i < size; i++) {", distractors: [{text: "for (int i = 1; i <= size; i++) {", reason: "Array indices start at 0, not 1."}, {text: "for (int i = 0; i <= size; i++) {", reason: "This would access beyond the array bounds; should be i < size."}], indent: 1, explanation: "Loop through the array." },
        { correct: "    sum += array[i];", distractors: [{text: "sum += array[i+1];", reason: "This would skip the first element and access beyond bounds."}, {text: "sum *= array[i];", reason: "We want to add elements (sum), not multiply them."}], indent: 2, explanation: "Add each element to the sum." },
        { correct: "  }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "return sum;", reason: "The return should come after the loop, not inside it."}], indent: 1, explanation: "Close the loop." },
        { correct: "  printf(\"[C] Processing complete. Returning sum.\\n\");", distractors: [{text: "printf(\"[Python] Processing complete. Returning sum.\\n\");", reason: "This message is from the C code, not Python."}, {text: "printf(\"[C] Processing complete. Returning sum.\");", reason: "Missing newline character \\n."}], indent: 1, explanation: "Completion message from C." },
        { correct: "  return sum;", distractors: [{text: "return 0;", reason: "Should return the calculated sum, not 0."}, {text: "return array;", reason: "Should return the sum value, not the array pointer."}], indent: 1, explanation: "Return the final sum." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "#endif", reason: "This closes the function, not a preprocessor directive."}], indent: 0, explanation: "Close the C function." },
        { correct: "#ifdef __cplusplus", distractors: [{text: "#ifndef __cplusplus", reason: "Should be #ifdef to match the opening conditional."}, {text: "#endif", reason: "This should check for __cplusplus, not close immediately."}], indent: 0, explanation: "The matching end for the extern block." },
        { correct: "}", distractors: [{text: "#endif", reason: "This closes the extern \"C\" block, which uses curly braces."}, {text: "};", reason: "extern \"C\" blocks end with }, not };"}], indent: 0, explanation: "Close the extern block." },
        { correct: "#endif", distractors: [{text: "}", reason: "This closes the #ifdef preprocessor directive, which uses #endif."}, {text: "#end", reason: "The correct directive is #endif, not #end."}], indent: 0, explanation: "Close the second #ifdef preprocessor directive." },
        { correct: "// === Stage 1, Part B: Compiling the C Library ===", distractors: [{text: "// === Stage 1, Part B: Running the C Library ===", reason: "This stage is about compiling, not running the library."}, {text: "// === Stage 2, Part B: Compiling the C Library ===", reason: "This is still part of Stage 1 (C code), not Stage 2."}], indent: 0, explanation: "To call our C code, we must compile it into a shared library file." },
        { correct: "// On Linux or macOS, you would use a command like this in your terminal:", distractors: [{text: "// On Windows, you would use a command like this in your terminal:", reason: "This specific command is for Linux/macOS, not Windows."}, {text: "// On Linux or macOS, you would use a command like this in Python:", reason: "This is a terminal/shell command, not a Python command."}], indent: 0, explanation: "Provide the compilation command for Linux/macOS." },
        { correct: "// gcc -shared -o libprocess.so -fPIC process.c", distractors: [{text: "// gcc -static -o libprocess.so -fPIC process.c", reason: "-shared creates a shared library; -static would create a static library."}, {text: "// gcc -shared -o libprocess.dll -fPIC process.c", reason: ".dll is for Windows; Linux/macOS use .so files."}], indent: 0, explanation: "`-shared` creates a shared library. `-fPIC` generates Position-Independent Code, which is required for shared libraries." },
        { correct: "// On Windows, the command would be slightly different and produce a .dll file:", distractors: [{text: "// On Linux, the command would be slightly different and produce a .dll file:", reason: "This describes the Windows command, not Linux."}, {text: "// On Windows, the command would be slightly different and produce a .so file:", reason: "Windows uses .dll files, not .so files."}], indent: 0, explanation: "Provide the compilation command for Windows." },
        { correct: "// gcc -shared -o process.dll process.c", distractors: [{text: "// gcc -shared -o process.so process.c", reason: "Windows uses .dll extension, not .so."}, {text: "// gcc -static -o process.dll process.c", reason: "Should use -shared for a DLL, not -static."}], indent: 0, explanation: "This command creates a Dynamic-Link Library." },
        { correct: "// After running the command, you will have a `libprocess.so` or `process.dll` file.", distractors: [{text: "// After running the command, you will have a `process.exe` file.", reason: "We're creating a library (.so/.dll), not an executable (.exe)."}, {text: "// After running the command, you will have a `process.o` file.", reason: ".o files are object files; we're creating shared libraries (.so/.dll)."}], indent: 0, explanation: "Describe the output of the compilation." },
        { correct: "// === Stage 2: The Python Script ('main.py') ===", distractors: [{text: "// === Stage 2: The C Script ('main.py') ===", reason: "This is a Python script, not a C script."}, {text: "// === Stage 2: The Python Script ('main.c') ===", reason: "Python files use .py extension, not .c."}], indent: 0, explanation: "Now, we write the Python code to load and use our C library." },
        { correct: "import ctypes", distractors: [{text: "import types", reason: "We need ctypes for Foreign Function Interface, not the types module."}, {text: "include ctypes", reason: "Python uses import, not include (which is for C/C++)."}], indent: 0, explanation: "Import the `ctypes` library, Python's built-in tool for calling C functions." },
        { correct: "import numpy as np", distractors: [{text: "import numpy", reason: "While this works, the convention is to alias numpy as np."}, {text: "import array as np", reason: "We need numpy for numerical arrays, not the basic array module."}], indent: 0, explanation: "Import NumPy, the standard library for numerical data in Python." },
        { correct: "import platform", distractors: [{text: "import os", reason: "platform module is more appropriate for detecting OS type than os."}, {text: "import system", reason: "There's no 'system' module; we need 'platform'."}], indent: 0, explanation: "Import platform to handle differences between operating systems." },
        { correct: "# Load the shared library", distractors: [{text: "// Load the shared library", reason: "Python uses # for comments, not //."}, {text: "/* Load the shared library */", reason: "Python uses #, not C-style /* */ comments."}], indent: 0, explanation: "Python comment for loading the library." },
        { correct: "lib_path = \"./libprocess.so\"", distractors: [{text: "lib_path = \"./process.dll\"", reason: "This is the default for Linux/macOS (.so), not Windows (.dll)."}, {text: "lib_path = \"./libprocess.dll\"", reason: "Linux/macOS use .so files; .dll is for Windows."}], indent: 0, explanation: "Define the path to the library on Linux/macOS." },
        { correct: "if platform.system() == \"Windows\":", distractors: [{text: "if platform.system() == \"windows\":", reason: "The platform.system() returns 'Windows' with a capital W."}, {text: "if os.name == \"Windows\":", reason: "Should use platform.system(), not os.name for OS detection."}], indent: 0, explanation: "Check if the operating system is Windows." },
        { correct: "    lib_path = \"./process.dll\"", distractors: [{text: "lib_path = \"./process.dll\"", reason: "Should be indented to be inside the if statement."}, {text: "lib_path = \"./libprocess.dll\"", reason: "Windows convention typically doesn't use the 'lib' prefix."}], indent: 1, explanation: "If it is, change the library path to the .dll file." },
        { correct: "try:", distractors: [{text: "try {", reason: "Python uses a colon after try, not curly braces."}, {text: "try();", reason: "try is a statement, not a function call."}], indent: 0, explanation: "Use a try/except block to handle potential errors when loading the library." },
        { correct: "    c_lib = ctypes.CDLL(lib_path)", distractors: [{text: "c_lib = ctypes.CDLL(lib_path)", reason: "Should be indented to be inside the try block."}, {text: "c_lib = ctypes.DLL(lib_path)", reason: "The correct class is CDLL, not DLL."}], indent: 1, explanation: "Use `ctypes.CDLL` to load our shared library into memory." },
        { correct: "except OSError as e:", distractors: [{text: "except FileNotFoundError as e:", reason: "OSError is more general and catches library loading errors, not just file not found."}, {text: "catch OSError as e:", reason: "Python uses except, not catch (which is from other languages)."}], indent: 0, explanation: "Catch the `OSError` if the file is not found." },
        { correct: "    print(f\"Error: Could not load shared library from {lib_path}\")", distractors: [{text: "print(f\"Error: Could not load shared library from {lib_path}\")", reason: "Should be indented to be inside the except block."}, {text: "printf(\"Error: Could not load shared library from %s\", lib_path)", reason: "This is Python; use print(), not printf()."}], indent: 1, explanation: "Print a helpful error message." },
        { correct: "    print(\"Please compile the C code first (see comments in the C file).\")", distractors: [{text: "print(\"Please compile the C code first (see comments in the C file).\")", reason: "Should be indented to match the except block."}, {text: "print(\"Please compile the Python code first (see comments in the C file).\")", reason: "Need to compile the C code, not Python code."}], indent: 1, explanation: "Instruct the user on how to fix the error." },
        { correct: "    exit()", distractors: [{text: "exit()", reason: "Should be indented to be inside the except block."}, {text: "return", reason: "This is in the main script, not a function, so use exit() not return."}], indent: 1, explanation: "Exit the Python script." },
        { correct: "# Define the function signature (argument types and return type)", distractors: [{text: "// Define the function signature (argument types and return type)", reason: "Python uses # for comments, not //."}, {text: "# Define the function signatures (argument types and return type)", reason: "We're defining one function signature, so singular is correct."}], indent: 0, explanation: "This step is crucial for `ctypes` to work correctly." },
        { correct: "sum_array_func = c_lib.sum_array", distractors: [{text: "sum_array_func = c_lib.sum_array()", reason: "We want a reference to the function, not to call it immediately."}, {text: "sum_array_func = c_lib[\"sum_array\"]", reason: "Use dot notation, not dictionary-style access for function names."}], indent: 0, explanation: "Get a reference to our `sum_array` function from the loaded library." },
        { correct: "sum_array_func.argtypes = [np.ctypeslib.ndpointer(dtype=np.int64), ctypes.c_int]", distractors: [{text: "sum_array_func.argtypes = [ctypes.c_longlong, ctypes.c_int]", reason: "First argument should be a pointer to array data, not a single long long."}, {text: "sum_array_func.argtypes = [np.ctypeslib.ndpointer(dtype=np.int32), ctypes.c_int]", reason: "Should use int64 to match the C function's long long parameter."}], indent: 0, explanation: "Define the argument types: a pointer to a numpy array of 64-bit ints, and a C integer." },
        { correct: "sum_array_func.restype = ctypes.c_longlong", distractors: [{text: "sum_array_func.restype = ctypes.c_int", reason: "Should match the C function's long long return type, not int."}, {text: "sum_array_func.returntype = ctypes.c_longlong", reason: "The attribute is called restype, not returntype."}], indent: 0, explanation: "Define the return type as a C long long, which matches the `long long` in our C code." },
        { correct: "# Prepare data in Python", distractors: [{text: "// Prepare data in Python", reason: "Python uses # for comments, not //."}, {text: "# Prepare data in C", reason: "We're preparing data in Python, not C."}], indent: 0, explanation: "Python comment for data preparation." },
        { correct: "print(\"\\n[Python] Preparing data with NumPy...\")", distractors: [{text: "printf(\"\\n[Python] Preparing data with NumPy...\");", reason: "This is Python; use print(), not printf()."}, {text: "print(\"\\n[C] Preparing data with NumPy...\")", reason: "This message is from Python code, not C."}], indent: 0, explanation: "Informational message from Python." },
        { correct: "python_array = np.arange(1, 1000001, dtype=np.int64)", distractors: [{text: "python_array = np.arange(0, 1000000, dtype=np.int64)", reason: "Using 1 to 1000001 gives numbers 1-1000000, which is more intuitive."}, {text: "python_array = np.arange(1, 1000001, dtype=np.int32)", reason: "Should use int64 to match the C function's long long parameter."}], indent: 0, explanation: "Create a large NumPy array with numbers from 1 to 1,000,000." },
        { correct: "array_size = len(python_array)", distractors: [{text: "array_size = python_array.size", reason: "While .size works, len() is more conventional for getting array length."}, {text: "array_size = sizeof(python_array)", reason: "sizeof() is a C concept; Python uses len() for array length."}], indent: 0, explanation: "Get the size of the array." },
        { correct: "# Call the C function", distractors: [{text: "// Call the C function", reason: "Python uses # for comments, not //."}, {text: "# Call the Python function", reason: "We're calling the C function, not a Python function."}], indent: 0, explanation: "Python comment for calling the C function." },
        { correct: "print(\"[Python] Calling the C function to sum the array...\")", distractors: [{text: "print(\"[C] Calling the C function to sum the array...\")", reason: "This print statement is from Python code, not C."}, {text: "printf(\"[Python] Calling the C function to sum the array...\");", reason: "This is Python; use print(), not printf()."}], indent: 0, explanation: "Informational message." },
        { correct: "c_result = sum_array_func(python_array, array_size)", distractors: [{text: "c_result = sum_array_func(array_size, python_array)", reason: "Arguments are in wrong order; should be (array, size)."}, {text: "c_result = c_lib.sum_array(python_array, array_size)", reason: "Should use the configured function reference sum_array_func, not the raw c_lib.sum_array."}], indent: 0, explanation: "Call our C function. `ctypes` handles the conversion of the NumPy array to a pointer that C can understand." },
        { correct: "print(f\"\\n[Python] C function returned: {c_result}\")", distractors: [{text: "print(\"\\n[Python] C function returned: %d\" % c_result)", reason: "f-strings are more modern and readable than % formatting."}, {text: "print(f\"\\n[C] C function returned: {c_result}\")", reason: "This print statement is from Python code, not C."}], indent: 0, explanation: "Print the result returned by the C function." },
        { correct: "# Verify the result in Python", distractors: [{text: "// Verify the result in Python", reason: "Python uses # for comments, not //."}, {text: "# Verify the result in C", reason: "We're doing the verification in Python, not C."}], indent: 0, explanation: "Python comment for verification." },
        { correct: "print(\"[Python] Verifying result with NumPy's own sum()...\")", distractors: [{text: "print(\"[C] Verifying result with NumPy's own sum()...\")", reason: "This message is from Python code, not C."}, {text: "print(\"[Python] Verifying result with C's own sum()...\")", reason: "We're using NumPy's sum, not C's sum."}], indent: 0, explanation: "Informational message." },
        { correct: "python_sum = np.sum(python_array)", distractors: [{text: "python_sum = sum(python_array)", reason: "np.sum() is optimized for NumPy arrays and faster than built-in sum()."}, {text: "python_sum = python_array.sum()", reason: "While this works, np.sum() is more explicit about using NumPy."}], indent: 0, explanation: "Calculate the sum using NumPy's highly optimized built-in function." },
        { correct: "print(f\"[Python] NumPy's sum is: {python_sum}\")", distractors: [{text: "print(f\"[C] NumPy's sum is: {python_sum}\")", reason: "This message is from Python code, not C."}, {text: "printf(\"[Python] NumPy's sum is: %lld\", python_sum);", reason: "This is Python; use print(), not printf()."}], indent: 0, explanation: "Print the NumPy result." },
        { correct: "if c_result == python_sum:", distractors: [{text: "if c_result = python_sum:", reason: "Use == for comparison, not = for assignment."}, {text: "if python_sum == c_result:", reason: "While equivalent, putting c_result first is more conventional."}], indent: 0, explanation: "Compare the result from our C library with the result from NumPy." },
        { correct: "    print(\"\\nSUCCESS: The result from the C library matches the NumPy result!\")", distractors: [{text: "print(\"\\nSUCCESS: The result from the C library matches the NumPy result!\")", reason: "Should be indented to be inside the if statement."}, {text: "print(\"\\nFAILURE: The result from the C library matches the NumPy result!\")", reason: "If results match, it's SUCCESS, not FAILURE."}], indent: 1, explanation: "Print a success message if they match." },
        { correct: "else:", distractors: [{text: "elif:", reason: "Use else for the alternative case, not elif."}, {text: "else {", reason: "Python uses a colon after else, not curly braces."}], indent: 0, explanation: "If they don't match..." },
        { correct: "    print(\"\\nFAILURE: The results do not match.\")", distractors: [{text: "print(\"\\nFAILURE: The results do not match.\")", reason: "Should be indented to be inside the else statement."}, {text: "print(\"\\nSUCCESS: The results do not match.\")", reason: "If results don't match, it's FAILURE, not SUCCESS."}], indent: 1, explanation: "Print a failure message." }
    ]
    },
   // Level 89: 24-bit BMP image filters
{
    "goal": "Build a tool to read, apply filters to, and write 24-bit BMP image files.",
    concepts: "Binary I/O, structs, #pragma pack, fread, fwrite, pixel manipulation, data alignment",
    sequence: [
        { correct: "// === Stage 1: Setup and BMP File Format Structures ===", distractors: [{text: "// === Stage 1: Setup and BMP File Format Structure ===", reason: "We're defining multiple structures, so plural is correct."}, {text: "// === Step 1: Setup and BMP File Format Structures ===", reason: "'Stage' is more appropriate for major sections than 'Step'."}], indent: 0, explanation: "Define the necessary includes and the precise structures that match the BMP file format specification." },
        { correct: "#include <stdio.h>", distractors: [{text: "include <stdio.h>", reason: "Preprocessor directives must begin with '#'."}, {text: "#include \"stdio.h\"", reason: "Standard library headers use angle brackets <>, not quotes."}], indent: 0, explanation: "Standard I/O for file operations." },
        { correct: "#include <stdlib.h>", distractors: [{text: "#include <malloc.h>", reason: "stdlib.h is the standard header for malloc/free, not malloc.h."}, {text: "#include <memory.h>", reason: "memory.h is not standard C; malloc is declared in stdlib.h."}], indent: 0, explanation: "For memory management." },
        { correct: "#include <stdint.h>", distractors: [{text: "#include <inttypes.h>", reason: "stdint.h is for fixed-width types like uint16_t; inttypes.h is for format macros."}, {text: "#include <limits.h>", reason: "stdint.h provides fixed-width types, not numeric limits."}], indent: 0, explanation: "For fixed-width integer types like `uint16_t`." },
        { correct: "#include <string.h>", distractors: [{text: "#include <strings.h>", reason: "string.h is the standard header; strings.h is a different POSIX header."}, {text: "#include <cstring.h>", reason: "cstring.h doesn't exist in C; that's a C++ header concept."}], indent: 0, explanation: "For `strcmp`." },
        { correct: "// The BMP format has padding to ensure struct members are aligned.", distractors: [{text: "// The BMP format has no padding since struct members are aligned.", reason: "BMP format does have specific alignment requirements that we need to handle."}, {text: "// The BMP format has padding to ensure struct members are compressed.", reason: "Padding is about alignment, not compression."}], indent: 0, explanation: "Comment on data alignment in file formats." },
        { correct: "// We use `#pragma pack(push, 1)` to tell the compiler to pack these structs tightly, with no extra padding.", distractors: [{text: "// We use `#pragma pack(push, 4)` to tell the compiler to pack these structs tightly, with no extra padding.", reason: "pack(1) means 1-byte alignment (tight packing); pack(4) would allow padding."}, {text: "// We use `#pragma pack(pop, 1)` to tell the compiler to pack these structs tightly, with no extra padding.", reason: "pack(push, 1) saves current packing and sets to 1; pack(pop) restores it."}], indent: 0, explanation: "This ensures our `sizeof` matches the file format exactly." },
        { correct: "#pragma pack(push, 1)", distractors: [{text: "#pragma pack(1)", reason: "Using push saves the current packing state so we can restore it later."}, {text: "#pragma pack(pop, 1)", reason: "pack(push, 1) sets packing; pack(pop) restores the previous setting."}], indent: 0, explanation: "Apply tight packing." },
        { correct: "typedef struct {", distractors: [{text: "struct BMPFileHeader {", reason: "Using typedef creates an alias so we don't need 'struct BMPFileHeader' everywhere."}, {text: "typedef class {", reason: "C uses struct, not class (which is C++)."}], indent: 0, explanation: "The BMP File Header is the first 14 bytes of the file." },
        { correct: "  uint16_t type; // Magic identifier: 0x4D42 ('BM')", distractors: [{text: "uint16_t type; // Magic identifier: 0x4D42 ('BM')", reason: "Should be indented to match struct members."}, {text: "uint32_t type; // Magic identifier: 0x4D42 ('BM')", reason: "BMP file type field is 2 bytes (uint16_t), not 4 bytes."}], indent: 1, explanation: "The file type, must be 'BM' for a bitmap." },
        { correct: "  uint32_t size; // Size of the BMP file in bytes", distractors: [{text: "uint16_t size; // Size of the BMP file in bytes", reason: "File size needs 4 bytes (uint32_t) to handle large files."}, {text: "int size; // Size of the BMP file in bytes", reason: "Should use unsigned type (uint32_t) for file sizes."}], indent: 1, explanation: "Total file size." },
        { correct: "  uint16_t reserved1, reserved2;", distractors: [{text: "uint32_t reserved1, reserved2;", reason: "Reserved fields in BMP are 2 bytes each (uint16_t), not 4."}, {text: "uint16_t reserved;", reason: "BMP format has two separate 2-byte reserved fields."}], indent: 1, explanation: "Reserved fields, must be zero." },
        { correct: "  uint32_t offset; // Byte offset to the beginning of image data", distractors: [{text: "uint16_t offset; // Byte offset to the beginning of image data", reason: "Offset field needs 4 bytes (uint32_t) to address large files."}, {text: "uint32_t* offset; // Byte offset to the beginning of image data", reason: "offset is a value, not a pointer."}], indent: 1, explanation: "Where the pixel data starts." },
        { correct: "} BMPFileHeader;", distractors: [{text: "};", reason: "When using typedef, we need to provide the type name before the semicolon."}, {text: "} BMPFileHeader", reason: "Missing semicolon after the typedef."}], indent: 0, explanation: "Close the File Header struct." },
        { correct: "typedef struct {", distractors: [{text: "typedef union {", reason: "BMP header fields are separate, not overlapping, so use struct not union."}, {text: "struct BMPInfoHeader {", reason: "Using typedef creates an alias for cleaner usage."}], indent: 0, explanation: "The DIB (Device-Independent Bitmap) Header follows the file header." },
        { correct: "  uint32_t header_size; // Size of this header (40 bytes)", distractors: [{text: "uint16_t header_size; // Size of this header (40 bytes)", reason: "Header size field is 4 bytes (uint32_t) in BMP format."}, {text: "uint32_t header_size; // Size of this header (14 bytes)", reason: "DIB header is 40 bytes, not 14 (which is the file header size)."}], indent: 1, explanation: "Size of this DIB header." },
        { correct: "  int32_t width; // Image width in pixels", distractors: [{text: "uint32_t width; // Image width in pixels", reason: "Width uses signed int32_t in BMP format (though negative width is rare)."}, {text: "int width; // Image width in pixels", reason: "Should use fixed-width type int32_t for file format compatibility."}], indent: 1, explanation: "The width of the image." },
        { correct: "  int32_t height; // Image height in pixels", distractors: [{text: "uint32_t height; // Image height in pixels", reason: "Height uses signed int32_t; negative values indicate top-to-bottom storage."}, {text: "int height; // Image height in pixels", reason: "Should use fixed-width type int32_t for file format compatibility."}], indent: 1, explanation: "The height of the image." },
        { correct: "  uint16_t planes; // Number of color planes (must be 1)", distractors: [{text: "uint32_t planes; // Number of color planes (must be 1)", reason: "Planes field is 2 bytes (uint16_t) in BMP format."}, {text: "uint16_t planes; // Number of color planes (must be 3)", reason: "BMP planes field must be 1, not 3."}], indent: 1, explanation: "Must be 1." },
        { correct: "  uint16_t bit_count; // Bits per pixel (e.g., 24 for true color)", distractors: [{text: "uint32_t bit_count; // Bits per pixel (e.g., 24 for true color)", reason: "Bits per pixel field is 2 bytes (uint16_t) in BMP format."}, {text: "uint8_t bit_count; // Bits per pixel (e.g., 24 for true color)", reason: "Bit count field is 2 bytes (uint16_t), not 1 byte."}], indent: 1, explanation: "We will only support 24-bit images." },
        { correct: "  uint32_t compression, size_image, x_pixels_per_m, y_pixels_per_m, colors_used, colors_important;", distractors: [{text: "uint16_t compression, size_image, x_pixels_per_m, y_pixels_per_m, colors_used, colors_important;", reason: "These fields are all 4 bytes (uint32_t) in BMP format."}, {text: "int32_t compression, size_image, x_pixels_per_m, y_pixels_per_m, colors_used, colors_important;", reason: "These fields use unsigned integers (uint32_t) in BMP format."}], indent: 1, explanation: "Other fields, which we can ignore for uncompressed 24-bit images." },
        { correct: "} BMPInfoHeader;", distractors: [{text: "};", reason: "When using typedef, we need to provide the type name."}, {text: "} BMPInfoHeader", reason: "Missing semicolon after the typedef."}], indent: 0, explanation: "Close the Info Header struct." },
        { correct: "#pragma pack(pop)", distractors: [{text: "#pragma pack()", reason: "pack(pop) explicitly restores the previous packing state."}, {text: "#pragma pack(push)", reason: "pack(pop) restores packing; pack(push) would save current state."}], indent: 0, explanation: "Restore the default compiler packing behavior." },
        { correct: "// A struct to hold a single 24-bit pixel. Note the BGR order in BMP files.", distractors: [{text: "// A struct to hold a single 24-bit pixel. Note the RGB order in BMP files.", reason: "BMP files store pixels in BGR order, not RGB."}, {text: "// A struct to hold a single 32-bit pixel. Note the BGR order in BMP files.", reason: "We're working with 24-bit pixels, not 32-bit."}], indent: 0, explanation: "Comment on pixel structure and color order." },
        { correct: "typedef struct { uint8_t b, g, r; } Pixel;", distractors: [{text: "typedef struct { uint8_t r, g, b; } Pixel;", reason: "BMP format stores pixels in BGR order, not RGB."}, {text: "typedef struct { int b, g, r; } Pixel;", reason: "Pixel components are single bytes (uint8_t), not full integers."}], indent: 0, explanation: "Represents a single Blue, Green, Red pixel." },
        { correct: "// A struct to hold our image data in memory.", distractors: [{text: "// A struct to hold our image data on disk.", reason: "This struct is for in-memory representation, not disk storage."}, {text: "// A function to hold our image data in memory.", reason: "This is a struct definition, not a function."}], indent: 0, explanation: "Comment on the in-memory Image struct." },
        { correct: "typedef struct { int width, height; Pixel* data; } Image;", distractors: [{text: "typedef struct { int width, height; Pixel data; } Image;", reason: "Need a pointer to dynamic array (Pixel*), not a single pixel."}, {text: "typedef struct { float width, height; Pixel* data; } Image;", reason: "Image dimensions should be integers, not floats."}], indent: 0, explanation: "The main image container with dimensions and a dynamic pixel buffer." },
        { correct: "// --- Function Prototypes ---", distractors: [{text: "// --- Function Prototype ---", reason: "We're declaring multiple function prototypes, so plural is correct."}, {text: "// --- Function Declarations ---", reason: "'Prototypes' is the more specific term for forward declarations."}], indent: 0, explanation: "Declare all our image processing functions." },
        { correct: "Image* bmp_load(const char* filename);", distractors: [{text: "Image bmp_load(const char* filename);", reason: "Should return a pointer to Image for dynamic allocation."}, {text: "void bmp_load(const char* filename, Image* img);", reason: "Returning a pointer is more conventional than passing output parameter."}], indent: 0, explanation: "Prototype for the BMP loading function." },
        { correct: "int bmp_save(const Image* img, const char* filename);", distractors: [{text: "void bmp_save(const Image* img, const char* filename);", reason: "Should return int for error handling (0 = success, non-zero = error)."}, {text: "int bmp_save(Image* img, const char* filename);", reason: "Should use const since we're not modifying the image."}], indent: 0, explanation: "Prototype for the BMP saving function." },
        { correct: "void image_apply_grayscale(Image* img);", distractors: [{text: "Image* image_apply_grayscale(Image* img);", reason: "This function modifies the image in-place, so void return is appropriate."}, {text: "void image_apply_grayscale(const Image* img);", reason: "Need to modify the image, so can't use const."}], indent: 0, explanation: "Prototype for the grayscale filter." },
        { correct: "void image_apply_invert(Image* img);", distractors: [{text: "Image* image_apply_invert(const Image* img);", reason: "This function modifies the image in-place, so void return and non-const parameter."}, {text: "int image_apply_invert(Image* img);", reason: "No error conditions to report, so void return is fine."}], indent: 0, explanation: "Prototype for the color inversion filter." },
        { correct: "void image_destroy(Image* img);", distractors: [{text: "int image_destroy(Image* img);", reason: "Destructors typically return void since there's nothing meaningful to return."}, {text: "void image_destroy(const Image* img);", reason: "Need to modify/free the image, so can't use const."}], indent: 0, explanation: "Prototype for freeing image memory." },
        { correct: "// === Stage 2: Main Program and Argument Parsing ===", distractors: [{text: "// === Stage 2: Main Program and Arguments Parsing ===", reason: "'Argument parsing' is the correct term, not 'arguments parsing'."}, {text: "// === Step 2: Main Program and Argument Parsing ===", reason: "'Stage' is consistent with previous sections."}], indent: 0, explanation: "The main function will parse commands and orchestrate the process." },
        { correct: "int main(int argc, char* argv[]) {", distractors: [{text: "void main(int argc, char* argv[]) {", reason: "Standard C requires main to return int."}, {text: "int main(char* argv[], int argc) {", reason: "Convention is argc first, then argv."}], indent: 0, explanation: "Start main, accepting command-line arguments." },
        { correct: "  if (argc != 4) {", distractors: [{text: "if (argc != 4) {", reason: "Should be indented to match function body."}, {text: "if (argc < 4) {", reason: "We need exactly 4 arguments, not just at least 4."}], indent: 1, explanation: "Check for the correct number of arguments." },
        { correct: "    printf(\"Usage: %s <input.bmp> <grayscale|invert> <output.bmp>\\n\", argv[0]);", distractors: [{text: "printf(\"Usage: %s <input.bmp> <grayscale|invert> <output.bmp>\\n\", argv[0]);", reason: "Should be indented to match the if block."}, {text: "printf(\"Usage: %s <input.bmp> <output.bmp> <grayscale|invert>\\n\", argv[0]);", reason: "Operation should come before output file for better usability."}], indent: 2, explanation: "Print usage instructions if arguments are incorrect." },
        { correct: "    return 1;", distractors: [{text: "return 1;", reason: "Should be indented to match the if block."}, {text: "return 0;", reason: "Return 1 indicates error; 0 indicates success."}], indent: 2, explanation: "Exit with an error." },
        { correct: "  }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "return 1;", reason: "The return is already inside the if block."}], indent: 1, explanation: "Close argument check." },
        { correct: "  const char* input_file = argv[1];", distractors: [{text: "char* input_file = argv[1];", reason: "Using const since we won't modify the filename string."}, {text: "const char input_file = argv[1];", reason: "Need a pointer to string (char*), not a single char."}], indent: 1, explanation: "Get the input filename from the arguments." },
        { correct: "  const char* operation = argv[2];", distractors: [{text: "const char operation = argv[2];", reason: "Need a pointer to string (char*), not a single char."}, {text: "int operation = argv[2];", reason: "Operation is a string, not an integer."}], indent: 1, explanation: "Get the desired operation from the arguments." },
        { correct: "  const char* output_file = argv[3];", distractors: [{text: "const char output_file = argv[3];", reason: "Need a pointer to string (char*), not a single char."}, {text: "FILE* output_file = argv[3];", reason: "argv[3] is a string, not a file pointer."}], indent: 1, explanation: "Get the output filename from the arguments." },
        { correct: "  printf(\"Loading image from %s...\\n\", input_file);", distractors: [{text: "printf(\"Loading image from %s...\", input_file);", reason: "Missing newline character \\n."}, {text: "printf(\"Loading image from %d...\\n\", input_file);", reason: "Should use %s for strings, not %d for integers."}], indent: 1, explanation: "Informational message." },
        { correct: "  Image* img = bmp_load(input_file);", distractors: [{text: "Image img = bmp_load(input_file);", reason: "bmp_load returns a pointer to Image, not an Image struct."}, {text: "Image* img = bmp_load(output_file);", reason: "Should load from input_file, not output_file."}], indent: 1, explanation: "Call the function to load the BMP file into memory." },
        { correct: "  if (!img) { printf(\"Failed to load image.\\n\"); return 1; }", distractors: [{text: "if (img == NULL) { printf(\"Failed to load image.\\n\"); return 1; }", reason: "!img is more concise than img == NULL."}, {text: "if (!img) { printf(\"Failed to load image.\\n\"); return 0; }", reason: "Return 1 for error, not 0."}], indent: 1, explanation: "If loading failed, print an error and exit." },
        { correct: "  printf(\"Image loaded successfully (%d x %d pixels).\\n\", img->width, img->height);", distractors: [{text: "printf(\"Image loaded successfully (%d x %d pixels).\\n\", img.width, img.height);", reason: "img is a pointer, so use -> not . to access members."}, {text: "printf(\"Image loaded successfully (%s x %s pixels).\\n\", img->width, img->height);", reason: "Width and height are integers, so use %d not %s."}], indent: 1, explanation: "Confirm successful loading." },
        { correct: "  // Apply the requested filter", distractors: [{text: "// Apply the requested filter", reason: "Should be indented to match function body."}, {text: "// Apply the requested filters", reason: "We're applying one filter, so singular is correct."}], indent: 1, explanation: "Comment on the filtering stage." },
        { correct: "  if (strcmp(operation, \"grayscale\") == 0) {", distractors: [{text: "if (operation == \"grayscale\") {", reason: "Can't compare strings with == in C; use strcmp()."}, {text: "if (strcmp(operation, \"grayscale\") = 0) {", reason: "Use == for comparison, not = for assignment."}], indent: 1, explanation: "Check if the requested operation is 'grayscale'." },
        { correct: "    printf(\"Applying grayscale filter...\\n\");", distractors: [{text: "printf(\"Applying grayscale filter...\\n\");", reason: "Should be indented to match the if block."}, {text: "printf(\"Applying invert filter...\\n\");", reason: "This branch is for grayscale, not invert."}], indent: 2, explanation: "Informational message." },
        { correct: "    image_apply_grayscale(img);", distractors: [{text: "image_apply_grayscale(img);", reason: "Should be indented to match the if block."}, {text: "img = image_apply_grayscale(img);", reason: "Function modifies in-place and returns void, so no assignment needed."}], indent: 2, explanation: "Call the grayscale filter function." },
        { correct: "  } else if (strcmp(operation, \"invert\") == 0) {", distractors: [{text: "} else if (operation == \"invert\") {", reason: "Can't compare strings with == in C; use strcmp()."}, {text: "} else if (strcmp(operation, \"invert\") != 0) {", reason: "Should check if operation equals \"invert\", not if it's different."}], indent: 1, explanation: "Check if the requested operation is 'invert'." },
        { correct: "    printf(\"Applying invert filter...\\n\");", distractors: [{text: "printf(\"Applying grayscale filter...\\n\");", reason: "This branch is for invert, not grayscale."}, {text: "printf(\"Applying invert filter...\");", reason: "Missing newline character \\n."}], indent: 2, explanation: "Informational message." },
        { correct: "    image_apply_invert(img);", distractors: [{text: "image_apply_grayscale(img);", reason: "This branch should apply invert, not grayscale."}, {text: "img = image_apply_invert(img);", reason: "Function modifies in-place and returns void."}], indent: 2, explanation: "Call the invert filter function." },
        { correct: "  } else {", distractors: [{text: "} else {", reason: "Should be indented to match the if/else chain."}, {text: "else {", reason: "Missing closing brace } for the previous else if."}], indent: 1, explanation: "Handle unknown operations." },
        { correct: "    printf(\"Error: Unknown operation '%s'.\\n\", operation);", distractors: [{text: "printf(\"Error: Unknown operation '%s'.\\n\", operation);", reason: "Should be indented to match the else block."}, {text: "printf(\"Error: Unknown operation '%d'.\\n\", operation);", reason: "Operation is a string, so use %s not %d."}], indent: 2, explanation: "Print an error for an invalid filter name." },
        { correct: "    image_destroy(img);", distractors: [{text: "image_destroy(img);", reason: "Should be indented to match the else block."}, {text: "free(img);", reason: "Should use image_destroy() which properly frees both data and struct."}], indent: 2, explanation: "Clean up the loaded image before exiting." },
        { correct: "    return 1;", distractors: [{text: "return 1;", reason: "Should be indented to match the else block."}, {text: "return 0;", reason: "Return 1 for error, not 0."}], indent: 2, explanation: "Exit with an error." },
        { correct: "  }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "return 1;", reason: "The return is already inside the else block."}], indent: 1, explanation: "Close the operation selection logic." },
        { correct: "  printf(\"Saving image to %s...\\n\", output_file);", distractors: [{text: "printf(\"Saving image to %s...\", output_file);", reason: "Missing newline character \\n."}, {text: "printf(\"Loading image from %s...\\n\", output_file);", reason: "We're saving to output_file, not loading from it."}], indent: 1, explanation: "Informational message for saving." },
        { correct: "  if (bmp_save(img, output_file) != 0) {", distractors: [{text: "if (bmp_save(img, output_file) == 0) {", reason: "bmp_save returns 0 on success, non-zero on error."}, {text: "if (!bmp_save(img, output_file)) {", reason: "bmp_save returns int, not boolean; check != 0 for error."}], indent: 1, explanation: "Call the save function and check for errors." },
        { correct: "    printf(\"Failed to save image.\\n\");", distractors: [{text: "printf(\"Failed to save image.\\n\");", reason: "Should be indented to match the if block."}, {text: "printf(\"Image saved successfully.\\n\");", reason: "This branch handles save failure, not success."}], indent: 2, explanation: "Print an error if saving failed." },
        { correct: "  } else {", distractors: [{text: "} else {", reason: "Should be indented to match the if statement."}, {text: "} if {", reason: "Should be 'else', not 'if'."}], indent: 1, explanation: "If saving was successful..." },
        { correct: "    printf(\"Image saved successfully.\\n\");", distractors: [{text: "printf(\"Image saved successfully.\\n\");", reason: "Should be indented to match the else block."}, {text: "printf(\"Failed to save image.\\n\");", reason: "This branch handles success, not failure."}], indent: 2, explanation: "Print a success message." },
        { correct: "  }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "printf(\"Done.\\n\");", reason: "No additional print needed here."}], indent: 1, explanation: "Close the save check." },
        { correct: "  // Cleanup", distractors: [{text: "// Cleanup", reason: "Should be indented to match function body."}, {text: "// Memory cleanup", reason: "'Cleanup' is more concise."}], indent: 1, explanation: "Comment on the final cleanup." },
        { correct: "  image_destroy(img);", distractors: [{text: "image_destroy(img);", reason: "Should be indented to match function body."}, {text: "free(img);", reason: "Should use image_destroy() which properly handles both data and struct."}], indent: 1, explanation: "Free all memory associated with the image." },
        { correct: "  return 0;", distractors: [{text: "return 0;", reason: "Should be indented to match function body."}, {text: "return 1;", reason: "Return 0 for success, not 1."}], indent: 1, explanation: "Indicate success." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "exit(0);", reason: "We already returned 0; this would be unreachable."}], indent: 0, explanation: "Close main." },
        { correct: "// === Stage 3: BMP File I/O and Filter Implementations ===", distractors: [{text: "// === Stage 3: BMP File I/O and Filter Implementation ===", reason: "We're implementing multiple functions, so plural is correct."}, {text: "// === Step 3: BMP File I/O and Filter Implementations ===", reason: "'Stage' is consistent with previous sections."}], indent: 0, explanation: "Implement the core logic for loading, saving, and filtering." },
        { correct: "Image* bmp_load(const char* filename) {", distractors: [{text: "Image bmp_load(const char* filename) {", reason: "Should return a pointer for dynamic allocation."}, {text: "void bmp_load(const char* filename, Image* img) {", reason: "Returning pointer is more conventional than output parameter."}], indent: 0, explanation: "Start the BMP loading function." },
        { correct: "  FILE* fp = fopen(filename, \"rb\");", distractors: [{text: "FILE* fp = fopen(filename, \"r\");", reason: "Must use \"rb\" (binary read) for binary files like BMP."}, {text: "FILE fp = fopen(filename, \"rb\");", reason: "fopen returns a pointer to FILE, not a FILE struct."}], indent: 1, explanation: "Open the file in binary read mode ('rb')." },
        { correct: "  if (!fp) { perror(\"fopen\"); return NULL; }", distractors: [{text: "if (fp == NULL) { perror(\"fopen\"); return NULL; }", reason: "!fp is more concise than fp == NULL."}, {text: "if (!fp) { printf(\"Error opening file\\n\"); return NULL; }", reason: "perror() provides more detailed error information than printf."}], indent: 1, explanation: "Handle file open error." },
        { correct: "  BMPFileHeader file_header;", distractors: [{text: "BMPFileHeader* file_header;", reason: "We want the struct itself on the stack, not a pointer."}, {text: "BMPInfoHeader file_header;", reason: "This should be the file header, not info header."}], indent: 1, explanation: "A struct to hold the file header." },
        { correct: "  fread(&file_header, sizeof(BMPFileHeader), 1, fp);", distractors: [{text: "fread(file_header, sizeof(BMPFileHeader), 1, fp);", reason: "Need address of the struct (&file_header), not the struct itself."}, {text: "fread(&file_header, 1, sizeof(BMPFileHeader), fp);", reason: "fread parameters are (ptr, size, count, file), not (ptr, count, size, file)."}], indent: 1, explanation: "Read the 14-byte file header from the file." },
        { correct: "  if (file_header.type != 0x4D42) {", distractors: [{text: "if (file_header.type == 0x4D42) {", reason: "Should check for inequality to detect non-BMP files."}, {text: "if (file_header.type != \"BM\") {", reason: "0x4D42 is the hex representation; can't compare to string."}], indent: 1, explanation: "Check the magic number to confirm it's a BMP file. 'BM' is 0x4D42 in little-endian." },
        { correct: "    printf(\"Error: Not a BMP file.\\n\"); fclose(fp); return NULL;", distractors: [{text: "printf(\"Error: Not a BMP file.\\n\"); return NULL;", reason: "Must close the file before returning to avoid resource leak."}, {text: "printf(\"Error: Not a BMP file.\\n\"); fclose(fp); return 0;", reason: "Should return NULL for pointer return type, not 0."}], indent: 2, explanation: "Error if not a BMP." },
        { correct: "  }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "return NULL;", reason: "The return is already in the if block."}], indent: 1, explanation: "Close magic number check." },
        { correct: "  BMPInfoHeader info_header;", distractors: [{text: "BMPFileHeader info_header;", reason: "This should be the info header, not file header."}, {text: "BMPInfoHeader* info_header;", reason: "We want the struct on the stack, not a pointer."}], indent: 1, explanation: "A struct to hold the DIB header." },
        { correct: "  fread(&info_header, sizeof(BMPInfoHeader), 1, fp);", distractors: [{text: "fread(info_header, sizeof(BMPInfoHeader), 1, fp);", reason: "Need address of the struct (&info_header)."}, {text: "fwrite(&info_header, sizeof(BMPInfoHeader), 1, fp);", reason: "Should be fread (reading), not fwrite (writing)."}], indent: 1, explanation: "Read the 40-byte info header." },
        { correct: "  if (info_header.bit_count != 24 || info_header.compression != 0) {", distractors: [{text: "if (info_header.bit_count == 24 || info_header.compression == 0) {", reason: "Should check for unsupported formats (not 24-bit or compressed)."}, {text: "if (info_header.bit_count != 32 || info_header.compression != 0) {", reason: "We're supporting 24-bit images, not 32-bit."}], indent: 1, explanation: "Check that the BMP is a 24-bit, uncompressed image, which is all our simple parser supports." },
        { correct: "    printf(\"Error: Only 24-bit uncompressed BMPs are supported.\\n\"); fclose(fp); return NULL;", distractors: [{text: "printf(\"Error: Only 24-bit uncompressed BMPs are supported.\\n\"); return NULL;", reason: "Must close file before returning."}, {text: "printf(\"Error: Only 32-bit uncompressed BMPs are supported.\\n\"); fclose(fp); return NULL;", reason: "We support 24-bit, not 32-bit images."}], indent: 2, explanation: "Error if unsupported format." },
        { correct: "  }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "fclose(fp);", reason: "Only close on error, not in normal flow."}], indent: 1, explanation: "Close format check." },
        { correct: "  fseek(fp, file_header.offset, SEEK_SET);", distractors: [{text: "fseek(fp, info_header.offset, SEEK_SET);", reason: "Offset is in file_header, not info_header."}, {text: "fseek(fp, file_header.offset, SEEK_CUR);", reason: "SEEK_SET positions from start of file, which is what we want."}], indent: 1, explanation: "Jump to the start of the pixel data, using the offset from the file header." },
        { correct: "  Image* img = malloc(sizeof(Image));", distractors: [{text: "Image img = malloc(sizeof(Image));", reason: "malloc returns a pointer, so img should be a pointer type."}, {text: "Image* img = calloc(sizeof(Image));", reason: "calloc takes two parameters: count and size."}], indent: 1, explanation: "Allocate memory for our in-memory Image struct." },
        { correct: "  img->width = info_header.width;", distractors: [{text: "img.width = info_header.width;", reason: "img is a pointer, so use -> not . to access members."}, {text: "img->width = file_header.width;", reason: "Width is in info_header, not file_header."}], indent: 1, explanation: "Set the width from the header." },
        { correct: "  img->height = abs(info_header.height);", distractors: [{text: "img->height = info_header.height;", reason: "abs() handles negative height (top-to-bottom storage)."}, {text: "img->height = abs(info_header.width);", reason: "Should use height, not width."}], indent: 1, explanation: "Set the height. A negative height means the image is stored top-to-bottom." },
        { correct: "  size_t data_size = img->width * img->height * sizeof(Pixel);", distractors: [{text: "size_t data_size = img->width * img->height;", reason: "Need to multiply by sizeof(Pixel) to get byte count."}, {text: "int data_size = img->width * img->height * sizeof(Pixel);", reason: "size_t is more appropriate for memory sizes than int."}], indent: 1, explanation: "Calculate the size of the pixel buffer." },
        { correct: "  img->data = malloc(data_size);", distractors: [{text: "img->data = malloc(img->width * img->height);", reason: "Should use the calculated data_size which includes sizeof(Pixel)."}, {text: "img.data = malloc(data_size);", reason: "img is a pointer, so use -> not ."}], indent: 1, explanation: "Allocate memory for the pixel buffer." },
        { correct: "  fread(img->data, 1, data_size, fp);", distractors: [{text: "fread(img->data, data_size, 1, fp);", reason: "Reading byte-by-byte: fread(ptr, 1, count, file)."}, {text: "fwrite(img->data, 1, data_size, fp);", reason: "Should be fread (reading), not fwrite (writing)."}], indent: 1, explanation: "Read the entire pixel data block from the file into our buffer." },
        { correct: "  fclose(fp);", distractors: [{text: "close(fp);", reason: "Use fclose() for FILE*, not close() (which is for file descriptors)."}, {text: "fp = NULL;", reason: "Should close the file, not just null the pointer."}], indent: 1, explanation: "Close the file." },
        { correct: "  return img;", distractors: [{text: "return *img;", reason: "Should return the pointer, not dereference it."}, {text: "return NULL;", reason: "Should return the successfully loaded image, not NULL."}], indent: 1, explanation: "Return the loaded image." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "free(img);", reason: "We want to return the image, not free it."}], indent: 0, explanation: "Close `bmp_load`." },
        { correct: "int bmp_save(const Image* img, const char* filename) {", distractors: [{text: "void bmp_save(const Image* img, const char* filename) {", reason: "Should return int for error handling."}, {text: "int bmp_save(Image* img, const char* filename) {", reason: "Should use const since we're not modifying the image."}], indent: 0, explanation: "Start the BMP saving function." },
        { correct: "  FILE* fp = fopen(filename, \"wb\");", distractors: [{text: "FILE* fp = fopen(filename, \"w\");", reason: "Must use \"wb\" (binary write) for binary files."}, {text: "FILE* fp = fopen(filename, \"rb\");", reason: "Should be \"wb\" (write), not \"rb\" (read)."}], indent: 1, explanation: "Open the destination file in binary write mode." },
        { correct: "  if (!fp) { return -1; }", distractors: [{text: "if (!fp) { return NULL; }", reason: "Function returns int, so return -1 for error, not NULL."}, {text: "if (fp) { return -1; }", reason: "Should check if fp is NULL (!fp), not if it's valid."}], indent: 1, explanation: "Handle file open error." },
        { correct: "  size_t data_size = img->width * img->height * sizeof(Pixel);", distractors: [{text: "size_t data_size = img->width * img->height;", reason: "Need to multiply by sizeof(Pixel) for byte count."}, {text: "int data_size = img->width * img->height * sizeof(Pixel);", reason: "size_t is more appropriate for memory sizes."}], indent: 1, explanation: "Calculate the size of the pixel data." },
        { correct: "  BMPFileHeader file_header = {0x4D42, sizeof(BMPFileHeader) + sizeof(BMPInfoHeader) + data_size, 0, 0, sizeof(BMPFileHeader) + sizeof(BMPInfoHeader)};", distractors: [{text: "BMPFileHeader file_header = {0x4D42, data_size, 0, 0, sizeof(BMPFileHeader)};", reason: "File size should include headers plus data, and offset should include both headers."}, {text: "BMPFileHeader file_header = {0x4142, sizeof(BMPFileHeader) + sizeof(BMPInfoHeader) + data_size, 0, 0, sizeof(BMPFileHeader) + sizeof(BMPInfoHeader)};", reason: "BMP magic number is 0x4D42 ('BM'), not 0x4142."}], indent: 1, explanation: "Construct the file header with correct values." },
        { correct: "  BMPInfoHeader info_header = {sizeof(BMPInfoHeader), img->width, img->height, 1, 24, 0, data_size, 0, 0, 0, 0};", distractors: [{text: "BMPInfoHeader info_header = {sizeof(BMPFileHeader), img->width, img->height, 1, 24, 0, data_size, 0, 0, 0, 0};", reason: "Header size should be sizeof(BMPInfoHeader), not sizeof(BMPFileHeader)."}, {text: "BMPInfoHeader info_header = {sizeof(BMPInfoHeader), img->width, img->height, 3, 24, 0, data_size, 0, 0, 0, 0};", reason: "Planes field must be 1, not 3."}], indent: 1, explanation: "Construct the info header." },
        { correct: "  fwrite(&file_header, sizeof(BMPFileHeader), 1, fp);", distractors: [{text: "fwrite(file_header, sizeof(BMPFileHeader), 1, fp);", reason: "Need address of the struct (&file_header)."}, {text: "fread(&file_header, sizeof(BMPFileHeader), 1, fp);", reason: "Should be fwrite (writing), not fread (reading)."}], indent: 1, explanation: "Write the file header to the file." },
        { correct: "  fwrite(&info_header, sizeof(BMPInfoHeader), 1, fp);", distractors: [{text: "fwrite(&file_header, sizeof(BMPInfoHeader), 1, fp);", reason: "Should write info_header, not file_header again."}, {text: "fwrite(info_header, sizeof(BMPInfoHeader), 1, fp);", reason: "Need address of the struct (&info_header)."}], indent: 1, explanation: "Write the info header to the file." },
        { correct: "  fwrite(img->data, 1, data_size, fp);", distractors: [{text: "fwrite(img->data, data_size, 1, fp);", reason: "Writing byte-by-byte: fwrite(ptr, 1, count, file)."}, {text: "fread(img->data, 1, data_size, fp);", reason: "Should be fwrite (writing), not fread (reading)."}], indent: 1, explanation: "Write the raw pixel data to the file." },
        { correct: "  fclose(fp);", distractors: [{text: "close(fp);", reason: "Use fclose() for FILE*, not close()."}, {text: "free(fp);", reason: "Use fclose() to close files, not free()."}], indent: 1, explanation: "Close the file." },
        { correct: "  return 0;", distractors: [{text: "return 1;", reason: "Return 0 for success, non-zero for error."}, {text: "return NULL;", reason: "Function returns int, not pointer."}], indent: 1, explanation: "Return 0 on success." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "fclose(fp);", reason: "File is already closed before return."}], indent: 0, explanation: "Close `bmp_save`." },
        { correct: "void image_destroy(Image* img) {", distractors: [{text: "int image_destroy(Image* img) {", reason: "Destructors typically return void."}, {text: "void image_destroy(const Image* img) {", reason: "Need to modify/free the image, so can't use const."}], indent: 0, explanation: "Implement the destructor." },
        { correct: "  if (img) { free(img->data); free(img); }", distractors: [{text: "if (img) { free(img); free(img->data); }", reason: "Must free data first, then the struct containing the pointer."}, {text: "free(img->data); free(img);", reason: "Should check if img is not NULL before dereferencing."}], indent: 1, explanation: "Free the pixel data first, then the main struct." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "return;", reason: "void functions don't need explicit return at the end."}], indent: 0, explanation: "Close `image_destroy`." },
        { correct: "void image_apply_grayscale(Image* img) {", distractors: [{text: "Image* image_apply_grayscale(Image* img) {", reason: "This function modifies in-place, so void return is appropriate."}, {text: "void image_apply_grayscale(const Image* img) {", reason: "Need to modify pixels, so can't use const."}], indent: 0, explanation: "Implement the grayscale filter." },
        { correct: "  for (int i = 0; i < img->width * img->height; i++) {", distractors: [{text: "for (int i = 1; i <= img->width * img->height; i++) {", reason: "Array indices start at 0, not 1."}, {text: "for (int i = 0; i < img->width + img->height; i++) {", reason: "Total pixels is width * height, not width + height."}], indent: 1, explanation: "Loop through every pixel in the image." },
        { correct: "    uint8_t gray = (uint8_t)(img->data[i].r * 0.299 + img->data[i].g * 0.587 + img->data[i].b * 0.114);", distractors: [{text: "uint8_t gray = (img->data[i].r + img->data[i].g + img->data[i].b) / 3;", reason: "Weighted average (0.299, 0.587, 0.114) is more accurate than simple average."}, {text: "uint8_t gray = (uint8_t)(img->data[i].b * 0.299 + img->data[i].g * 0.587 + img->data[i].r * 0.114);", reason: "Standard weights are: red=0.299, green=0.587, blue=0.114."}], indent: 2, explanation: "Calculate the weighted average of the R, G, and B components to get a grayscale value." },
        { correct: "    img->data[i].r = gray;", distractors: [{text: "img->data[i].r = 255;", reason: "Should set to the calculated gray value, not always 255."}, {text: "img->data[i].g = gray;", reason: "This line should set the red component."}], indent: 2, explanation: "Set the Red component to the gray value." },
        { correct: "    img->data[i].g = gray;", distractors: [{text: "img->data[i].g = 0;", reason: "Should set to the calculated gray value, not 0."}, {text: "img->data[i].r = gray;", reason: "This line should set the green component."}], indent: 2, explanation: "Set the Green component to the gray value." },
        { correct: "    img->data[i].b = gray;", distractors: [{text: "img->data[i].b = 128;", reason: "Should set to the calculated gray value, not a fixed value."}, {text: "img->data[i].g = gray;", reason: "This line should set the blue component."}], indent: 2, explanation: "Set the Blue component to the gray value." },
        { correct: "  }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "i++;", reason: "The for loop already increments i."}], indent: 1, explanation: "Close the pixel loop." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "return;", reason: "void functions don't need explicit return."}], indent: 0, explanation: "Close `image_apply_grayscale`." },
        { correct: "void image_apply_invert(Image* img) {", distractors: [{text: "Image* image_apply_invert(const Image* img) {", reason: "Function modifies in-place and returns void."}, {text: "int image_apply_invert(Image* img) {", reason: "No error conditions to report, so void return is appropriate."}], indent: 0, explanation: "Implement the color inversion filter." },
        { correct: "  for (int i = 0; i < img->width * img->height; i++) {", distractors: [{text: "for (int i = 0; i <= img->width * img->height; i++) {", reason: "Should be < not <= to avoid accessing beyond array bounds."}, {text: "for (int i = 0; i < img->width; i++) {", reason: "Should iterate through all pixels (width * height), not just width."}], indent: 1, explanation: "Loop through every pixel." },
        { correct: "    img->data[i].r = 255 - img->data[i].r;", distractors: [{text: "img->data[i].r = 0 - img->data[i].r;", reason: "Inversion is 255 - value, not 0 - value."}, {text: "img->data[i].r = img->data[i].r - 255;", reason: "Should be 255 - value, not value - 255."}], indent: 2, explanation: "Invert the Red component." },
        { correct: "    img->data[i].g = 255 - img->data[i].g;", distractors: [{text: "img->data[i].g = ~img->data[i].g;", reason: "Use arithmetic inversion (255-x), not bitwise NOT (~x)."}, {text: "img->data[i].r = 255 - img->data[i].g;", reason: "Should invert green into green, not green into red."}], indent: 2, explanation: "Invert the Green component." },
        { correct: "    img->data[i].b = 255 - img->data[i].b;", distractors: [{text: "img->data[i].b = 256 - img->data[i].b;", reason: "Max value for uint8_t is 255, not 256."}, {text: "img->data[i].g = 255 - img->data[i].b;", reason: "Should invert blue into blue, not blue into green."}], indent: 2, explanation: "Invert the Blue component." },
        { correct: "  }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "return img;", reason: "Function returns void, not Image*."}], indent: 1, explanation: "Close the pixel loop." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "return 0;", reason: "Function returns void, not int."}], indent: 0, explanation: "Close `image_apply_invert`." }
    ]
},

// Level 90: convolutional kernels
{
    "goal": "Apply convolutional kernels to an image for advanced filtering like sharpening and edge detection.",
    concepts: "Convolution, image kernels, nested loops, boundary handling, advanced image processing",
    sequence: [
        { correct: "// === Stage 1: Setup and Prerequisite Image Structs ===", distractors: [{text: "// === Stage 1: Setup and Prerequisite Image Struct ===", reason: "We're defining multiple structs, so plural is correct."}, {text: "// === Step 1: Setup and Prerequisite Image Structs ===", reason: "'Stage' is more appropriate for major sections."}], indent: 0, explanation: "Define the necessary includes and data structures. We will reuse some from the previous level." },
        { correct: "#include <stdio.h>", distractors: [{text: "include <stdio.h>", reason: "Preprocessor directives must begin with '#'."}, {text: "#include \"stdio.h\"", reason: "Standard library headers use angle brackets <>, not quotes."}], indent: 0, explanation: "Standard I/O." },
        { correct: "#include <stdlib.h>", distractors: [{text: "#include <malloc.h>", reason: "stdlib.h is the standard header for memory management."}, {text: "#include <memory.h>", reason: "memory.h is not standard C; malloc is in stdlib.h."}], indent: 0, explanation: "Memory management." },
        { correct: "#include <stdint.h>", distractors: [{text: "#include <inttypes.h>", reason: "stdint.h provides fixed-width types like uint8_t."}, {text: "#include <limits.h>", reason: "stdint.h is for fixed-width types, not numeric limits."}], indent: 0, explanation: "Fixed-width integers." },
        { correct: "#include <string.h>", distractors: [{text: "#include <strings.h>", reason: "string.h is the standard header for memcpy."}, {text: "#include <cstring.h>", reason: "cstring.h doesn't exist in C."}], indent: 0, explanation: "For `memcpy`." },
        { correct: "// A simplified Pixel struct for this example.", distractors: [{text: "// A complex Pixel struct for this example.", reason: "We're using a simplified struct for grayscale."}, {text: "// A simplified Pixels struct for this example.", reason: "We're defining one pixel type, so singular is correct."}], indent: 0, explanation: "We will work with grayscale images for simplicity in convolution." },
        { correct: "typedef struct { uint8_t value; } PixelGray;", distractors: [{text: "typedef struct { int value; } PixelGray;", reason: "Grayscale pixels are single bytes (uint8_t), not full integers."}, {text: "typedef struct { uint8_t r, g, b; } PixelGray;", reason: "Grayscale pixels have one value, not separate RGB components."}], indent: 0, explanation: "A struct for a single 8-bit grayscale pixel." },
        { correct: "typedef struct { int width, height; PixelGray* data; } ImageGray;", distractors: [{text: "typedef struct { float width, height; PixelGray* data; } ImageGray;", reason: "Image dimensions should be integers, not floats."}, {text: "typedef struct { int width, height; PixelGray data; } ImageGray;", reason: "Need a pointer to dynamic array (PixelGray*), not a single pixel."}], indent: 0, explanation: "A struct to hold a grayscale image." },
        { correct: "// A struct to represent our convolutional kernel.", distractors: [{text: "// A struct to represent our convolutional kernels.", reason: "We're defining one kernel type, so singular is correct."}, {text: "// A function to represent our convolutional kernel.", reason: "This is a struct definition, not a function."}], indent: 0, explanation: "The kernel is a small matrix that we slide over the image." },
        { correct: "typedef struct { int size; float* data; } Kernel;", distractors: [{text: "typedef struct { int width, height; float* data; } Kernel;", reason: "We assume square kernels, so one size dimension is sufficient."}, {text: "typedef struct { int size; int* data; } Kernel;", reason: "Kernel values are often fractional, so float is more appropriate than int."}], indent: 0, explanation: "We will assume square kernels (e.g., 3x3), so we only need one size dimension." },
        { correct: "// --- Function Prototypes ---", distractors: [{text: "// --- Function Prototype ---", reason: "We're declaring multiple prototypes, so plural is correct."}, {text: "// --- Function Declarations ---", reason: "'Prototypes' is the more specific term."}], indent: 0, explanation: "Declare the functions for our convolution engine." },
        { correct: "ImageGray* image_create(int width, int height);", distractors: [{text: "ImageGray image_create(int width, int height);", reason: "Should return a pointer for dynamic allocation."}, {text: "void image_create(int width, int height, ImageGray* img);", reason: "Returning pointer is more conventional."}], indent: 0, explanation: "Creates an empty grayscale image." },
        { correct: "void image_destroy(ImageGray* img);", distractors: [{text: "int image_destroy(ImageGray* img);", reason: "Destructors typically return void."}, {text: "void image_destroy(const ImageGray* img);", reason: "Need to modify/free the image, so can't use const."}], indent: 0, explanation: "Frees an image." },
        { correct: "ImageGray* image_apply_convolution(const ImageGray* src, const Kernel* kernel);", distractors: [{text: "void image_apply_convolution(ImageGray* src, const Kernel* kernel);", reason: "Should return new image rather than modify in-place for convolution."}, {text: "ImageGray* image_apply_convolution(ImageGray* src, Kernel* kernel);", reason: "Both inputs should be const since we're not modifying them."}], indent: 0, explanation: "The core function to apply a kernel to a source image." },
        { correct: "// --- Stage 2: Convolution Algorithm Implementation ===", distractors: [{text: "// --- Stage 2: Convolution Algorithm Implementations ===", reason: "We're implementing one main algorithm, so singular is correct."}, {text: "// --- Step 2: Convolution Algorithm Implementation ===", reason: "'Stage' is consistent with previous sections."}], indent: 0, explanation: "Implement the core logic for applying the filter." },
        { correct: "ImageGray* image_create(int width, int height) {", distractors: [{text: "ImageGray image_create(int width, int height) {", reason: "Should return pointer for dynamic allocation."}, {text: "void image_create(int width, int height, ImageGray* result) {", reason: "Returning pointer is more conventional than output parameter."}], indent: 0, explanation: "Start the image constructor." },
        { correct: "  ImageGray* img = malloc(sizeof(ImageGray));", distractors: [{text: "ImageGray* img = malloc(sizeof(ImageGray));", reason: "Should be indented to match function body."}, {text: "ImageGray img = malloc(sizeof(ImageGray));", reason: "malloc returns a pointer, so img should be pointer type."}], indent: 1, explanation: "Allocate the main struct." },
        { correct: "  img->width = width; img->height = height;", distractors: [{text: "img.width = width; img.height = height;", reason: "img is a pointer, so use -> not . to access members."}, {text: "img->width = height; img->height = width;", reason: "Don't swap width and height."}], indent: 1, explanation: "Set dimensions." },
        { correct: "  img->data = malloc(width * height * sizeof(PixelGray));", distractors: [{text: "img->data = malloc(width * height);", reason: "Need to multiply by sizeof(PixelGray) to get correct byte count."}, {text: "img.data = malloc(width * height * sizeof(PixelGray));", reason: "img is a pointer, so use -> not ."}], indent: 1, explanation: "Allocate the pixel buffer." },
        { correct: "  return img;", distractors: [{text: "return *img;", reason: "Should return the pointer, not dereference it."}, {text: "return NULL;", reason: "Should return the successfully created image."}], indent: 1, explanation: "Return the new image." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "free(img);", reason: "We want to return the image, not free it."}], indent: 0, explanation: "Close `image_create`." },
        { correct: "void image_destroy(ImageGray* img) {", distractors: [{text: "int image_destroy(ImageGray* img) {", reason: "Destructors typically return void."}, {text: "void image_destroy(const ImageGray* img) {", reason: "Need to free the image, so can't use const."}], indent: 0, explanation: "Implement the destructor." },
        { correct: "  if (img) { free(img->data); free(img); }", distractors: [{text: "if (img) { free(img); free(img->data); }", reason: "Must free data first, then the struct containing the pointer."}, {text: "free(img->data); free(img);", reason: "Should check if img is not NULL before dereferencing."}], indent: 1, explanation: "Free the pixel data and then the struct." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "return;", reason: "void functions don't need explicit return."}], indent: 0, explanation: "Close `image_destroy`." },
        { correct: "uint8_t clamp(float value) {", distractors: [{text: "int clamp(float value) {", reason: "Should return uint8_t to match pixel component type."}, {text: "float clamp(float value) {", reason: "Should return uint8_t since we're clamping to 0-255 range."}], indent: 0, explanation: "A helper function to ensure pixel values stay within the 0-255 range." },
        { correct: "  if (value > 255.0f) return 255;", distractors: [{text: "if (value > 256.0f) return 255;", reason: "Max value for uint8_t is 255, not 256."}, {text: "if (value >= 255.0f) return 255;", reason: "255 is a valid value, so use > not >=."}], indent: 1, explanation: "Clamp high values to 255." },
        { correct: "  if (value < 0.0f) return 0;", distractors: [{text: "if (value <= 0.0f) return 0;", reason: "0 is a valid value, so use < not <=."}, {text: "if (value < -1.0f) return 0;", reason: "Should clamp any negative value to 0."}], indent: 1, explanation: "Clamp low values to 0." },
        { correct: "  return (uint8_t)value;", distractors: [{text: "return value;", reason: "Need to cast float to uint8_t."}, {text: "return (int)value;", reason: "Should cast to uint8_t, not int."}], indent: 1, explanation: "Return the value as a valid byte." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "return 0;", reason: "We already returned the clamped value."}], indent: 0, explanation: "Close `clamp`." },
        { correct: "ImageGray* image_apply_convolution(const ImageGray* src, const Kernel* kernel) {", distractors: [{text: "void image_apply_convolution(ImageGray* src, const Kernel* kernel) {", reason: "Should return new image rather than modify in-place."}, {text: "ImageGray* image_apply_convolution(ImageGray* src, Kernel* kernel) {", reason: "Both parameters should be const since we don't modify them."}], indent: 0, explanation: "The main convolution function." },
        { correct: "  printf(\"Applying %dx%d kernel...\\n\", kernel->size, kernel->size);", distractors: [{text: "printf(\"Applying %dx%d kernel...\\n\", kernel->width, kernel->height);", reason: "Kernel struct uses size field, not width/height."}, {text: "printf(\"Applying %dx%d kernel...\", kernel->size, kernel->size);", reason: "Missing newline character \\n."}], indent: 1, explanation: "Informational message." },
        { correct: "  ImageGray* dest = image_create(src->width, src->height);", distractors: [{text: "ImageGray dest = image_create(src->width, src->height);", reason: "image_create returns a pointer, so dest should be pointer type."}, {text: "ImageGray* dest = image_create(kernel->size, kernel->size);", reason: "Destination should have same dimensions as source, not kernel."}], indent: 1, explanation: "Create a new destination image to store the results. We cannot modify the image in-place." },
        { correct: "  int kernel_radius = kernel->size / 2;", distractors: [{text: "int kernel_radius = kernel->size * 2;", reason: "Radius is size divided by 2, not multiplied by 2."}, {text: "float kernel_radius = kernel->size / 2.0f;", reason: "Integer division is fine here; we want integer coordinates."}], indent: 1, explanation: "Calculate the radius of the kernel (e.g., for a 3x3 kernel, the radius is 1)." },
        { correct: "  // Iterate over every pixel in the source image.", distractors: [{text: "// Iterate over every pixel in the source image.", reason: "Should be indented to match function body."}, {text: "// Iterate over every pixel in the destination image.", reason: "We're iterating over source image coordinates."}], indent: 1, explanation: "Comment on the main loop." },
        { correct: "  for (int y = 0; y < src->height; y++) {", distractors: [{text: "for (int y = 1; y <= src->height; y++) {", reason: "Array indices start at 0, not 1."}, {text: "for (int y = 0; y < dest->height; y++) {", reason: "While equivalent, using src is more clear about what we're iterating."}], indent: 1, explanation: "Loop through each row." },
        { correct: "    for (int x = 0; x < src->width; x++) {", distractors: [{text: "for (int x = 1; x <= src->width; x++) {", reason: "Array indices start at 0, not 1."}, {text: "for (int x = 0; x < kernel->size; x++) {", reason: "Should iterate through image width, not kernel size."}], indent: 2, explanation: "Loop through each column." },
        { correct: "      // For each pixel, apply the kernel.", distractors: [{text: "// For each pixel, apply the kernel.", reason: "Should be indented to match the nested loop."}, {text: "// For each kernel, apply the pixel.", reason: "We apply the kernel to each pixel, not the other way around."}], indent: 3, explanation: "Comment on applying the kernel." },
        { correct: "      float sum = 0.0f;", distractors: [{text: "int sum = 0;", reason: "Should use float for accumulator to handle fractional kernel values."}, {text: "float sum;", reason: "Should initialize sum to 0 before accumulating."}], indent: 3, explanation: "Initialize the accumulator for the weighted sum." },
        { correct: "      // Iterate over the kernel itself.", distractors: [{text: "// Iterate over the kernel itself.", reason: "Should be indented to match the nested loop."}, {text: "// Iterate over the image itself.", reason: "This inner loop iterates over the kernel, not the image."}], indent: 3, explanation: "Comment on the kernel loop." },
        { correct: "      for (int ky = 0; ky < kernel->size; ky++) {", distractors: [{text: "for (int ky = 1; ky <= kernel->size; ky++) {", reason: "Array indices start at 0, not 1."}, {text: "for (int ky = 0; ky < src->height; ky++) {", reason: "Should iterate through kernel size, not image height."}], indent: 3, explanation: "Loop through kernel rows." },
        { correct: "        for (int kx = 0; kx < kernel->size; kx++) {", distractors: [{text: "for (int kx = 1; kx <= kernel->size; kx++) {", reason: "Array indices start at 0, not 1."}, {text: "for (int kx = 0; kx < src->width; kx++) {", reason: "Should iterate through kernel size, not image width."}], indent: 4, explanation: "Loop through kernel columns." },
        { correct: "          // Find the corresponding image pixel for this kernel point.", distractors: [{text: "// Find the corresponding image pixel for this kernel point.", reason: "Should be indented to match the nested loop."}, {text: "// Find the corresponding kernel point for this image pixel.", reason: "We're finding image pixels that correspond to kernel points."}], indent: 5, explanation: "Comment on coordinate calculation." },
        { correct: "          int pixel_x = x + (kx - kernel_radius);", distractors: [{text: "int pixel_x = x + kx;", reason: "Need to subtract kernel_radius to center the kernel."}, {text: "int pixel_x = kx - kernel_radius;", reason: "Need to add the image x coordinate to the kernel offset."}], indent: 5, explanation: "Calculate the x-coordinate of the image pixel under the kernel." },
        { correct: "          int pixel_y = y + (ky - kernel_radius);", distractors: [{text: "int pixel_y = y + ky;", reason: "Need to subtract kernel_radius to center the kernel."}, {text: "int pixel_y = x + (ky - kernel_radius);", reason: "Should use y coordinate, not x coordinate."}], indent: 5, explanation: "Calculate the y-coordinate." },
        { correct: "          // Handle image boundaries (edge cases).", distractors: [{text: "// Handle image boundaries (edge cases).", reason: "Should be indented to match the nested loop."}, {text: "// Handle kernel boundaries (edge cases).", reason: "We're checking image boundaries, not kernel boundaries."}], indent: 5, explanation: "Comment on boundary handling." },
        { correct: "          if (pixel_x >= 0 && pixel_x < src->width && pixel_y >= 0 && pixel_y < src->height) {", distractors: [{text: "if (pixel_x > 0 && pixel_x <= src->width && pixel_y > 0 && pixel_y <= src->height) {", reason: "Should use >= 0 and < size, not > 0 and <= size."}, {text: "if (pixel_x >= 0 && pixel_x < dest->width && pixel_y >= 0 && pixel_y < dest->height) {", reason: "Should check source image bounds, not destination (though they're the same)."}], indent: 5, explanation: "Check if the calculated pixel is within the image bounds." },
        { correct: "            float image_val = src->data[pixel_y * src->width + pixel_x].value;", distractors: [{text: "float image_val = src->data[pixel_x * src->width + pixel_y].value;", reason: "2D to 1D indexing is row * width + col, not col * width + row."}, {text: "int image_val = src->data[pixel_y * src->width + pixel_x].value;", reason: "Should use float for calculations even though pixel is uint8_t."}], indent: 6, explanation: "Get the value of the source image pixel." },
        { correct: "            float kernel_val = kernel->data[ky * kernel->size + kx];", distractors: [{text: "float kernel_val = kernel->data[kx * kernel->size + ky];", reason: "2D to 1D indexing is row * width + col, so ky * size + kx."}, {text: "float kernel_val = kernel->data[ky + kx];", reason: "Need proper 2D to 1D indexing: ky * kernel->size + kx."}], indent: 6, explanation: "Get the corresponding value from the kernel." },
        { correct: "            sum += image_val * kernel_val;", distractors: [{text: "sum += image_val + kernel_val;", reason: "Convolution uses multiplication, not addition."}, {text: "sum = image_val * kernel_val;", reason: "Should accumulate (+=), not replace (=)."}], indent: 6, explanation: "Multiply them and add to the sum." },
        { correct: "          }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "sum = 0;", reason: "Don't reset sum here; we're accumulating."}], indent: 5, explanation: "Close the boundary check." },
        { correct: "        }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "break;", reason: "No need to break; continue the kernel loop."}], indent: 4, explanation: "Close kernel column loop." },
        { correct: "      }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "continue;", reason: "No need for continue at end of loop."}], indent: 3, explanation: "Close kernel row loop." },
        { correct: "      // Set the destination pixel's value to the calculated sum.", distractors: [{text: "// Set the destination pixel's value to the calculated sum.", reason: "Should be indented to match the nested loop."}, {text: "// Set the source pixel's value to the calculated sum.", reason: "We're setting the destination pixel, not modifying the source."}], indent: 3, explanation: "Comment on setting the destination pixel." },
        { correct: "      dest->data[y * dest->width + x].value = clamp(sum);", distractors: [{text: "dest->data[x * dest->width + y].value = clamp(sum);", reason: "2D to 1D indexing is row * width + col, not col * width + row."}, {text: "src->data[y * src->width + x].value = clamp(sum);", reason: "Should set destination pixel, not modify source."}], indent: 3, explanation: "Assign the final sum to the destination image, clamping it to the 0-255 range." },
        { correct: "    }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "return dest;", reason: "The return should come after both loops complete."}], indent: 2, explanation: "Close image column loop." },
        { correct: "  }", distractors: [{text: "};", reason: "Code blocks end with }, not };"}, {text: "return dest;", reason: "The return should come after both loops complete."}], indent: 1, explanation: "Close image row loop." },
        { correct: "  return dest;", distractors: [{text: "return src;", reason: "Should return the new destination image, not the source."}, {text: "return NULL;", reason: "Should return the processed destination image."}], indent: 1, explanation: "Return the newly created, filtered image." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "image_destroy(dest);", reason: "We want to return dest, not destroy it."}], indent: 0, explanation: "Close `image_apply_convolution`." },
        { correct: "// === Stage 3: Main Program to Demonstrate Convolution ===", distractors: [{text: "// === Stage 3: Main Program to Demonstrate Convolutions ===", reason: "We're demonstrating one convolution operation, so singular is correct."}, {text: "// === Step 3: Main Program to Demonstrate Convolution ===", reason: "'Stage' is consistent with previous sections."}], indent: 0, explanation: "A `main` function to define kernels and apply them." },
        { correct: "int main() {", distractors: [{text: "void main() {", reason: "Standard C requires main to return int."}, {text: "int main(void) {", reason: "Empty parentheses are fine when no arguments are used."}], indent: 0, explanation: "Start main." },
        { correct: "  // Create a simple source image (e.g., a white square on a black background).", distractors: [{text: "// Create a simple source image (e.g., a white square on a black background).", reason: "Should be indented to match function body."}, {text: "// Create a complex source image (e.g., a white square on a black background).", reason: "This is a simple test image."}], indent: 1, explanation: "Comment on creating a test image." },
        { correct: "  ImageGray* source_image = image_create(50, 50);", distractors: [{text: "ImageGray source_image = image_create(50, 50);", reason: "image_create returns a pointer, so should be pointer type."}, {text: "ImageGray* source_image = image_create(50, 60);", reason: "Using 50x50 makes a square, which is simpler for demo."}], indent: 1, explanation: "Create a 50x50 image." },
        { correct: "  for(int y=10; y<40; y++) { for(int x=10; x<40; x++) source_image->data[y*50+x].value = 255; }", distractors: [{text: "for(int y=10; y<40; y++) { for(int x=10; x<40; x++) source_image->data[x*50+y].value = 255; }", reason: "2D to 1D indexing is row * width + col, not col * width + row."}, {text: "for(int y=0; y<50; y++) { for(int x=0; x<50; x++) source_image->data[y*50+x].value = 255; }", reason: "Creating a white box in the middle (10-40) is better for edge detection demo."}], indent: 1, explanation: "Draw a white box in the middle of it." },
        { correct: "  printf(\"--- Convolution Demo ---\\n\");", distractors: [{text: "printf(\"--- Convolution Demo ---\\n\");", reason: "Should be indented to match function body."}, {text: "printf(\"--- Convolution Demo ---\");", reason: "Missing newline character \\n."}], indent: 1, explanation: "Header." },
        { correct: "  // Define an Edge Detection Kernel (Sobel X).", distractors: [{text: "// Define an Edge Detection Kernel (Sobel X).", reason: "Should be indented to match function body."}, {text: "// Define a Blur Kernel (Sobel X).", reason: "Sobel kernels are for edge detection, not blurring."}], indent: 1, explanation: "Comment on the edge detection kernel." },
        { correct: "  float sobel_x_data[] = { -1, 0, 1, -2, 0, 2, -1, 0, 1 };", distractors: [{text: "int sobel_x_data[] = { -1, 0, 1, -2, 0, 2, -1, 0, 1 };", reason: "Kernel values can be fractional, so float is more appropriate."}, {text: "float sobel_x_data[] = { 1, 0, -1, 2, 0, -2, 1, 0, -1 };", reason: "This is Sobel X flipped; standard form has negative values on left."}], indent: 1, explanation: "This kernel detects vertical edges." },
        { correct: "  Kernel sobel_kernel = { .size = 3, .data = sobel_x_data };", distractors: [{text: "Kernel sobel_kernel = { .size = 9, .data = sobel_x_data };", reason: "Size is the dimension (3x3), not the total number of elements (9)."}, {text: "Kernel sobel_kernel = { 3, sobel_x_data };", reason: "Using designated initializers (.size =) is clearer."}], indent: 1, explanation: "Create a Kernel struct for it." },
        { correct: "  // Apply the kernel.", distractors: [{text: "// Apply the kernel.", reason: "Should be indented to match function body."}, {text: "// Apply the kernels.", reason: "We're applying one kernel, so singular is correct."}], indent: 1, explanation: "Comment on applying the filter." },
        { correct: "  ImageGray* edge_image = image_apply_convolution(source_image, &sobel_kernel);", distractors: [{text: "ImageGray edge_image = image_apply_convolution(source_image, &sobel_kernel);", reason: "Function returns a pointer, so should be pointer type."}, {text: "ImageGray* edge_image = image_apply_convolution(&source_image, sobel_kernel);", reason: "source_image is already a pointer; sobel_kernel needs address-of."}], indent: 1, explanation: "Call the convolution function." },
        { correct: "  printf(\"Edge detection filter applied.\\n\");", distractors: [{text: "printf(\"Edge detection filter applied.\\n\");", reason: "Should be indented to match function body."}, {text: "printf(\"Blur filter applied.\\n\");", reason: "We applied edge detection, not blur."}], indent: 1, explanation: "Confirmation message." },
        { correct: "  // In a real program, you would now save `edge_image` to a file to see the result.", distractors: [{text: "// In a real program, you would now save `edge_image` to a file to see the result.", reason: "Should be indented to match function body."}, {text: "// In a real program, you would now save `source_image` to a file to see the result.", reason: "We want to save the processed edge_image, not the original."}], indent: 1, explanation: "Comment on what the next step would be." },
        { correct: "  printf(\"The resulting image would show bright lines on the vertical edges of the white square.\\n\");", distractors: [{text: "printf(\"The resulting image would show bright lines on the horizontal edges of the white square.\\n\");", reason: "Sobel X kernel detects vertical edges, not horizontal."}, {text: "printf(\"The resulting image would show dark lines on the vertical edges of the white square.\\n\");", reason: "Edge detection typically produces bright lines on edges."}], indent: 1, explanation: "Describe the expected output." },
        { correct: "  // Cleanup", distractors: [{text: "// Cleanup", reason: "Should be indented to match function body."}, {text: "// Memory cleanup", reason: "'Cleanup' is more concise."}], indent: 1, explanation: "Comment on cleanup." },
        { correct: "  image_destroy(source_image);", distractors: [{text: "image_destroy(source_image);", reason: "Should be indented to match function body."}, {text: "free(source_image);", reason: "Should use image_destroy which properly handles both data and struct."}], indent: 1, explanation: "Free the source image." },
        { correct: "  image_destroy(edge_image);", distractors: [{text: "image_destroy(source_image);", reason: "This line should destroy edge_image, not source_image again."}, {text: "free(edge_image);", reason: "Should use image_destroy for proper cleanup."}], indent: 1, explanation: "Free the destination image." },
        { correct: "  return 0;", distractors: [{text: "return 0;", reason: "Should be indented to match function body."}, {text: "return 1;", reason: "Return 0 for success, not 1."}], indent: 1, explanation: "Indicate success." },
        { correct: "}", distractors: [{text: "};", reason: "Function definitions end with }, not };"}, {text: "exit(0);", reason: "We already returned 0; this would be unreachable."}], indent: 0, explanation: "Close main." }
    ]
},
    // Level 91: Prep for Samsung
    {
    "goal": "Implement a fixed-block-size memory pool allocator to manage memory efficiently, a common task in embedded and system-level programming.",
    "concepts": "Memory management, pointers, linked lists, bit manipulation, memory alignment, system programming",
    "sequence": [
    { "correct": "// === Stage 1: Data Structures and Core Declarations ===", distractors: [{"text":"// === Stage 1: The Main Program ===", reason:"Good design dictates that we define the core data structures and API before implementing the logic or the main program that uses them."}], indent: 0, explanation: "Define the fundamental structures for our memory pool." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"The standard I/O function `printf` is declared in `<stdio.h>`."}], indent: 0, explanation: "For standard input/output functions like printf." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <string.h>", reason:"The standard memory allocation functions `malloc` and `free` are prototyped in `<stdlib.h>`."}], indent: 0, explanation: "For standard memory allocation (`malloc`, `free`) to get the initial memory pool." },
    { "correct": "#include <stdint.h>", distractors: [{"text":"#include <inttypes.h>", reason:"While `<inttypes.h>` also provides fixed-width types, `<stdint.h>` is the more direct and standard header for just the type definitions like `uintptr_t`."}], indent: 0, explanation: "For using fixed-width integer types like `uintptr_t` and `size_t`." },
    { "correct": "#define BLOCK_SIZE 64", distractors: [{"text":"const size_t BLOCK_SIZE = 64;", reason:"Using a `const` variable is also a valid way to create a constant. A `#define` is a preprocessor macro that is a common C idiom for such constants, especially in systems programming."}], indent: 0, explanation: "Define the size of each memory block we will manage. 64 bytes is a common size." },
    { "correct": "#define POOL_SIZE 1024", distractors: [{"text":"#define POOL_SIZE 1024;", reason:"Preprocessor macros should not end with a semicolon, as it becomes part of the text replacement and can cause syntax errors in certain contexts."}], indent: 0, explanation: "Define the total number of blocks in our memory pool." },
    { "correct": "// This node will be part of a free list, overlayed on the unused memory blocks.", distractors: [{"text":"// A struct to hold user data.", reason:"This struct is not for user data. It's a clever trick: its structure is temporarily imposed on a free block of memory to turn it into a node in a linked list."}], indent: 0, explanation: "A comment explaining the purpose of the FreeBlockNode struct." },
    { "correct": "typedef struct FreeBlockNode {", distractors: [{"text":"struct FreeBlockNode {", reason:"Without `typedef`, you would have to write `struct FreeBlockNode*` every time, which is more verbose."}], indent: 0, explanation: "Start definition of the node for the free list." },
    { "correct": "  struct FreeBlockNode* next;", distractors: [{"text":"  FreeBlockNode next;", reason:"A struct cannot contain a full instance of itself, as this would require infinite memory. It must be a pointer to its own type to form a linked list."}], indent: 1, explanation: "A pointer to the next free block in the list." },
    { "correct": "} FreeBlockNode;", distractors: [{"text":"};", reason:"When using `typedef` with a struct definition, the new type alias (`FreeBlockNode`) must be provided before the final semicolon."}], indent: 0, explanation: "Complete the typedef for FreeBlockNode." },
    { "correct": "// This is the main struct for our memory pool allocator.", distractors: [{"text":"// A struct to represent a single block.", reason:"This comment is inaccurate. This is the main control struct for the *entire pool*, not just one block."}], indent: 0, explanation: "A comment explaining the allocator's main control structure." },
    { "correct": "typedef struct {", distractors: [{"text":"struct MemoryPool {", reason:"Using `typedef` is a convenience that lets us declare pool variables as `MemoryPool p;` instead of `struct MemoryPool p;`."}], indent: 0, explanation: "Start definition of the MemoryPool struct." },
    { "correct": "  void* pool_start;", distractors: [{"text":"  char* pool_start;", reason:"Using `char*` would also work (and is necessary for pointer arithmetic), but `void*` is more explicit that this is a pointer to raw, untyped memory."}], indent: 1, explanation: "A pointer to the beginning of the large memory chunk we allocate from the OS." },
    { "correct": "  FreeBlockNode* free_list_head;", distractors: [{"text":"  FreeBlockNode free_list_head;", reason:"The head of the list must be a pointer so it can be `NULL` (indicating an empty list) and can point to different blocks as the list changes."}], indent: 1, explanation: "A pointer to the head of the linked list of available blocks." },
    { "correct": "} MemoryPool;", distractors: [{"text":"} MemoryPool", reason:"A `typedef` statement must always end with a semicolon."}], indent: 0, explanation: "Complete the typedef for MemoryPool." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text":"// --- Function Implementations ---", reason:"These are just the forward declarations (prototypes) for the API. The implementations come later."}], indent: 0, explanation: "Declare the public API for our memory allocator." },
    { "correct": "void pool_init(MemoryPool* pool);", distractors: [{"text":"MemoryPool* pool_init();", reason:"This is an alternative design where the function allocates the pool struct itself. The current design requires the user to provide the struct, which is also a common pattern."}], indent: 0, explanation: "Initializes the memory pool, setting up the free list." },
    { "correct": "void* pool_alloc(MemoryPool* pool);", distractors: [{"text":"int pool_alloc(MemoryPool* pool);", reason:"The function must return a pointer to the allocated memory block. `void*` is the correct generic pointer type for this."}], indent: 0, explanation: "Allocates one block of memory from the pool." },
    { "correct": "void pool_free(MemoryPool* pool, void* block);", distractors: [{"text":"void pool_free(void* block);", reason:"The function needs to know which pool the block belongs to in order to add it back to the correct free list."}], indent: 0, explanation: "Returns a block of memory to the pool's free list." },
    { "correct": "void pool_destroy(MemoryPool* pool);", distractors: [{"text":"int pool_destroy(MemoryPool* pool);", reason:"A 'destroy' function's job is to clean up. It doesn't need to return a value, so `void` is the appropriate return type."}], indent: 0, explanation: "Releases the entire memory pool back to the OS." },
    { "correct": "// === Stage 2: Memory Pool Initialization ===", distractors: [{"text":"// === Stage 2: Allocation Logic ===", reason:"Before we can allocate from the pool, we must first implement the logic to create and initialize it."}], indent: 0, explanation: "Implement the logic to set up the memory pool and the free list." },
    { "correct": "void pool_init(MemoryPool* pool) {", distractors: [{"text":"void pool_init(MemoryPool pool) {", reason:"The definition must match the prototype. Passing by value would modify a copy, and the changes would be lost when the function returns. We must use a pointer."}], indent: 0, explanation: "Begin the implementation of `pool_init`." },
    { "correct": "  printf(\"Initializing memory pool with %d blocks of %d bytes...\\n\", POOL_SIZE, BLOCK_SIZE);", distractors: [{"text":"  printf(\"Initializing memory pool.\\n\");", reason:"This is less informative. Printing the specific size and capacity of the pool is much more useful for debugging."}], indent: 1, explanation: "Print an informational message about the pool's capacity." },
    { "correct": "  size_t total_size = POOL_SIZE * BLOCK_SIZE;", distractors: [{"text":"  size_t total_size = POOL_SIZE;", reason:"This would only allocate enough memory for 1024 bytes, not 1024 blocks of 64 bytes each."}], indent: 1, explanation: "Calculate the total number of bytes needed for the entire pool." },
    { "correct": "  pool->pool_start = malloc(total_size);", distractors: [{"text":"  pool.pool_start = malloc(total_size);", reason:"`pool` is a pointer to a struct. You must use the arrow operator `->` to access its members, not the dot operator `.`."}], indent: 1, explanation: "Request a single large chunk of memory from the operating system." },
    { "correct": "  if (pool->pool_start == NULL) {", distractors: [{"text":"  if (!pool->pool_start) {", reason:"This is a valid and common shorthand for checking if a pointer is NULL."}], indent: 1, explanation: "Check if the system `malloc` failed." },
    { "correct": "    fprintf(stderr, \"Failed to allocate memory for the pool.\\n\");", distractors: [{"text":"    printf(\"Failed to allocate memory for the pool.\\n\");", reason:"It is conventional to print critical error messages to standard error (`stderr`) instead of standard output (`stdout`)."}] , indent: 2, explanation: "Print an error message to standard error if allocation fails." },
    { "correct": "    exit(EXIT_FAILURE);", distractors: [{"text":"    return;", reason:"This is a critical, unrecoverable error. If the pool can't be created, the program cannot continue. It's appropriate to `exit` immediately."}], indent: 2, explanation: "Terminate the program if we cannot create the memory pool." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block's closing brace."}], indent: 1, explanation: "Close the failure check block." },
    { "correct": "  // Now, build the linked list of free blocks.", distractors: [{"text":"  // The memory is ready to use.", reason:"This is false. The memory has been allocated, but the free list data structure has not been built yet, so our `pool_alloc` would not work."}], indent: 1, explanation: "Comment explaining the next step: creating the free list." },
    { "correct": "  pool->free_list_head = NULL;", distractors: [{"text":"  // No initialization needed.", reason:"This is a bug. If the head is not initialized to `NULL`, it will start with a garbage value, and the linking logic that follows will fail."}], indent: 1, explanation: "Initialize the head of the free list to NULL before building it." },
    { "correct": "  for (int i = 0; i < POOL_SIZE; ++i) {", distractors: [{"text":"  for (int i = 0; i <= POOL_SIZE - 1; ++i) {", reason:"This is a logically equivalent and correct way to write the loop's condition."}], indent: 1, explanation: "Loop through each block in the pool to add it to the free list." },
    { "correct": "    // Calculate the address of the current block.", distractors: [{"text":"    // Allocate each block individually.", reason:"This is incorrect. We are not allocating here; we are calculating the address of a block within the single large chunk we already allocated."}], indent: 2, explanation: "Comment on calculating block address." },
    { "correct": "    void* current_block_addr = (char*)pool->pool_start + (i * BLOCK_SIZE);", distractors: [{"text":"    void* current_block_addr = pool->pool_start + (i * BLOCK_SIZE);", reason:"This is a compiler error. You cannot perform pointer arithmetic on a `void*`. It must first be cast to a pointer of a known size, like `char*`."}], indent: 2, explanation: "Get the address of the i-th block by offsetting from the start of the pool." },
    { "correct": "    // Cast this block to a FreeBlockNode to add it to the list.", distractors: [{"text":"    // Allocate a new FreeBlockNode.", reason:"This is incorrect. The core idea is to *overlay* the `FreeBlockNode` structure on top of the existing block's memory, not to allocate new memory for it."}], indent: 2, explanation: "Comment explaining the type cast." },
    { "correct": "    FreeBlockNode* new_node = (FreeBlockNode*)current_block_addr;", distractors: [{"text":"    FreeBlockNode new_node = *(FreeBlockNode*)current_block_addr;", reason:"This would create a local copy of the node, which would not work. We need a pointer to the actual memory block."}], indent: 2, explanation: "Treat the current block's memory as a FreeBlockNode." },
    { "correct": "    new_node->next = pool->free_list_head;", distractors: [{"text":"    pool->free_list_head = new_node;", reason:"This assignment must come *after* linking the new node to the old head. Doing it first would lose the rest of the list on every iteration."}], indent: 2, explanation: "Set the new node's `next` to the current head of the free list." },
    { "correct": "    pool->free_list_head = new_node;", distractors: [{"text":"    new_node->next = NULL;", reason:"This would be a bug. Each new node would have its `next` set to `NULL`, so the free list would never contain more than one item."}], indent: 2, explanation: "Update the head of the free list to be this new node." },
    { "correct": "  }", distractors: [{"text":"end for;", reason:"This is not valid C syntax."}], indent: 1, explanation: "End of the for loop for initializing free list nodes." },
    { "correct": "  printf(\"Memory pool initialized successfully.\\n\");", distractors: [{"text":"  puts(\"Memory pool initialized successfully.\");", reason:"`puts` is a simpler and equally valid way to print this message."}], indent: 1, explanation: "Confirm successful initialization." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "Close the `pool_init` function." },
    { "correct": "// === Stage 3: Allocation and Deallocation Logic ===", distractors: [{"text":"// === Stage 3: Initialization ===", reason:"Initialization was Stage 2. This stage implements the core `alloc` and `free` logic."}], indent: 0, explanation: "Implement the core functions for getting and returning memory blocks." },
    { "correct": "void* pool_alloc(MemoryPool* pool) {", distractors: [{"text":"void* pool_alloc(MemoryPool pool) {", reason:"The function must operate on the original pool, not a copy. It must accept a pointer."}], indent: 0, explanation: "Begin the implementation of `pool_alloc`." },
    { "correct": "  // Check if there are any free blocks available.", distractors: [{"text":"  // Allocate a new block.", reason:"This allocator does not get more memory from the OS; it manages a fixed-size pool. This step checks if any pre-allocated blocks are available."}], indent: 1, explanation: "Comment explaining the check for an empty free list." },
    { "correct": "  if (pool->free_list_head == NULL) {", distractors: [{"text":"  if (!pool->free_list_head) {", reason:"This is a valid and common shorthand for checking if a pointer is NULL."}], indent: 1, explanation: "If the free list head is NULL, the pool is full." },
    { "correct": "    printf(\"Allocation failed: Memory pool is empty.\\n\");", distractors: [{"text":"    return exit(1);", reason:"A failed allocation is not necessarily a fatal error. Returning `NULL` allows the calling program to handle the failure gracefully."}], indent: 2, explanation: "Inform the user that no blocks are available." },
    { "correct": "    return NULL; // Indicate failure", distractors: [{"text":"    return 0;", reason:"This function returns a pointer. The standard way to indicate a failed pointer allocation is to return `NULL`, not the integer 0."}], indent: 2, explanation: "Return NULL to signal that the allocation failed." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "Close the empty check block." },
    { "correct": "  // Get the block from the head of the free list.", distractors: [{"text":"  // Search the list for a free block.", reason:"Searching is not necessary. The `free_list_head` always points directly to an available block, making allocation a fast O(1) operation."}], indent: 1, explanation: "Comment explaining how a block is retrieved." },
    { "correct": "  FreeBlockNode* block_to_alloc = pool->free_list_head;", distractors: [{"text":"  void* block_to_alloc = pool->free_list_head;", reason:"It's better to get the node as a `FreeBlockNode*` first, so we can access its `next` member before casting it to `void*` for the return."}], indent: 1, explanation: "Get a pointer to the first available block." },
    { "correct": "  // Move the free list head to the next available block.", distractors: [{"text":"  // Free the block we are allocating.", reason:"This is incorrect. We are taking the block *off* the free list to give to the user; we are not freeing it."}], indent: 1, explanation: "Comment on updating the free list." },
    { "correct": "  pool->free_list_head = block_to_alloc->next;", distractors: [{"text":"  pool->free_list_head = NULL;", reason:"This would be a bug. It would make the free list empty after the very first allocation."}], indent: 1, explanation: "Advance the free list head to the next node." },
    { "correct": "  // Return the allocated block as a generic pointer.", distractors: [{"text":"  // Return the whole pool.", reason:"The function should return a pointer to a single block, not the entire pool."}], indent: 1, explanation: "Comment on the return value." },
    { "correct": "  return (void*)block_to_alloc;", distractors: [{"text":"  return block_to_alloc;", reason:"While this often works due to implicit casting, explicitly casting to `void*` makes the function's intent clear."}], indent: 1, explanation: "Return the pointer to the allocated memory. The user can now use this block." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "Close the `pool_alloc` function." },
    { "correct": "void pool_free(MemoryPool* pool, void* block) {", distractors: [{"text":"void* pool_free(MemoryPool* pool, void* block) {", reason:"This function modifies the pool's state but doesn't need to return a value, so `void` is the correct return type."}], indent: 0, explanation: "Begin the implementation of `pool_free`." },
    { "correct": "  if (block == NULL) {", distractors: [{"text":"  if (!block) {", reason:"This is a valid and common shorthand for checking if a pointer is NULL."}], indent: 1, explanation: "Check for an attempt to free a NULL pointer." },
    { "correct": "    printf(\"Warning: Attempt to free a NULL pointer.\\n\");", distractors: [{"text":"    return NULL;", reason:"The function's return type is `void`, so it cannot return a value. An empty `return;` is correct."}], indent: 2, explanation: "It's good practice to handle this case." },
    { "correct": "    return;", distractors: [{"text":"    // Do nothing", reason:"An explicit `return` is clearer and stops execution immediately, which is good practice."}], indent: 2, explanation: "Exit the function if the block is NULL." },
    { "correct": "  }", distractors: [{"text": "};", reason:"Semicolons are not used after `if` blocks."}], indent: 1, explanation: "Close the NULL check." },
    { "correct": "  // Boundary check: ensure the pointer is within our pool.", distractors: [{"text":"  // This check is optional.", reason:"This is false. This check is critical for stability. Without it, a user could accidentally free a pointer not from the pool, corrupting the free list."}], indent: 1, explanation: "A crucial security and stability check." },
    { "correct": "  uintptr_t block_addr = (uintptr_t)block;", distractors: [{"text":"  int block_addr = (int)block;", reason:"An `int` may not be large enough to hold a memory address on a 64-bit system. `uintptr_t` is guaranteed to be large enough, making it the correct, portable choice."}], indent: 1, explanation: "Cast the block pointer to an integer for address arithmetic." },
    { "correct": "  uintptr_t pool_start_addr = (uintptr_t)pool->pool_start;", distractors: [{"text":"  // No need for this variable", reason:"Assigning the addresses to named variables makes the boundary check condition on the next line much easier to read."}], indent: 1, explanation: "Get the starting address of the pool as an integer." },
    { "correct": "  uintptr_t pool_end_addr = pool_start_addr + (POOL_SIZE * BLOCK_SIZE);", distractors: [{"text":"  uintptr_t pool_end_addr = pool_start_addr + POOL_SIZE;", reason:"This is a bug. The total size is the number of blocks multiplied by the size of each block."}], indent: 1, explanation: "Calculate the end address of the pool." },
    { "correct": "  if (block_addr < pool_start_addr || block_addr >= pool_end_addr) {", distractors: [{"text":"  if (block_addr > pool_start_addr && block_addr < pool_end_addr) {", reason:"This logic is reversed. This would check if the block is *inside* the pool, but the error should trigger if it's *outside*."}], indent: 1, explanation: "Check if the block address is outside the valid range." },
    { "correct": "    fprintf(stderr, \"Error: Attempt to free memory not managed by this pool.\\n\");", distractors: [{"text":"    printf(\"Error: Invalid pointer.\\n\");", reason:"Using `fprintf` to `stderr` is conventional for error messages. The original message is also more descriptive."}], indent: 2, explanation: "Report a critical error." },
    { "correct": "    return;", distractors: [{"text":"    exit(1);", reason:"This is a severe error, but exiting the entire program might be too drastic. Returning allows the caller to decide how to handle the error."}], indent: 2, explanation: "Exit if the pointer is invalid." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used after `if` blocks."}], indent: 1, explanation: "Close the boundary check." },
    { "correct": "  // Alignment check: ensure it's a valid block boundary.", distractors: [{"text":"  // No need for this check.", reason:"This check is very important. It prevents a user from freeing a pointer that is somewhere in the *middle* of a valid block, which would corrupt memory."}], indent: 1, explanation: "Another important validation step." },
    { "correct": "  if ((block_addr - pool_start_addr) % BLOCK_SIZE != 0) {", distractors: [{"text":"  if ((block_addr - pool_start_addr) % BLOCK_SIZE == 0) {", reason:"This logic is reversed. The modulo should be 0 for a correctly aligned pointer. This `if` should trigger if the result is *not* 0."}], indent: 1, explanation: "Check if the pointer corresponds to the start of a block." },
    { "correct": "    fprintf(stderr, \"Error: Attempt to free a pointer with invalid alignment.\\n\");", distractors: [{"text":"    printf(\"Error: Bad pointer.\\n\");", reason:"The original error message is much more specific and helpful for debugging what went wrong."}], indent: 2, explanation: "This indicates memory corruption or incorrect pointer usage." },
    { "correct": "    return;", distractors: [{"text":"    // Continue", reason:"This is a critical memory safety error. The program must not proceed with freeing this invalid pointer."}], indent: 2, explanation: "Exit on alignment error." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 1, explanation: "Close the alignment check." },
    { "correct": "  // Cast the block back to a FreeBlockNode.", distractors: [{"text":"  // Allocate a new FreeBlockNode.", reason:"This is incorrect. We are not allocating new memory; we are re-imposing the `FreeBlockNode` structure on the block of memory that the user is returning."}], indent: 1, explanation: "Comment explaining the type cast for re-linking." },
    { "correct": "  FreeBlockNode* node_to_free = (FreeBlockNode*)block;", distractors: [{"text":"  FreeBlockNode* node_to_free = malloc(sizeof(FreeBlockNode));", reason:"This is a bug. It would allocate a new node instead of reusing the memory from the block being freed."}], indent: 1, explanation: "Overlay the FreeBlockNode structure onto the memory being freed." },
    { "correct": "  // Add the block back to the head of the free list.", distractors: [{"text":"  // Add the block to the tail of the free list.", reason:"Adding to the head is an O(1) operation and is much simpler and faster than traversing the entire list to add to the tail."}], indent: 1, explanation: "Comment on the re-linking process." },
    { "correct": "  node_to_free->next = pool->free_list_head;", distractors: [{"text":"  pool->free_list_head = node_to_free;", reason:"This is a bug. This assignment must come *after* linking the freed block to the old head. Doing it first orphans the rest of the free list."}], indent: 1, explanation: "The freed block's `next` pointer now points to the old head." },
    { "correct": "  pool->free_list_head = node_to_free;", distractors: [{"text":"  node_to_free->next = NULL;", reason:"This would be incorrect. It would make the free list only ever contain the last block that was freed, effectively losing all other freed blocks."}], indent: 1, explanation: "The head of the free list is now the block we just freed." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "Close the `pool_free` function." },
    { "correct": "// === Stage 4: Pool Destruction and Cleanup ===", distractors: [{"text":"// === Stage 4: Allocation Logic ===", reason:"This stage is about destroying the pool, not allocating from it."}], indent: 0, explanation: "Implement the function to release all resources." },
    { "correct": "void pool_destroy(MemoryPool* pool) {", distractors: [{"text":"void pool_destroy(void) {", reason:"The function needs to know *which* pool to destroy, so it must accept the `MemoryPool*` as a parameter."}], indent: 0, explanation: "Begin the implementation of `pool_destroy`." },
    { "correct": "  printf(\"Destroying memory pool...\\n\");", distractors: [{"text":"  puts(\"Destroying memory pool...\");", reason:"`puts` is a valid and simpler alternative for printing this fixed string."}], indent: 1, explanation: "Informational message about cleanup." },
    { "correct": "  if (pool && pool->pool_start) {", distractors: [{"text":"  if (pool) {", reason:"This is not safe enough. `pool` could exist, but `pool_start` could be `NULL` if initialization failed partway. Checking both is more robust."}], indent: 1, explanation: "Check if the pool and its memory exist before trying to free them." },
    { "correct": "    free(pool->pool_start);", distractors: [{"text":"    for (int i=0; i<POOL_SIZE; i++) { free(...); }", reason:"This is a critical bug. The entire pool was allocated as one single chunk. It must be freed with one single call to `free`. Freeing individual blocks will cause a crash."}], indent: 2, explanation: "Release the large chunk of memory back to the operating system." },
    { "correct": "    pool->pool_start = NULL;", distractors: [{"text":"    // No need to set to NULL", reason:"Setting a pointer to NULL after freeing it is a crucial safety practice called 'nullifying a dangling pointer'. It prevents accidental use-after-free."}], indent: 2, explanation: "Set the pointer to NULL to prevent dangling pointers." },
    { "correct": "    pool->free_list_head = NULL;", distractors: [{"text":"    free(pool->free_list_head);", reason:"This is a bug. `free_list_head` is just a pointer into the `pool_start` memory block, which has already been freed. Freeing it again is a double-free error."}], indent: 2, explanation: "Also nullify the free list head." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 1, explanation: "Close the check block." },
    { "correct": "  printf(\"Memory pool destroyed.\\n\");", distractors: [{"text":"  puts(\"Memory pool destroyed.\");", reason:"`puts` is an equally valid way to print this message."}], indent: 1, explanation: "Confirm successful destruction." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "Close the `pool_destroy` function." },
    { "correct": "// === Stage 5: Main Program for Demonstration ===", distractors: [{"text":"// === Stage 5: The Allocator Implementation ===", reason:"This stage is the `main` function that acts as a user of our allocator to test and demonstrate it."}], indent: 0, explanation: "A `main` function to test the memory pool allocator." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid and often preferred way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start of the main function." },
    { "correct": "  printf(\"--- Custom Memory Allocator Demo ---\\n\");", distractors: [{"text":"  puts(\"--- Custom Memory Allocator Demo ---\");", reason:"`puts` is a valid and simpler alternative for printing this title."}], indent: 1, explanation: "Print a title for the demonstration." },
    { "correct": "  MemoryPool my_pool;", distractors: [{"text":"  MemoryPool* my_pool = malloc(sizeof(MemoryPool));", reason:"Our `pool_init` function is designed to work on an existing struct. Creating it on the stack is simpler than allocating it dynamically."}], indent: 1, explanation: "Declare an instance of our MemoryPool struct." },
    { "correct": "  pool_init(&my_pool);", distractors: [{"text":"  pool_init(my_pool);", reason:"The `pool_init` function expects a pointer to the pool (`MemoryPool*`). We must pass the address of our stack variable using the `&` operator."}], indent: 1, explanation: "Initialize the memory pool." },
    { "correct": "  // --- Test allocation ---", distractors: [{"text":"  // --- Test deallocation ---", reason:"This comment is inaccurate. The following lines test the allocation logic."}], indent: 1, explanation: "Comment indicating the start of the allocation test." },
    { "correct": "  void* ptr1 = pool_alloc(&my_pool);", distractors: [{"text":"  int* ptr1 = pool_alloc(&my_pool);", reason:"`pool_alloc` returns a generic `void*`. While it will be cast to an `int*` later, it's best practice to store it as a `void*` first."}], indent: 1, explanation: "Allocate the first block." },
    { "correct": "  printf(\"Allocated block 1 at address: %p\\n\", ptr1);", distractors: [{"text":"  printf(\"Allocated block 1\\n\");", reason:"This is less useful. Printing the actual memory address is key to seeing how the allocator works."}], indent: 1, explanation: "Print the address of the allocated block." },
    { "correct": "  void* ptr2 = pool_alloc(&my_pool);", distractors: [{"text":"  void* ptr2 = malloc(BLOCK_SIZE);", reason:"This would bypass our custom allocator and use the system's `malloc`. The goal is to use our own `pool_alloc` function."}], indent: 1, explanation: "Allocate the second block." },
    { "correct": "  printf(\"Allocated block 2 at address: %p\\n\", ptr2);", distractors: [{"text":"  printf(\"Allocated block 2 at address: %d\\n\", ptr2);", reason:"`%d` is for integers. The correct format specifier for printing a pointer address is `%p`."}], indent: 1, explanation: "Print its address." },
    { "correct": "  // Let's use the memory to store some data", distractors: [{"text":"  // The memory is empty", reason:"This comment is less descriptive of the action being taken in the following lines."}], indent: 1, explanation: "Comment on actually using the allocated memory." },
    { "correct": "  if (ptr1) { *(int*)ptr1 = 12345; }", distractors: [{"text":"  if (ptr1) { *ptr1 = 12345; }", reason:"This is a compiler error. You cannot dereference a `void*`. It must first be cast to a specific pointer type, like `int*`."}], indent: 1, explanation: "Store an integer in the first block." },
    { "correct": "  if (ptr2) { *(int*)ptr2 = 67890; }", distractors: [{"text":"  if (ptr2) { (int*)ptr2 = 67890; }", reason:"The cast `(int*)` must be part of the dereference expression `*(int*)ptr2`, not on the left side of the assignment."}], indent: 1, explanation: "Store an integer in the second block." },
    { "correct": "  printf(\"Stored data: ptr1 -> %d, ptr2 -> %d\\n\", *(int*)ptr1, *(int*)ptr2);", distractors: [{"text":"  printf(\"Stored data: %d, %d\\n\", ptr1, ptr2);", reason:"This would print the memory addresses as integers, not the data stored at those addresses. You must dereference the casted pointers."}], indent: 1, explanation: "Retrieve and print the stored data to verify." },
    { "correct": "  // --- Test deallocation ---", distractors: [{"text":"  // --- Test allocation ---", reason:"This comment is incorrect. The following code demonstrates freeing memory, not allocating it."}], indent: 1, explanation: "Comment indicating the start of the deallocation test." },
    { "correct": "  printf(\"Freeing block 1...\\n\");", distractors: [{"text":"  puts(\"Freeing block 1...\");", reason:"`puts` is a valid and simpler alternative here."}], indent: 1, explanation: "Informational message." },
    { "correct": "  pool_free(&my_pool, ptr1);", distractors: [{"text":"  free(ptr1);", reason:"This is a critical error. The memory was allocated by our custom pool, so it must be returned to the pool using `pool_free`. Using the system `free` would corrupt the heap."}], indent: 1, explanation: "Return the first block to the pool." },
    { "correct": "  printf(\"Block 1 returned to the pool.\\n\");", distractors: [{"text":"  puts(\"Block 1 returned to the pool.\");", reason:"`puts` is an equally valid way to print this message."}], indent: 1, explanation: "Confirmation." },
    { "correct": "  // --- Test reallocation ---", distractors: [{"text":"  // --- Test initialization ---", reason:"This is not initialization. This section demonstrates that freed blocks are reused by subsequent allocations."}], indent: 1, explanation: "Comment for reallocation test." },
    { "correct": "  void* ptr3 = pool_alloc(&my_pool);", distractors: [{"text":"  void* ptr3 = ptr1;", reason:"This would be a use-after-free bug. `ptr1` has been freed and its memory is available for reuse, but the pointer itself is now invalid."}], indent: 1, explanation: "Allocate another block. It should reuse the memory from ptr1." },
    { "correct": "  printf(\"Allocated block 3 at address: %p (should be same as ptr1)\\n\", ptr3);", distractors: [{"text":"  if (ptr3 == ptr1) { printf(\"Reuse successful\\n\"); }", reason:"This is another good way to verify that the memory was reused as expected."}], indent: 1, explanation: "Print the address of the new block to show it's the same as the freed one." },
    { "correct": "  // --- Test exhaustion ---", distractors: [{"text":"  // --- Test performance ---", reason:"While this demonstrates a characteristic of the pool, 'exhaustion' is a more accurate term for testing its capacity limits."}], indent: 1, explanation: "Comment for testing the pool's limit." },
    { "correct": "  printf(\"Attempting to exhaust the pool...\\n\");", distractors: [{"text":"  puts(\"Attempting to exhaust the pool...\");", reason:"`puts` is a valid alternative here."}], indent: 1, explanation: "Informational message." },
    { "correct": "  void* pointers[POOL_SIZE];", distractors: [{"text":"  void* pointers[POOL_SIZE + 1];", reason:"This would allocate more space than needed. The goal is to see what happens when the pool is full, so an array of exactly `POOL_SIZE` is appropriate."}], indent: 1, explanation: "Create an array to hold pointers to all allocated blocks." },
    { "correct": "  int allocated_count = 0;", distractors: [{"text":"  int allocated_count;", reason:"It's critical to initialize counters to 0. An uninitialized local variable holds a garbage value."}], indent: 1, explanation: "Initialize a counter for allocations." },
    { "correct": "  for(int i = 0; i < POOL_SIZE; ++i) {", distractors: [{"text":"  for(int i = 0; i < POOL_SIZE * BLOCK_SIZE; ++i) {", reason:"This is a bug. The loop should run `POOL_SIZE` times (once for each block), not once for each byte."}], indent: 1, explanation: "Loop to try and allocate all available blocks." },
    { "correct": "    pointers[i] = pool_alloc(&my_pool);", distractors: [{"text":"    pointers[allocated_count] = pool_alloc(&my_pool);", reason:"Using `i` as the index is correct for this loop. `allocated_count` might not be the same if an allocation were to fail unexpectedly."}], indent: 2, explanation: "Attempt to allocate a block." },
    { "correct": "    if (pointers[i] != NULL) {", distractors: [{"text":"    if (pointers[i]) {", reason:"This is a valid and common shorthand for checking if a pointer is not NULL."}], indent: 2, explanation: "Check if allocation was successful." },
    { "correct": "      allocated_count++;", distractors: [{"text":"      allocated_count += 1;", reason:"This is also correct, but `++` is the more common C idiom."}], indent: 3, explanation: "Increment the counter if successful." },
    { "correct": "    } else {", distractors: [{"text":"    }", reason:"An `else` block is needed to handle the case where `pool_alloc` returns NULL, so we can `break` the loop."}], indent: 2, explanation: "If allocation fails..." },
    { "correct": "      break; // Stop when the pool is empty.", distractors: [{"text":"      continue;", reason:"`continue` would just move to the next iteration of the loop, which would also fail. `break` is needed to exit the loop entirely."}], indent: 3, explanation: "Break the loop." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used after `if/else` blocks."}], indent: 2, explanation: "Close the if/else block." },
    { "correct": "  }", distractors: [{"text":"end for;", reason:"This is not valid C syntax."}], indent: 1, explanation: "End of the allocation loop." },
    { "correct": "  printf(\"Successfully allocated %d blocks before exhaustion.\\n\", allocated_count);", distractors: [{"text":"  printf(\"Loop finished.\\n\");", reason:"This is less informative. Printing the actual count of allocated blocks is better for verifying the test."}], indent: 1, explanation: "Report how many blocks were allocated." },
    { "correct": "  void* extra_ptr = pool_alloc(&my_pool); // This should fail", distractors: [{"text":"  void* extra_ptr = malloc(BLOCK_SIZE);", reason:"This would bypass our pool and use the system allocator. The point of this test is to show our pool correctly reporting it is full."}], indent: 1, explanation: "Try to allocate one more block, expecting failure." },
    { "correct": "  if (extra_ptr == NULL) { printf(\"As expected, allocation failed after pool was exhausted.\\n\"); }", distractors: [{"text":"  if (!extra_ptr) { ... }", reason:"This is a valid and common shorthand for checking if the pointer is NULL."}], indent: 1, explanation: "Confirm that the allocation failed as expected." },
    { "correct": "  // --- Test cleanup ---", distractors: [{"text":"  // --- Test finished ---", reason:"'Test cleanup' is more descriptive, as the following lines are about freeing memory."}], indent: 1, explanation: "Comment indicating the final cleanup test." },
    { "correct": "  pool_destroy(&my_pool);", distractors: [{"text":"  free(&my_pool);", reason:"`my_pool` is a stack variable, so it cannot be freed. More importantly, you must call `pool_destroy` to free the large memory chunk *inside* the pool."}], indent: 1, explanation: "Destroy the pool, releasing all its memory." },
    { "correct": "  printf(\"--- Demo Finished ---\\n\");", distractors: [{"text":"  puts(\"--- Demo Finished ---\");", reason:"`puts` is a valid alternative here."}], indent: 1, explanation: "Final message." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 signals an error. This program should return 0 to indicate it completed its demonstration successfully."}], indent: 1, explanation: "Return 0 to indicate successful execution." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of the main function." }
]
},
// Level 92: Prep for Oracle
{
    "goal": "Implement a simplified in-memory B-Tree to store and search for integer keys, simulating a core component of a database index.",
    "concepts": "B-Tree, data structures, recursion, dynamic memory allocation, file I/O (for persistence simulation), database indexing concepts",
    "sequence": [
    { "correct": "// === Stage 1: B-Tree Node Structure and Constants ===", distractors: [{"text":"// === Stage 1: The Main Program ===", reason:"It is fundamental to define the data structures of a complex system like a B-Tree before writing the code that uses them."}], indent: 0, explanation: "Define the constants and data structures that form the building blocks of our B-Tree." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"The standard I/O function `printf` is declared in `<stdio.h>`."}], indent: 0, explanation: "For standard I/O operations like printf." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <stdbool.h>", reason:"`malloc` and `free` are part of the standard library, `<stdlib.h>`."}], indent: 0, explanation: "For memory management functions like malloc and free." },
    { "correct": "#include <stdbool.h>", distractors: [{"text":"// No include needed for bool", reason:"The `bool`, `true`, and `false` keywords are not part of the C language by default. They are defined in the `<stdbool.h>` header as of the C99 standard."}], indent: 0, explanation: "For using boolean types `true` and `false`." },
    { "correct": "#define T 3", distractors: [{"text":"#define T 2", reason:"T=2 defines a 2-3-4 tree, which is a specific, valid type of B-Tree. T must be >= 2."}, {"text":"const int T = 3;", reason:"Using `#define` allows `T` to be used to declare the size of arrays inside our struct, which is not possible with a `const int` variable."}], indent: 0, explanation: "Define the minimum degree (or order) of the B-Tree. T=3 means each node has at most 5 keys (2*T-1) and at most 6 children (2*T)." },
    { "correct": "// A structure to represent a node in the B-Tree", distractors: [{"text":"// A structure for the entire B-Tree", reason:"This struct defines a single node. The B-Tree itself will be a separate struct that just points to the root node."}], indent: 0, explanation: "Comment explaining the B-Tree node." },
    { "correct": "typedef struct BTreeNode {", distractors: [{"text":"struct BTreeNode {", reason:"Without `typedef`, we would have to write `struct BTreeNode *children[...]` and `struct BTreeNode*` for the return type, which is more verbose."}], indent: 0, explanation: "Start of the BTreeNode struct definition." },
    { "correct": "  int keys[2 * T - 1];", distractors: [{"text":"  int* keys;", reason:"For a B-Tree where `T` is a small, compile-time constant, embedding the array directly in the struct is simpler and more memory-efficient than managing a separate dynamic allocation for keys."}], indent: 1, explanation: "An array to store the keys within the node." },
    { "correct": "  struct BTreeNode *children[2 * T];", distractors: [{"text":"  BTreeNode* children[2*T];", reason:"Because the `typedef` for `BTreeNode` is not yet complete, you must use the `struct BTreeNode` syntax for self-referential pointers."}], indent: 1, explanation: "An array of pointers to child nodes." },
    { "correct": "  int n;", distractors: [{"text":"  size_t n;", reason:"`size_t` is also a perfectly valid and often preferred type for counts and sizes."}], indent: 1, explanation: "The current number of keys stored in the node." },
    { "correct": "  bool is_leaf;", distractors: [{"text":"  int is_leaf;", reason:"Using an `int` as a boolean flag (0 for false, 1 for true) is the traditional C way. Using `bool` from `<stdbool.h>` is more modern and expressive."}], indent: 1, explanation: "A boolean flag that is true if the node is a leaf, and false otherwise." },
    { "correct": "} BTreeNode;", distractors: [{"text":"};", reason:"Because this is a `typedef`, the new type alias (`BTreeNode`) must be provided before the final semicolon."}], indent: 0, explanation: "End of the BTreeNode typedef." },
    { "correct": "// A structure for the B-Tree itself", distractors: [{"text":"// A structure for a B-Tree leaf node", reason:"This comment is incorrect. This is the main control structure for the entire tree, not just a leaf."}], indent: 0, explanation: "Comment for the main B-Tree control structure." },
    { "correct": "typedef struct {", distractors: [{"text":"struct BTree {", reason:"Using `typedef` is a convenience that lets us declare trees as `BTree* t;` instead of `struct BTree* t;`."}], indent: 0, explanation: "Start of the BTree struct definition." },
    { "correct": "  BTreeNode *root;", distractors: [{"text":"  BTreeNode root;", reason:"The root must be a pointer. If it were a struct, the `BTree` object itself would be huge, and we couldn't represent an empty tree or change the root node easily."}], indent: 1, explanation: "A pointer to the root node of the tree." },
    { "correct": "} BTree;", distractors: [{"text":"} BTree", reason:"A `typedef` statement must always end with a semicolon."}], indent: 0, explanation: "End of the BTree typedef." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text":"// --- Function Implementations ---", reason:"These are just the forward declarations (prototypes). The function bodies (implementations) are defined later."}], indent: 0, explanation: "Forward declarations of the functions we will implement." },
    { "correct": "BTree* btree_create();", distractors: [{"text":"void btree_create(BTree* tree);", reason:"A 'constructor' function typically allocates memory for the new object and returns a pointer to it."}], indent: 0, explanation: "Creates and initializes an empty B-Tree." },
    { "correct": "BTreeNode* btree_create_node(bool is_leaf);", distractors: [{"text":"BTreeNode btree_create_node(bool is_leaf);", reason:"Nodes are always dynamically allocated, so this function must return a pointer (`BTreeNode*`), not a struct by value."}], indent: 0, explanation: "Allocates and initializes a single B-Tree node." },
    { "correct": "void btree_insert(BTree* tree, int key);", distractors: [{"text":"int btree_insert(BTree* tree, int key);", reason:"An insert operation modifies the tree's state. It doesn't typically calculate a value to return, so `void` is a good return type."}], indent: 0, explanation: "Inserts a new key into the B-Tree." },
    { "correct": "void btree_insert_nonfull(BTreeNode* node, int key);", distractors: [{"text":"void btree_insert(BTreeNode* node, int key);", reason:"Using a different name for this internal helper function makes the code's intent clearer. This function has the special precondition that the node is not full."}], indent: 0, explanation: "Helper function to insert a key into a non-full node." },
    { "correct": "void btree_split_child(BTreeNode* parent, int index, BTreeNode* child);", distractors: [{"text":"void btree_split_child(BTreeNode* child);", reason:"To split a child, the function needs a pointer to the parent node so it can be modified to link to the new sibling and adopt the median key."}], indent: 0, explanation: "Splits a full child node of a given parent node." },
    { "correct": "BTreeNode* btree_search(BTreeNode* node, int key);", distractors: [{"text":"bool btree_search(BTreeNode* node, int key);", reason:"Returning just `true` or `false` is a valid design. Returning a pointer to the node that contains the key can be more useful, as it allows the caller to access other data in that node."}], indent: 0, explanation: "Searches for a key in the subtree rooted at a given node." },
    { "correct": "void btree_traverse(BTreeNode* node);", distractors: [{"text":"void btree_traverse(BTree* tree);", reason:"Traversal is a recursive operation that works on nodes. It's conventional to start it by passing the root node, not the entire tree structure."}], indent: 0, explanation: "Traverses and prints all keys in the subtree rooted at a given node." },
    { "correct": "// === Stage 2: Node and Tree Creation ===", distractors: [{"text":"// === Stage 2: The Main Program ===", reason:"First, we must implement the core creation logic before we can use it in a main program."}], indent: 0, explanation: "Implement the basic allocation and initialization functions." },
    { "correct": "BTreeNode* btree_create_node(bool is_leaf) {", distractors: [{"text":"BTreeNode* btree_create_node(int is_leaf) {", reason:"The definition must match the prototype. Using the `bool` type from `<stdbool.h>` is more expressive than using an `int`."}], indent: 0, explanation: "Begin implementation of the node constructor." },
    { "correct": "  BTreeNode* new_node = (BTreeNode*)malloc(sizeof(BTreeNode));", distractors: [{"text":"  BTreeNode* new_node = (BTreeNode*)malloc(sizeof(BTreeNode*));", reason:"This is a critical bug. It allocates memory for a pointer, not the entire, much larger, BTreeNode struct, which would lead to a buffer overflow."}], indent: 1, explanation: "Allocate memory for a new node." },
    { "correct": "  if (!new_node) { perror(\"Failed to allocate BTreeNode\"); exit(EXIT_FAILURE); }", distractors: [{"text":"  if (new_node == NULL) { return NULL; }", reason:"Failing to allocate a node is a critical, unrecoverable error in this design. Exiting the program is an appropriate response."}], indent: 1, explanation: "Error handling for malloc failure." },
    { "correct": "  new_node->is_leaf = is_leaf;", distractors: [{"text":"  new_node.is_leaf = is_leaf;", reason:"`new_node` is a pointer. The arrow operator `->` must be used to access members of a struct through a pointer."}], indent: 1, explanation: "Set the leaf property based on the parameter." },
    { "correct": "  new_node->n = 0;", distractors: [{"text":"  // No need to initialize n", reason:"This is a bug. The key count `n` would start with a garbage value, and all the B-Tree logic would fail."}], indent: 1, explanation: "Initialize the number of keys to 0." },
    { "correct": "  for (int i = 0; i < 2 * T; i++) { new_node->children[i] = NULL; }", distractors: [{"text":"  // No need to initialize children", reason:"This is a critical bug. The children pointers would hold garbage addresses, and any attempt to traverse the tree would crash."}], indent: 1, explanation: "Initialize all child pointers to NULL." },
    { "correct": "  return new_node;", distractors: [{"text":"  return *new_node;", reason:"This is a type mismatch. The function must return a pointer (`BTreeNode*`), not the struct itself by value."}], indent: 1, explanation: "Return the newly created node." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "End of `btree_create_node`." },
    { "correct": "BTree* btree_create() {", distractors: [{"text":"BTree btree_create() {", reason:"The function definition must match the prototype. It returns a pointer (`BTree*`)."}], indent: 0, explanation: "Begin implementation of the B-Tree constructor." },
    { "correct": "  printf(\"Creating a new B-Tree with minimum degree T=%d\\n\", T);", distractors: [{"text":"  puts(\"Creating a new B-Tree...\");", reason:"This is a valid way to print a message, but the original is more informative because it includes the value of T."}], indent: 1, explanation: "Informational message about the tree's properties." },
    { "correct": "  BTree* new_tree = (BTree*)malloc(sizeof(BTree));", distractors: [{"text":"  BTree new_tree;", reason:"This creates a temporary stack variable. It would be destroyed when the function returns. We need persistent memory from `malloc`."}], indent: 1, explanation: "Allocate memory for the B-Tree control structure." },
    { "correct": "  if (!new_tree) { perror(\"Failed to allocate BTree\"); exit(EXIT_FAILURE); }", distractors: [{"text":"  // Assume malloc succeeds", reason:"This is unsafe. `malloc` can and does fail. You must always check its return value for NULL."}], indent: 1, explanation: "Error handling for malloc failure." },
    { "correct": "  BTreeNode* root = btree_create_node(true);", distractors: [{"text":"  new_tree->root = NULL;", reason:"In this B-Tree implementation, a tree is never truly empty; it always has at least a root node (which may contain 0 keys)."}], indent: 1, explanation: "Create the root node, which is initially a leaf." },
    { "correct": "  new_tree->root = root;", distractors: [{"text":"  new_tree.root = root;", reason:"`new_tree` is a pointer, so the arrow operator `->` must be used to access its members."}], indent: 1, explanation: "Assign the new node as the root of the tree." },
    { "correct": "  return new_tree;", distractors: [{"text":"  return root;", reason:"The API function must return a pointer to the main `BTree` control structure, not just its root node."}], indent: 1, explanation: "Return the pointer to the new B-Tree." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "End of `btree_create`." },
    { "correct": "// === Stage 3: Core B-Tree Operations - Split and Insert ===", distractors: [{"text":"// === Stage 3: Searching ===", reason:"You cannot search the tree until you have implemented the logic to insert data into it."}], indent: 0, explanation: "Implement the logic for splitting a full node and inserting a new key." },
    { "correct": "void btree_split_child(BTreeNode* parent, int index, BTreeNode* child_to_split) {", distractors: [{"text":"void btree_split_child(BTreeNode* parent, int index) {", reason:"The function needs a pointer to the actual child node that is being split to access its keys and children."}], indent: 0, explanation: "Begin implementation of `btree_split_child`." },
    { "correct": "  printf(\"Splitting child at index %d...\\n\", index);", distractors: [{"text":"  // No logging needed", reason:"For a complex algorithm like a B-Tree, logging key operations like node splits is invaluable for debugging and understanding its behavior."}], indent: 1, explanation: "Log the split operation." },
    { "correct": "  // Create a new node which will store (T-1) keys of child_to_split", distractors: [{"text":"  // Create a new node to store T keys", reason:"This is incorrect. A B-Tree node holds a minimum of T-1 keys. After a split, both resulting nodes will have T-1 keys."}], indent: 1, explanation: "Comment explaining the purpose of the new node." },
    { "correct": "  BTreeNode* new_sibling = btree_create_node(child_to_split->is_leaf);", distractors: [{"text":"  BTreeNode* new_sibling = btree_create_node(false);", reason:"The new sibling node will be at the same level as the original child, so it must share the same `is_leaf` status."}], indent: 1, explanation: "The new node has the same leaf status as the node being split." },
    { "correct": "  new_sibling->n = T - 1;", distractors: [{"text":"  new_sibling->n = T;", reason:"This violates a core B-Tree property. A node resulting from a split must have exactly T-1 keys."}], indent: 1, explanation: "The new sibling will have T-1 keys." },
    { "correct": "  // Copy the last (T-1) keys from child_to_split to new_sibling", distractors: [{"text":"  // Copy the first (T-1) keys", reason:"This would be incorrect. The split operation moves the *second half* of the keys to the new sibling node."}], indent: 1, explanation: "Comment on the key transfer." },
    { "correct": "  for (int j = 0; j < T - 1; j++) {", distractors: [{"text":"  for (int j = 0; j < T; j++) {", reason:"This loop would run one too many times, copying an invalid key from the original child."}], indent: 1, explanation: "Loop to copy the keys." },
    { "correct": "    new_sibling->keys[j] = child_to_split->keys[j + T];", distractors: [{"text":"    new_sibling->keys[j] = child_to_split->keys[j];", reason:"This would incorrectly copy the first half of the keys, not the second half."}], indent: 2, explanation: "Copy the second half of the keys from the full child." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End key copy loop." },
    { "correct": "  // If the split node was not a leaf, copy its last T children to the new sibling", distractors: [{"text":"  // Always copy children", reason:"This is incorrect. A leaf node has no children, so this operation should only happen if the node is not a leaf."}], indent: 1, explanation: "Comment on child pointer transfer." },
    { "correct": "  if (!child_to_split->is_leaf) {", distractors: [{"text":"  if (child_to_split->is_leaf) {", reason:"This logic is reversed. Child pointers are only copied if the node is an internal node, not a leaf."}], indent: 1, explanation: "Check if the node to split is an internal node." },
    { "correct": "    for (int j = 0; j < T; j++) {", distractors: [{"text":"    for (int j = 0; j < T - 1; j++) {", reason:"A non-leaf node with 2*T-1 keys has 2*T children. We need to copy T children, not T-1."}], indent: 2, explanation: "Loop to copy child pointers." },
    { "correct": "      new_sibling->children[j] = child_to_split->children[j + T];", distractors: [{"text":"      new_sibling->children[j+T] = child_to_split->children[j];", reason:"This logic is backwards. It copies from the wrong source to the wrong destination."}], indent: 3, explanation: "Copy the second half of the child pointers." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 2, explanation: "End child pointer copy loop." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End of child pointer copy block." },
    { "correct": "  // Reduce the number of keys in the original child", distractors: [{"text":"  // The original child is now empty.", reason:"This is incorrect. After the split, the original child still holds the first T-1 keys."}], indent: 1, explanation: "Comment on updating the original child node." },
    { "correct": "  child_to_split->n = T - 1;", distractors: [{"text":"  child_to_split->n = 0;", reason:"This would incorrectly discard the first T-1 keys remaining in the original child node."}], indent: 1, explanation: "The original child now only has T-1 keys." },
    { "correct": "  // Make space for the new child pointer in the parent node", distractors: [{"text":"  // Overwrite the parent's child pointer.", reason:"We cannot just overwrite. We must shift the existing pointers to the right to make space for the new sibling."}], indent: 1, explanation: "Comment on modifying the parent node." },
    { "correct": "  for (int j = parent->n; j >= index + 1; j--) {", distractors: [{"text":"  for (int j = index + 1; j < parent->n; j++) {", reason:"To shift elements right, you must iterate from right to left to avoid overwriting the values you still need to move."}], indent: 1, explanation: "Loop to shift child pointers in the parent." },
    { "correct": "    parent->children[j + 1] = parent->children[j];", distractors: [{"text":"    parent->children[j] = parent->children[j + 1];", reason:"This would shift elements to the left, overwriting the pointer at `index + 1`."}], indent: 2, explanation: "Shift child pointers one position to the right." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used after a `for` loop."}], indent: 1, explanation: "End child shifting loop." },
    { "correct": "  // Link the new sibling to the parent", distractors: [{"text":"  // Link the old child to the parent again.", reason:"This is incorrect. We need to link the *new sibling node* that was created by the split."}], indent: 1, explanation: "Comment on linking the new node." },
    { "correct": "  parent->children[index + 1] = new_sibling;", distractors: [{"text":"  parent->children[index] = new_sibling;", reason:"This would overwrite the pointer to the original child. The new sibling belongs at `index + 1`."}], indent: 1, explanation: "Insert the new sibling into the parent's children array." },
    { "correct": "  // Make space for the median key in the parent node", distractors: [{"text":"  // Find a space for the key.", reason:"We don't need to find space, we need to *make* space by shifting existing keys."}], indent: 1, explanation: "Comment on shifting keys in the parent." },
    { "correct": "  for (int j = parent->n - 1; j >= index; j--) {", distractors: [{"text":"  for (int j = index; j < parent->n - 1; j++) {", reason:"Shifting right requires iterating from right to left to avoid data loss."}], indent: 1, explanation: "Loop to shift keys in the parent." },
    { "correct": "    parent->keys[j + 1] = parent->keys[j];", distractors: [{"text":"    parent->keys[j] = parent->keys[j-1];", reason:"This would shift left and cause an out-of-bounds read when j=0."}], indent: 2, explanation: "Shift keys one position to the right." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End key shifting loop." },
    { "correct": "  // Move the median key from the child to the parent", distractors: [{"text":"  // Copy the median key from the child.", reason:"'Move' or 'promote' is a more accurate term, because the key is no longer present in the child's key range after the split."}], indent: 1, explanation: "Comment on promoting the median key." },
    { "correct": "  parent->keys[index] = child_to_split->keys[T - 1];", distractors: [{"text":"  parent->keys[index] = child_to_split->keys[T];", reason:"The median key in a full node of size 2*T-1 is at index T-1. Index T is out of bounds for the remaining keys."}], indent: 1, explanation: "The median key is promoted to the parent." },
    { "correct": "  // Increment the count of keys in the parent", distractors: [{"text":"  // Parent key count is unchanged.", reason:"This is false. The parent gains one key (the median from the child) as a result of the split."}], indent: 1, explanation: "Comment on updating the parent's key count." },
    { "correct": "  parent->n = parent->n + 1;", distractors: [{"text":"  parent->n++;", reason:"`n++` is a more common and concise way to increment a variable by one."}], indent: 1, explanation: "The parent now has one more key." },
    { "correct": "}", distractors: [{"text":"end split;", reason:"This is not valid C syntax."}], indent: 0, explanation: "End of `btree_split_child`." },
    { "correct": "void btree_insert_nonfull(BTreeNode* node, int key) {", distractors: [{"text":"void btree_insert_full(BTreeNode* node, int key) {", reason:"The name is misleading. This function's primary precondition is that the node is *not* full."}], indent: 0, explanation: "Begin implementation of `btree_insert_nonfull`." },
    { "correct": "  int i = node->n - 1;", distractors: [{"text":"  int i = node->n;", reason:"Valid array indices are from 0 to n-1. Initializing `i` to `n` would cause an immediate out-of-bounds read in the `while` loop."}], indent: 1, explanation: "Initialize index as the rightmost key." },
    { "correct": "  if (node->is_leaf) {", distractors: [{"text":"  if (node->n == 0) {", reason:"The logic must differentiate between a leaf and an internal node, not whether it's empty."}], indent: 1, explanation: "Case 1: The node is a leaf." },
    { "correct": "    // Find location for new key and move all greater keys one space ahead", distractors: [{"text":"    // Append the new key.", reason:"This is incorrect. Keys in a B-Tree node must always be kept in sorted order. We must find the correct location."}], indent: 2, explanation: "Comment on finding insertion point." },
    { "correct": "    while (i >= 0 && node->keys[i] > key) {", distractors: [{"text":"    while (node->keys[i] > key && i >= 0) {", reason:"This order is dangerous. If `i` becomes -1, `node->keys[i]` would be an out-of-bounds access *before* the `i >= 0` check. The order matters due to short-circuit evaluation."}], indent: 2, explanation: "Loop to shift keys." },
    { "correct": "      node->keys[i + 1] = node->keys[i];", distractors: [{"text":"      node->keys[i] = node->keys[i - 1];", reason:"This would shift keys to the left, overwriting data."}], indent: 3, explanation: "Shift the key to the right." },
    { "correct": "      i--;", distractors: [{"text":"      i = i - 1;", reason:"This is also correct, but `i--` is the more idiomatic C syntax."}], indent: 3, explanation: "Decrement the index." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after a `while` loop."}], indent: 2, explanation: "End key shifting loop." },
    { "correct": "    // Insert the new key at the found location", distractors: [{"text":"    // Insert key at the end.", reason:"This is incorrect. The key must be inserted at the sorted position found by the previous loop."}], indent: 2, explanation: "Comment on insertion." },
    { "correct": "    node->keys[i + 1] = key;", distractors: [{"text":"    node->keys[i] = key;", reason:"After the `while` loop, `i` points to the element just before the insertion point. The correct index is `i + 1`."}], indent: 2, explanation: "Place the new key." },
    { "correct": "    node->n = node->n + 1;", distractors: [{"text":"    node->n++;", reason:"This is an equally valid and more concise way to increment the key count."}], indent: 2, explanation: "Increment the key count for the node." },
    { "correct": "    printf(\"Inserted key %d into leaf node.\\n\", key);", distractors: [{"text":"    printf(\"Inserted key into leaf node.\\n\");", reason:"This is okay, but logging the actual key value is more useful for debugging."}], indent: 2, explanation: "Log the insertion." },
    { "correct": "  } else {", distractors: [{"text":"  } else if (!node->is_leaf) {", reason:"This check is redundant. If the first `if (node->is_leaf)` is false, the `else` block is guaranteed to handle the non-leaf case."}], indent: 1, explanation: "Case 2: The node is not a leaf." },
    { "correct": "    // Find the child which is going to have the new key", distractors: [{"text":"    // Find the parent of the new key.", reason:"This is incorrect. We are descending the tree, so we need to find the correct child to move into."}], indent: 2, explanation: "Comment on finding the correct child." },
    { "correct": "    while (i >= 0 && node->keys[i] > key) { i--; }", distractors: [{"text":"    // This logic is complex", reason:"This loop efficiently finds the correct index for the child subtree where the new key belongs."}], indent: 2, explanation: "Find the correct child index to descend into." },
    { "correct": "    i++; // Move to the correct child index.", distractors: [{"text":"    // No increment needed", reason:"This is a bug. The `while` loop finds the last key smaller than the new key. The correct child is at the index *after* that key."}], indent: 2, explanation: "Increment i to point to the correct child." },
    { "correct": "    // Check if the found child is full", distractors: [{"text":"    // Assume child is not full.", reason:"This would violate a core B-Tree guarantee. We must check if the child is full and split it *before* recursing, to ensure we never try to insert into a full node."}], indent: 2, explanation: "Comment on the fullness check." },
    { "correct": "    if (node->children[i]->n == 2 * T - 1) {", distractors: [{"text":"    if (node->children[i]->n >= T) {", reason:"The condition for splitting a node is that it is completely full (contains 2*T - 1 keys), not just that it has more than the minimum."}], indent: 2, explanation: "If the child is full, we must split it." },
    { "correct": "      btree_split_child(node, i, node->children[i]);", distractors: [{"text":"      btree_split_child(node, i, NULL);", reason:"The function needs a valid pointer to the child that needs to be split."}], indent: 3, explanation: "Call the split function." },
    { "correct": "      // After split, the middle key of children[i] goes up and children[i] is split into two.", distractors: [{"text":"      // After split, the child is now empty.", reason:"This is false. The split operation divides the child into two new nodes, each with T-1 keys."}], indent: 3, explanation: "Comment on the result of the split." },
    { "correct": "      // Decide which of the two children is going to have the new key", distractors: [{"text":"      // Always insert into the left child.", reason:"This is a bug. After the split, we must compare the new key against the promoted median key to decide which of the two new siblings to descend into."}], indent: 3, explanation: "Comment on choosing the correct path after splitting." },
    { "correct": "      if (node->keys[i] < key) { i++; }", distractors: [{"text":"      if (node->keys[i] > key) { i--; }", reason:"This is a logic error. If the key is greater than the new median key at `keys[i]`, we need to move to the new right sibling at `children[i+1]`."}], indent: 3, explanation: "If the new key is greater than the promoted median, go to the right sibling." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 2, explanation: "End of fullness check block." },
    { "correct": "    btree_insert_nonfull(node->children[i], key);", distractors: [{"text":"    btree_insert(node->children[i], key);", reason:"This would cause a compiler error, as `btree_insert` takes a `BTree*`, not a `BTreeNode*`. We must call the recursive helper function."}], indent: 2, explanation: "Recursively call to insert the key in the appropriate child." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End of leaf/non-leaf block." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "End of `btree_insert_nonfull`." },
    { "correct": "void btree_insert(BTree* tree, int key) {", distractors: [{"text":"void btree_insert(BTreeNode* root, int key) {", reason:"The public-facing API should operate on the `BTree` handle, not directly on a node. This abstracts away the implementation details."}], indent: 0, explanation: "Begin implementation of the main `btree_insert` function." },
    { "correct": "  BTreeNode *root = tree->root;", distractors: [{"text":"  BTreeNode *root = tree.root;", reason:"`tree` is a pointer, so the arrow operator `->` is required to access its members."}], indent: 1, explanation: "Get a pointer to the root of the tree." },
    { "correct": "  // If root is full, the tree grows in height", distractors: [{"text":"  // If root is full, the insertion fails.", reason:"This is incorrect. A key property of B-Trees is that they grow upwards from the root, unlike binary search trees."}], indent: 1, explanation: "Comment explaining the special case for a full root." },
    { "correct": "  if (root->n == 2 * T - 1) {", distractors: [{"text":"  if (root->n == T - 1) {", reason:"This condition is wrong. A node is only split when it is completely full, i.e., when it has `2*T - 1` keys."}], indent: 1, explanation: "Check if the root node is full." },
    { "correct": "    printf(\"Root is full. Creating new root.\\n\");", distractors: [{"text":"    printf(\"Error: Root is full.\\n\");", reason:"This is not an error condition; it is the normal mechanism by which a B-Tree increases its height."}], indent: 2, explanation: "Log the tree height growth." },
    { "correct": "    BTreeNode *new_root = btree_create_node(false);", distractors: [{"text":"    BTreeNode *new_root = btree_create_node(true);", reason:"The new root will have the old root as a child, so it must be an internal node, not a leaf."}], indent: 2, explanation: "Create a new root, which will be an internal node." },
    { "correct": "    tree->root = new_root;", distractors: [{"text":"    root = new_root;", reason:"This only changes the local `root` pointer. To change the tree's actual root, you must modify `tree->root`."}], indent: 2, explanation: "Update the tree's root pointer." },
    { "correct": "    new_root->children[0] = root;", distractors: [{"text":"    new_root->keys[0] = root->keys[0];", reason:"This is incorrect. The new root's first child must be the entire old root node."}], indent: 2, explanation: "The old root becomes a child of the new root." },
    { "correct": "    btree_split_child(new_root, 0, root);", distractors: [{"text":"    btree_split_child(root, 0, new_root);", reason:"The arguments are reversed. The `new_root` is the parent, and the old `root` is the child being split."}], indent: 2, explanation: "Split the old root and move a key to the new root." },
    { "correct": "    btree_insert_nonfull(new_root, key);", distractors: [{"text":"    btree_insert_nonfull(root, key);", reason:"The insertion must now happen relative to the `new_root`, which has space, not the old `root` which is now a child."}], indent: 2, explanation: "Insert the new key into the (now non-full) new root's structure." },
    { "correct": "  } else {", distractors: [{"text":"  }", reason:"An `else` block is required to handle the normal case where the root is not full."}], indent: 1, explanation: "If the root is not full..." },
    { "correct": "    btree_insert_nonfull(root, key);", distractors: [{"text":"    btree_insert(tree, key);", reason:"This would cause infinite recursion. We must call the helper function that works on nodes, not the main function that works on the whole tree."}], indent: 2, explanation: "Call the helper function to insert into the root." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if/else` block."}], indent: 1, explanation: "End of root fullness check." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to end a function block."}], indent: 0, explanation: "End of `btree_insert`." },
    { "correct": "// === Stage 4: Traversal and Search ===", distractors: [{"text":"// === Stage 4: Deletion ===", reason:"Deletion in a B-Tree is significantly more complex than insertion and is not covered in this example."}], indent: 0, explanation: "Implement functions to find keys and display the tree's contents." },
    { "correct": "void btree_traverse(BTreeNode* node) {", distractors: [{"text":"void btree_traverse(BTree* tree) {", reason:"The definition must match the prototype. Traversal is a recursive algorithm that operates on nodes."}], indent: 0, explanation: "Begin implementation of `btree_traverse`." },
    { "correct": "  if (node != NULL) {", distractors: [{"text":"  if (node) {", reason:"This is a valid and common shorthand for checking if a pointer is not NULL."}], indent: 1, explanation: "Proceed only if the node is not NULL." },
    { "correct": "  int i;", distractors: [{"text":"  // No variable needed", reason:"A loop counter `i` is needed to iterate through the keys and children."}], indent: 1, explanation: "Declare loop variable." },
    { "correct": "  for (i = 0; i < node->n; i++) {", distractors: [{"text":"  for (i = 0; i <= node->n - 1; i++) {", reason:"This is a logically equivalent and correct way to write the loop condition."}], indent: 1, explanation: "Loop through keys and children." },
    { "correct": "    // If this is not a leaf, then before printing key[i], traverse the subtree rooted with child children[i].", distractors: [{"text":"    // Print the key first.", reason:"This would result in a pre-order traversal. For a B-Tree, an in-order traversal is desired because it prints the keys in sorted order."}], indent: 2, explanation: "Comment explaining the recursive call." },
    { "correct": "    if (!node->is_leaf) { btree_traverse(node->children[i]); }", distractors: [{"text":"    if (node->is_leaf) { btree_traverse(node->children[i]); }", reason:"This is a bug. A leaf has no children, so trying to traverse them would access a NULL pointer."}], indent: 2, explanation: "Recursively traverse the left child." },
    { "correct": "    printf(\" %d\", node->keys[i]);", distractors: [{"text":"    printf(\" %d\", node->keys[i+1]);", reason:"This would be an off-by-one error, skipping the first key and reading past the end on the last iteration."}], indent: 2, explanation: "Print the key at the current index." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End of the main traversal loop." },
    { "correct": "    // Print the subtree rooted with the last child", distractors: [{"text":"    // No more children to print", reason:"This is incorrect. A node with `n` keys has `n+1` children. This final recursive call is needed to traverse the rightmost subtree."}], indent: 1, explanation: "Comment on traversing the rightmost child." },
    { "correct": "    if (!node->is_leaf) { btree_traverse(node->children[i]); }", distractors: [{"text":"    btree_traverse(node->children[i]);", reason:"The check for `!node->is_leaf` is essential to prevent trying to dereference a NULL child pointer on a leaf node."}], indent: 1, explanation: "Traverse the subtree of the last child." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 0, explanation: "End of NULL check." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End of `btree_traverse`." },
    { "correct": "BTreeNode* btree_search(BTreeNode* node, int key) {", distractors: [{"text":"BTree* btree_search(BTree* tree, int key) {", reason:"The definition must match the prototype. Search is a recursive algorithm on nodes."}], indent: 0, explanation: "Begin implementation of `btree_search`." },
    { "correct": "  if (node == NULL) return NULL;", distractors: [{"text":"  if (!node) return 0;", reason:"The function returns a pointer. The standard way to signal 'not found' is to return `NULL`, not the integer 0."}], indent: 1, explanation: "Base case: If the node is NULL, the key is not found." },
    { "correct": "  int i = 0;", distractors: [{"text":"  int i = 1;", reason:"Array indices in C are 0-based. Starting at 1 would skip the first key in every node."}], indent: 1, explanation: "Initialize index for searching keys." },
    { "correct": "  while (i < node->n && key > node->keys[i]) { i++; }", distractors: [{"text":"  while (key > node->keys[i] && i < node->n) { i++; }", reason:"This order is dangerous. If `i` reaches `node->n`, `node->keys[i]` would be an out-of-bounds access *before* the `i < node->n` check could stop it."}] , indent: 1, explanation: "Find the first key greater than or equal to the target key." },
    { "correct": "  if (i < node->n && key == node->keys[i]) {", distractors: [{"text":"  if (key == node->keys[i]) {", reason:"This is unsafe. The first part of the check, `i < node->n`, is required to prevent an out-of-bounds access on `node->keys[i]` if the key is larger than all keys in the node."}], indent: 1, explanation: "Check if the key is found at the current position." },
    { "correct": "    printf(\"Key %d found.\\n\", key);", distractors: [{"text":"    printf(\"Key found.\\n\");", reason:"This is okay, but printing the actual key that was found is better for confirmation."}], indent: 2, explanation: "Log that the key was found." },
    { "correct": "    return node;", distractors: [{"text":"    return node->keys[i];", reason:"This is a type mismatch. The function must return a pointer to the node (`BTreeNode*`), not the integer key itself."}], indent: 2, explanation: "Return the node containing the key." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End of found-key check." },
    { "correct": "  if (node->is_leaf) {", distractors: [{"text":"  if (!node->children[i]) {", reason:"Explicitly checking `node->is_leaf` is clearer and more directly expresses the logic of the B-Tree search algorithm."}], indent: 1, explanation: "If the node is a leaf and the key wasn't found, it doesn't exist." },
    { "correct": "    printf(\"Key %d not found.\\n\", key);", distractors: [{"text":"    puts(\"Key not found.\");", reason:"This is a valid alternative, but printing the specific key we were searching for is more informative."}], indent: 2, explanation: "Log that the key was not found." },
    { "correct": "    return NULL;", distractors: [{"text":"    return node;", reason:"This is a bug. If the key is not in a leaf node, we must return `NULL` to signal it was not found."}], indent: 2, explanation: "Return NULL." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End of leaf check." },
    { "correct": "  // Go to the appropriate child", distractors: [{"text":"  // Search is finished", reason:"This is incorrect. If we are at an internal node, we must make one more recursive call to search the appropriate child."}], indent: 1, explanation: "Comment on the recursive step." },
    { "correct": "  return btree_search(node->children[i], key);", distractors: [{"text":"  return btree_search(node, key);", reason:"This would cause infinite recursion. We must descend to the appropriate child node (`node->children[i]`)."}], indent: 1, explanation: "Recursively search in the appropriate child node." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to end a function block."}], indent: 0, explanation: "End of `btree_search`." },
    { "correct": "// === Stage 5: Main Program for Demonstration ===", distractors: [{"text":"// === Stage 5: B-Tree Implementation ===", reason:"This is incorrect. This stage demonstrates the *use* of our B-Tree library, it does not implement it."}], indent: 0, explanation: "A `main` function to test the B-Tree implementation." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid, and often preferred, way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start of the main function." },
    { "correct": "  printf(\"--- B-Tree Index Simulation ---\\n\");", distractors: [{"text":"  puts(\"--- B-Tree Index Simulation ---\");", reason:"`puts` is a valid alternative for printing this header, and it automatically adds a newline."}], indent: 1, explanation: "Print a title for the demo." },
    { "correct": "  BTree* t = btree_create();", distractors: [{"text":"  BTree t;", reason:"Our API works with pointers to dynamically allocated `BTree` structs. This creates a stack variable, which would not be correctly handled by our functions."}], indent: 1, explanation: "Create a new B-Tree." },
    { "correct": "  int keys_to_insert[] = {10, 20, 5, 6, 12, 30, 7, 17, 3, 1, 4, 15, 18, 22, 25};", distractors: [{"text":"  int keys_to_insert[] = {1, 3, 4, 5, 6, 7, 10, 12, 15, 17, 18, 20, 22, 25, 30};", reason:"Inserting keys in sorted order is a worst-case scenario for some tree structures, but a B-Tree handles it gracefully."}], indent: 1, explanation: "Define a set of keys to be inserted." },
    { "correct": "  int num_keys = sizeof(keys_to_insert)/sizeof(keys_to_insert[0]);", distractors: [{"text":"  int num_keys = 15;", reason:"Hardcoding the size is bad practice. If you add or remove keys, you might forget to update the count. The `sizeof` method is robust and calculates it automatically."}], indent: 1, explanation: "Calculate the number of keys in the array." },
    { "correct": "  for (int i = 0; i < num_keys; i++) {", distractors: [{"text":"  int i=0; while(i < num_keys) { ... i++; }", reason:"A `while` loop is an equally valid way to structure this iteration."}], indent: 1, explanation: "Loop to insert all keys." },
    { "correct": "    printf(\"\\nInserting key: %d\\n\", keys_to_insert[i]);", distractors: [{"text":"    printf(\"\\nInserting a key...\\n\");", reason:"This is less useful for debugging. Logging the specific key being inserted makes it much easier to trace the algorithm's behavior."}], indent: 2, explanation: "Log which key is being inserted." },
    { "correct": "    btree_insert(t, keys_to_insert[i]);", distractors: [{"text":"    btree_insert(&t, keys_to_insert[i]);", reason:"`t` is already a pointer (`BTree*`). Passing its address would be a `BTree**`, which is the wrong type for the function."}], indent: 2, explanation: "Call the insert function." },
    { "correct": "    printf(\"Current Tree: \"); btree_traverse(t->root); printf(\"\\n\");", distractors: [{"text":"    btree_traverse(t);", reason:"This is a type mismatch. Our `btree_traverse` function is designed to work on nodes (`BTreeNode*`), so we must pass it the root node (`t->root`)."}], indent: 2, explanation: "Print the state of the tree after each insertion." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End of insertion loop." },
    { "correct": "  printf(\"\\n--- Final B-Tree Structure ---\\n\");", distractors: [{"text":"  puts(\"\\n--- Final B-Tree Structure ---\");", reason:"`puts` automatically adds its own newline, so the `\\n` at the beginning would create an unwanted extra blank line."}], indent: 1, explanation: "Header for the final tree traversal." },
    { "correct": "  printf(\"Traversal of the constructed tree is: \");", distractors: [{"text":"  puts(\"Traversal of the constructed tree is: \");", reason:"This also works, but `printf` is generally more flexible if you wanted to add more formatted output later."}], indent: 1, explanation: "Informational message." },
    { "correct": "  btree_traverse(t->root);", distractors: [{"text":"  btree_traverse(t);", reason:"Our traversal function works on nodes, so we must pass the root node `t->root`, not the `BTree` struct itself."}], indent: 1, explanation: "Display all keys in sorted order." },
    { "correct": "  printf(\"\\n\");", distractors: [{"text":"  puts(\"\");", reason:"Calling `puts` with an empty string is another valid way to print a single newline character."}], indent: 1, explanation: "Print a newline for formatting." },
    { "correct": "  printf(\"\\n--- Searching for keys ---\\n\");", distractors: [{"text":"  puts(\"\\n--- Searching for keys ---\");", reason:"The initial `\\n` would cause `puts` to print an extra blank line."}], indent: 1, explanation: "Header for the search test." },
    { "correct": "  btree_search(t->root, 6);", distractors: [{"text":"  btree_search(t, 6);", reason:"Our search function is recursive on nodes. We must start the search at the root node, `t->root`."}], indent: 1, explanation: "Search for a key that exists." },
    { "correct": "  btree_search(t->root, 15);", distractors: [{"text":"  if (btree_search(t->root, 15) != NULL) { ... }", reason:"This is a good practice. The search function returns a pointer, which should ideally be checked before being used."}], indent: 1, explanation: "Search for another key that exists." },
    { "correct": "  btree_search(t->root, 99);", distractors: [{"text":"  btree_search(t->root, 10);", reason:"Searching for 10 would also work, but searching for a non-existent key (99) is a better test case."}], indent: 1, explanation: "Search for a key that does not exist." },
    { "correct": "  // Cleanup would involve a recursive free of all nodes, not implemented here for brevity.", distractors: [{"text":"  free(t);", reason:"This is a massive memory leak. You would only free the `BTree` struct itself, but not any of the `BTreeNode`s it points to. A recursive `btree_destroy` function is required."}], indent: 1, explanation: "A note on the importance of cleanup in a real application." },
    { "correct": "  printf(\"\\n--- Demo Finished ---\\n\");", distractors: [{"text":"  puts(\"--- Demo Finished ---\");", reason:"`puts` is a valid alternative to print this message."}], indent: 1, explanation: "Final message." },
    { "correct": "  // free(t); // In a real scenario, you'd free the tree and all its nodes.", distractors: [{"text":"  btree_destroy(t);", reason:"If we had implemented a proper `btree_destroy` function, this is where we would call it to prevent memory leaks."}], indent: 1, explanation: "Commented out cleanup code." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 conventionally signals an error. This program should return 0 to indicate it ran successfully."}], indent: 1, explanation: "Indicate successful execution." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of the main function." }
]
},
// Level 93: Prep for Tesla
{
    "goal": "Implement a basic real-time, fixed-priority, preemptive task scheduler to manage and execute tasks based on their priority and timing constraints.",
    "concepts": "Real-time systems, scheduling algorithms, data structures (priority queue), function pointers, state machines, embedded systems programming",
    "sequence": [
    { "correct": "// === Stage 1: Core Data Structures and Definitions ===", distractors: [{"text":"// === Stage 1: The Main Program Logic ===", reason:"Good software design starts with defining the fundamental data structures before writing the logic that operates on them."}], indent: 0, explanation: "Define the structures for tasks, the scheduler, and system-wide constants." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"The standard I/O function `printf` is declared in `<stdio.h>`."}], indent: 0, explanation: "For standard I/O." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <stdbool.h>", reason:"Memory allocation (`malloc`) and program termination (`exit`) are part of the standard library, `<stdlib.h>`."}], indent: 0, explanation: "For memory allocation." },
    { "correct": "#include <stdint.h>", distractors: [{"text":"// No include needed for uint32_t", reason:"This is false. Fixed-width integer types like `uint32_t` are not built-in; they are defined in the C99 standard header `<stdint.h>`."}], indent: 0, explanation: "For using fixed-width integer types like `uint32_t`." },
    { "correct": "#include <stdbool.h>", distractors: [{"text":"// `bool` is a built-in type.", reason:"In C, `bool`, `true`, and `false` are macros defined in `<stdbool.h>`. They are not built-in keywords like in C++."}], indent: 0, explanation: "For boolean types." },
    { "correct": "#include <string.h>", distractors: [{"text":"#include <strings.h>", reason:"The standard C header for string functions like `strcpy` is `<string.h>`."}], indent: 0, explanation: "For string manipulation, e.g., `strcpy`." },
    { "correct": "#define MAX_TASKS 10", distractors: [{"text":"const int MAX_TASKS = 10;", reason:"Using a `#define` is a common C idiom for array sizes, as it guarantees a compile-time constant. A `const int` is also a valid alternative in many cases."}], indent: 0, explanation: "The maximum number of tasks our scheduler can handle." },
    { "correct": "#define MAX_TASK_NAME 32", distractors: [{"text":"#define MAX_TASK_NAME 32;", reason:"Macros should not end with a semicolon. The semicolon would become part of the replacement text, causing syntax errors."}], indent: 0, explanation: "Maximum length for a task's name." },
    { "correct": "// Represents the state of a task.", distractors: [{"text":"// An integer representing the task state.", reason:"While an enum is an integer type, describing it as a distinct set of 'states' is more accurate to its purpose in a state machine."}], indent: 0, explanation: "Comment on the TaskState enum." },
    { "correct": "typedef enum { READY, RUNNING, WAITING, FINISHED } TaskState;", distractors: [{"text":"#define READY 0\n#define RUNNING 1\n...", reason:"Using `#define` for states works, but an `enum` is better because it creates a distinct type (`TaskState`), providing better type safety and readability."}], indent: 0, explanation: "Defines the possible states a task can be in." },
    { "correct": "// The Task Control Block (TCB).", distractors: [{"text":"// The Task class.", reason:"C does not have classes. A `struct` is used to group related data into a 'block'."}], indent: 0, explanation: "Comment explaining the TCB struct." },
    { "correct": "typedef struct {", distractors: [{"text":"struct TCB {", reason:"Using `typedef` is a convenience that allows us to declare variables as `TCB my_task;` instead of `struct TCB my_task;`."}], indent: 0, explanation: "Start of the TCB struct." },
    { "correct": "  char name[MAX_TASK_NAME];", distractors: [{"text":"  char* name;", reason:"Using `char*` would require an extra `malloc` for every task's name. A fixed-size array is simpler and avoids heap fragmentation, which is important in embedded systems."}], indent: 1, explanation: "A human-readable name for the task." },
    { "correct": "  void (*task_func)(void*);", distractors: [{"text":"  void* task_func(void*);", reason:"This declares a function, not a function pointer. The `(*)` syntax is required to declare a pointer to a function."}], indent: 1, explanation: "A function pointer to the code the task will execute." },
    { "correct": "  void* arg;", distractors: [{"text":"  int arg;", reason:"Using `void*` allows us to pass a pointer to *any* kind of data as an argument to our task, making the system much more flexible."}], indent: 1, explanation: "An argument to be passed to the task function." },
    { "correct": "  uint32_t priority;", distractors: [{"text":"  int priority;", reason:"Using a fixed-width unsigned type like `uint32_t` makes the priority system's behavior consistent across different hardware platforms."}], indent: 1, explanation: "Task priority (lower number = higher priority)." },
    { "correct": "  TaskState state;", distractors: [{"text":"  int state;", reason:"Using the specific `TaskState` enum type is clearer and provides better type safety than using a generic `int`."}], indent: 1, explanation: "The current state of the task." },
    { "correct": "  uint32_t ticks_to_wait;", distractors: [{"text":"  double ticks_to_wait;", reason:"System ticks are discrete integer events, so an integer type is the correct choice, not a floating-point type."}], indent: 1, explanation: "If waiting, how many system ticks to wait for." },
    { "correct": "} TCB;", distractors: [{"text":"};", reason:"To complete the `typedef`, the new type alias name (`TCB`) must be placed before the final semicolon."}], indent: 0, explanation: "End of the TCB typedef." },
    { "correct": "// The main scheduler control structure.", distractors: [{"text":"// The task list.", reason:"This struct is more than just a list; it's the main control block for the entire scheduler, containing the clock and run state as well."}], indent: 0, explanation: "Comment for the Scheduler struct." },
    { "correct": "typedef struct {", distractors: [{"text":"struct Scheduler {", reason:"Using `typedef` allows us to declare schedulers as `Scheduler s;` instead of `struct Scheduler s;`."}], indent: 0, explanation: "Start of the Scheduler struct." },
    { "correct": "  TCB task_list[MAX_TASKS];", distractors: [{"text":"  TCB* task_list;", reason:"Using a fixed-size array is a common design for embedded schedulers to avoid dynamic memory allocation (`malloc`/`realloc`) during runtime, which can be non-deterministic."}], indent: 1, explanation: "An array to hold all the tasks managed by the scheduler." },
    { "correct": "  uint32_t task_count;", distractors: [{"text":"  int task_count;", reason:"Using `uint32_t` is consistent with other count/ID types in our system."}], indent: 1, explanation: "The current number of tasks registered." },
    { "correct": "  uint32_t current_tick;", distractors: [{"text":"  double current_tick;", reason:"Ticks are discrete integer events, so an integer type is appropriate."}], indent: 1, explanation: "A counter simulating the system clock." },
    { "correct": "  int currently_running_task_index;", distractors: [{"text":"  TCB* currently_running_task;", reason:"Storing an index is often simpler and safer than a direct pointer, as it avoids issues with dangling pointers if the task list were reallocated."}], indent: 1, explanation: "Index of the task that is currently in the RUNNING state (-1 if none)." },
    { "correct": "} Scheduler;", distractors: [{"text":"} Scheduler", reason:"A `typedef` statement must always end with a semicolon."}], indent: 0, explanation: "End of the Scheduler typedef." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text":"// --- Function Implementations ---", reason:"These are just the forward declarations (prototypes). The function bodies (implementations) are defined later."}], indent: 0, explanation: "Declarations for scheduler functions." },
    { "correct": "void scheduler_init(Scheduler* sched);", distractors: [{"text":"Scheduler* scheduler_init();", reason:"This is an alternative design where the init function also allocates the scheduler struct. The current design requires the user to provide the struct instance."}], indent: 0, explanation: "Initializes the scheduler." },
    { "correct": "bool scheduler_add_task(Scheduler* sched, const char* name, uint32_t priority, void (*func)(void*), void* arg);", distractors: [{"text":"void scheduler_add_task(...);", reason:"Returning a `bool` is good design. It allows the function to signal to the caller whether the task was added successfully or not (e.g., if the scheduler was full)."}], indent: 0, explanation: "Adds a new task to the scheduler." },
    { "correct": "void scheduler_run(Scheduler* sched);", distractors: [{"text":"int scheduler_run(Scheduler* sched);", reason:"The main `run` loop typically doesn't exit until all tasks are finished. It doesn't need to return a value, so `void` is appropriate."}], indent: 0, explanation: "Starts the main scheduling loop." },
    { "correct": "void scheduler_tick(Scheduler* sched);", distractors: [{"text":"void scheduler_tick(void);", reason:"The tick function needs to know *which* scheduler to update, so it must take the scheduler pointer as a parameter."}], indent: 0, explanation: "Advances the system clock and re-evaluates task states." },
    { "correct": "void task_wait(Scheduler* sched, uint32_t ticks);", distractors: [{"text":"void task_wait(uint32_t ticks);", reason:"A task needs to tell the scheduler about its state change, so the scheduler handle (`Scheduler*`) must be passed as an argument."}], indent: 0, explanation: "API for a running task to put itself into a WAITING state." },
    { "correct": "void print_task_states(const Scheduler* sched);", distractors: [{"text":"void print_task_states(Scheduler* sched);", reason:"A print function should not modify the data it's printing. Using `const` makes this guarantee clear."}], indent: 0, explanation: "A helper to visualize the state of all tasks." },
    { "correct": "// === Stage 2: Scheduler Initialization and Task Registration ===", distractors: [{"text":"// === Stage 2: The Main Loop ===", reason:"Before the main loop can run, we must first implement the functions to initialize the scheduler and add tasks to it."}], indent: 0, explanation: "Implement the basic setup functions." },
    { "correct": "void scheduler_init(Scheduler* sched) {", distractors: [{"text":"void scheduler_init(Scheduler sched) {", reason:"The definition must match the prototype. It must accept a pointer (`Scheduler*`) so it can modify the original struct."}], indent: 0, explanation: "Begin `scheduler_init` implementation." },
    { "correct": "  printf(\"Initializing the Real-Time Scheduler...\\n\");", distractors: [{"text":"  puts(\"Initializing...\");", reason:"This is valid, but the original message is more descriptive."}], indent: 1, explanation: "Informational message." },
    { "correct": "  sched->task_count = 0;", distractors: [{"text":"  sched.task_count = 0;", reason:"`sched` is a pointer. You must use the arrow operator `->` to access members of a struct through a pointer."}], indent: 1, explanation: "Start with zero tasks." },
    { "correct": "  sched->current_tick = 0;", distractors: [{"text":"  // No need to init tick", reason:"This is a bug. An uninitialized member will hold a garbage value, causing the scheduler's timing to be incorrect from the start."}], indent: 1, explanation: "Initialize system clock to zero." },
    { "correct": "  sched->currently_running_task_index = -1;", distractors: [{"text":"  sched->currently_running_task_index = 0;", reason:"Using -1 is a common convention to indicate 'no task' or an invalid index, which is clearer than using 0 (a valid index)."}], indent: 1, explanation: "No task is running initially." },
    { "correct": "  for (int i = 0; i < MAX_TASKS; i++) { sched->task_list[i].state = FINISHED; }", distractors: [{"text":"  memset(sched->task_list, 0, sizeof(sched->task_list));", reason:"`memset` would zero out the entire task list. While this would set the state to 0 (READY), our logic considers `FINISHED` as the 'empty' slot state."}], indent: 1, explanation: "Mark all task slots as available by setting state to FINISHED." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "End of `scheduler_init`." },
    { "correct": "bool scheduler_add_task(Scheduler* sched, const char* name, uint32_t priority, void (*func)(void*), void* arg) {", distractors: [{"text":"void scheduler_add_task(...)", reason:"The function's definition must match its prototype, which returns a `bool` to signal success or failure."}], indent: 0, explanation: "Begin `scheduler_add_task` implementation." },
    { "correct": "  if (sched->task_count >= MAX_TASKS) {", distractors: [{"text":"  if (sched->task_count > MAX_TASKS) {", reason:"This is an off-by-one error. Since array indices are 0 to `MAX_TASKS - 1`, the check should be `>=`."}], indent: 1, explanation: "Check if the task list is full." },
    { "correct": "    fprintf(stderr, \"Cannot add task '%s': Scheduler is full.\\n\", name);", distractors: [{"text":"    printf(\"Scheduler is full.\\n\");", reason:"Printing to `stderr` is conventional for error messages. Including the task name makes the error more specific."}], indent: 2, explanation: "Report an error if no more tasks can be added." },
    { "correct": "    return false;", distractors: [{"text":"    return 0;", reason:"The function is declared to return a `bool`. While 0 is equivalent to false, using the `false` keyword from `<stdbool.h>` is clearer."}], indent: 2, explanation: "Return false to indicate failure." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons do not follow `if` statements."}], indent: 1, explanation: "End of fullness check." },
    { "correct": "  printf(\"Adding task '%s' with priority %u.\\n\", name, priority);", distractors: [{"text":"  printf(\"Adding task.\\n\");", reason:"This is less informative. Logging the name and priority is very helpful for debugging the scheduler's behavior."}], indent: 1, explanation: "Log the addition of the new task." },
    { "correct": "  TCB* new_task = &sched->task_list[sched->task_count];", distractors: [{"text":"  TCB* new_task = malloc(sizeof(TCB));", reason:"Our scheduler uses a statically allocated array for tasks. We don't need `malloc`; we just get a pointer to the next available slot in the array."}], indent: 1, explanation: "Get a pointer to the next available TCB slot." },
    { "correct": "  strncpy(new_task->name, name, MAX_TASK_NAME - 1);", distractors: [{"text":"  strcpy(new_task->name, name);", reason:"`strcpy` is unsafe. If the source `name` is too long, it will cause a buffer overflow. `strncpy` is required for safety."}], indent: 1, explanation: "Copy the task name securely." },
    { "correct": "  new_task->name[MAX_TASK_NAME - 1] = '\\0';", distractors: [{"text":"  // `strncpy` always null-terminates.", reason:"This is a common and dangerous misconception. `strncpy` will *not* null-terminate if the source string is as long as the size limit. You must do it manually."}], indent: 1, explanation: "Ensure null-termination of the task name." },
    { "correct": "  new_task->priority = priority;", distractors: [{"text":"  new_task->priority = 0;", reason:"This would be a bug, ignoring the priority specified by the user."}], indent: 1, explanation: "Set the task's priority." },
    { "correct": "  new_task->task_func = func;", distractors: [{"text":"  new_task->task_func = &func;", reason:"For a function pointer, the name of the function (`func`) decays to a pointer automatically. The `&` operator is optional and usually omitted."}], indent: 1, explanation: "Set the task's function pointer." },
    { "correct": "  new_task->arg = arg;", distractors: [{"text":"  new_task->arg = &arg;", reason:"`arg` is already a `void*` pointer. Taking its address would make it a `void**`, which is the wrong type."}], indent: 1, explanation: "Set the task's argument." },
    { "correct": "  new_task->state = READY;", distractors: [{"text":"  new_task->state = RUNNING;", reason:"A new task should start in the READY state. The scheduler will decide when to transition it to RUNNING."}], indent: 1, explanation: "The new task is ready to run." },
    { "correct": "  new_task->ticks_to_wait = 0;", distractors: [{"text":"  // No need to initialize wait time", reason:"This is a bug. The member would contain a garbage value, which could cause incorrect behavior if the task's state is ever checked."}], indent: 1, explanation: "Initialize wait time to zero." },
    { "correct": "  sched->task_count++;", distractors: [{"text":"  sched->task_count = sched->task_count + 1;", reason:"This is also correct, but `++` is the more concise and idiomatic way to increment in C."}], indent: 1, explanation: "Increment the total number of tasks." },
    { "correct": "  return true;", distractors: [{"text":"  return 1;", reason:"While 1 is equivalent to true, using the `true` keyword from `<stdbool.h>` is more expressive and clear."}], indent: 1, explanation: "Return true to indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "End of `scheduler_add_task`." },
    { "correct": "// === Stage 3: The Scheduler Tick and Preemption Logic ===", distractors: [{"text":"// === Stage 3: Task Registration ===", reason:"This stage implements the core scheduling algorithm, which happens on every 'tick' of the system clock."}], indent: 0, explanation: "Implement the core logic that drives the scheduler." },
    { "correct": "void scheduler_tick(Scheduler* sched) {", distractors: [{"text":"void scheduler_tick(const Scheduler* sched) {", reason:"This function modifies the state of the scheduler and its tasks, so the `sched` parameter cannot be `const`."}], indent: 0, explanation: "Begin `scheduler_tick` implementation. This simulates a timer interrupt." },
    { "correct": "  sched->current_tick++;", distractors: [{"text":"  // Tick is incremented by hardware", reason:"In a real system this is true, but in our simulation, we must increment the tick manually as the first step of the scheduler's work."}], indent: 1, explanation: "Increment the global system tick." },
    { "correct": "  printf(\"\\n--- Tick %u ---\\n\", sched->current_tick);", distractors: [{"text":"  printf(\"Tick\\n\");", reason:"Logging the actual tick number is essential for debugging and tracing the scheduler's behavior."}], indent: 1, explanation: "Print the current tick number for logging." },
    { "correct": "  // First, update the state of any waiting tasks.", distractors: [{"text":"  // First, find the highest priority task.", reason:"Before selecting a new task to run, we must update the state of all tasks (like moving WAITING tasks to READY), otherwise our selection might be based on outdated information."}], indent: 1, explanation: "Comment on the first phase of the tick: updating waiting tasks." },
    { "correct": "  for (uint32_t i = 0; i < sched->task_count; i++) {", distractors: [{"text":"  for (uint32_t i = 0; i <= sched->task_count - 1; i++) {", reason:"This is a logically equivalent and correct way to write the loop condition."}], indent: 1, explanation: "Loop through all registered tasks." },
    { "correct": "    if (sched->task_list[i].state == WAITING) {", distractors: [{"text":"    if (sched->task_list[i].ticks_to_wait > 0) {", reason:"A task could have a non-zero wait time but be in a different state. It's more precise to check for the `WAITING` state explicitly."}], indent: 2, explanation: "Check if a task is in the WAITING state." },
    { "correct": "      sched->task_list[i].ticks_to_wait--;", distractors: [{"text":"      sched->task_list[i].ticks_to_wait = sched->task_list[i].ticks_to_wait - 1;", reason:"This is also correct, but `--` is the more concise C idiom."}], indent: 3, explanation: "Decrement its wait counter." },
    { "correct": "      if (sched->task_list[i].ticks_to_wait == 0) {", distractors: [{"text":"      if (!sched->task_list[i].ticks_to_wait) {", reason:"This shorthand is also a valid way to check if the value is zero."}], indent: 3, explanation: "If the wait time is over..." },
    { "correct": "        sched->task_list[i].state = READY;", distractors: [{"text":"        sched->task_list[i].state = RUNNING;", reason:"This is a bug. The task should become READY. The scheduler will then decide if it has a high enough priority to become RUNNING."}], indent: 4, explanation: "Transition the task back to the READY state." },
    { "correct": "        printf(\"Task '%s' is now READY.\\n\", sched->task_list[i].name);", distractors: [{"text":"        puts(\"Task is ready.\");", reason:"This is okay, but logging the specific task name makes the output much easier to trace."}], indent: 4, explanation: "Log the state change." },
    { "correct": "      }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 3, explanation: "End of wait-time-over check." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 2, explanation: "End of WAITING state check." },
    { "correct": "  }", distractors: [{"text":"end for;", reason:"This is not valid C syntax."}], indent: 1, explanation: "End of task loop." },
    { "correct": "  // Now, find the highest priority task that is READY.", distractors: [{"text":"  // Now, run the first ready task.", reason:"This would be a First-Come, First-Served (FCFS) scheduler, not a preemptive priority-based one."}], indent: 1, explanation: "Comment on the second phase: finding the next task to run." },
    { "correct": "  int highest_priority_ready_task = -1;", distractors: [{"text":"  int highest_priority_ready_task = 0;", reason:"Using -1 as a 'not found' sentinel is clearer than using 0, which is a valid index."}], indent: 1, explanation: "Initialize index to -1 (no task found yet)." },
    { "correct": "  uint32_t best_priority = -1; // -1 is max uint, so it's the lowest possible priority", distractors: [{"text":"  uint32_t best_priority = 9999;", reason:"Hardcoding a large number is not robust. Using `-1` is a common C trick that guarantees the value is the maximum possible for an `unsigned` type."}], indent: 1, explanation: "Initialize best priority to the lowest possible value." },
    { "correct": "  for (uint32_t i = 0; i < sched->task_count; i++) {", distractors: [{"text":"  // No loop needed", reason:"This is false. The scheduler must iterate through all tasks to find the one with the highest priority."}], indent: 1, explanation: "Loop through all tasks to find the best candidate." },
    { "correct": "    if (sched->task_list[i].state == READY) {", distractors: [{"text":"    if (sched->task_list[i].state != WAITING) {", reason:"This is not specific enough. The scheduler should only consider tasks that are explicitly `READY`, not those that might be `RUNNING` or `FINISHED`."}], indent: 2, explanation: "Consider only tasks that are in the READY state." },
    { "correct": "      if (sched->task_list[i].priority < best_priority) {", distractors: [{"text":"      if (sched->task_list[i].priority > best_priority) {", reason:"This logic is reversed. Since a lower number means higher priority, we must use `<` to find the best candidate."}], indent: 3, explanation: "If this task has a higher priority (lower number) than the best found so far..." },
    { "correct": "        best_priority = sched->task_list[i].priority;", distractors: [{"text":"        best_priority--;", reason:"This is a bug. The `best_priority` must be set to the priority of the new best task, not just decremented."}], indent: 4, explanation: "Update the best priority." },
    { "correct": "        highest_priority_ready_task = i;", distractors: [{"text":"        highest_priority_ready_task = sched->task_count;", reason:"This is a bug. The index must be `i`, the index of the task we just found."}], indent: 4, explanation: "Update the index of the best candidate." },
    { "correct": "      }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 3, explanation: "End of priority comparison." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 2, explanation: "End of READY state check." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used after a `for` loop."}], indent: 1, explanation: "End of candidate search loop." },
    { "correct": "  // Preemption Logic: Decide if we need to switch tasks.", distractors: [{"text":"  // Cooperative Logic: Wait for task to yield.", reason:"This is a preemptive scheduler. It does not wait for tasks to yield; it will forcibly preempt a lower-priority task."}], indent: 1, explanation: "Comment on the third phase: context switching." },
    { "correct": "  int current_task_idx = sched->currently_running_task_index;", distractors: [{"text":"  int current_task_idx = 0;", reason:"We need the actual index of the currently running task to compare its priority."}], indent: 1, explanation: "Get the index of the currently running task." },
    { "correct": "  if (highest_priority_ready_task != -1) { // If a ready task exists", distractors: [{"text":"  if (highest_priority_ready_task >= 0) {", reason:"This is an equally valid way to check if a suitable task was found."}], indent: 1, explanation: "Check if we found any ready task." },
    { "correct": "    if (current_task_idx == -1 || sched->task_list[highest_priority_ready_task].priority < sched->task_list[current_task_idx].priority) {", distractors: [{"text":"    if (current_task_idx == -1 && sched->task_list[...].priority < ...)", reason:"The logical operator must be OR (`||`). We should switch if the CPU is idle *OR* if a higher-priority task is ready."}] , indent: 2, explanation: "Switch if no task is running OR if the new task has higher priority." },
    { "correct": "      if (current_task_idx != -1) {", distractors: [{"text":"      if (current_task_idx >= 0) {", reason:"This is another valid way to check if there was a task running."}], indent: 3, explanation: "If a task was running..." },
    { "correct": "        sched->task_list[current_task_idx].state = READY;", distractors: [{"text":"        sched->task_list[current_task_idx].state = WAITING;", reason:"This is a bug. A preempted task is not waiting for an event; it is ready to run as soon as the higher-priority task finishes or waits. It must go back to the READY state."}], indent: 4, explanation: "Set the preempted task's state back to READY." },
    { "correct": "        printf(\"PREEMPTING task '%s'.\\n\", sched->task_list[current_task_idx].name);", distractors: [{"text":"        puts(\"Preempting task.\");", reason:"This is less informative. Logging the name of the specific task being preempted is crucial for debugging."}], indent: 4, explanation: "Log the preemption." },
    { "correct": "      }", distractors: [{"text":"};", reason:"Semicolons are not used after `if` blocks."}], indent: 3, explanation: "End of preemption check." },
    { "correct": "      sched->currently_running_task_index = highest_priority_ready_task;", distractors: [{"text":"      sched->currently_running_task_index = -1;", reason:"This would be a bug, causing the CPU to go idle even though a high-priority task is ready."}], indent: 3, explanation: "Update the index of the running task." },
    { "correct": "      sched->task_list[highest_priority_ready_task].state = RUNNING;", distractors: [{"text":"      sched->task_list[highest_priority_ready_task].state = READY;", reason:"This is incorrect. The task that has been chosen by the scheduler to execute must be transitioned into the RUNNING state."}], indent: 3, explanation: "Set the new task's state to RUNNING." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 2, explanation: "End of switch condition." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 1, explanation: "End of ready task check." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End of `scheduler_tick`." },
    { "correct": "// === Stage 4: Scheduler Execution and Task API ===", distractors: [{"text":"// === Stage 4: Initialization ===", reason:"This stage implements the main `run` loop and the API functions that running tasks can call."}], indent: 0, explanation: "Implement the main loop and functions for tasks to use." },
    { "correct": "void scheduler_run(Scheduler* sched) {", distractors: [{"text":"void scheduler_run(const Scheduler* sched) {", reason:"This function modifies the scheduler's state via `scheduler_tick` and executing tasks, so the `sched` pointer cannot be `const`."}], indent: 0, explanation: "Begin `scheduler_run` implementation." },
    { "correct": "  printf(\"\\n--- Starting Scheduler Main Loop ---\\n\");", distractors: [{"text":"  puts(\"\\n--- Starting Scheduler Main Loop ---\");", reason:"`puts` automatically adds its own newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Header for the main loop." },
    { "correct": "  while (true) {", distractors: [{"text":"  for(;;) {", reason:"An empty `for` loop `for(;;)` is a common C idiom for creating an infinite loop, just like `while(true)`."}], indent: 1, explanation: "The main loop of the scheduler. In a real system, this would be the idle loop." },
    { "correct": "    scheduler_tick(sched);", distractors: [{"text":"    // scheduler_tick(sched);", reason:"This would be a critical bug. Without the tick, the system clock would never advance, and waiting tasks would never become ready."}], indent: 2, explanation: "Process one tick of the scheduler clock." },
    { "correct": "    print_task_states(sched);", distractors: [{"text":"    // Not necessary", reason:"While not strictly necessary for operation, printing the states at each tick is invaluable for visualizing and debugging the scheduler's behavior."}], indent: 2, explanation: "Print the current state of all tasks for visualization." },
    { "correct": "    int running_idx = sched->currently_running_task_index;", distractors: [{"text":"    int running_idx = 0;", reason:"This is a bug. We must get the actual index of the task chosen by `scheduler_tick`."}], indent: 2, explanation: "Get the index of the task to execute." },
    { "correct": "    if (running_idx != -1) {", distractors: [{"text":"    if (running_idx >= 0) {", reason:"This is an equally valid way to check if a task is scheduled to run."}], indent: 2, explanation: "If there is a task to run..." },
    { "correct": "      TCB* current_task = &sched->task_list[running_idx];", distractors: [{"text":"      TCB current_task = sched->task_list[running_idx];", reason:"This would create a copy of the TCB. We need a pointer to the original so that any state changes made by the task are persistent."}], indent: 3, explanation: "Get a pointer to its TCB." },
    { "correct": "      printf(\"Executing task '%s'...\\n\", current_task->name);", distractors: [{"text":"      printf(\"Executing task.\\n\");", reason:"Logging the name of the specific task that is running is essential for tracing the program's execution."}], indent: 3, explanation: "Log the execution." },
    { "correct": "      current_task->task_func(sched); // Pass scheduler for API calls like task_wait", distractors: [{"text":"      current_task->task_func(current_task->arg);", reason:"While passing `current_task->arg` is a common pattern, our design passes a pointer to the scheduler itself so tasks can call API functions like `task_wait`."}], indent: 3, explanation: "Call the task's function. We pass the scheduler as an argument." },
    { "correct": "    } else {", distractors: [{"text":"    }", reason:"An `else` block is needed to handle the idle case where no tasks are ready to run."}], indent: 2, explanation: "If no task is running..." },
    { "correct": "      printf(\"CPU is idle.\\n\");", distractors: [{"text":"      // Do nothing", reason:"It's good practice to have an explicit log message for the idle state so it's clear the system is still running correctly."}], indent: 3, explanation: "Log that the system is idle." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 2, explanation: "End of task execution block." },
    { "correct": "    // Check for termination condition (all tasks are finished).", distractors: [{"text":"    // Loop forever.", reason:"For this demonstration, we need a condition to stop the simulation. In a real embedded system, this loop would indeed run forever."}], indent: 2, explanation: "Comment on the loop termination condition." },
    { "correct": "    bool all_finished = true;", distractors: [{"text":"    bool all_finished = false;", reason:"The logic requires that we assume all tasks are finished and then prove that assumption wrong. Starting with `false` would not work."}], indent: 2, explanation: "Assume all tasks are finished." },
    { "correct": "    for (uint32_t i = 0; i < sched->task_count; i++) {", distractors: [{"text":"    for (uint32_t i = 0; i < MAX_TASKS; i++) {", reason:"This would incorrectly check empty task slots. We only need to check the tasks that have actually been added, up to `sched->task_count`."}], indent: 2, explanation: "Loop through all tasks." },
    { "correct": "      if (sched->task_list[i].state != FINISHED) { all_finished = false; break; }", distractors: [{"text":"      if (sched->task_list[i].state != FINISHED) { all_finished = false; }", reason:"Without the `break`, the loop would continue checking other tasks unnecessarily after we already know not all tasks are finished. `break` makes it more efficient."}] , indent: 3, explanation: "If any task is not finished, clear the flag and break." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used after a `for` loop."}], indent: 2, explanation: "End of termination check loop." },
    { "correct": "    if (all_finished) { break; }", distractors: [{"text":"    if (all_finished) { return; }", reason:"`return` would exit the `scheduler_run` function immediately. `break` correctly exits the `while` loop, allowing code after the loop to execute."}], indent: 2, explanation: "If all tasks are done, exit the main loop." },
    { "correct": "  }", distractors: [{"text":"end while;", reason:"This is not valid C syntax."}], indent: 1, explanation: "End of `while(true)`." },
    { "correct": "  printf(\"\\n--- All Tasks Finished. Scheduler Halting. ---\\n\");", distractors: [{"text":"  puts(\"Scheduler Halting.\");", reason:"This is okay, but the original message is more descriptive about why it's halting."}], indent: 1, explanation: "Final message." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End of `scheduler_run`." },
    { "correct": "void task_wait(Scheduler* sched, uint32_t ticks) {", distractors: [{"text":"void task_wait(uint32_t ticks) {", reason:"This API function needs a pointer to the scheduler to modify the state of the calling task."}], indent: 0, explanation: "Begin `task_wait` implementation. This is an API for tasks." },
    { "correct": "  int current_idx = sched->currently_running_task_index;", distractors: [{"text":"  int current_idx = 0;", reason:"This is a bug. The function must get the index of the *actually running* task."}], indent: 1, explanation: "Get the index of the currently running task." },
    { "correct": "  if (current_idx != -1) {", distractors: [{"text":"  // No check needed", reason:"This check is important. It prevents this function from being called erroneously when no task is actually running."}], indent: 1, explanation: "This function should only be called by a running task." },
    { "correct": "    TCB* task = &sched->task_list[current_idx];", distractors: [{"text":"    TCB* task = sched->task_list;", reason:"This would point to the beginning of the task array, not the specific TCB for the currently running task."}], indent: 2, explanation: "Get the TCB of the calling task." },
    { "correct": "    printf(\"Task '%s' is entering WAITING state for %u ticks.\\n\", task->name, ticks);", distractors: [{"text":"    printf(\"Task is waiting.\\n\");", reason:"This is less useful for debugging. Logging the specific task and the duration of the wait is much better."}], indent: 2, explanation: "Log the state change." },
    { "correct": "    task->state = WAITING;", distractors: [{"text":"    task->state = READY;", reason:"This is incorrect. The task is waiting for a timer, so its state must be `WAITING`, not `READY`."}], indent: 2, explanation: "Change the task's state to WAITING." },
    { "correct": "    task->ticks_to_wait = ticks;", distractors: [{"text":"    task->ticks_to_wait = ticks + sched->current_tick;", reason:"This would be a valid alternative design (storing the wakeup time). The current design stores the duration, which is simpler."}], indent: 2, explanation: "Set the number of ticks to wait." },
    { "correct": "    sched->currently_running_task_index = -1; // Yield the CPU", distractors: [{"text":"    // No need to change running index", reason:"This is a critical bug. If the task doesn't yield the CPU by clearing the running index, the scheduler will never run another task."}], indent: 2, explanation: "The CPU is now available for other tasks." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 1, explanation: "End of current task check." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End of `task_wait`." },
    { "correct": "// === Stage 5: Helper Functions and Demo Tasks ===", distractors: [{"text":"// === Stage 5: The Scheduler ===", reason:"This stage contains helper utilities and the specific task logic for the demo, not the scheduler itself."}], indent: 0, explanation: "Implement utility functions and the actual tasks for the demo." },
    { "correct": "void print_task_states(const Scheduler* sched) {", distractors: [{"text":"void print_task_states(Scheduler* sched) {", reason:"The definition should match the prototype, which used `const` because this function only reads scheduler data."}], indent: 0, explanation: "Begin `print_task_states` implementation." },
    { "correct": "  printf(\"Task States: | \");", distractors: [{"text":"  puts(\"Task States: | \");", reason:"`puts` would add a newline, which we don't want here as we're about to print more on the same line."}], indent: 1, explanation: "Print a header." },
    { "correct": "  for (uint32_t i = 0; i < sched->task_count; i++) {", distractors: [{"text":"  for (uint32_t i = 0; i < MAX_TASKS; i++) {", reason:"This would print all possible task slots, even empty ones. It's better to only loop through the active tasks up to `sched->task_count`."}], indent: 1, explanation: "Loop through all tasks." },
    { "correct": "    const char* state_str;", distractors: [{"text":"    char state_str[16];", reason:"Since we are assigning pointers to read-only string literals, `const char*` is the appropriate type."}], indent: 2, explanation: "Declare a string for the state." },
    { "correct": "    switch(sched->task_list[i].state) {", distractors: [{"text":"    switch(i) {", reason:"We need to switch on the `state` of the task at index `i`, not the index `i` itself."}], indent: 2, explanation: "Switch on the task's state enum." },
    { "correct": "      case READY: state_str = \"Ready\"; break;", distractors: [{"text":"      case READY: state_str = \"Ready\";", reason:"Without a `break`, execution would 'fall through' to the next case, incorrectly setting `state_str` to \"Running\"."}], indent: 3, explanation: "Case for READY." },
    { "correct": "      case RUNNING: state_str = \"Running\"; break;", distractors: [{"text":"      case RUNNING: return;", reason:"`return` would exit the entire `print_task_states` function prematurely."}], indent: 3, explanation: "Case for RUNNING." },
    { "correct": "      case WAITING: state_str = \"Waiting\"; break;", distractors: [{"text":"      case WAITING: strcpy(state_str, \"Waiting\"); break;", reason:"`state_str` is a pointer, not a character array. It should be assigned a pointer to the string literal, not copied into."}], indent: 3, explanation: "Case for WAITING." },
    { "correct": "      case FINISHED: state_str = \"Finished\"; break;", distractors: [{"text":"      case FINISHED: state_str = \"Done\"; break;", reason:"Using a different string like \"Done\" is a valid choice, but \"Finished\" matches the enum name."}], indent: 3, explanation: "Case for FINISHED." },
    { "correct": "      default: state_str = \"Unknown\"; break;", distractors: [{"text":"      default: state_str = \"Unknown\";", reason:"It's good practice to have a `break` even on the default case for consistency."}], indent: 3, explanation: "Default case." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after a `switch` statement."}], indent: 2, explanation: "End of switch." },
    { "correct": "    printf(\"%s: %s | \", sched->task_list[i].name, state_str);", distractors: [{"text":"    printf(\"%s | \", state_str);", reason:"This is less informative. Printing the task name alongside its state is crucial for understanding the output."}], indent: 2, explanation: "Print the name and state of the task." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End of task loop." },
    { "correct": "  printf(\"\\n\");", distractors: [{"text":"  puts(\"\");", reason:"Calling `puts` with an empty string is another correct way to print a single newline character."}], indent: 1, explanation: "Print a newline for formatting." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End of `print_task_states`." },
    { "correct": "// --- Demo Task Definitions ---", distractors: [{"text":"// --- Scheduler Definitions ---", reason:"This section defines the specific functions that will be *run by* the scheduler, not the scheduler itself."}], indent: 0, explanation: "Define the functions that our tasks will execute." },
    { "correct": "void high_priority_task(void* arg) {", distractors: [{"text":"void high_priority_task() {", reason:"All task functions must match the signature defined by the function pointer in the TCB, which is `void (*task_func)(void*)`."}], indent: 0, explanation: "A high-priority task (e.g., brake monitoring)." },
    { "correct": "  Scheduler* sched = (Scheduler*)arg;", distractors: [{"text":"  Scheduler* sched = arg;", reason:"While this often works, explicitly casting the `void*` argument to the type you know it is (`Scheduler*`) is safer and clearer."}], indent: 1, explanation: "Cast the argument back to a Scheduler pointer." },
    { "correct": "  printf(\"  [HP Task] Running. Checking critical systems.\\n\");", distractors: [{"text":"  printf(\"High priority task is running.\\n\");", reason:"Using a consistent log prefix like `[HP Task]` makes the output much easier to read and filter."}], indent: 1, explanation: "Task-specific log." },
    { "correct": "  task_wait(sched, 3); // This task runs, then waits for 3 ticks.", distractors: [{"text":"  // This task runs forever.", reason:"This is a bug. A high-priority task that never waits or finishes (a 'busy-wait') would starve all lower-priority tasks, preventing them from ever running."}], indent: 1, explanation: "The task puts itself to sleep, allowing lower priority tasks to run." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function definition."}], indent: 0, explanation: "End of high priority task." },
    { "correct": "void medium_priority_task(void* arg) {", distractors: [{"text":"void medium_priority_task(void* argument) {", reason:"Using a different parameter name is perfectly fine as long as the type matches the required signature."}], indent: 0, explanation: "A medium-priority task (e.g., navigation update)." },
    { "correct": "  Scheduler* sched = (Scheduler*)arg;", distractors: [{"text":"  Scheduler sched = *(Scheduler*)arg;", reason:"This would create a local copy of the scheduler. The `task_wait` function requires a pointer to the original scheduler."}], indent: 1, explanation: "Get scheduler pointer." },
    { "correct": "  printf(\"  [MP Task] Running. Updating GPS coordinates.\\n\");", distractors: [{"text":"  printf(\"  [MP Task] Running...\\n\");", reason:"Being specific about what the task is simulating makes the demo easier to understand."}], indent: 1, explanation: "Task-specific log." },
    { "correct": "  task_wait(sched, 5); // This task runs, then waits for 5 ticks.", distractors: [{"text":"  task_wait(sched, 1);", reason:"A longer wait time is chosen for this task to better demonstrate how different tasks get a chance to run based on their wait states."}], indent: 1, explanation: "This task has a longer periodic wait." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "End of medium priority task." },
    { "correct": "void low_priority_task(void* arg) {", distractors: [{"text":"void low_priority_task(Scheduler* sched) {", reason:"This is a type mismatch. The function signature must match the TCB's function pointer, which is `void (*func)(void*)`."}], indent: 0, explanation: "A low-priority task (e.g., music player)." },
    { "correct": "  Scheduler* sched = (Scheduler*)arg;", distractors: [{"text":"  // No need to get scheduler", reason:"The task needs a pointer to the scheduler to modify its own state to `FINISHED`."}], indent: 1, explanation: "Get scheduler pointer." },
    { "correct": "  printf(\"  [LP Task] Running. Decoding audio buffer.\\n\");", distractors: [{"text":"  puts(\"  [LP Task] Running. Decoding audio buffer.\");", reason:"`puts` is a valid and simpler alternative for printing this message."}], indent: 1, explanation: "Task-specific log." },
    { "correct": "  // This task will run whenever nothing else is ready. Let's make it 'finish' after one run.", distractors: [{"text":"  // This task waits for 10 ticks.", reason:"For this demo, we want a task that finishes to show the scheduler can eventually halt. Making it wait would extend the simulation."}], indent: 1, explanation: "Comment on this task's behavior." },
    { "correct": "  sched->task_list[sched->currently_running_task_index].state = FINISHED;", distractors: [{"text":"  sched->task_list[2].state = FINISHED;", reason:"Hardcoding the index `2` is not robust. `currently_running_task_index` correctly identifies the currently executing task, regardless of its position in the array."}], indent: 1, explanation: "Mark itself as finished." },
    { "correct": "  sched->currently_running_task_index = -1;", distractors: [{"text":"  // No need to yield", reason:"This is a bug. A task that changes its own state to non-running (e.g., FINISHED or WAITING) must yield the CPU by clearing the `currently_running_task_index`."}], indent: 1, explanation: "Yield the CPU." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function."}], indent: 0, explanation: "End of low priority task." },
    { "correct": "// === Stage 6: Main Program to Run the Simulation ===", distractors: [{"text":"// === Stage 6: The Scheduler Logic ===", reason:"This stage is the `main` driver program that sets up and runs a simulation using our scheduler."}], indent: 0, explanation: "The main entry point to set up and run the scheduler simulation." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid, and often preferred, way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start of the main function." },
    { "correct": "  Scheduler my_scheduler;", distractors: [{"text":"  Scheduler* my_scheduler = malloc(sizeof(Scheduler));", reason:"For a top-level control structure like this, creating it on the stack is simpler than allocating it dynamically and having to remember to free it."}], indent: 1, explanation: "Declare the scheduler instance." },
    { "correct": "  scheduler_init(&my_scheduler);", distractors: [{"text":"  scheduler_init(my_scheduler);", reason:"The `init` function needs to modify the struct, so it requires a pointer. We must pass the address of `my_scheduler` with the `&` operator."}], indent: 1, explanation: "Initialize the scheduler." },
    { "correct": "  // Add tasks in an order that is different from their priority.", distractors: [{"text":"  // Add tasks in priority order.", reason:"Adding them out of order is a better test to prove that the scheduler correctly picks tasks based on priority, not registration order."}], indent: 1, explanation: "Comment explaining task registration order." },
    { "correct": "  scheduler_add_task(&my_scheduler, \"Music Player\", 10, low_priority_task, &my_scheduler);", distractors: [{"text":"  scheduler_add_task(&my_scheduler, \"Music Player\", 10, low_priority_task, NULL);", reason:"Our tasks are designed to accept a pointer to the scheduler as their argument so they can call API functions like `task_wait`."}], indent: 1, explanation: "Add the low priority task first." },
    { "correct": "  scheduler_add_task(&my_scheduler, \"Brake Monitor\", 1, high_priority_task, &my_scheduler);", distractors: [{"text":"  scheduler_add_task(&my_scheduler, \"Brake Monitor\", 0, ...);", reason:"While 0 would be the highest priority, using 1 is a common convention for the most critical task."}], indent: 1, explanation: "Add the high priority task second." },
    { "correct": "  scheduler_add_task(&my_scheduler, \"Navigation\", 5, medium_priority_task, &my_scheduler);", distractors: [{"text":"  scheduler_add_task(&my_scheduler, \"Navigation\", 5, NULL, NULL);", reason:"A task is useless without a function pointer to the code it needs to execute."}], indent: 1, explanation: "Add the medium priority task last." },
    { "correct": "  // The scheduler should pick the highest priority task first, regardless of add order.", distractors: [{"text":"  // The scheduler will run tasks in the order they were added.", reason:"This is false. This is a priority-based scheduler, not a first-in, first-out (FIFO) queue."}], indent: 1, explanation: "Comment on expected scheduler behavior." },
    { "correct": "  // For this demo, we'll manually limit the simulation ticks.", distractors: [{"text":"  scheduler_run(&my_scheduler);", reason:"Calling `scheduler_run` would start an infinite loop. The simplified `for` loop is better for a short, predictable demonstration."}], indent: 1, explanation: "Comment on the simulation loop." },
    { "correct": "  printf(\"\\n--- Starting Scheduler Simulation for 10 Ticks ---\\n\");", distractors: [{"text":"  puts(\"--- Starting Scheduler Simulation for 10 Ticks ---\");", reason:"This is a valid alternative, but `printf` is used consistently elsewhere in the code."}], indent: 1, explanation: "Header for the simulation." },
    { "correct": "  for (int i = 0; i < 10; i++) {", distractors: [{"text":"  while(i < 10) { ... i++; }", reason:"A `while` loop is an equally valid way to construct this limited simulation."}], indent: 1, explanation: "A simplified main loop for the demo." },
    { "correct": "    scheduler_tick(&my_scheduler);", distractors: [{"text":"    // No tick needed in demo", reason:"This is a critical error. The `scheduler_tick` function contains the core logic for updating states and choosing which task to run. The simulation would not work without it."}], indent: 2, explanation: "Advance the scheduler tick." },
    { "correct": "    print_task_states(&my_scheduler);", distractors: [{"text":"    // Not needed", reason:"While not strictly required for operation, printing the states at each tick is essential for being able to see and understand what the scheduler is doing."}], indent: 2, explanation: "Print current state." },
    { "correct": "    int running_idx = my_scheduler.currently_running_task_index;", distractors: [{"text":"    int running_idx = my_scheduler->currently_running_task_index;", reason:"`my_scheduler` is a struct variable on the stack, not a pointer. You must use the dot operator `.` to access its members."}], indent: 2, explanation: "Find out which task should run." },
    { "correct": "    if (running_idx != -1) {", distractors: [{"text":"    if (running_idx > -1) {", reason:"This is an equally valid way to check if the index is valid (i.e., 0 or greater)."}], indent: 2, explanation: "If a task is scheduled to run..." },
    { "correct": "      printf(\"Executing task '%s'.\\n\", my_scheduler.task_list[running_idx].name);", distractors: [{"text":"      printf(\"Executing task %d.\\n\", running_idx);", reason:"Printing the task name is much more informative than printing its internal index."}], indent: 3, explanation: "Log its execution." },
    { "correct": "      my_scheduler.task_list[running_idx].task_func(&my_scheduler);", distractors: [{"text":"      my_scheduler.task_list[running_idx].task_func(NULL);", reason:"The tasks in this demo are designed to accept a pointer to the scheduler so they can call API functions like `task_wait`."}], indent: 3, explanation: "Execute the task's function." },
    { "correct": "    } else {", distractors: [{"text":"    }", reason:"The `else` block is necessary to explicitly handle the 'idle' case, which is an important part of a scheduler's behavior."}], indent: 2, explanation: "If no task is ready..." },
    { "correct": "      printf(\"CPU is idle.\\n\");", distractors: [{"text":"      // Do nothing", reason:"Printing an 'idle' message makes it clear that the scheduler is still running correctly, even when no tasks are ready to execute."}], indent: 3, explanation: "Log idle state." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 2, explanation: "End of execution block." },
    { "correct": "  }", distractors: [{"text":"end for;", reason:"This is not valid C syntax."}], indent: 1, explanation: "End of simulation loop." },
    { "correct": "  printf(\"\\n--- Demo Finished ---\\n\");", distractors: [{"text":"  puts(\"\\n--- Demo Finished ---\");", reason:"`puts` adds its own newline, so the initial `\\n` would create an extra blank line."}], indent: 1, explanation: "Final message." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 conventionally signals that an error occurred. The program should return 0 to indicate a successful run."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of main." }
]
},
// Level 94: Prep for Amazon
{
    "goal": "Implement a hash table that automatically resizes and rehashes its elements when the load factor becomes too high, ensuring efficient lookups, insertions, and deletions.",
    "concepts": "Hash tables, hash functions, collision resolution (chaining), dynamic memory allocation, load factor, rehashing, pointers",
    "sequence": [
    { "correct": "// === Stage 1: Data Structures and Core Declarations ===", distractors: [{"text":"// === Stage 1: The Main Program ===", reason:"Good software design starts with defining the core data structures and their API before writing the main program that uses them."}], indent: 0, explanation: "Define the structures for key-value pairs, hash table entries, and the main hash table." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"`printf` is a standard I/O function and requires `<stdio.h>`."}], indent: 0, explanation: "For standard input/output." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <string.h>", reason:"Dynamic memory functions like `malloc`, `free`, and `calloc` are prototyped in `<stdlib.h>`."}], indent: 0, explanation: "For dynamic memory management (`malloc`, `free`)." },
    { "correct": "#include <string.h>", distractors: [{"text":"#include <strings.h>", reason:"The standard C header for string functions like `strcmp` and `strdup` is `<string.h>`."}], indent: 0, explanation: "For string operations like `strcpy` and `strcmp`." },
    { "correct": "#include <stdint.h>", distractors: [{"text":"// No include needed", reason:"While not strictly required for this specific implementation, using `<stdint.h>` for types like `size_t` (which is also in `stdlib.h`) is good practice in systems programming."}], indent: 0, explanation: "For fixed-width integer types." },
    { "correct": "#define INITIAL_CAPACITY 8", distractors: [{"text":"#define INITIAL_CAPACITY 1000", reason:"Starting with a very large capacity wastes memory if the table ends up storing few items. A small initial capacity that can grow is more efficient."}], indent: 0, explanation: "The initial number of buckets in our hash table." },
    { "correct": "#define MAX_LOAD_FACTOR 0.75", distractors: [{"text":"#define MAX_LOAD_FACTOR 1.0", reason:"A load factor of 1.0 means there are as many items as buckets, which guarantees many collisions. A value like 0.75 triggers a resize before performance degrades too much."}], indent: 0, explanation: "The threshold at which we will trigger a resize and rehash." },
    { "correct": "// A single entry in a hash table bucket (using chaining for collisions).", distractors: [{"text":"// A struct to hold the entire hash table.", reason:"This comment is incorrect. This struct represents a single node in a linked list, not the whole table."}], indent: 0, explanation: "Comment explaining the EntryNode struct." },
    { "correct": "typedef struct EntryNode {", distractors: [{"text":"struct EntryNode {", reason:"Without `typedef`, we would have to write `struct EntryNode* next;`, which is more verbose."}], indent: 0, explanation: "Start definition of an entry node." },
    { "correct": "  char* key;", distractors: [{"text":"  char key[128];", reason:"A fixed-size array limits key length and can waste memory. Using `char*` with dynamic allocation is more flexible."}], indent: 1, explanation: "The key for the entry (we will use strings)." },
    { "correct": "  int value;", distractors: [{"text":"  void* value;", reason:"Using `void*` would make the table more generic, able to store any data type, but adds complexity. For this example, storing a simple `int` is clearer."}], indent: 1, explanation: "The value associated with the key." },
    { "correct": "  struct EntryNode* next;", distractors: [{"text":"  EntryNode next;", reason:"A struct cannot contain a full instance of itself, as this would require infinite memory. It must be a pointer to its own type."}], indent: 1, explanation: "Pointer to the next entry in the same bucket (for chaining)." },
    { "correct": "} EntryNode;", distractors: [{"text":"};", reason:"When using `typedef` with a struct definition, the new type alias (`EntryNode`) must be provided before the final semicolon."}], indent: 0, explanation: "End of EntryNode typedef." },
    { "correct": "// The main Hash Table structure.", distractors: [{"text":"// A linked list.", reason:"This is incorrect. The hash table is an array of linked lists, a more complex structure."}], indent: 0, explanation: "Comment for the HashTable struct." },
    { "correct": "typedef struct {", distractors: [{"text":"struct HashTable {", reason:"Using `typedef` is a convenience that lets us declare variables as `HashTable ht;` instead of `struct HashTable ht;`."}], indent: 0, explanation: "Start definition of the HashTable struct." },
    { "correct": "  EntryNode** buckets;", distractors: [{"text":"  EntryNode* buckets[INITIAL_CAPACITY];", reason:"This creates a fixed-size array of buckets. To allow resizing, the `buckets` member itself must be a pointer (`EntryNode**`) that can be reallocated."}], indent: 1, explanation: "An array of pointers to EntryNodes. This is our bucket array." },
    { "correct": "  size_t capacity;", distractors: [{"text":"  int capacity;", reason:"`size_t` is the appropriate type for memory sizes and counts, as it's guaranteed to be large enough. An `int` could be too small."}], indent: 1, explanation: "The current number of buckets in the `buckets` array." },
    { "correct": "  size_t size;", distractors: [{"text":"  // No need for size", reason:"This is false. Tracking the `size` (number of items) is essential for calculating the load factor and knowing when to resize."}], indent: 1, explanation: "The current number of key-value pairs stored in the table." },
    { "correct": "} HashTable;", distractors: [{"text":"} HashTable", reason:"A `typedef` statement must always end with a semicolon."}], indent: 0, explanation: "End of HashTable typedef." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text":"// --- Function Implementations ---", reason:"These are just forward declarations (prototypes). The full implementations come later."}], indent: 0, explanation: "Declare the public API for our hash table." },
    { "correct": "HashTable* ht_create();", distractors: [{"text":"void ht_create(HashTable* table);", reason:"A 'constructor' function typically handles the allocation itself and returns a pointer to the new object."}], indent: 0, explanation: "Creates and initializes a new hash table." },
    { "correct": "void ht_destroy(HashTable* table);", distractors: [{"text":"int ht_destroy(HashTable* table);", reason:"A 'destroy' function's job is to clean up memory; it doesn't need to return a value, so `void` is appropriate."}], indent: 0, explanation: "Frees all memory associated with the hash table." },
    { "correct": "unsigned long hash_function(const char* str, size_t capacity);", distractors: [{"text":"unsigned long hash_function(const char* str);", reason:"The hash function needs to know the table's current capacity to correctly calculate an index within the array's bounds."}], indent: 0, explanation: "Computes the hash of a string key." },
    { "correct": "void ht_insert(HashTable* table, const char* key, int value);", distractors: [{"text":"bool ht_insert(HashTable* table, const char* key, int value);", reason:"Returning a `bool` to indicate success is a valid design choice, but a `void` return is also common for insert functions."}], indent: 0, explanation: "Inserts or updates a key-value pair." },
    { "correct": "int* ht_get(HashTable* table, const char* key);", distractors: [{"text":"int ht_get(HashTable* table, const char* key);", reason:"Returning an `int*` pointer allows the caller to differentiate between a key not being found (NULL) and a key being found with the value 0."}], indent: 0, explanation: "Retrieves the value for a given key." },
    { "correct": "void ht_delete(HashTable* table, const char* key);", distractors: [{"text":"bool ht_delete(HashTable* table, const char* key);", reason:"Returning a boolean to indicate if the key was actually found and deleted is a good, robust API design."}], indent: 0, explanation: "Deletes a key-value pair." },
    { "correct": "static void ht_resize_and_rehash(HashTable* table);", distractors: [{"text":"void ht_resize_and_rehash(HashTable* table);", reason:"Marking this function as `static` makes it private to this source file. It is an internal implementation detail and should not be part of the public API."}], indent: 0, explanation: "The internal function to grow the table and rehash elements." },
    { "correct": "// === Stage 2: Hash Function and Table Creation/Destruction ===", distractors: [{"text":"// === Stage 2: The Main Program ===", reason:"First, we must implement the core functions of our data structure before we can use them in a `main` function."}], indent: 0, explanation: "Implement the foundational components." },
    { "correct": "unsigned long hash_function(const char* str, size_t capacity) {", distractors: [{"text":"unsigned long hash_function(const char* str) {", reason:"The function definition must match the prototype, which includes the `capacity` parameter."}], indent: 0, explanation: "Begin hash function (djb2 algorithm)." },
    { "correct": "  unsigned long hash = 5381;", distractors: [{"text":"  unsigned long hash = 0;", reason:"While starting with 0 works, using a non-zero prime often helps produce a better distribution of initial hash values."}], indent: 1, explanation: "Start with a magic prime number." },
    { "correct": "  int c;", distractors: [{"text":"  char c;", reason:"The pattern `(c = *str++)` can read `EOF` (an `int`) at the end of some streams, so using `int` is the standard, safe practice."}], indent: 1, explanation: "Variable to hold each character." },
    { "correct": "  while ((c = *str++)) {", distractors: [{"text":"  for(size_t i=0; i < strlen(str); i++) { c = str[i]; ... }", reason:"This works, but requires an initial pass over the string to get its length. The `while` loop is a classic C idiom that processes the string in a single pass."}], indent: 1, explanation: "Iterate through the string." },
    { "correct": "    hash = ((hash << 5) + hash) + c; /* hash * 33 + c */", distractors: [{"text":"    hash = hash + c;", reason:"This is a very simple hashing algorithm that would result in many collisions (e.g., 'ab' and 'ba' would have the same hash). The bit shift creates a better distribution."}], indent: 2, explanation: "Incorporate each character into the hash value." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after the closing brace of a `while` loop."}], indent: 1, explanation: "End of loop." },
    { "correct": "  return hash % capacity;", distractors: [{"text":"  return hash % INITIAL_CAPACITY;", reason:"This is a bug. The hash must be modulo the *current* capacity of the table, not just the initial capacity, especially after resizing."}], indent: 1, explanation: "Return the hash modulo the table capacity to get a bucket index." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "End of `hash_function`." },
    { "correct": "HashTable* ht_create() {", distractors: [{"text":"HashTable ht_create() {", reason:"This function must return a pointer to the dynamically allocated table, so the return type must be `HashTable*`."}], indent: 0, explanation: "Begin `ht_create`." },
    { "correct": "  printf(\"Creating hash table with initial capacity %d.\\n\", INITIAL_CAPACITY);", distractors: [{"text":"  puts(\"Creating hash table...\");", reason:"This is valid, but printing the specific capacity provides more useful debug information."}], indent: 1, explanation: "Log the creation event." },
    { "correct": "  HashTable* table = malloc(sizeof(HashTable));", distractors: [{"text":"  HashTable* table = malloc(sizeof(table));", reason:"This is a bug. `sizeof(table)` gives the size of a pointer (e.g., 8 bytes), not the size of the `HashTable` struct it's supposed to point to."}], indent: 1, explanation: "Allocate the main HashTable struct." },
    { "correct": "  if (!table) { return NULL; }", distractors: [{"text":"  // Assume malloc succeeds", reason:"This is unsafe. `malloc` can fail if the system is out of memory. You must always check its return value."}], indent: 1, explanation: "Handle allocation failure." },
    { "correct": "  table->capacity = INITIAL_CAPACITY;", distractors: [{"text":"  table->capacity = 0;", reason:"The capacity must be initialized to the actual size of the allocated bucket array."}], indent: 1, explanation: "Set the initial capacity." },
    { "correct": "  table->size = 0;", distractors: [{"text":"  // No need to initialize size", reason:"This is a bug. An uninitialized `size` member would contain a garbage value, corrupting the load factor calculation."}], indent: 1, explanation: "Initialize the size to zero." },
    { "correct": "  table->buckets = calloc(table->capacity, sizeof(EntryNode*));", distractors: [{"text":"  table->buckets = malloc(table->capacity * sizeof(EntryNode*));", reason:"`malloc` also works, but you would then need a separate loop or `memset` call to initialize all bucket pointers to NULL. `calloc` does both allocation and zero-initialization in one step."}], indent: 1, explanation: "Allocate the bucket array and initialize all bucket pointers to NULL using calloc." },
    { "correct": "  if (!table->buckets) { free(table); return NULL; }", distractors: [{"text":"  if (!table->buckets) { return NULL; }", reason:"This is a memory leak. If the bucket allocation fails, you must free the `HashTable` struct itself before returning."}], indent: 1, explanation: "Handle bucket allocation failure." },
    { "correct": "  return table;", distractors: [{"text":"  return &table;", reason:"`table` is already a pointer. Returning its address would yield a `HashTable**`, which is the wrong type."}], indent: 1, explanation: "Return the newly created table." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of `ht_create`." },
    { "correct": "void ht_destroy(HashTable* table) {", distractors: [{"text":"void ht_destroy(const HashTable* table) {", reason:"A destroy function frees memory, which is a 'modifying' action on the data structure, so the pointer should not be `const`."}], indent: 0, explanation: "Begin `ht_destroy`." },
    { "correct": "  if (!table) return;", distractors: [{"text":"  if (table == NULL) return;", reason:"This is an equally valid and often clearer way to check if the pointer is NULL. It's good practice to make `destroy` functions safe to call on NULL."}], indent: 1, explanation: "Do nothing if the table is already NULL." },
    { "correct": "  printf(\"Destroying hash table...\\n\");", distractors: [{"text":"  puts(\"Destroying hash table...\");", reason:"`puts` is a valid and simpler alternative for printing this fixed string."}], indent: 1, explanation: "Log the destruction." },
    { "correct": "  for (size_t i = 0; i < table->capacity; i++) {", distractors: [{"text":"  for (size_t i = 0; i < table->size; i++) {", reason:"This is a bug. We must iterate through every *bucket* (`capacity`), not just every *item* (`size`), to find all the linked lists."}], indent: 1, explanation: "Iterate through each bucket." },
    { "correct": "    EntryNode* entry = table->buckets[i];", distractors: [{"text":"    free(table->buckets[i]);", reason:"This would only free the *first* node in the collision chain, leaking all subsequent nodes in the same bucket."}], indent: 2, explanation: "Get the head of the linked list for the current bucket." },
    { "correct": "    while (entry) {", distractors: [{"text":"    if (entry) {", reason:"An `if` would only free the first node. A `while` loop is required to traverse the entire linked list."}], indent: 2, explanation: "Iterate through the linked list (chain)." },
    { "correct": "      EntryNode* next = entry->next;", distractors: [{"text":"      free(entry);", reason:"This is a classic use-after-free bug. If you free `entry` first, you can no longer access `entry->next` to move to the next node."}], indent: 3, explanation: "Save the pointer to the next node." },
    { "correct": "      free(entry->key);", distractors: [{"text":"      // No need to free key", reason:"This is a memory leak. The key was allocated with `strdup` (which uses `malloc`) and must be freed."}], indent: 3, explanation: "Free the string key." },
    { "correct": "      free(entry);", distractors: [{"text":"      entry = next;", reason:"This would leak the memory for the `EntryNode` struct itself before moving to the next one."}], indent: 3, explanation: "Free the node itself." },
    { "correct": "      entry = next;", distractors: [{"text":"      // No update needed", reason:"This is a bug. Without advancing `entry`, the `while` loop would become an infinite loop."}], indent: 3, explanation: "Move to the next node in the chain." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after a `while` loop."}], indent: 2, explanation: "End of linked list traversal." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End of bucket iteration." },
    { "correct": "  free(table->buckets);", distractors: [{"text":"  // No need to free buckets", reason:"This is a memory leak. The `buckets` array was itself dynamically allocated and must be freed."}], indent: 1, explanation: "Free the bucket array itself." },
    { "correct": "  free(table);", distractors: [{"text":"  // This is the only free needed", reason:"This is a massive memory leak. You must free all the nodes and strings *before* freeing the main table structure."}], indent: 1, explanation: "Free the main HashTable struct." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "End of `ht_destroy`." },
    { "correct": "// === Stage 3: Core Logic - Insertion with Rehashing ===", distractors: [{"text":"// === Stage 3: Retrieval Logic ===", reason:"Before we can retrieve data, we must first implement the logic for inserting it, which includes the critical resizing/rehashing step."}], indent: 0, explanation: "Implement the insertion logic, including the critical rehashing step." },
    { "correct": "static void ht_resize_and_rehash(HashTable* table) {", distractors: [{"text":"void ht_resize_and_rehash(HashTable* table) {", reason:"The `static` keyword makes this function private to this source file. Since it's an internal helper, it should not be exposed in a public API."}], indent: 0, explanation: "Begin the internal rehashing function." },
    { "correct": "  size_t old_capacity = table->capacity;", distractors: [{"text":"  size_t old_capacity = INITIAL_CAPACITY;", reason:"This is a bug. The table may have already been resized before. We must use its *current* capacity."}], indent: 1, explanation: "Store the old capacity." },
    { "correct": "  EntryNode** old_buckets = table->buckets;", distractors: [{"text":"  EntryNode* old_buckets = *table->buckets;", reason:"`old_buckets` needs to be a pointer to the array of buckets (`EntryNode**`) so we can free it later."}], indent: 1, explanation: "Store a pointer to the old bucket array." },
    { "correct": "  size_t new_capacity = old_capacity * 2;", distractors: [{"text":"  size_t new_capacity = old_capacity + 10;", reason:"While adding a fixed amount works, doubling the capacity is a standard strategy that leads to amortized O(1) insertion time."}], indent: 1, explanation: "Double the capacity of the hash table." },
    { "correct": "  printf(\"--- Rehashing: capacity %zu -> %zu ---\\n\", old_capacity, new_capacity);", distractors: [{"text":"  printf(\"Rehashing...\\n\");", reason:"This is less useful. Logging the capacity change is crucial for debugging and observing the hash table's dynamic behavior."}], indent: 1, explanation: "Log the resize event." },
    { "correct": "  // Create a new, larger bucket array", distractors: [{"text":"  // Reallocate the existing bucket array", reason:"This is a subtle but important error. `realloc` is not sufficient, because all existing elements must be *re-hashed* into new bucket indices based on the new capacity."}], indent: 1, explanation: "Comment on creating the new storage." },
    { "correct": "  table->buckets = calloc(new_capacity, sizeof(EntryNode*));", distractors: [{"text":"  table->buckets = calloc(new_capacity, sizeof(EntryNode));", reason:"This is a bug. We are allocating an array of *pointers*, so the element size must be `sizeof(EntryNode*)`, not the size of the full struct."}], indent: 1, explanation: "Allocate the new, larger bucket array." },
    { "correct": "  if (!table->buckets) {", distractors: [{"text":"  // Assume allocation succeeds", reason:"This is a critical failure point. If memory cannot be allocated for the resize, the program must handle it gracefully."}], indent: 1, explanation: "Handle allocation failure (critical)." },
    { "correct": "    fprintf(stderr, \"Critical: Failed to allocate memory for rehashing.\\n\");", distractors: [{"text":"    printf(\"Rehash failed.\\n\");", reason:"Printing to `stderr` is conventional for critical errors. The original message is also more descriptive."}], indent: 2, explanation: "Print an error." },
    { "correct": "    table->buckets = old_buckets; // Restore old state", distractors: [{"text":"    // Do nothing", reason:"Restoring the old buckets pointer is crucial. It leaves the hash table in its previous, valid (though full) state instead of a corrupted state."}], indent: 2, explanation: "Attempt to restore the table to a usable (though full) state." },
    { "correct": "    return; // Abort rehash", distractors: [{"text":"    exit(1);", reason:"Exiting the entire program might be too severe. Aborting the rehash allows the calling code to potentially continue, even if the table is full."}], indent: 2, explanation: "Exit the function." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 1, explanation: "End failure check." },
    { "correct": "  table->capacity = new_capacity;", distractors: [{"text":"  // No need to update capacity", reason:"This is a bug. The table's capacity field must be updated to reflect the size of the new bucket array."}], indent: 1, explanation: "Update the capacity in the table struct." },
    { "correct": "  table->size = 0; // Size will be recounted as we re-insert", distractors: [{"text":"  // Keep the old size", reason:"This is incorrect. The `ht_insert` function increments the size, so we must reset it to 0 before re-inserting all the old elements."}], indent: 1, explanation: "Reset the size before re-inserting." },
    { "correct": "  // Iterate over the old buckets and re-insert every entry into the new buckets", distractors: [{"text":"  // Copy old buckets to new buckets", reason:"This is a critical bug. Because the capacity has changed, the hash index for each key will be different. You *must* re-calculate the hash and re-insert each element."}], indent: 1, explanation: "Comment on the re-insertion process." },
    { "correct": "  for (size_t i = 0; i < old_capacity; i++) {", distractors: [{"text":"  for (size_t i = 0; i < new_capacity; i++) {", reason:"The loop must iterate over the `old_buckets` array, which has `old_capacity` elements."}], indent: 1, explanation: "Loop through all the old buckets." },
    { "correct": "    EntryNode* entry = old_buckets[i];", distractors: [{"text":"    EntryNode* entry = &old_buckets[i];", reason:"`old_buckets[i]` is already a pointer (`EntryNode*`). Taking its address would be an error."}], indent: 2, explanation: "Get the head of the chain in the old bucket." },
    { "correct": "    while (entry) {", distractors: [{"text":"    if (entry) {", reason:"An `if` would only process the first entry in the chain. A `while` loop is necessary to traverse and re-insert all entries."}], indent: 2, explanation: "Iterate through the chain." },
    { "correct": "      EntryNode* next = entry->next;", distractors: [{"text":"      // No need to save next", reason:"This is a bug. `ht_insert` will modify the `next` pointer of the entry. We must save it *before* calling `ht_insert`."}], indent: 3, explanation: "Save the next pointer." },
    { "correct": "      // Re-insert the entry into the new, larger table", distractors: [{"text":"      // Manually calculate new hash and link", reason:"It's much better to reuse the existing `ht_insert` function, as this avoids duplicating code and logic."}], indent: 3, explanation: "Comment on the re-insertion call." },
    { "correct": "      ht_insert(table, entry->key, entry->value);", distractors: [{"text":"      ht_set(table, entry->key, entry->value);", reason:"The function is named `ht_insert`. Using a non-existent function name would cause a compile error."}], indent: 3, explanation: "Call the main insert function, which will use the new capacity for hashing." },
    { "correct": "      // Free the old entry's memory", distractors: [{"text":"      // No need to free here", reason:"This is a bug. `ht_insert` makes new copies of the key. We must free the memory associated with the old entry to prevent leaks."}], indent: 3, explanation: "Comment on cleanup." },
    { "correct": "      free(entry->key);", distractors: [{"text":"      // No need to free key", reason:"This is a memory leak. `ht_insert` created a new copy of the key with `strdup`, so the old copy must be freed."}], indent: 3, explanation: "Free the key from the old entry." },
    { "correct": "      free(entry);", distractors: [{"text":"      free(entry->value);", reason:"The value is an `int`, not a pointer. It is part of the struct's memory and does not need to be freed separately."}], indent: 3, explanation: "Free the old entry node itself." },
    { "correct": "      entry = next;", distractors: [{"text":"      // No update needed", reason:"This is a bug. Without advancing `entry` to the saved `next` pointer, the loop would become an infinite loop."}], indent: 3, explanation: "Move to the next entry in the old chain." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 2, explanation: "End chain traversal." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End old bucket traversal." },
    { "correct": "  free(old_buckets);", distractors: [{"text":"  // No need to free this array", reason:"This is a memory leak. The `old_buckets` array was dynamically allocated and must be freed after we are done with it."}], indent: 1, explanation: "Free the old bucket array itself." },
    { "correct": "  printf(\"--- Rehash complete ---\\n\");", distractors: [{"text":"  puts(\"--- Rehash complete ---\");", reason:"`puts` is a valid and simpler alternative for printing this message."}], indent: 1, explanation: "Log completion." },
    { "correct": "}", distractors: [{"text":"end rehash;", reason:"This is not valid C syntax."}], indent: 0, explanation: "End of `ht_resize_and_rehash`." },
    { "correct": "void ht_insert(HashTable* table, const char* key, int value) {", distractors: [{"text":"void ht_insert(HashTable table, ...)", reason:"The function must take a pointer to the hash table so it can modify its contents (size, capacity, buckets)."}], indent: 0, explanation: "Begin `ht_insert`." },
    { "correct": "  if (!table || !key) return;", distractors: [{"text":"  if (!table && !key) return;", reason:"The logical operator must be OR (`||`). We should return if the table is NULL *or* if the key is NULL."}], indent: 1, explanation: "Guard against NULL inputs." },
    { "correct": "  // Check load factor and resize if necessary", distractors: [{"text":"  // Insert first, then check load factor.", reason:"This is a logic error. You must check the load factor *before* inserting to ensure there is enough space. This is called 'proactive' resizing."}], indent: 1, explanation: "Comment on the load factor check." },
    { "correct": "  if ((float)table->size / table->capacity >= MAX_LOAD_FACTOR) {", distractors: [{"text":"  if (table->size / table->capacity >= MAX_LOAD_FACTOR) {", reason:"This is a bug. `size` and `capacity` are integers, so this would perform integer division, which will likely result in 0. We must cast one to `float` to force floating-point division."}] , indent: 1, explanation: "Calculate the current load factor and compare to the max." },
    { "correct": "    ht_resize_and_rehash(table);", distractors: [{"text":"    // Table is full, return error.", reason:"The point of a dynamic hash table is that it *isn't* full. It should resize itself automatically instead of returning an error."}], indent: 2, explanation: "Trigger the resize and rehash operation." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 1, explanation: "End load factor check." },
    { "correct": "  size_t index = hash_function(key, table->capacity);", distractors: [{"text":"  size_t index = hash_function(key, INITIAL_CAPACITY);", reason:"This is a bug. We must always use the table's *current* capacity, which may have changed after a rehash."}], indent: 1, explanation: "Calculate the bucket index for the key." },
    { "correct": "  EntryNode* entry = table->buckets[index];", distractors: [{"text":"  EntryNode* entry = NULL;", reason:"We need to start traversal at the actual head of the chain for this bucket, which is `table->buckets[index]`."}], indent: 1, explanation: "Get the head of the chain for this bucket." },
    { "correct": "  // Traverse the chain to see if the key already exists", distractors: [{"text":"  // Assume the key is new.", reason:"This is a bug. If we don't check for existing keys, we would insert duplicates, which violates how a hash map should work."}], indent: 1, explanation: "Comment on checking for existing keys." },
    { "correct": "  while (entry) {", distractors: [{"text":"  if (entry) {", reason:"An `if` would only check the first node. A `while` loop is needed to traverse the entire collision chain."}], indent: 1, explanation: "Loop through the chain." },
    { "correct": "    if (strcmp(entry->key, key) == 0) {", distractors: [{"text":"    if (entry->key == key) {", reason:"This is a critical error. Strings must be compared with `strcmp`. `==` only compares pointer addresses."}], indent: 2, explanation: "If the key already exists..." },
    { "correct": "      entry->value = value; // Update the value", distractors: [{"text":"      // Key already exists, do nothing.", reason:"A common behavior for hash table insertion is to update the value if the key already exists."}], indent: 3, explanation: "Update the value for the existing key." },
    { "correct": "      printf(\"Updated key '%s' to value %d.\\n\", key, value);", distractors: [{"text":"      puts(\"Updated key.\");", reason:"This is less informative. Logging the key and new value is better for debugging."}], indent: 3, explanation: "Log the update." },
    { "correct": "      return;", distractors: [{"text":"      break;", reason:"`break` would exit the `while` loop, but the code would then proceed to incorrectly add a new entry. `return` exits the function entirely."}], indent: 3, explanation: "Exit the function." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 2, explanation: "End key comparison." },
    { "correct": "    entry = entry->next;", distractors: [{"text":"    // No update needed", reason:"This is a bug. Forgetting to advance to the next node would cause an infinite loop."}], indent: 2, explanation: "Move to the next node." },
    { "correct": "  }", distractors: [{"text":"end while;", reason:"This is not valid C syntax."}], indent: 1, explanation: "End chain traversal." },
    { "correct": "  // If key not found, create a new entry and add it to the front of the chain.", distractors: [{"text":"  // If key not found, do nothing.", reason:"This would be a bug. If the key doesn't exist, the `insert` function's job is to create and add it."}], indent: 1, explanation: "Comment on creating a new entry." },
    { "correct": "  EntryNode* new_entry = malloc(sizeof(EntryNode));", distractors: [{"text":"  EntryNode new_entry;", reason:"This creates a local stack variable that is destroyed when the function returns. The node must be dynamically allocated with `malloc`."}], indent: 1, explanation: "Allocate memory for the new node." },
    { "correct": "  new_entry->key = strdup(key); // Duplicate the key string", distractors: [{"text":"  new_entry->key = key;", reason:"This is a bug. It only copies the pointer, not the string content. `strdup` correctly allocates new memory and makes a copy."}], indent: 1, explanation: "Allocate memory for and copy the key string." },
    { "correct": "  new_entry->value = value;", distractors: [{"text":"  new_entry->value = 0;", reason:"This would be a bug, ignoring the value that the user provided."}], indent: 1, explanation: "Set the value." },
    { "correct": "  new_entry->next = table->buckets[index];", distractors: [{"text":"  new_entry->next = NULL;", reason:"This is incorrect if there is already a collision chain in this bucket. It must be linked to the existing head."}], indent: 1, explanation: "The new entry's `next` points to the old head of the chain." },
    { "correct": "  table->buckets[index] = new_entry;", distractors: [{"text":"  // No need to update bucket", reason:"This is a critical bug. The bucket pointer must be updated to point to our new entry, making it the new head of the chain."}], indent: 1, explanation: "The new entry becomes the new head of the chain." },
    { "correct": "  table->size++;", distractors: [{"text":"  // No need to update size", reason:"This is a bug. We must increment the size so our load factor calculation is correct and triggers a rehash when needed."}], indent: 1, explanation: "Increment the total size of the hash table." },
    { "correct": "  printf(\"Inserted key '%s' with value %d.\\n\", key, value);", distractors: [{"text":"  puts(\"Inserted key.\");", reason:"This is less useful for debugging. Logging the actual key and value is better."}], indent: 1, explanation: "Log the insertion." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End of `ht_insert`." },
    { "correct": "// === Stage 4: Retrieval and Deletion ===", distractors: [{"text":"// === Stage 4: Rehashing ===", reason:"Rehashing is an internal part of insertion. This stage implements the public-facing `get` and `delete` functions."}], indent: 0, explanation: "Implement the get and delete operations." },
    { "correct": "int* ht_get(HashTable* table, const char* key) {", distractors: [{"text":"int ht_get(HashTable* table, const char* key) {", reason:"The definition must match the prototype. Returning a pointer (`int*`) allows us to distinguish between 'key not found' (`NULL`) and 'key found with value 0'."}], indent: 0, explanation: "Begin `ht_get`." },
    { "correct": "  if (!table || !key) return NULL;", distractors: [{"text":"  if (!table) return NULL;", reason:"We should also check if the `key` is `NULL` to prevent a crash in the hash function."}], indent: 1, explanation: "Guard against NULL inputs." },
    { "correct": "  size_t index = hash_function(key, table->capacity);", distractors: [{"text":"  size_t index = strlen(key) % table->capacity;", reason:"Using `strlen` as a hash function is simple but performs poorly, leading to many collisions."}], indent: 1, explanation: "Calculate the bucket index for the key." },
    { "correct": "  EntryNode* entry = table->buckets[index];", distractors: [{"text":"  EntryNode* entry = NULL;", reason:"We must start the search at the head of the chain for the calculated bucket, which is `table->buckets[index]`."}], indent: 1, explanation: "Get the head of the chain." },
    { "correct": "  while (entry) {", distractors: [{"text":"  for (EntryNode* e = entry; e != NULL; e = e->next) {", reason:"A `for` loop is an equally valid way to structure the traversal of the linked list."}], indent: 1, explanation: "Traverse the chain." },
    { "correct": "    if (strcmp(entry->key, key) == 0) {", distractors: [{"text":"    if (entry->key == key) {", reason:"This is a critical error. String content must be compared with `strcmp`, not the `==` operator."}], indent: 2, explanation: "If the key is found..." },
    { "correct": "      printf(\"Key '%s' found with value %d.\\n\", key, entry->value);", distractors: [{"text":"      puts(\"Key found.\");", reason:"This is less informative. Logging the key and its found value is better."}], indent: 3, explanation: "Log the find." },
    { "correct": "      return &entry->value; // Return a pointer to the value", distractors: [{"text":"      return entry->value;", reason:"This would be a type mismatch. The function returns a pointer (`int*`), not an `int`. Returning a pointer allows the caller to modify the value if desired."}], indent: 3, explanation: "Return a pointer to the value to allow modification." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 2, explanation: "End key comparison." },
    { "correct": "    entry = entry->next;", distractors: [{"text":"    // No update needed", reason:"This is a bug. Forgetting to advance the pointer would cause an infinite loop."}], indent: 2, explanation: "Move to the next node." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `while` loop."}], indent: 1, explanation: "End chain traversal." },
    { "correct": "  printf(\"Key '%s' not found.\\n\", key);", distractors: [{"text":"  printf(\"Key not found.\\n\");", reason:"Echoing the key that wasn't found provides better feedback to the user."}], indent: 1, explanation: "Log that the key was not found." },
    { "correct": "  return NULL;", distractors: [{"text":"  return 0;", reason:"The function returns a pointer. `NULL` is the standard way to indicate a 'not found' error for a pointer return type."}], indent: 1, explanation: "Return NULL if the key is not in the table." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "End of `ht_get`." },
    { "correct": "void ht_delete(HashTable* table, const char* key) {", distractors: [{"text":"bool ht_delete(HashTable* table, const char* key) {", reason:"The function definition must match the prototype. Returning a `bool` would be a good design to indicate if the deletion was successful."}], indent: 0, explanation: "Begin `ht_delete`." },
    { "correct": "  if (!table || !key) return;", distractors: [{"text":"  // Assume valid input", reason:"This is unsafe. A robust function should always guard against NULL pointers."}], indent: 1, explanation: "Guard against NULL inputs." },
    { "correct": "  size_t index = hash_function(key, table->capacity);", distractors: [{"text":"  size_t index = 0;", reason:"This is a bug. We must calculate the hash of the key to know which bucket to search."}], indent: 1, explanation: "Calculate the bucket index." },
    { "correct": "  EntryNode* entry = table->buckets[index];", distractors: [{"text":"  EntryNode* entry = NULL;", reason:"This is a bug. We must start the search at the head of the correct bucket's chain."}], indent: 1, explanation: "Get the head of the chain." },
    { "correct": "  EntryNode* prev = NULL;", distractors: [{"text":"  EntryNode* prev = entry;", reason:"The `prev` pointer must start at `NULL`, as there is no node before the head of the list."}], indent: 1, explanation: "Keep track of the previous node to relink the chain." },
    { "correct": "  while (entry) {", distractors: [{"text":"  if (entry) {", reason:"An `if` would only check the first node. A `while` loop is needed to traverse the whole chain."}], indent: 1, explanation: "Traverse the chain." },
    { "correct": "    if (strcmp(entry->key, key) == 0) {", distractors: [{"text":"    if (entry->key == key) {", reason:"This is a critical error. Strings must be compared with `strcmp`."}], indent: 2, explanation: "If the key is found..." },
    { "correct": "      if (prev == NULL) { // The node to delete is the head of the chain", distractors: [{"text":"      // No special case needed", reason:"This is false. Deleting the head of a linked list is a special case because you have to update the bucket pointer itself, not a `next` pointer of a previous node."}], indent: 3, explanation: "Check if the target node is the first one." },
    { "correct": "        table->buckets[index] = entry->next;", distractors: [{"text":"        table->buckets[index] = NULL;", reason:"This is a bug. It would orphan the rest of the chain if other nodes were present."}], indent: 4, explanation: "Update the bucket to point to the next node." },
    { "correct": "      } else { // The node to delete is in the middle or end of the chain", distractors: [{"text":"      }", reason:"The `else` block is required to handle the case where the node is not the head of the list."}], indent: 3, explanation: "If it's not the head." },
    { "correct": "        prev->next = entry->next;", distractors: [{"text":"        entry->next = prev->next;", reason:"This is incorrect logic that would not correctly unlink the node from the list."}], indent: 4, explanation: "Unlink the node by connecting the previous to the next." },
    { "correct": "      }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if/else` block."}], indent: 3, explanation: "End of relinking logic." },
    { "correct": "      printf(\"Deleted key '%s'.\\n\", key);", distractors: [{"text":"      puts(\"Deleted key.\");", reason:"This is less informative. Logging the specific key is better."}], indent: 3, explanation: "Log the deletion." },
    { "correct": "      free(entry->key);", distractors: [{"text":"      // No need to free key", reason:"This is a memory leak. The key was allocated with `strdup` and must be freed."}], indent: 3, explanation: "Free the key's memory." },
    { "correct": "      free(entry);", distractors: [{"text":"      free(&entry);", reason:"`free` must be called on the pointer itself, not its address."}], indent: 3, explanation: "Free the node's memory." },
    { "correct": "      table->size--;", distractors: [{"text":"      // No need to update size", reason:"This is a bug. The size must be decremented to keep the load factor accurate."}], indent: 3, explanation: "Decrement the table size." },
    { "correct": "      return;", distractors: [{"text":"      break;", reason:"`break` would exit the loop, but the function would then incorrectly print the 'not found' message. `return` exits the function completely."}], indent: 3, explanation: "Exit the function." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 2, explanation: "End key comparison." },
    { "correct": "    prev = entry;", distractors: [{"text":"    // prev doesn't change", reason:"This is a bug. On each iteration, the current node becomes the 'previous' node for the next iteration."}], indent: 2, explanation: "Advance the previous pointer." },
    { "correct": "    entry = entry->next;", distractors: [{"text":"    entry = prev->next;", reason:"This is correct, as `prev` was just updated to the current `entry`."}], indent: 2, explanation: "Advance the current pointer." },
    { "correct": "  }", distractors: [{"text":"end while;", reason:"This is not valid C syntax."}], indent: 1, explanation: "End chain traversal." },
    { "correct": "  printf(\"Key '%s' not found for deletion.\\n\", key);", distractors: [{"text":"  // Do nothing if not found", reason:"Printing a message is better user experience, as it confirms the program understood the command but found nothing to delete."}], indent: 1, explanation: "Log if the key to delete was not found." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End of `ht_delete`." },
    { "correct": "// === Stage 5: Main Program for Demonstration ===", distractors: [{"text":"// === Stage 5: The Hash Table Library ===", reason:"This is the main program that *uses* our hash table library to demonstrate its features."}], indent: 0, explanation: "A `main` function to test the dynamic hash table." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid and often preferred way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start of the main function." },
    { "correct": "  printf(\"--- Dynamic Hash Table Demo ---\\n\");", distractors: [{"text":"  puts(\"--- Dynamic Hash Table Demo ---\");", reason:"`puts` is a valid alternative that also prints a newline."}], indent: 1, explanation: "Print a title." },
    { "correct": "  HashTable* my_ht = ht_create();", distractors: [{"text":"  HashTable my_ht;", reason:"Our API is designed to work with pointers to dynamically allocated hash tables. Creating it on the stack would not work with our functions."}], indent: 1, explanation: "Create the hash table." },
    { "correct": "  // Insert items to trigger a rehash", distractors: [{"text":"  // Insert one item", reason:"The goal of this demo is to specifically test the automatic resizing, which requires inserting enough items to exceed the load factor."}], indent: 1, explanation: "Comment on the insertion phase." },
    { "correct": "  ht_insert(my_ht, \"apple\", 10);", distractors: [{"text":"  ht_insert(&my_ht, \"apple\", 10);", reason:"`my_ht` is already a pointer. Passing its address would be a `HashTable**`, which is the wrong type."}], indent: 1, explanation: "Insert item 1." },
    { "correct": "  ht_insert(my_ht, \"banana\", 20);", distractors: [{"text":"  ht_insert(my_ht, \"banana\", \"20\");", reason:"The `value` parameter for our `ht_insert` function is an `int`, not a string."}], indent: 1, explanation: "Insert item 2." },
    { "correct": "  ht_insert(my_ht, \"cherry\", 30);", distractors: [{"text":"  // No more insertions", reason:"We need to insert more items to cross the load factor threshold and trigger the rehash."}], indent: 1, explanation: "Insert item 3." },
    { "correct": "  ht_insert(my_ht, \"date\", 40);", distractors: [{"text":"  ht_insert(my_ht, \"date\", 40.5);", reason:"The value type for our hash table is `int`, so a floating point number would be truncated."}], indent: 1, explanation: "Insert item 4." },
    { "correct": "  ht_insert(my_ht, \"elderberry\", 50);", distractors: [{"text":"  ht_insert(my_ht, \"elderberry\", 'A');", reason:"A character literal like 'A' is treated as its integer ASCII value, so this would be a valid, if unusual, insertion."}], indent: 1, explanation: "Insert item 5." },
    { "correct": "  // (0.75 * 8 = 6). The next insertion should trigger a rehash.", distractors: [{"text":"  // The table will resize when it's full.", reason:"This is incorrect. The table resizes when its *load factor* exceeds the maximum, which happens here *before* it is completely full."}], indent: 1, explanation: "Explain when the rehash will happen." },
    { "correct": "  ht_insert(my_ht, \"fig\", 60);", distractors: [{"text":"  ht_resize_and_rehash(my_ht);", reason:"The user should not call the internal `resize` function directly. The `insert` function handles this automatically."}], indent: 1, explanation: "Insert item 6. This should trigger rehash." },
    { "correct": "  ht_insert(my_ht, \"grape\", 70);", distractors: [{"text":"  ht_insert(my_ht, \"fig\", 70);", reason:"This would update the value for 'fig' instead of inserting a new 'grape' key."}], indent: 1, explanation: "Insert another item into the resized table." },
    { "correct": "  printf(\"Current table size: %zu, capacity: %zu\\n\", my_ht->size, my_ht->capacity);", distractors: [{"text":"  printf(\"Size: %d, Capacity: %d\\n\", my_ht->size, my_ht->capacity);", reason:"The correct format specifier for `size_t` is `%zu`. Using `%d` can fail on systems where `size_t` is larger than `int`."}], indent: 1, explanation: "Print the state after rehashing." },
    { "correct": "  // --- Test retrieval ---", distractors: [{"text":"  // --- Test destruction ---", reason:"We should test that the data is correct before we test destroying it."}], indent: 1, explanation: "Comment on the retrieval test." },
    { "correct": "  int* val = ht_get(my_ht, \"apple\");", distractors: [{"text":"  int val = ht_get(my_ht, \"apple\");", reason:"`ht_get` returns a pointer (`int*`), not an `int`. This would be a type mismatch."}], indent: 1, explanation: "Get an existing key." },
    { "correct": "  if(val) printf(\"Value for 'apple' is %d\\n\", *val);", distractors: [{"text":"  printf(\"Value for 'apple' is %d\\n\", *val);", reason:"This is unsafe. `ht_get` can return `NULL` if the key isn't found. The `if(val)` check is required to prevent dereferencing a NULL pointer."}], indent: 1, explanation: "Print the found value." },
    { "correct": "  ht_get(my_ht, \"zucchini\"); // Get a non-existent key", distractors: [{"text":"  int* val = ht_get(my_ht, \"zucchini\"); printf(\"%d\", *val);", reason:"This would be a bug. `ht_get` will return `NULL` for a non-existent key, and trying to dereference it with `*val` will crash the program."}], indent: 1, explanation: "Try to get a key that isn't there." },
    { "correct": "  // --- Test update ---", distractors: [{"text":"  // --- Test insertion ---", reason:"We are testing the update functionality of the `ht_insert` function, not adding a new key."}], indent: 1, explanation: "Comment on the update test." },
    { "correct": "  ht_insert(my_ht, \"banana\", 25);", distractors: [{"text":"  ht_update(my_ht, \"banana\", 25);", reason:"Our API uses the `ht_insert` function for both inserting new keys and updating existing ones. We did not implement a separate `ht_update`."}], indent: 1, explanation: "Update an existing key." },
    { "correct": "  val = ht_get(my_ht, \"banana\");", distractors: [{"text":"  // No need to get again", reason:"We need to call `ht_get` again to retrieve the new, updated value."}], indent: 1, explanation: "Get the updated key." },
    { "correct": "  if(val) printf(\"New value for 'banana' is %d\\n\", *val);", distractors: [{"text":"  if(val) printf(\"New value is %d\\n\", val);", reason:"This would print the memory address stored in the pointer `val`. We need to dereference it with `*val` to get the integer value."}], indent: 1, explanation: "Print the new value." },
    { "correct": "  // --- Test deletion ---", distractors: [{"text":"  // --- Test retrieval ---", reason:"This section specifically tests the `ht_delete` functionality."}], indent: 1, explanation: "Comment on the deletion test." },
    { "correct": "  ht_delete(my_ht, \"cherry\");", distractors: [{"text":"  ht_insert(my_ht, \"cherry\", 0);", reason:"Setting the value to 0 is not the same as deleting the key-value pair from the table."}], indent: 1, explanation: "Delete a key." },
    { "correct": "  ht_get(my_ht, \"cherry\"); // Verify it's gone", distractors: [{"text":"  // Assume it's gone.", reason:"You should always verify the state of your data structure after an operation to confirm it behaved as expected."}], indent: 1, explanation: "Try to get the deleted key." },
    { "correct": "  printf(\"Current table size after deletion: %zu\\n\", my_ht->size);", distractors: [{"text":"  printf(\"Current capacity after deletion: %zu\\n\", my_ht->capacity);", reason:"Deleting an element reduces the `size`, but it does not shrink the `capacity` in this implementation."}], indent: 1, explanation: "Check the size after deletion." },
    { "correct": "  // --- Cleanup ---", distractors: [{"text":"  // --- End of program ---", reason:"'Cleanup' is a more descriptive term for the memory deallocation phase."}], indent: 1, explanation: "Comment on cleanup." },
    { "correct": "  ht_destroy(my_ht);", distractors: [{"text":"  free(my_ht);", reason:"This is a massive memory leak. `free(my_ht)` only frees the `HashTable` struct itself, not the bucket array or any of the nodes and strings it contains. The custom `ht_destroy` function is mandatory."}], indent: 1, explanation: "Free all allocated memory." },
    { "correct": "  printf(\"--- Demo Finished ---\\n\");", distractors: [{"text":"  puts(\"--- Demo Finished ---\");", reason:"`puts` is a valid alternative for printing this message."}], indent: 1, explanation: "Final message." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 signals an error. Since the program completed successfully, it should return 0."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of main." }
]
},
// Level 95: Prep for Meta
{
    "goal": "Implement a graph data structure using an adjacency list to model a social network, with features to add users, create friendships, and find mutual friends.",
    "concepts": "Graphs, adjacency lists, nodes, edges, dynamic memory allocation, data structures, searching algorithms",
    "sequence": [
    { "correct": "// === Stage 1: Core Data Structures for the Graph ===", distractors: [{"text":"// === Stage 1: The Main Program ===", reason:"It's good design practice to define the core data structures for a system before writing the main logic that uses them."}], indent: 0, explanation: "Define the structures for graph nodes, the adjacency list, and the main graph container." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"The standard I/O function `printf` is declared in `<stdio.h>`."}], indent: 0, explanation: "For standard I/O like printf." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <string.h>", reason:"Memory management functions like `malloc` and `free` are prototyped in `<stdlib.h>`."}], indent: 0, explanation: "For memory management (malloc, free)." },
    { "correct": "#include <string.h>", distractors: [{"text":"#include <strings.h>", reason:"The standard C header for string functions like `strdup` and `strcmp` is `<string.h>`."}], indent: 0, explanation: "For string manipulation like strdup." },
    { "correct": "#define MAX_USERS 50", distractors: [{"text":"const int MAX_USERS = 50;", reason:"Using `#define` allows `MAX_USERS` to be used to declare the size of an array member inside our struct, which is not possible with a `const int` variable."}], indent: 0, explanation: "Set a maximum number of users our social network can hold." },
    { "correct": "// Represents a node in the adjacency list, i.e., a friend of a user.", distractors: [{"text":"// Represents a user.", reason:"This comment is inaccurate. This struct represents an entry in a user's *list of friends*, not the user itself."}], indent: 0, explanation: "Comment explaining the purpose of AdjListNode." },
    { "correct": "typedef struct AdjListNode {", distractors: [{"text":"struct AdjListNode {", reason:"Without `typedef`, we would have to write `struct AdjListNode* next;`, which is more verbose."}], indent: 0, explanation: "Start of the adjacency list node struct." },
    { "correct": "  int user_id;", distractors: [{"text":"  UserNode* user;", reason:"Storing a direct pointer to the `UserNode` would also work, but using an integer ID is often simpler, more memory-efficient, and avoids complex pointer management."}], indent: 1, explanation: "The ID of the user this node points to. This ID is the index in the main user array." },
    { "correct": "  struct AdjListNode* next;", distractors: [{"text":"  AdjListNode next;", reason:"A struct cannot contain a full instance of itself, as this would require infinite memory. It must be a pointer to its own type to form a linked list."}], indent: 1, explanation: "Pointer to the next friend in the list." },
    { "correct": "} AdjListNode;", distractors: [{"text":"};", reason:"When using `typedef` with a struct definition, the new type alias (`AdjListNode`) must be provided before the final semicolon."}], indent: 0, explanation: "End of AdjListNode typedef." },
    { "correct": "// Represents a user in the social network.", distractors: [{"text":"// Represents a friend.", reason:"This is the main struct for a user, containing their name and their entire list of friends."}], indent: 0, explanation: "Comment explaining the UserNode struct." },
    { "correct": "typedef struct {", distractors: [{"text":"typedef struct UserNode {", reason:"This syntax is for creating a named struct with a typedef. For an anonymous struct, the name is omitted."}], indent: 0, explanation: "Start of the UserNode struct." },
    { "correct": "  char* name;", distractors: [{"text":"  char name[50];", reason:"A fixed-size array is simpler but less flexible. Using `char*` with dynamic allocation allows for names of any length."}], indent: 1, explanation: "The name of the user." },
    { "correct": "  AdjListNode* friends_head;", distractors: [{"text":"  AdjListNode friends[100];", reason:"This would limit every user to a fixed number of friends. A linked list (`friends_head`) is a dynamic structure that can grow to any size."}], indent: 1, explanation: "The head of the linked list of this user's friends." },
    { "correct": "} UserNode;", distractors: [{"text":"} UserNode", reason:"A `typedef` statement must always end with a semicolon."}], indent: 0, explanation: "End of UserNode typedef." },
    { "correct": "// Represents the entire social network graph.", distractors: [{"text":"// Represents a list of users.", reason:"'Graph' is the more accurate computer science term for this structure, which represents not just the users (vertices) but also their relationships (edges)."}], indent: 0, explanation: "Comment for the main Graph struct." },
    { "correct": "typedef struct {", distractors: [{"text":"struct Graph {", reason:"Using `typedef` is a convenience that allows us to declare graphs as `Graph g;` instead of `struct Graph g;`."}], indent: 0, explanation: "Start of the Graph struct." },
    { "correct": "  UserNode users[MAX_USERS];", distractors: [{"text":"  UserNode* users;", reason:"For a graph with a known maximum number of vertices, a static array is often simpler and more efficient than a dynamic one, as it avoids `realloc` calls."}], indent: 1, explanation: "An array to store all user data. The index is the user's ID." },
    { "correct": "  int user_count;", distractors: [{"text":"  size_t user_count;", reason:"`size_t` is also a perfectly valid and often preferred type for counts, as it's guaranteed to be unsigned and large enough."}], indent: 1, explanation: "The current number of users registered in the network." },
    { "correct": "} Graph;", distractors: [{"text":"} Graph", reason:"A `typedef` statement requires a semicolon at the end."}], indent: 0, explanation: "End of Graph typedef." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text":"// --- Function Implementations ---", reason:"These are just the forward declarations (prototypes). The function bodies (implementations) come later."}], indent: 0, explanation: "Forward declarations for our graph functions." },
    { "correct": "Graph* create_graph();", distractors: [{"text":"void create_graph(Graph* graph);", reason:"A 'constructor' function typically handles the allocation itself and returns a pointer to the new object."}], indent: 0, explanation: "Creates and initializes an empty graph." },
    { "correct": "void destroy_graph(Graph* graph);", distractors: [{"text":"int destroy_graph(Graph* graph);", reason:"A 'destroy' function's job is to clean up memory; it doesn't need to return a value, so `void` is appropriate."}], indent: 0, explanation: "Frees all memory used by the graph." },
    { "correct": "int add_user(Graph* graph, const char* name);", distractors: [{"text":"void add_user(Graph* graph, const char* name);", reason:"Returning an `int` (the new user's ID) is good API design, as it provides useful information back to the caller."}], indent: 0, explanation: "Adds a new user to the network and returns their ID." },
    { "correct": "void add_friendship(Graph* graph, int user_id1, int user_id2);", distractors: [{"text":"void add_friendship(int user_id1, int user_id2);", reason:"The function needs to know *which* graph to modify, so it must take the `Graph*` pointer as an argument."}], indent: 0, explanation: "Creates a bidirectional friendship between two users." },
    { "correct": "void find_mutual_friends(Graph* graph, int user_id1, int user_id2);", distractors: [{"text":"AdjListNode* find_mutual_friends(...);", reason:"Returning a linked list of mutual friends would be a valid, but more complex, API design. Simply printing them is simpler for this example."}], indent: 0, explanation: "Finds and prints all mutual friends between two users." },
    { "correct": "void print_graph(const Graph* graph);", distractors: [{"text":"void print_graph(Graph* graph);", reason:"A print function should not modify the data it's printing. Using `const` makes this guarantee clear."}], indent: 0, explanation: "Prints the entire social network structure." },
    { "correct": "// === Stage 2: Graph Initialization and Destruction ===", distractors: [{"text":"// === Stage 2: The Main Program ===", reason:"First, we must implement the core creation and destruction functions before we can use them in a main program."}], indent: 0, explanation: "Implement functions to manage the graph's lifecycle." },
    { "correct": "Graph* create_graph() {", distractors: [{"text":"Graph create_graph() {", reason:"The definition must match the prototype. This function must return a pointer (`Graph*`) to a dynamically allocated object."}], indent: 0, explanation: "Begin `create_graph` implementation." },
    { "correct": "  printf(\"Creating a new social network graph...\\n\");", distractors: [{"text":"  puts(\"Creating a new social network graph...\");", reason:"`puts` is a valid and simpler alternative for printing a fixed string followed by a newline."}], indent: 1, explanation: "Log the creation event." },
    { "correct": "  Graph* graph = (Graph*)malloc(sizeof(Graph));", distractors: [{"text":"  Graph* graph = (Graph*)malloc(sizeof(graph));", reason:"This is a bug. `sizeof(graph)` would give the size of a pointer, not the much larger size of the `Graph` struct."}], indent: 1, explanation: "Allocate memory for the main graph structure." },
    { "correct": "  if (!graph) { perror(\"Failed to create graph\"); exit(EXIT_FAILURE); }", distractors: [{"text":"  if (graph == NULL) { return NULL; }", reason:"Failing to create the graph is a critical error. Exiting the program is an appropriate response in this case."}], indent: 1, explanation: "Handle memory allocation failure." },
    { "correct": "  graph->user_count = 0;", distractors: [{"text":"  graph.user_count = 0;", reason:"`graph` is a pointer. You must use the arrow operator `->` to access the members of a struct through a pointer."}], indent: 1, explanation: "Initialize the user count to zero." },
    { "correct": "  for (int i = 0; i < MAX_USERS; i++) {", distractors: [{"text":"  for (int i = 0; i < graph->user_count; i++) {", reason:"This is a bug. At this point, `user_count` is 0, so the loop would not run and the user array would not be initialized."}], indent: 1, explanation: "Loop through the user array for initialization." },
    { "correct": "    graph->users[i].name = NULL;", distractors: [{"text":"    // No need to initialize name", reason:"This is a bug. It's crucial to initialize pointers to NULL so you can later check if a user slot is 'empty' or has been filled."}], indent: 2, explanation: "Initialize user name to NULL." },
    { "correct": "    graph->users[i].friends_head = NULL;", distractors: [{"text":"    // No need to initialize friends_head", reason:"This is a critical bug. The head of each friends list must be initialized to NULL to indicate that a new user has no friends yet."}], indent: 2, explanation: "Initialize the friends list head to NULL." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End initialization loop." },
    { "correct": "  return graph;", distractors: [{"text":"  return *graph;", reason:"This is a type mismatch. The function must return a pointer (`Graph*`), not the struct itself by value."}], indent: 1, explanation: "Return the newly created graph." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of `create_graph`." },
    { "correct": "void destroy_graph(Graph* graph) {", distractors: [{"text":"void destroy_graph(const Graph* graph) {", reason:"A destroy function frees memory, which is a 'modifying' action, so the pointer should not be `const`."}], indent: 0, explanation: "Begin `destroy_graph` implementation." },
    { "correct": "  if (!graph) return;", distractors: [{"text":"  if (graph == NULL) return;", reason:"This is an equally valid and often clearer way to check if the pointer is NULL. Making destroy functions safe to call on NULL is good practice."}], indent: 1, explanation: "Guard against NULL graph pointer." },
    { "correct": "  printf(\"\\nDestroying the graph and freeing all memory...\\n\");", distractors: [{"text":"  free(graph);", reason:"This is a massive memory leak. You must iterate through all users and free their names and friend lists *before* freeing the main graph structure."}], indent: 1, explanation: "Log the destruction event." },
    { "correct": "  for (int i = 0; i < graph->user_count; i++) {", distractors: [{"text":"  for (int i = 0; i < MAX_USERS; i++) {", reason:"This would be incorrect if not all user slots are filled. It could try to free a `NULL` name pointer (which is safe but inefficient) or access uninitialized data."}], indent: 1, explanation: "Iterate through each user to free their data." },
    { "correct": "    free(graph->users[i].name);", distractors: [{"text":"    // No need to free name", reason:"This is a memory leak. The user's name was allocated with `strdup` (which uses `malloc`) and must be freed."}], indent: 2, explanation: "Free the memory allocated for the user's name." },
    { "correct": "    AdjListNode* current_friend = graph->users[i].friends_head;", distractors: [{"text":"    free(graph->users[i].friends_head);", reason:"This would only free the *first* node in the friends list, leaking all the rest."}], indent: 2, explanation: "Get the head of the friends list for the current user." },
    { "correct": "    while (current_friend) {", distractors: [{"text":"    if (current_friend) {", reason:"An `if` would only free the first friend. A `while` loop is necessary to traverse the entire linked list."}], indent: 2, explanation: "Loop through the friends list." },
    { "correct": "      AdjListNode* next_friend = current_friend->next;", distractors: [{"text":"      free(current_friend);", reason:"This is a classic use-after-free bug. If you free `current_friend` first, you can no longer safely access `current_friend->next` to move to the next node."}], indent: 3, explanation: "Store the pointer to the next friend node." },
    { "correct": "      free(current_friend);", distractors: [{"text":"      current_friend = next_friend;", reason:"This would leak the memory for the `AdjListNode` itself before moving to the next one."}], indent: 3, explanation: "Free the current friend node." },
    { "correct": "      current_friend = next_friend;", distractors: [{"text":"      // No update needed", reason:"This is a bug. Forgetting to advance the pointer would cause an infinite loop."}], indent: 3, explanation: "Move to the next friend in the list." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after a `while` loop."}], indent: 2, explanation: "End of friends list traversal." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End of user iteration." },
    { "correct": "  free(graph);", distractors: [{"text":"  // No need to free graph", reason:"This is a memory leak. The main graph struct was allocated with `malloc` and must be freed."}], indent: 1, explanation: "Free the main graph structure itself." },
    { "correct": "  printf(\"Graph destroyed.\\n\");", distractors: [{"text":"  puts(\"Graph destroyed.\");", reason:"`puts` is a valid and simpler alternative for printing this message."}], indent: 1, explanation: "Confirm destruction." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "End of `destroy_graph`." },
    { "correct": "// === Stage 3: Core Operations - Adding Users and Friendships ===", distractors: [{"text":"// === Stage 3: The Main Program ===", reason:"This stage implements the core graph manipulation functions, not the main program that demonstrates them."}], indent: 0, explanation: "Implement the functions to populate the social network." },
    { "correct": "int add_user(Graph* graph, const char* name) {", distractors: [{"text":"void add_user(Graph* graph, const char* name) {", reason:"The definition must match the prototype. Returning the new user's ID (`int`) is part of the function's API."}], indent: 0, explanation: "Begin `add_user` implementation." },
    { "correct": "  if (graph->user_count >= MAX_USERS) {", distractors: [{"text":"  if (graph->user_count > MAX_USERS) {", reason:"This is an off-by-one error. Because indices are 0 to `MAX_USERS - 1`, the check must be `>=` to prevent writing out of bounds."}], indent: 1, explanation: "Check if the user limit has been reached." },
    { "correct": "    fprintf(stderr, \"Error: Cannot add more users. Network is full.\\n\");", distractors: [{"text":"    printf(\"Error: Network is full.\\n\");", reason:"Printing to `stderr` is conventional for error messages. The original is also more descriptive."}], indent: 2, explanation: "Print an error message if the network is full." },
    { "correct": "    return -1; // Indicate failure", distractors: [{"text":"    return 0;", reason:"Since 0 is a valid user ID, we must return a value outside the valid range, like -1, to unambiguously signal an error."}], indent: 2, explanation: "Return -1 to signal an error." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 1, explanation: "End of capacity check." },
    { "correct": "  int new_user_id = graph->user_count;", distractors: [{"text":"  int new_user_id = graph->user_count + 1;", reason:"Array indices are 0-based. The next available index is simply the current `user_count`."}], indent: 1, explanation: "The new user's ID will be the current user count." },
    { "correct": "  graph->users[new_user_id].name = strdup(name);", distractors: [{"text":"  graph->users[new_user_id].name = name;", reason:"This is a bug. It only copies the pointer, not the string content. The original `name` pointer might be temporary. `strdup` safely allocates new memory and copies the string."}], indent: 1, explanation: "Allocate memory for and copy the user's name." },
    { "correct": "  graph->users[new_user_id].friends_head = NULL;", distractors: [{"text":"  // No initialization needed", reason:"This is a critical bug. The `friends_head` pointer for a new user must be set to `NULL` to signify an empty list."}], indent: 1, explanation: "The new user starts with no friends." },
    { "correct": "  graph->user_count++;", distractors: [{"text":"  // No need to increment count", reason:"This is a bug. The `user_count` must be incremented to reflect the new user and ensure the next user gets a new ID."}], indent: 1, explanation: "Increment the total number of users in the graph." },
    { "correct": "  printf(\"Added user '%s' with ID %d.\\n\", name, new_user_id);", distractors: [{"text":"  puts(\"Added user.\");", reason:"This is less informative. Logging the name and assigned ID is much better for debugging."}], indent: 1, explanation: "Log the addition of the new user." },
    { "correct": "  return new_user_id;", distractors: [{"text":"  return graph->user_count;", reason:"This would return the new count (e.g., 1), not the ID that was assigned (e.g., 0)."}], indent: 1, explanation: "Return the ID assigned to the new user." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of `add_user`." },
    { "correct": "void add_friendship(Graph* graph, int user_id1, int user_id2) {", distractors: [{"text":"void add_friendship(Graph graph, ...)", reason:"The function must take a pointer to the graph to modify it. Passing by value would mean all changes are lost."}], indent: 0, explanation: "Begin `add_friendship` implementation." },
    { "correct": "  if (user_id1 >= graph->user_count || user_id2 >= graph->user_count || user_id1 < 0 || user_id2 < 0) {", distractors: [{"text":"  if (user_id1 >= MAX_USERS || user_id2 >= MAX_USERS) {", reason:"This is less precise. We should check against the current `user_count`, not the maximum possible number of users."}], indent: 1, explanation: "Check if the provided user IDs are valid." },
    { "correct": "    fprintf(stderr, \"Error: Invalid user ID for friendship.\\n\");", distractors: [{"text":"    printf(\"Invalid user ID.\\n\");", reason:"Printing to `stderr` is the convention for error messages."}], indent: 2, explanation: "Print an error for invalid IDs." },
    { "correct": "    return;", distractors: [{"text":"    exit(1);", reason:"An invalid ID is a recoverable error. It's better to print an error and `return` rather than terminating the entire program."}], indent: 2, explanation: "Exit the function." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 1, explanation: "End of ID validation." },
    { "correct": "  printf(\"Creating friendship between '%s' and '%s'.\\n\", graph->users[user_id1].name, graph->users[user_id2].name);", distractors: [{"text":"  printf(\"Creating friendship between %d and %d\\n\", user_id1, user_id2);", reason:"This is okay, but printing the names makes the log more human-readable."}], indent: 1, explanation: "Log the friendship creation." },
    { "correct": "  // Add edge from user1 to user2", distractors: [{"text":"  // Add user1 to user2's friends", reason:"This comment describes the action of this block correctly."}], indent: 1, explanation: "Comment on the first direction of the edge." },
    { "correct": "  AdjListNode* node1 = (AdjListNode*)malloc(sizeof(AdjListNode));", distractors: [{"text":"  AdjListNode node1;", reason:"This creates a local stack variable that will be destroyed when the function returns. The node must be dynamically allocated with `malloc`."}], indent: 1, explanation: "Allocate a new node for user1's friend list." },
    { "correct": "  node1->user_id = user_id2;", distractors: [{"text":"  node1->user_id = user_id1;", reason:"This is a bug. This would create a friendship from a user to themselves."}], indent: 1, explanation: "Set the destination ID." },
    { "correct": "  node1->next = graph->users[user_id1].friends_head;", distractors: [{"text":"  graph->users[user_id1].friends_head = node1;", reason:"This assignment must happen *after* setting `node1->next`. Doing it first would lose the rest of the friends list."}], indent: 1, explanation: "Link the new node to the front of the list." },
    { "correct": "  graph->users[user_id1].friends_head = node1;", distractors: [{"text":"  node1->next = NULL;", reason:"This is a bug. It would make the new friend the *only* friend, overwriting the existing list."}], indent: 1, explanation: "Update the head of user1's friend list." },
    { "correct": "  // Add edge from user2 to user1 (since friendship is mutual)", distractors: [{"text":"  // No second edge needed", reason:"This is incorrect. A social network is an undirected graph. If A is friends with B, B must be friends with A. We need to add an edge in both directions."}], indent: 1, explanation: "Comment on the second, bidirectional edge." },
    { "correct": "  AdjListNode* node2 = (AdjListNode*)malloc(sizeof(AdjListNode));", distractors: [{"text":"  AdjListNode* node2 = node1;", reason:"This is a bug. You cannot reuse the same node. A separate node must be allocated for the second user's list."}], indent: 1, explanation: "Allocate a new node for user2's friend list." },
    { "correct": "  node2->user_id = user_id1;", distractors: [{"text":"  node2->user_id = user_id2;", reason:"This would add user2 to their own friend list, which is incorrect."}], indent: 1, explanation: "Set the destination ID." },
    { "correct": "  node2->next = graph->users[user_id2].friends_head;", distractors: [{"text":"  node2->next = NULL;", reason:"This would erase all of user2's existing friends."}], indent: 1, explanation: "Link the new node to the front of the list." },
    { "correct": "  graph->users[user_id2].friends_head = node2;", distractors: [{"text":"  // No update needed", reason:"This is a bug. The head of user2's friend list must be updated to point to the newly created node."}], indent: 1, explanation: "Update the head of user2's friend list." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "End of `add_friendship`." },
    { "correct": "// === Stage 4: Social Network Algorithm - Finding Mutuals ===", distractors: [{"text":"// === Stage 4: Adding Friends ===", reason:"This stage implements the more complex algorithm of finding mutual connections, not just adding them."}], indent: 0, explanation: "Implement the logic to find common connections between two users." },
    { "correct": "void find_mutual_friends(Graph* graph, int user_id1, int user_id2) {", distractors: [{"text":"int find_mutual_friends(Graph* graph, int user_id1, int user_id2) {", reason:"The definition must match the prototype. This function prints results directly, so a `void` return type is appropriate."}], indent: 0, explanation: "Begin `find_mutual_friends` implementation." },
    { "correct": "  if (user_id1 >= graph->user_count || user_id2 >= graph->user_count || user_id1 < 0 || user_id2 < 0) {", distractors: [{"text":"  if (user_id1 == user_id2) { return; }", reason:"While you can't be a mutual friend with yourself, the main priority is to validate that the IDs are within the bounds of the `users` array."}], indent: 1, explanation: "Perform validity check on user IDs." },
    { "correct": "    fprintf(stderr, \"Error: Invalid user ID for finding mutuals.\\n\");", distractors: [{"text":"    printf(\"Error: Invalid user ID.\\n\");", reason:"Printing to `stderr` is the convention for error messages."}], indent: 2, explanation: "Report an error if IDs are out of bounds." },
    { "correct": "    return;", distractors: [{"text":"    exit(1);", reason:"This is a user error, not a critical system failure. It's better to print a message and return than to terminate the whole program."}], indent: 2, explanation: "Exit the function." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 1, explanation: "End of validity check." },
    { "correct": "  printf(\"\\nFinding mutual friends between '%s' and '%s':\\n\", graph->users[user_id1].name, graph->users[user_id2].name);", distractors: [{"text":"  printf(\"Finding mutual friends...\\n\");", reason:"This is less informative. Printing the names of the users involved makes the output clearer."}], indent: 1, explanation: "Print a header for the output." },
    { "correct": "  // To do this efficiently, we can load one user's friends into a temporary lookup array.", distractors: [{"text":"  // We must use a nested loop to compare every friend of user1 with every friend of user2.", reason:"While a nested loop works, it's inefficient (O(N*M)). Using a lookup table or hash set is a more performant approach (O(N+M))."}], indent: 1, explanation: "Comment on the chosen algorithm." },
    { "correct": "  int friends1_lookup[MAX_USERS] = {0}; // Initialize a boolean-like lookup table.", distractors: [{"text":"  int friends1_lookup[MAX_USERS];", reason:"This is a critical bug. An uninitialized array contains garbage values. It must be initialized to all zeros to work correctly as a lookup table."}], indent: 1, explanation: "Create a lookup table, initialized to all zeros (false)." },
    { "correct": "  AdjListNode* friend1_iter = graph->users[user_id1].friends_head;", distractors: [{"text":"  AdjListNode* friend1_iter = NULL;", reason:"The iterator must be initialized to the head of the friends list to begin traversal."}], indent: 1, explanation: "Get the head of the first user's friend list." },
    { "correct": "  while (friend1_iter) {", distractors: [{"text":"  for (int i=0; i < graph->user_count; i++) {", reason:"This would iterate over all users, not just the friends of `user_id1`."}], indent: 1, explanation: "Iterate through the friends of the first user." },
    { "correct": "    friends1_lookup[friend1_iter->user_id] = 1; // Mark this ID as a friend of user 1.", distractors: [{"text":"    friends1_lookup[friend1_iter->user_id]++;", reason:"We only need a boolean flag (0 or 1), so setting to 1 is sufficient. Incrementing is unnecessary."}], indent: 2, explanation: "Set the value at the friend's ID index to 1 (true)." },
    { "correct": "    friend1_iter = friend1_iter->next;", distractors: [{"text":"    // No update needed", reason:"This is a bug. Forgetting to advance the iterator would cause an infinite loop."}], indent: 2, explanation: "Move to the next friend." },
    { "correct": "  }", distractors: [{"text":"end while;", reason:"This is not valid C syntax."}], indent: 1, explanation: "End of populating the lookup table." },
    { "correct": "  // Now, iterate through the second user's friends and check against the lookup table.", distractors: [{"text":"  // Now, do the same thing for the second user.", reason:"This is incorrect. We don't need to build a second lookup table; we iterate through the second user's friends and check them against the first table."}], indent: 1, explanation: "Comment on the second phase of the algorithm." },
    { "correct": "  int mutual_count = 0;", distractors: [{"text":"  int mutual_count;", reason:"All counters must be initialized to 0. An uninitialized variable will contain a garbage value."}], indent: 1, explanation: "Initialize a counter for mutual friends." },
    { "correct": "  AdjListNode* friend2_iter = graph->users[user_id2].friends_head;", distractors: [{"text":"  AdjListNode* friend2_iter = friend1_iter;", reason:"This is a bug. `friend1_iter` is now `NULL`. We must get the head of the second user's friend list."}], indent: 1, explanation: "Get the head of the second user's friend list." },
    { "correct": "  while (friend2_iter) {", distractors: [{"text":"  if (friend2_iter) {", reason:"An `if` would only check the first friend. A `while` loop is needed to iterate through the entire list."}], indent: 1, explanation: "Iterate through the friends of the second user." },
    { "correct": "    if (friends1_lookup[friend2_iter->user_id] == 1) {", distractors: [{"text":"    if (friends1_lookup[friend2_iter->user_id]) {", reason:"This is a valid and common shorthand for checking if the value is non-zero (true)."}], indent: 2, explanation: "Check if this friend is also in user1's friend lookup table." },
    { "correct": "      printf(\"  - %s\\n\", graph->users[friend2_iter->user_id].name);", distractors: [{"text":"      printf(\"  - %d\\n\", friend2_iter->user_id);", reason:"Printing the user's ID works, but printing their name is more human-readable and useful."}], indent: 3, explanation: "If it is, print the name of the mutual friend." },
    { "correct": "      mutual_count++;", distractors: [{"text":"      mutual_count = 1;", reason:"This is a bug. The counter must be incremented (`++`) to count all mutuals, not just reset to 1."}], indent: 3, explanation: "Increment the mutual friend counter." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 2, explanation: "End of lookup check." },
    { "correct": "    friend2_iter = friend2_iter->next;", distractors: [{"text":"    friend2_iter++;", reason:"This is a bug. This performs pointer arithmetic, not linked-list traversal. You must follow the `next` pointer."}], indent: 2, explanation: "Move to the next friend of user 2." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End of the second iteration." },
    { "correct": "  if (mutual_count == 0) {", distractors: [{"text":"  if (!mutual_count) {", reason:"This is a valid and common shorthand for checking if `mutual_count` is zero."}], indent: 1, explanation: "Check if no mutual friends were found." },
    { "correct": "    printf(\"  No mutual friends found.\\n\");", distractors: [{"text":"    puts(\"  No mutual friends found.\");", reason:"`puts` is a valid and simpler way to print this message."}], indent: 2, explanation: "Print a message indicating no mutuals." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 1, explanation: "End of zero-count check." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End of `find_mutual_friends`." },
    { "correct": "// === Stage 5: Utility and Display Functions ===", distractors: [{"text":"// === Stage 5: The Core Algorithm ===", reason:"This stage contains helper/utility functions, not the core mutual friend algorithm."}], indent: 0, explanation: "Implement a helper function to visualize the graph's structure." },
    { "correct": "void print_graph(const Graph* graph) {", distractors: [{"text":"void print_graph(Graph* graph) {", reason:"The function definition must match the prototype. Using `const` is correct as this function only reads data."}], indent: 0, explanation: "Begin `print_graph` implementation." },
    { "correct": "  printf(\"\\n--- Social Network Overview ---\\n\");", distractors: [{"text":"  puts(\"\\n--- Social Network Overview ---\");", reason:"`puts` adds its own newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Print a title for the output." },
    { "correct": "  for (int i = 0; i < graph->user_count; i++) {", distractors: [{"text":"  for (int i = 0; i < MAX_USERS; i++) {", reason:"This would incorrectly try to print all possible user slots, even uninitialized ones, which could lead to a crash."}], indent: 1, explanation: "Iterate through each user in the network." },
    { "correct": "    printf(\"User %d: %s -> Friends: \", i, graph->users[i].name);", distractors: [{"text":"    printf(\"User %d: -> Friends: \", i);", reason:"This is less informative. The output should include the user's name."}], indent: 2, explanation: "Print the current user's name and ID." },
    { "correct": "    AdjListNode* friend_iter = graph->users[i].friends_head;", distractors: [{"text":"    AdjListNode* friend_iter = NULL;", reason:"This is a bug. The iterator must be initialized to the head of the current user's friends list."}], indent: 2, explanation: "Get the head of the current user's friend list." },
    { "correct": "    if (!friend_iter) {", distractors: [{"text":"    if (friend_iter == NULL) {", reason:"This is an equally valid and often clearer way to check if the friends list is empty."}], indent: 2, explanation: "Check if the user has any friends." },
    { "correct": "      printf(\"None\");", distractors: [{"text":"      // Do nothing", reason:"Printing 'None' provides clear output that the user has no friends, which is better than printing nothing."}], indent: 3, explanation: "Print 'None' if the friend list is empty." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 2, explanation: "End of no-friend check." },
    { "correct": "    while (friend_iter) {", distractors: [{"text":"    if (friend_iter) {", reason:"An `if` would only print the first friend. A `while` loop is required to traverse the entire list."}], indent: 2, explanation: "Loop through the friend list." },
    { "correct": "      printf(\"%s\", graph->users[friend_iter->user_id].name);", distractors: [{"text":"      printf(\"%d\", friend_iter->user_id);", reason:"Printing the user ID works, but printing the name is more human-readable."}], indent: 3, explanation: "Print the name of the friend." },
    { "correct": "      if (friend_iter->next) { printf(\", \"); }", distractors: [{"text":"      printf(\", \");", reason:"This would result in a dangling comma after the last friend in the list. The `if` check prevents this."}], indent: 3, explanation: "Print a comma if it's not the last friend." },
    { "correct": "      friend_iter = friend_iter->next;", distractors: [{"text":"      // No update", reason:"This would be a bug causing an infinite loop."}], indent: 3, explanation: "Move to the next friend." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used after a `while` loop."}], indent: 2, explanation: "End of friend list loop." },
    { "correct": "    printf(\"\\n\");", distractors: [{"text":"    puts(\"\");", reason:"Calling `puts` with an empty string is another valid way to print a newline."}], indent: 2, explanation: "Print a newline for the next user." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End of user loop." },
    { "correct": "  printf(\"--- End of Overview ---\\n\");", distractors: [{"text":"  puts(\"--- End of Overview ---\");", reason:"`puts` is a valid and simpler alternative here."}], indent: 1, explanation: "Print a footer." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to end a function block."}], indent: 0, explanation: "End of `print_graph`." },
    { "correct": "// === Stage 6: Main Program for Demonstration ===", distractors: [{"text":"// === Stage 6: The Graph Library ===", reason:"This is the main program that *uses* our graph library, not the library implementation itself."}], indent: 0, explanation: "The main function to create and test our social network graph." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid and often preferred way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start of the main function." },
    { "correct": "  printf(\"--- Social Network Graph Demo ---\\n\");", distractors: [{"text":"  puts(\"--- Social Network Graph Demo ---\");", reason:"`puts` is a valid alternative that also prints a newline."}], indent: 1, explanation: "Print a demo title." },
    { "correct": "  Graph* social_network = create_graph();", distractors: [{"text":"  Graph social_network;", reason:"Our API is designed to work with a pointer to a dynamically allocated graph. This stack variable would not be handled correctly."}], indent: 1, explanation: "Create the graph instance." },
    { "correct": "  // Add users to the network", distractors: [{"text":"  // Add friendships", reason:"We must add users to the graph first before we can create friendships between them."}], indent: 1, explanation: "Comment on the user creation phase." },
    { "correct": "  int alice_id = add_user(social_network, \"Alice\");", distractors: [{"text":"  add_user(social_network, \"Alice\");", reason:"The `add_user` function returns the new user's ID. We need to store it in a variable to use it later when creating friendships."}], indent: 1, explanation: "Add user Alice." },
    { "correct": "  int bob_id = add_user(social_network, \"Bob\");", distractors: [{"text":"  int bob_id = 1;", reason:"It's better to use the actual ID returned by the `add_user` function rather than assuming it will be 1."}], indent: 1, explanation: "Add user Bob." },
    { "correct": "  int charlie_id = add_user(social_network, \"Charlie\");", distractors: [{"text":"  int charlie_id = add_user(&social_network, \"Charlie\");", reason:"`social_network` is already a pointer. Passing its address would be a `Graph**`, which is the wrong type."}], indent: 1, explanation: "Add user Charlie." },
    { "correct": "  int diana_id = add_user(social_network, \"Diana\");", distractors: [{"text":"  int diana_id = add_user(social_network, 'Diana');", reason:"'Diana' with single quotes is a multi-character literal, which is a non-standard integer constant. A string literal with double quotes is required."}], indent: 1, explanation: "Add user Diana." },
    { "correct": "  int eve_id = add_user(social_network, \"Eve\");", distractors: [{"text":"  int eve_id = 3;", reason:"Relying on hardcoded IDs is fragile. It's much safer to use the return value from the `add_user` call."}], indent: 1, explanation: "Add user Eve." },
    { "correct": "  // Create friendships", distractors: [{"text":"  // Print graph", reason:"It's more illustrative to create the friendships first and then print the fully constructed graph."}], indent: 1, explanation: "Comment on the friendship creation phase." },
    { "correct": "  add_friendship(social_network, alice_id, bob_id);", distractors: [{"text":"  add_friendship(social_network, 0, 1);", reason:"While this works, using the named ID variables (`alice_id`, `bob_id`) makes the code much more readable and less prone to 'magic number' errors."}], indent: 1, explanation: "Alice and Bob are friends." },
    { "correct": "  add_friendship(social_network, alice_id, charlie_id);", distractors: [{"text":"  add_friendship(social_network, alice_id, alice_id);", reason:"This would incorrectly make Alice friends with herself."}], indent: 1, explanation: "Alice and Charlie are friends." },
    { "correct": "  add_friendship(social_network, bob_id, charlie_id);", distractors: [{"text":"  add_friendship(social_network, charlie_id, bob_id);", reason:"Our `add_friendship` function is bidirectional, so this call would be redundant and create duplicate entries in the friends lists."}], indent: 1, explanation: "Bob and Charlie are friends." },
    { "correct": "  add_friendship(social_network, bob_id, diana_id);", distractors: [{"text":"  add_friendship(social_network, bob_id, 4);", reason:"`diana_id` might not be 4. Using the variable is safer."}], indent: 1, explanation: "Bob and Diana are friends." },
    { "correct": "  add_friendship(social_network, charlie_id, diana_id);", distractors: [{"text":"  add_friendship(social_network, 2, 3);", reason:"Using the named ID variables is more readable and maintainable."}], indent: 1, explanation: "Charlie and Diana are friends." },
    { "correct": "  add_friendship(social_network, diana_id, eve_id);", distractors: [{"text":"  add_friendship(social_network, 3, 4);", reason:"It's always better to use the named variables for IDs."}], indent: 1, explanation: "Diana and Eve are friends." },
    { "correct": "  // Display the final state of the network", distractors: [{"text":"  // Test mutual friends", reason:"It's a good idea to display the whole graph structure first so you can visually verify the results of the mutual friends test."}], indent: 1, explanation: "Comment on printing the graph." },
    { "correct": "  print_graph(social_network);", distractors: [{"text":"  print_graph(&social_network);", reason:"`social_network` is already a pointer. Taking its address results in a `Graph**`, which is the wrong type."}], indent: 1, explanation: "Call the print function." },
    { "correct": "  // Test the mutual friends feature", distractors: [{"text":"  // Test adding friends", reason:"This section is specifically for testing the `find_mutual_friends` algorithm."}], indent: 1, explanation: "Comment on testing the core algorithm." },
    { "correct": "  find_mutual_friends(social_network, alice_id, diana_id);", distractors: [{"text":"  find_mutual_friends(social_network, 0, 3);", reason:"Using the named ID variables is much clearer."}], indent: 1, explanation: "Find mutuals between Alice and Diana (should be Bob and Charlie)." },
    { "correct": "  find_mutual_friends(social_network, alice_id, eve_id);", distractors: [{"text":"  find_mutual_friends(social_network, alice_id, 4);", reason:"Using the `eve_id` variable is more robust than assuming the ID is 4."}], indent: 1, explanation: "Find mutuals between Alice and Eve (should be none)." },
    { "correct": "  // Clean up all allocated memory", distractors: [{"text":"  // End program", reason:"'Clean up' is a more descriptive comment for the memory deallocation phase."}], indent: 1, explanation: "Comment on the cleanup phase." },
    { "correct": "  destroy_graph(social_network);", distractors: [{"text":"  free(social_network);", reason:"This is a massive memory leak. `free` would only release the `Graph` struct, not all the user names and friend list nodes inside. The custom `destroy_graph` function is mandatory."}], indent: 1, explanation: "Call the destructor function." },
    { "correct": "  printf(\"\\n--- Demo Finished ---\\n\");", distractors: [{"text":"  puts(\"--- Demo Finished ---\");", reason:"`puts` is a valid alternative here."}], indent: 1, explanation: "Final message." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 signals an error. Since the demo completed successfully, it should return 0."}], indent: 1, explanation: "Indicate successful execution." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of main." }
]
},
// Level 96: Prep for Netflix
{
    "goal": "Implement a parser for a custom binary data protocol to deserialize and validate packets from a raw byte buffer, simulating the processing of streaming data.",
    "concepts": "Bit manipulation, data serialization, structs, pointers, buffer management, checksums, network programming concepts",
    "sequence": [
    { "correct": "// === Stage 1: Protocol Definition and Data Structures ===", distractors: [{"text":"// === Stage 1: The Main Program ===", reason:"In protocol design, it's essential to define the exact layout of the data structures first. All other code is then written to adhere to that definition."}], indent: 0, explanation: "Define the structure of our binary packet and any necessary constants." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"The standard I/O function `printf` is declared in `<stdio.h>`."}], indent: 0, explanation: "For standard I/O (printf)." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <string.h>", reason:"`malloc` and `free` for memory management are part of the standard library, `<stdlib.h>`."}], indent: 0, explanation: "For memory allocation." },
    { "correct": "#include <stdint.h>", distractors: [{"text":"// No include needed", reason:"Fixed-width types like `uint32_t` are not built-in. They are defined in `<stdint.h>` (from the C99 standard) and are critical for creating portable binary formats."}], indent: 0, explanation: "For fixed-width integers like uint32_t, uint16_t, etc." },
    { "correct": "#include <string.h>", distractors: [{"text":"#include <strings.h>", reason:"The standard C header for `memcpy` is `<string.h>`."}], indent: 0, explanation: "For memcpy and other memory operations." },
    { "correct": "// This pragma ensures the compiler doesn't add padding bytes to our struct.", distractors: [{"text":"// This pragma makes the struct faster.", reason:"While removing padding can sometimes affect performance, its primary purpose here is to ensure the C `struct` layout exactly matches the byte-for-byte layout of the protocol on the wire."}], indent: 0, explanation: "Crucial for mapping the struct directly onto a byte buffer." },
    { "correct": "#pragma pack(1)", distractors: [{"text":"// #pragma pack(1)", reason:"Without this pragma, the compiler is free to add padding bytes between struct members for alignment, which would break our ability to map the struct directly onto a raw byte buffer."}], indent: 0, explanation: "Set structure packing to 1 byte." },
    { "correct": "#define SYNC_WORD 0xDEADBEEF", distractors: [{"text":"#define SYNC_WORD \"DEADBEEF\"", reason:"A sync word is a numerical constant, not a string. It's used for a fast integer comparison to find the potential start of a packet."}], indent: 0, explanation: "A magic number to identify the start of a valid packet." },
    { "correct": "// Define the types of packets our protocol supports.", distractors: [{"text":"// Define packet states.", reason:"This enum doesn't represent the state of a single packet (like 'sent' or 'received'), but rather the *type* of data it contains."}], indent: 0, explanation: "Comment on the PacketType enum." },
    { "correct": "typedef enum { VIDEO_DATA = 1, AUDIO_DATA = 2, KEEPALIVE = 3, METADATA = 4 } PacketType;", distractors: [{"text":"enum { VIDEO_DATA, AUDIO_DATA, ... };", reason:"Using `typedef` creates a named type `PacketType`, which is clearer and provides better type safety than using an anonymous enum."}], indent: 0, explanation: "Enum for different packet content types." },
    { "correct": "// The header structure for every packet in our stream.", distractors: [{"text":"// The packet payload.", reason:"This comment is incorrect. This struct defines the metadata *header*, not the data payload that follows it."}], indent: 0, explanation: "Comment explaining the PacketHeader struct." },
    { "correct": "typedef struct {", distractors: [{"text":"struct PacketHeader {", reason:"Using `typedef` is a convenience that allows us to declare headers as `PacketHeader h;` instead of `struct PacketHeader h;`."}], indent: 0, explanation: "Start of PacketHeader struct definition." },
    { "correct": "  uint32_t sync_word;", distractors: [{"text":"  int sync_word;", reason:"The size of `int` can vary between systems. Using a fixed-width type like `uint32_t` guarantees the header size is always the same, making the protocol portable."}], indent: 1, explanation: "Should always be 0xDEADBEEF." },
    { "correct": "  uint16_t payload_len;", distractors: [{"text":"  size_t payload_len;", reason:"For a portable binary format, you must use fixed-width types. The size of `size_t` can vary (e.g., 32-bit vs 64-bit), which would make the file format incompatible between systems."}], indent: 1, explanation: "The length of the data payload that follows this header." },
    { "correct": "  uint8_t packet_type;", distractors: [{"text":"  PacketType packet_type;", reason:"While using the `PacketType` enum here is possible, `uint8_t` explicitly defines the size (1 byte) of this field in the binary protocol, which is crucial for serialization."}], indent: 1, explanation: "The type of the packet (VIDEO_DATA, AUDIO_DATA, etc.)." },
    { "correct": "  uint8_t checksum;", distractors: [{"text":"  int checksum;", reason:"Using `uint8_t` explicitly specifies that the checksum is a single byte, which is essential for defining a cross-platform binary protocol."}], indent: 1, explanation: "A simple checksum to verify payload integrity." },
    { "correct": "} PacketHeader;", distractors: [{"text":"};", reason:"To complete the `typedef`, you must provide the new type alias (`PacketHeader`) before the final semicolon."}], indent: 0, explanation: "End of PacketHeader typedef." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text":"// --- Function Implementations ---", reason:"These are forward declarations (prototypes). The function bodies (implementations) come later."}], indent: 0, explanation: "Declarations of our protocol handling functions." },
    { "correct": "uint8_t calculate_checksum(const uint8_t* payload, uint16_t len);", distractors: [{"text":"int calculate_checksum(const uint8_t* payload, uint16_t len);", reason:"Since the checksum algorithm produces a single byte result, the return type should be `uint8_t`."}], indent: 0, explanation: "Calculates a simple XOR checksum for a data payload." },
    { "correct": "void* create_packet(PacketType type, const uint8_t* payload, uint16_t len, uint32_t* out_total_size);", distractors: [{"text":"void* create_packet(..., uint32_t out_total_size);", reason:"To return the total size back to the caller, the function must accept a pointer to a variable (`uint32_t*`), not a value."}], indent: 0, explanation: "Serializes a packet (header + payload) into a single byte buffer." },
    { "correct": "void process_stream(const uint8_t* stream_buffer, uint32_t stream_size);", distractors: [{"text":"uint8_t* process_stream(...);", reason:"This function processes a buffer and prints output; it doesn't create and return a new buffer, so `void` is the appropriate return type."}], indent: 0, explanation: "The main function to parse a buffer containing multiple packets." },
    { "correct": "void handle_video_packet(const uint8_t* payload, uint16_t len);", distractors: [{"text":"void handle_video_packet(const PacketHeader* header);", reason:"A handler function typically only needs the payload data and its length, not the entire header."}], indent: 0, explanation: "Handler function for video data." },
    { "correct": "void handle_audio_packet(const uint8_t* payload, uint16_t len);", distractors: [{"text":"void handle_audio_packet();", reason:"The handler needs to know where the audio data is (`payload`) and how long it is (`len`), so it must accept those parameters."}], indent: 0, explanation: "Handler function for audio data." },
    { "correct": "void handle_keepalive_packet();", distractors: [{"text":"void handle_keepalive_packet(void);", reason:"Using `(void)` is an equally valid, and often clearer, way to declare that a function takes no arguments."}], indent: 0, explanation: "Handler for keepalive messages." },
    { "correct": "// === Stage 2: Checksum and Packet Serialization ===", distractors: [{"text":"// === Stage 2: Deserialization ===", reason:"This stage is about *building* (serializing) packets. Deserializing them from a stream comes next."}], indent: 0, explanation: "Implement functions to build our packets." },
    { "correct": "uint8_t calculate_checksum(const uint8_t* payload, uint16_t len) {", distractors: [{"text":"uint8_t calculate_checksum(uint8_t* payload, uint16_t len) {", reason:"The definition must match the prototype. The function only reads the payload, so it should be `const` correct."}], indent: 0, explanation: "Begin `calculate_checksum` implementation." },
    { "correct": "  uint8_t chk = 0;", distractors: [{"text":"  uint8_t chk;", reason:"An accumulator variable must be initialized. An uninitialized local variable contains a garbage value, which would make the checksum incorrect."}], indent: 1, explanation: "Initialize the checksum accumulator to 0." },
    { "correct": "  for (uint16_t i = 0; i < len; i++) {", distractors: [{"text":"  for (uint16_t i = 0; i <= len - 1; i++) {", reason:"This is a logically equivalent and correct way to write the loop's condition."}], indent: 1, explanation: "Loop through each byte of the payload." },
    { "correct": "    chk ^= payload[i];", distractors: [{"text":"    chk += payload[i];", reason:"Using addition (`+=`) is another way to create a checksum (a simple sum), but it's more prone to overflow. XOR (`^=`) is a very common choice for simple, fast checksums."}], indent: 2, explanation: "XOR the current byte with the accumulator." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End of payload loop." },
    { "correct": "  return chk;", distractors: [{"text":"  return ~chk;", reason:"Returning the bitwise NOT (`~`) of the checksum is another valid design choice (sometimes called a ones' complement checksum), but a simple XOR sum is sufficient here."}], indent: 1, explanation: "Return the final checksum value." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End of `calculate_checksum`." },
    { "correct": "void* create_packet(PacketType type, const uint8_t* payload, uint16_t len, uint32_t* out_total_size) {", distractors: [{"text":"uint8_t* create_packet(...)", reason:"Returning `void*` is more idiomatic for a function that returns a pointer to raw, untyped memory buffer."}], indent: 0, explanation: "Begin `create_packet` implementation." },
    { "correct": "  *out_total_size = sizeof(PacketHeader) + len;", distractors: [{"text":"  out_total_size = sizeof(PacketHeader) + len;", reason:"`out_total_size` is a pointer. You must dereference it with `*` to assign a value to the variable it points to."}], indent: 1, explanation: "Calculate the total size of the packet." },
    { "correct": "  uint8_t* packet_buffer = (uint8_t*)malloc(*out_total_size);", distractors: [{"text":"  void* packet_buffer = malloc(*out_total_size);", reason:"Allocating to a `void*` is fine, but casting to `uint8_t*` is useful because it allows for byte-level pointer arithmetic."}], indent: 1, explanation: "Allocate a buffer of the required size." },
    { "correct": "  if (!packet_buffer) { return NULL; }", distractors: [{"text":"  // Assume malloc succeeds", reason:"This is unsafe. `malloc` can fail if the system is out of memory. You must always check its return value."}], indent: 1, explanation: "Handle memory allocation failure." },
    { "correct": "  PacketHeader* header = (PacketHeader*)packet_buffer;", distractors: [{"text":"  PacketHeader* header = malloc(sizeof(PacketHeader));", reason:"This is incorrect. We don't allocate a separate header. The core idea is to overlay the `PacketHeader` struct directly onto the beginning of our `packet_buffer`."}], indent: 1, explanation: "Map the header struct onto the beginning of the buffer." },
    { "correct": "  printf(\"Creating packet: type=%d, payload_len=%u...\\n\", type, len);", distractors: [{"text":"  puts(\"Creating packet\");", reason:"This is less informative. Logging the type and length is important for debugging."}], indent: 1, explanation: "Log the packet creation." },
    { "correct": "  // Populate the header fields.", distractors: [{"text":"  // Copy the header.", reason:"We are not copying a header, we are populating the fields of the struct that is mapped onto our buffer."}], indent: 1, explanation: "Comment on populating the header." },
    { "correct": "  header->sync_word = SYNC_WORD;", distractors: [{"text":"  header.sync_word = SYNC_WORD;", reason:"`header` is a pointer. The arrow operator `->` must be used to access members of a struct via a pointer."}], indent: 1, explanation: "Set the sync word." },
    { "correct": "  header->packet_type = type;", distractors: [{"text":"  header->packet_type = (uint8_t)type;", reason:"Casting the enum to `uint8_t` is a good practice for explicitness, but it will be implicitly converted correctly anyway."}], indent: 1, explanation: "Set the packet type from the enum." },
    { "correct": "  header->payload_len = len;", distractors: [{"text":"  header->payload_len = 0;", reason:"This is a bug. The header must contain the correct length of the payload that follows it."}], indent: 1, explanation: "Set the payload length." },
    { "correct": "  // Copy the payload data into the buffer right after the header.", distractors: [{"text":"  // Copy payload to the start of the buffer.", reason:"This would be a bug. It would overwrite the header we just populated."}], indent: 1, explanation: "Comment on copying the payload." },
    { "correct": "  if (payload && len > 0) {", distractors: [{"text":"  if (len > 0) {", reason:"This is less safe. It's good practice to also check that the `payload` pointer is not NULL before trying to copy from it."}], indent: 1, explanation: "Check if there is a payload to copy." },
    { "correct": "    memcpy(packet_buffer + sizeof(PacketHeader), payload, len);", distractors: [{"text":"    memcpy(packet_buffer, payload, len);", reason:"This is a bug that would overwrite the packet header. The destination for the copy must be offset by the size of the header."}], indent: 2, explanation: "Copy the payload data." },
    { "correct": "  }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 1, explanation: "End payload copy check." },
    { "correct": "  // Calculate and set the checksum based on the payload.", distractors: [{"text":"  // Calculate checksum on the header.", reason:"This is a valid design choice, but checksums typically protect the data payload from corruption. Some protocols checksum the header and payload separately."}], indent: 1, explanation: "Comment on the checksum calculation." },
    { "correct": "  header->checksum = calculate_checksum(payload, len);", distractors: [{"text":"  header->checksum = calculate_checksum(packet_buffer, *out_total_size);", reason:"This would be a bug. The checksum must be calculated on the original payload *before* it is placed in the packet, otherwise the checksum value itself would affect the calculation."}], indent: 1, explanation: "Calculate and store the checksum in the header." },
    { "correct": "  return packet_buffer;", distractors: [{"text":"  return header;", reason:"This would be a type mismatch. The function returns a generic pointer to the whole buffer (`void*`), not a pointer to the header struct."}], indent: 1, explanation: "Return the pointer to the complete, serialized packet buffer." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "End of `create_packet`." },
    { "correct": "// === Stage 3: Stream Processing and Packet Deserialization ===", distractors: [{"text":"// === Stage 3: Packet Serialization ===", reason:"This stage is about parsing (deserializing) a raw stream of bytes, not creating (serializing) packets."}], indent: 0, explanation: "Implement the core logic to read and validate packets from a buffer." },
    { "correct": "void process_stream(const uint8_t* stream_buffer, uint32_t stream_size) {", distractors: [{"text":"void process_stream(uint8_t* stream_buffer, uint32_t stream_size) {", reason:"The definition must match the prototype. This function only reads from the stream, so the buffer should be `const`."}], indent: 0, explanation: "Begin `process_stream` implementation." },
    { "correct": "  printf(\"\\n--- Processing Stream (Total Size: %u bytes) ---\\n\", stream_size);", distractors: [{"text":"  puts(\"Processing Stream\");", reason:"This is less informative. Including the total size is useful for context."}], indent: 1, explanation: "Print a header for the processing log." },
    { "correct": "  const uint8_t* current_pos = stream_buffer;", distractors: [{"text":"  uint8_t* current_pos = stream_buffer;", reason:"Since `stream_buffer` is `const`, the `current_pos` pointer should also be `const` to maintain type correctness."}], indent: 1, explanation: "Initialize a pointer to the current position in the stream." },
    { "correct": "  uint32_t bytes_processed = 0;", distractors: [{"text":"  uint32_t bytes_processed;", reason:"Counters must be initialized to 0. An uninitialized variable holds a garbage value."}], indent: 1, explanation: "Initialize a counter for bytes processed." },
    { "correct": "  while (bytes_processed < stream_size) {", distractors: [{"text":"  while (current_pos < stream_buffer + stream_size) {", reason:"This is an alternative, pointer-based way to write the loop condition which is also correct."}], indent: 1, explanation: "Loop as long as there are bytes left to process." },
    { "correct": "    printf(\"\\nProcessing at offset %u...\\n\", bytes_processed);", distractors: [{"text":"    printf(\"\\nProcessing...\\n\");", reason:"Logging the current byte offset is crucial for debugging parsing logic."}], indent: 2, explanation: "Log the current position in the stream." },
    { "correct": "    if (stream_size - bytes_processed < sizeof(PacketHeader)) {", distractors: [{"text":"    if (bytes_processed > stream_size) {", reason:"This check must be done *before* attempting to read the header to prevent reading past the end of the buffer."}], indent: 2, explanation: "Check if there's enough data left for at least a header." },
    { "correct": "      printf(\"  -> Incomplete data, not enough for a header. Stopping.\\n\");", distractors: [{"text":"      printf(\"  -> End of stream.\\n\");", reason:"'Incomplete data' is more specific. It tells us the stream ended unexpectedly in the middle of a potential packet."}], indent: 3, explanation: "Log the reason for stopping." },
    { "correct": "      break;", distractors: [{"text":"      return;", reason:"`break` correctly exits the parsing loop, allowing code after the loop to run. `return` would exit the entire `process_stream` function."}], indent: 3, explanation: "Exit the loop if data is truncated." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if` block."}], indent: 2, explanation: "End of size check." },
    { "correct": "    // Map the header struct onto the current position in the buffer.", distractors: [{"text":"    // Copy the header data from the buffer.", reason:"We are not copying data. We are more efficiently creating a pointer (`header`) that interprets the raw bytes at `current_pos` as a `PacketHeader` struct."}], indent: 2, explanation: "Comment on deserialization." },
    { "correct": "    const PacketHeader* header = (const PacketHeader*)current_pos;", distractors: [{"text":"    PacketHeader header; memcpy(&header, current_pos, sizeof(PacketHeader));", reason:"This also works, but it's less efficient as it involves a memory copy. Direct casting is faster."}], indent: 2, explanation: "Create a header pointer to the current buffer position." },
    { "correct": "    // --- Validation Step 1: Check Sync Word ---", distractors: [{"text":"    // --- Validation Step 1: Check Checksum ---", reason:"We must find a valid packet first by checking the sync word *before* we can validate its contents like the checksum."}], indent: 2, explanation: "Comment on the first validation step." },
    { "correct": "    if (header->sync_word != SYNC_WORD) {", distractors: [{"text":"    if (header->sync_word == SYNC_WORD) {", reason:"This logic is reversed. This block should execute if the sync word does *not* match."}], indent: 2, explanation: "Check if the sync word matches our protocol's magic number." },
    { "correct": "      printf(\"  -> ERROR: Invalid sync word (Expected 0x%X, Got 0x%X). Skipping 1 byte.\\n\", SYNC_WORD, header->sync_word);", distractors: [{"text":"      printf(\"  -> ERROR: Invalid sync word.\\n\");", reason:"This is less helpful for debugging. Printing the expected and actual values makes it easier to diagnose the problem."}], indent: 3, explanation: "Log a sync error." },
    { "correct": "      current_pos++;", distractors: [{"text":"      current_pos += sizeof(PacketHeader);", reason:"This is a bug. If the sync word is wrong, we don't know if we're looking at a valid packet at all. We should only advance by one byte to check if the *next* byte is the start of a sync word."}], indent: 3, explanation: "Advance the buffer by one byte to search for the next sync word." },
    { "correct": "      bytes_processed++;", distractors: [{"text":"      // No need to increment", reason:"This is a bug. We have processed one byte (by skipping it), so the counter must be incremented."}], indent: 3, explanation: "Increment the processed counter." },
    { "correct": "      continue; // Continue to the next iteration of the loop.", distractors: [{"text":"      break;", reason:"`break` would stop processing the rest of the stream. `continue` correctly skips to the next byte to continue searching for a valid packet."}], indent: 3, explanation: "Skip the rest of the processing for this position." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 2, explanation: "End of sync word check." },
    { "correct": "    printf(\"  -> Found valid sync word.\\n\");", distractors: [{"text":"    puts(\"  -> Found valid sync word.\");", reason:"`puts` is a valid and simpler way to print this message."}], indent: 2, explanation: "Log successful sync." },
    { "correct": "    // --- Validation Step 2: Check if payload fits in the stream ---", distractors: [{"text":"    // --- Validation Step 2: Assume length is correct ---", reason:"This is a major security risk. A malicious or corrupt packet could specify a huge length, causing the parser to read past the end of the buffer."}], indent: 2, explanation: "Comment on checking payload boundary." },
    { "correct": "    uint32_t total_packet_size = sizeof(PacketHeader) + header->payload_len;", distractors: [{"text":"    uint32_t total_packet_size = sizeof(PacketHeader);", reason:"This is a bug. The total packet size must include the length of the payload."}], indent: 2, explanation: "Calculate the expected full packet size." },
    { "correct": "    if (bytes_processed + total_packet_size > stream_size) {", distractors: [{"text":"    if (total_packet_size > stream_size) {", reason:"This check is not quite right. It doesn't account for the current offset (`bytes_processed`)."}], indent: 2, explanation: "Check if the declared payload length would read past the end of the buffer." },
    { "correct": "      printf(\"  -> ERROR: Declared payload length (%u) exceeds buffer size. Stopping.\\n\", header->payload_len);", distractors: [{"text":"      printf(\"  -> ERROR: Packet too long.\\n\");", reason:"The original message is more descriptive as it includes the problematic length value."}], indent: 3, explanation: "Log a truncated packet error." },
    { "correct": "      break;", distractors: [{"text":"      continue;", reason:"This is a non-recoverable stream error. If the length is wrong, we can't know where the next packet starts, so we must `break` and stop processing."}], indent: 3, explanation: "Exit the loop." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used here."}], indent: 2, explanation: "End of payload boundary check." },
    { "correct": "    const uint8_t* payload = current_pos + sizeof(PacketHeader);", distractors: [{"text":"    uint8_t* payload = malloc(header->payload_len); memcpy(payload, ...);", reason:"This is less efficient. We can operate directly on the stream buffer by creating a pointer to the payload's start location, avoiding an extra allocation and copy."}], indent: 2, explanation: "Get a pointer to the start of the payload data." },
    { "correct": "    // --- Validation Step 3: Checksum Verification ---", distractors: [{"text":"    // --- Validation Step 3: Assume data is correct ---", reason:"This is unsafe. A checksum is the primary way to detect if the payload data was corrupted during transmission."}], indent: 2, explanation: "Comment on the checksum validation." },
    { "correct": "    uint8_t calculated_checksum = calculate_checksum(payload, header->payload_len);", distractors: [{"text":"    uint8_t calculated_checksum = calculate_checksum(current_pos, total_packet_size);", reason:"This is a bug. The checksum is calculated only on the *payload*, not the entire packet including the header."}], indent: 2, explanation: "Calculate the checksum of the received payload." },
    { "correct": "    if (calculated_checksum != header->checksum) {", distractors: [{"text":"    if (calculated_checksum == header->checksum) {", reason:"This logic is reversed. The error block should execute if the checksums do *not* match."}], indent: 2, explanation: "Compare calculated checksum with the one in the header." },
    { "correct": "      printf(\"  -> ERROR: Checksum mismatch (Expected %u, Calculated %u). Discarding packet.\\n\", header->checksum, calculated_checksum);", distractors: [{"text":"      printf(\"  -> ERROR: Checksum mismatch.\\n\");", reason:"This is less helpful for debugging. Printing the expected and calculated values can help diagnose the corruption."}], indent: 3, explanation: "Log a checksum error." },
    { "correct": "    } else {", distractors: [{"text":"    }", reason:"An `else` block is required to handle the successful case where the checksum matches."}], indent: 2, explanation: "If the checksum is valid..." },
    { "correct": "      printf(\"  -> Checksum OK. Packet Type: %d.\\n\", header->packet_type);", distractors: [{"text":"      printf(\"  -> Checksum OK.\\n\");", reason:"Logging the packet type is useful for tracing the parser's logic."}], indent: 3, explanation: "Log successful validation." },
    { "correct": "      // --- Packet Handling ---", distractors: [{"text":"      // --- Packet Finished ---", reason:"This comment is inaccurate. We are about to dispatch the packet to its specific handler."}], indent: 3, explanation: "Comment on dispatching to the correct handler." },
    { "correct": "      switch ((PacketType)header->packet_type) {", distractors: [{"text":"      switch (header->packet_type) {", reason:"While this works, explicitly casting the `uint8_t` from the header to our `PacketType` enum makes the code's intent clearer."}], indent: 3, explanation: "Use a switch statement to call the appropriate handler." },
    { "correct": "        case VIDEO_DATA: handle_video_packet(payload, header->payload_len); break;", distractors: [{"text":"        case VIDEO_DATA: handle_video_packet(payload, header->payload_len);", reason:"A `break` is required. Without it, execution would 'fall through' to the `AUDIO_DATA` case, which is a bug."}], indent: 4, explanation: "Call the video handler." },
    { "correct": "        case AUDIO_DATA: handle_audio_packet(payload, header->payload_len); break;", distractors: [{"text":"        case 2: handle_audio_packet(...); break;", reason:"Using the named enumerator `AUDIO_DATA` is much more readable and maintainable than using its underlying integer value `2`."}], indent: 4, explanation: "Call the audio handler." },
    { "correct": "        case KEEPALIVE: handle_keepalive_packet(); break;", distractors: [{"text":"        case KEEPALIVE: handle_keepalive_packet(payload, len); break;", reason:"This would be a compiler error. The `handle_keepalive_packet` function was defined to take no arguments."}], indent: 4, explanation: "Call the keepalive handler." },
    { "correct": "        default: printf(\"  -> WARNING: Unknown packet type %d. Discarding.\\n\", header->packet_type); break;", distractors: [{"text":"        // No default case needed.", reason:"A `default` case is crucial for robust code. It handles unexpected or future packet types gracefully instead of just ignoring them."}], indent: 4, explanation: "Handle unknown packet types." },
    { "correct": "      }", distractors: [{"text":"};", reason:"Semicolons are not used after a `switch` statement."}], indent: 3, explanation: "End of switch statement." },
    { "correct": "    }", distractors: [{"text":"};", reason:"Semicolons are not used after an `if/else` block."}], indent: 2, explanation: "End of checksum validation block." },
    { "correct": "    // Move to the next packet in the stream", distractors: [{"text":"    // Move to the next byte.", reason:"This is a bug. After successfully processing a packet, we must advance the pointer by the *entire size* of that packet to get to the start of the next one."}], indent: 2, explanation: "Comment on advancing the buffer pointer." },
    { "correct": "    current_pos += total_packet_size;", distractors: [{"text":"    current_pos += sizeof(PacketHeader);", reason:"This is a bug. It would fail to advance past the payload, causing the next loop iteration to parse the payload as if it were a header."}], indent: 2, explanation: "Advance the position by the full size of the packet we just processed." },
    { "correct": "    bytes_processed += total_packet_size;", distractors: [{"text":"    bytes_processed++;", reason:"This is incorrect. We have processed the entire packet, so we must add its full size to the counter."}], indent: 2, explanation: "Update the total bytes processed counter." },
    { "correct": "  }", distractors: [{"text":"end while;", reason:"This is not valid C syntax."}], indent: 1, explanation: "End of main processing loop." },
    { "correct": "  printf(\"\\n--- End of Stream Processing ---\\n\");", distractors: [{"text":"  puts(\"\\n--- End of Stream Processing ---\");", reason:"`puts` adds its own newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Print a footer." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End of `process_stream`." },
    { "correct": "// === Stage 4: Packet Handler Implementations ===", distractors: [{"text":"// === Stage 4: The Main Program ===", reason:"This stage implements the helper functions that are called by the parser, not the main program driver."}], indent: 0, explanation: "Implement the functions that do something with the validated packet data." },
    { "correct": "void handle_video_packet(const uint8_t* payload, uint16_t len) {", distractors: [{"text":"void handle_video_packet(const uint8_t payload[], uint16_t len) {", reason:"In a function parameter, `const uint8_t*` and `const uint8_t[]` are treated identically by the compiler."}], indent: 0, explanation: "Begin video handler." },
    { "correct": "  printf(\"    [Handler] Processing %u bytes of video data. First byte: 0x%02X\\n\", len, payload[0]);", distractors: [{"text":"  printf(\"    [Handler] Processing video data.\\n\");", reason:"This is less informative. Logging the length and a sample byte is useful for verification."}], indent: 1, explanation: "Log video packet details." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "End video handler." },
    { "correct": "void handle_audio_packet(const uint8_t* payload, uint16_t len) {", distractors: [{"text":"int handle_audio_packet(...)", reason:"The definition must match the prototype. This handler doesn't need to return a value."}], indent: 0, explanation: "Begin audio handler." },
    { "correct": "  printf(\"    [Handler] Processing %u bytes of audio data. First byte: 0x%02X\\n\", len, payload[0]);", distractors: [{"text":"  printf(\"    [Handler] Processing %d bytes of audio data.\\n\", len);", reason:"The `%u` specifier is generally preferred for unsigned types like `uint16_t`."}], indent: 1, explanation: "Log audio packet details." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "End audio handler." },
    { "correct": "void handle_keepalive_packet() {", distractors: [{"text":"void handle_keepalive_packet(void* payload) {", reason:"The definition must match the prototype, which takes no arguments."}], indent: 0, explanation: "Begin keepalive handler." },
    { "correct": "  printf(\"    [Handler] Received Keepalive. Connection is active.\\n\");", distractors: [{"text":"  puts(\"    [Handler] Received Keepalive. Connection is active.\\n\");", reason:"`puts` is a valid alternative for printing a fixed string."}], indent: 1, explanation: "Log keepalive packet." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 0, explanation: "End keepalive handler." },
    { "correct": "// === Stage 5: Main Program for Demonstration ===", distractors: [{"text":"// === Stage 5: The Protocol Parser ===", reason:"This is the main driver program that sets up a test case and calls the parser."}], indent: 0, explanation: "Create a simulated stream buffer and test the parser." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid, and often preferred, way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start of main." },
    { "correct": "  printf(\"--- Custom Protocol Parser Demo ---\\n\");", distractors: [{"text":"  puts(\"--- Custom Protocol Parser Demo ---\");", reason:"`puts` is a valid and simpler way to print this title."}], indent: 1, explanation: "Demo title." },
    { "correct": "  // Create some sample payloads", distractors: [{"text":"  // Create some packets", reason:"This section creates the raw payload data, not the full serialized packets yet."}], indent: 1, explanation: "Comment on payload creation." },
    { "correct": "  uint8_t video_payload[] = { 0xDE, 0xC0, 0xAD, 0xED };", distractors: [{"text":"  const uint8_t* video_payload = { ... };", reason:"This is invalid syntax for initializing a pointer. An array `[]` correctly allocates memory and initializes it."}], indent: 1, explanation: "A small payload for a video packet." },
    { "correct": "  uint8_t audio_payload[] = { 0xC0, 0xCA, 0xC0, 0x1A };", distractors: [{"text":"  uint8_t audio_payload[4] = { ... };", reason:"Explicitly sizing the array is also correct, but `[]` is convenient as it sizes it automatically."}], indent: 1, explanation: "A small payload for an audio packet." },
    { "correct": "  // Create serialized packets from the payloads", distractors: [{"text":"  // Create raw data", reason:"This section calls `create_packet`, which serializes the header and payload into a single buffer."}], indent: 1, explanation: "Comment on packet serialization." },
    { "correct": "  uint32_t packet1_size, packet2_size, packet3_size, packet4_size;", distractors: [{"text":"  uint32_t packet1_size=0, packet2_size=0, ...;", reason:"Initializing these to zero is good practice, though not strictly necessary as they are 'out' parameters that will be written to by `create_packet`."}], indent: 1, explanation: "Variables to hold the size of each created packet." },
    { "correct": "  void* packet1 = create_packet(VIDEO_DATA, video_payload, sizeof(video_payload), &packet1_size);", distractors: [{"text":"  void* packet1 = create_packet(VIDEO_DATA, video_payload, sizeof(video_payload), packet1_size);", reason:"This is a bug. `create_packet` needs a pointer to `packet1_size` so it can return the calculated size back to the caller."}], indent: 1, explanation: "Create the first (valid) packet." },
    { "correct": "  void* packet2 = create_packet(AUDIO_DATA, audio_payload, sizeof(audio_payload), &packet2_size);", distractors: [{"text":"  void* packet2 = create_packet(AUDIO_DATA, audio_payload, 4, &packet2_size);", reason:"Using `sizeof(audio_payload)` is more robust than hardcoding the size `4`. If you add bytes to the payload, `sizeof` updates automatically."}], indent: 1, explanation: "Create the second (valid) packet." },
    { "correct": "  void* packet3 = create_packet(KEEPALIVE, NULL, 0, &packet3_size);", distractors: [{"text":"  void* packet3 = create_packet(KEEPALIVE, NULL, 0, NULL);", reason:"This would also work, but our current design requires the out-size parameter."}], indent: 1, explanation: "Create a keepalive packet (no payload)." },
    { "correct": "  void* packet4_corrupt = create_packet(VIDEO_DATA, video_payload, sizeof(video_payload), &packet4_size);", distractors: [{"text":"  void* packet4_corrupt = packet1;", reason:"This would just create another pointer to the first packet. We need to create a new packet so we can corrupt it independently."}], indent: 1, explanation: "Create a packet that we will manually corrupt." },
    { "correct": "  ((PacketHeader*)packet4_corrupt)->checksum++; // Corrupt the checksum", distractors: [{"text":"  ((PacketHeader*)packet4_corrupt)->sync_word = 0;", reason:"This would also corrupt the packet, but it would be caught by the sync word check instead of the checksum validation."}], indent: 1, explanation: "Manually alter the checksum to test validation." },
    { "correct": "  // Assemble the final stream buffer", distractors: [{"text":"  // Free the packets", reason:"We must assemble the stream first. The packets can only be freed after their data has been copied into the main stream buffer."}], indent: 1, explanation: "Comment on assembling the stream." },
    { "correct": "  uint32_t stream_size = packet1_size + packet2_size + packet3_size + packet4_size + 3; // Add junk bytes", distractors: [{"text":"  uint32_t stream_size = 4 * sizeof(PacketHeader);", reason:"This is a bug. The total size must include the payload lengths, not just the headers."}], indent: 1, explanation: "Calculate the total size of the stream buffer, including junk data." },
    { "correct": "  uint8_t* stream_buffer = malloc(stream_size);", distractors: [{"text":"  uint8_t stream_buffer[stream_size];", reason:"Variable-Length Arrays (VLAs) are allocated on the stack and can cause a stack overflow if the size is large. `malloc` is required for large, dynamically sized buffers."}], indent: 1, explanation: "Allocate memory for the stream buffer." },
    { "correct": "  uint32_t offset = 0;", distractors: [{"text":"  uint32_t offset;", reason:"It is critical to initialize an offset counter to 0 before starting to copy data."}], indent: 1, explanation: "Initialize an offset for copying data." },
    { "correct": "  stream_buffer[offset++] = 0xAA; // Junk byte at the start", distractors: [{"text":"  // No junk bytes", reason:"Adding junk bytes is a good way to test that the parser's sync word search logic is robust and can recover from alignment errors."}], indent: 1, explanation: "Add junk byte to test sync word search. NOTE: This will fail the first read, which is intended." },
    { "correct": "  memcpy(stream_buffer + offset, packet1, packet1_size); offset += packet1_size;", distractors: [{"text":"  memcpy(stream_buffer, packet1, packet1_size); offset += packet1_size;", reason:"This would overwrite the junk byte we added at the start. The destination must be offset."}], indent: 1, explanation: "Copy the first valid packet into the stream." },
    { "correct": "  stream_buffer[offset++] = 0xBB; // More junk", distractors: [{"text":"  // stream_buffer[offset] = 0xBB; offset++;", reason:"The post-increment operator `offset++` is a more compact way to write this."}], indent: 1, explanation: "This will fail because it's not a valid sync word." },
    { "correct": "  stream_buffer[offset++] = 0xCC; // More junk", distractors: [{"text":"  // No more junk", reason:"Adding multiple junk bytes tests the `continue` logic in the parser's sync-word search loop."}], indent: 1, explanation: "This will also fail." },
    { "correct": "  memcpy(stream_buffer + offset, packet2, packet2_size); offset += packet2_size;", distractors: [{"text":"  memcpy(stream_buffer + offset, packet2, sizeof(packet2));", reason:"This is a bug. `sizeof(packet2)` would give the size of the pointer `void*`, not the size of the packet data it points to."}], indent: 1, explanation: "Copy the second packet. NOTE: Sync will fail on BB and CC before finding this." },
    { "correct": "  memcpy(stream_buffer + offset, packet4_corrupt, packet4_size); offset += packet4_size;", distractors: [{"text":"  memcpy(stream_buffer + offset, packet1, packet1_size);", reason:"This would copy the valid packet again. To test our checksum validation, we must copy the corrupted packet."}], indent: 1, explanation: "Copy the corrupted packet." },
    { "correct": "  memcpy(stream_buffer + offset, packet3, packet3_size); offset += packet3_size;", distractors: [{"text":"  // No more packets", reason:"Adding the keepalive packet ensures we test packets both with and without payloads."}], indent: 1, explanation: "Copy the keepalive packet." },
    { "correct": "  // Process the assembled stream", distractors: [{"text":"  // Cleanup", reason:"We must process the stream *before* we free the memory it contains."}], indent: 1, explanation: "Comment on running the parser." },
    { "correct": "  process_stream(stream_buffer, stream_size);", distractors: [{"text":"  process_stream(&stream_buffer, stream_size);", reason:"`stream_buffer` is already a pointer. Passing its address would be a type mismatch."}], indent: 1, explanation: "Call the main processing function." },
    { "correct": "  // Cleanup", distractors: [{"text":"  // No cleanup needed", reason:"This is false. All 5 buffers (`packet1`, `packet2`, `packet3`, `packet4_corrupt`, and `stream_buffer`) were allocated with `malloc` and must be freed."}], indent: 1, explanation: "Comment on freeing memory." },
    { "correct": "  free(packet1); free(packet2); free(packet3); free(packet4_corrupt);", distractors: [{"text":"  free(packet1);", reason:"You must free every single pointer that was returned from `malloc`. Forgetting the others would result in a memory leak."}], indent: 1, explanation: "Free the individual packet buffers." },
    { "correct": "  free(stream_buffer);", distractors: [{"text":"  free(&stream_buffer);", reason:"`free` must be called on the pointer that `malloc` returned, not on its address."}], indent: 1, explanation: "Free the main stream buffer." },
    { "correct": "  printf(\"\\n--- Demo Finished ---\\n\");", distractors: [{"text":"  puts(\"--- Demo Finished ---\");", reason:"`puts` is a valid alternative for printing this message."}], indent: 1, explanation: "Final message." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 signals an error. Since the demo completed successfully, it should return 0."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of main." }
]
},
// Level 97: Prep for Nvidia
{
    "goal": "Simulate SIMD (Single Instruction, Multiple Data) processing by implementing vector arithmetic functions that operate on small blocks of data at a time, highlighting concepts relevant to GPU and high-performance computing.",
    "concepts": "Vectorization, SIMD, loop unrolling, pointer arithmetic, performance concepts, floating-point operations",
    "sequence": [
    { "correct": "// === Stage 1: Data Structures and Utility Declarations ===", distractors: [{"text":"// === Stage 1: The Main Program ===", reason:"Good design practice is to define the core data structures and their API before writing the main program that uses them."}], indent: 0, explanation: "Define the basic data structure for a vector and declare utility functions." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"The standard I/O function `printf` is declared in `<stdio.h>`."}], indent: 0, explanation: "For standard I/O." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <time.h>", reason:"Memory management functions like `malloc` and `free`, and the `rand` function are prototyped in `<stdlib.h>`."}], indent: 0, explanation: "For memory allocation." },
    { "correct": "#include <time.h>", distractors: [{"text":"// No include needed for time", reason:"The `time()` function, used to seed the random number generator, is part of the time library and requires `<time.h>`."}], indent: 0, explanation: "To seed the random number generator." },
    { "correct": "#define VECTOR_SIZE 1027", distractors: [{"text":"#define VECTOR_SIZE 1024", reason:"Using a size that is a perfect multiple of the SIMD width (like 1024) is a less robust test, as it wouldn't exercise the 'remainder' loop."}], indent: 0, explanation: "A large, non-divisible-by-4 number to test handling of remainders." },
    { "correct": "#define SIMD_WIDTH 4", distractors: [{"text":"#define SIMD_WIDTH 8", reason:"While modern CPUs have wider SIMD registers (AVX can do 8 floats), using 4 is a common width (SSE) and is simple for this simulation."}], indent: 0, explanation: "The 'width' of our simulated SIMD operation (i.e., process 4 floats at a time)." },
    { "correct": "// A simple struct to represent a vector of floats.", distractors: [{"text":"// A class for a vector.", reason:"C uses `struct` to group data. The term `class` is from object-oriented languages like C++."}], indent: 0, explanation: "Comment for the FloatVector struct." },
    { "correct": "typedef struct {", distractors: [{"text":"struct FloatVector {", reason:"Using `typedef` is a convenience that allows us to declare vectors as `FloatVector* v;` instead of `struct FloatVector* v;`."}], indent: 0, explanation: "Start of FloatVector struct definition." },
    { "correct": "  float* data;", distractors: [{"text":"  float data[VECTOR_SIZE];", reason:"This creates a fixed-size vector. Using a pointer (`float*`) allows us to create vectors of any size dynamically."}], indent: 1, explanation: "A pointer to the dynamically allocated array of floats." },
    { "correct": "  size_t size;", distractors: [{"text":"  int size;", reason:"`size_t` is the appropriate type for memory sizes and counts, as it's guaranteed to be large enough for any object. An `int` could be too small on some systems."}], indent: 1, explanation: "The number of elements in the vector." },
    { "correct": "} FloatVector;", distractors: [{"text":"} FloatVector", reason:"A `typedef` statement must always end with a semicolon."}], indent: 0, explanation: "End of FloatVector typedef." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text":"// --- Function Implementations ---", reason:"These are just the forward declarations (prototypes). The function bodies (implementations) come later."}], indent: 0, explanation: "Declarations for vector utilities and arithmetic functions." },
    { "correct": "FloatVector* vector_create(size_t size);", distractors: [{"text":"void vector_create(FloatVector* vec, size_t size);", reason:"This is an alternative design. A 'constructor' function that handles its own allocation and returns a pointer is a common and clean pattern."}], indent: 0, explanation: "Allocates and initializes a new vector." },
    { "correct": "void vector_destroy(FloatVector* vec);", distractors: [{"text":"int vector_destroy(FloatVector* vec);", reason:"A 'destroy' function's job is to clean up memory; it doesn't need to return a value, so `void` is appropriate."}], indent: 0, explanation: "Frees the memory used by a vector." },
    { "correct": "void vector_fill_random(FloatVector* vec);", distractors: [{"text":"void vector_fill_random(FloatVector vec);", reason:"The function needs to modify the vector's data, so it must accept a pointer to the vector, not a copy."}], indent: 0, explanation: "Fills a vector with random float values." },
    { "correct": "void vector_print(const FloatVector* vec, const char* name);", distractors: [{"text":"void vector_print(FloatVector* vec, const char* name);", reason:"A print function should not modify the data it's printing. Using `const` makes this guarantee clear."}], indent: 0, explanation: "Prints the contents of a vector." },
    { "correct": "void vector_add_naive(const FloatVector* a, const FloatVector* b, FloatVector* result);", distractors: [{"text":"void vector_add_naive(FloatVector* a, FloatVector* b, FloatVector* result);", reason:"The input vectors `a` and `b` are only read from, not modified. They should be `const` to enforce this."}], indent: 0, explanation: "Adds two vectors element by element (scalar approach)." },
    { "correct": "void vector_add_simd(const FloatVector* a, const FloatVector* b, FloatVector* result);", distractors: [{"text":"FloatVector* vector_add_simd(const FloatVector* a, const FloatVector* b);", reason:"This would be a valid alternative design where the result vector is created inside the function. Passing the result vector in is also a common pattern."}], indent: 0, explanation: "Adds two vectors using a simulated SIMD approach." },
    { "correct": "void vector_fma_simd(const FloatVector* a, const FloatVector* b, const FloatVector* c, FloatVector* result);", distractors: [{"text":"void vector_fma_simd(const FloatVector* vecs[4]);", reason:"Passing an array of vectors is possible, but listing the parameters explicitly makes the function signature clearer about its inputs (a, b, c) and output (result)."}], indent: 0, explanation: "Performs a fused multiply-add (a*b+c) using the SIMD approach." },
    { "correct": "// === Stage 2: Vector Utility Implementations ===", distractors: [{"text":"// === Stage 2: The Main Program ===", reason:"We must implement the utility functions first before we can use them to create and manage vectors in `main`."}], indent: 0, explanation: "Implement the helper functions for creating, destroying, and populating vectors." },
    { "correct": "FloatVector* vector_create(size_t size) {", distractors: [{"text":"FloatVector vector_create(size_t size) {", reason:"The function must return a pointer to a dynamically allocated struct, so its return type must be `FloatVector*`."}], indent: 0, explanation: "Begin `vector_create`." },
    { "correct": "  FloatVector* vec = malloc(sizeof(FloatVector));", distractors: [{"text":"  FloatVector* vec = malloc(sizeof(vec));", reason:"This is a bug. `sizeof(vec)` would give the size of a pointer, not the size of the `FloatVector` struct it points to."}], indent: 1, explanation: "Allocate the main struct." },
    { "correct": "  if (!vec) return NULL;", distractors: [{"text":"  // Assume malloc succeeds", reason:"This is unsafe. `malloc` can fail if the system is out of memory. You must always check its return value."}], indent: 1, explanation: "Handle allocation failure for the struct." },
    { "correct": "  vec->size = size;", distractors: [{"text":"  vec.size = size;", reason:"`vec` is a pointer. You must use the arrow operator `->` to access members of a struct through a pointer."}], indent: 1, explanation: "Set the size." },
    { "correct": "  vec->data = malloc(size * sizeof(float));", distractors: [{"text":"  vec->data = malloc(size);", reason:"This is a bug. `malloc` needs the total size in *bytes*. You must multiply the number of elements by `sizeof(float)`."}], indent: 1, explanation: "Allocate the data array. On GPUs, this would be aligned memory." },
    { "correct": "  if (!vec->data) { free(vec); return NULL; }", distractors: [{"text":"  if (!vec->data) { return NULL; }", reason:"This is a memory leak. If the data allocation fails, you must free the `FloatVector` struct itself before returning."}], indent: 1, explanation: "Handle allocation failure for the data array." },
    { "correct": "  return vec;", distractors: [{"text":"  return *vec;", reason:"This is a type mismatch. The function must return a pointer (`FloatVector*`), not the struct by value."}], indent: 1, explanation: "Return the new vector." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "End `vector_create`." },
    { "correct": "void vector_destroy(FloatVector* vec) {", distractors: [{"text":"void vector_destroy(const FloatVector* vec) {", reason:"A destroy function frees memory, which is a 'modifying' action. The pointer should not be `const`."}], indent: 0, explanation: "Begin `vector_destroy`." },
    { "correct": "  if (vec) {", distractors: [{"text":"  if (vec != NULL) {", reason:"This is an equally valid and often clearer way to check if the pointer is not NULL."}], indent: 1, explanation: "Check if the pointer is valid." },
    { "correct": "    free(vec->data);", distractors: [{"text":"    free(vec);", reason:"This is a memory leak. You must free the `data` array first before freeing the struct that contains the pointer to it."}], indent: 2, explanation: "Free the data array first." },
    { "correct": "    free(vec);", distractors: [{"text":"    // No need to free struct", reason:"This is a memory leak. The `FloatVector` struct itself was allocated with `malloc` and must be freed."}], indent: 2, explanation: "Then free the struct." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End validity check." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End `vector_destroy`." },
    { "correct": "void vector_fill_random(FloatVector* vec) {", distractors: [{"text":"void vector_fill_random(FloatVector vec) {", reason:"The definition must match the prototype. The function must accept a pointer to modify the vector's data."}], indent: 0, explanation: "Begin `vector_fill_random`." },
    { "correct": "  for (size_t i = 0; i < vec->size; i++) {", distractors: [{"text":"  for (size_t i = 0; i <= vec->size; i++) {", reason:"This is an off-by-one error. The loop would attempt to access `vec->data[vec->size]`, which is one element past the end of the allocated array."}], indent: 1, explanation: "Loop through each element." },
    { "correct": "    vec->data[i] = (float)rand() / (float)(RAND_MAX / 100.0);", distractors: [{"text":"    vec->data[i] = rand() / (RAND_MAX / 100);", reason:"This would perform integer division, resulting in a loss of precision. At least one of the operands must be cast to `float` to force floating-point division."}], indent: 2, explanation: "Assign a random float value between 0 and 100." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End loop." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to end function blocks."}], indent: 0, explanation: "End `vector_fill_random`." },
    { "correct": "void vector_print(const FloatVector* vec, const char* name) {", distractors: [{"text":"void vector_print(FloatVector* vec, char* name) {", reason:"The definition must match the prototype. The inputs should be `const` because they are only being read from."}], indent: 0, explanation: "Begin `vector_print`." },
    { "correct": "  printf(\"Vector '%s' (first 8 elements): [ \", name);", distractors: [{"text":"  printf(\"Vector '%s': [ \", name);", reason:"The original is better because it explicitly states that it's only printing a subset of the data, which prevents confusion with large vectors."}], indent: 1, explanation: "Print a header, indicating we only show a few elements." },
    { "correct": "  size_t limit = vec->size < 8 ? vec->size : 8;", distractors: [{"text":"  size_t limit = 8;", reason:"This is unsafe. If the vector has fewer than 8 elements, this would cause the following loop to read past the end of the allocated memory."}], indent: 1, explanation: "Determine the print limit to avoid out-of-bounds access." },
    { "correct": "  for (size_t i = 0; i < limit; i++) {", distractors: [{"text":"  for (size_t i = 0; i <= limit; i++) {", reason:"This is an off-by-one error that would cause an out-of-bounds read on the final iteration."}], indent: 1, explanation: "Loop up to the limit." },
    { "correct": "    printf(\"%.2f \", vec->data[i]);", distractors: [{"text":"    printf(\"%f \", vec->data[i]);", reason:"Using `%.2f` formats the output to two decimal places, which is neater and more readable than the default precision of `%f`."}], indent: 2, explanation: "Print each float formatted to two decimal places." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End loop." },
    { "correct": "  printf(\"]\\n\");", distractors: [{"text":"  printf(\"]\");", reason:"Forgetting the newline character `\\n` would cause subsequent output to appear on the same line."}], indent: 1, explanation: "Print the closing bracket and a newline." },
    { "correct": "}", distractors: [{"text":"end function;", reason:"This is not valid C syntax."}], indent: 0, explanation: "End `vector_print`." },
    { "correct": "// === Stage 3: Naive Scalar Implementation ===", distractors: [{"text":"// === Stage 3: The SIMD Implementation ===", reason:"First, we implement the simple 'naive' version to have a baseline for correctness and performance comparison."}], indent: 0, explanation: "Implement the simple, one-element-at-a-time version for comparison." },
    { "correct": "void vector_add_naive(const FloatVector* a, const FloatVector* b, FloatVector* result) {", distractors: [{"text":"FloatVector* vector_add_naive(const FloatVector* a, const FloatVector* b) {", reason:"The definition must match the prototype. This function is designed to fill a pre-existing result vector."}], indent: 0, explanation: "Begin `vector_add_naive`." },
    { "correct": "  if (a->size != b->size || a->size != result->size) return;", distractors: [{"text":"  if (a->size == b->size) { ... }", reason:"This logic is reversed. The function should proceed if the sizes are equal, and return early if they are not."}], indent: 1, explanation: "Ensure all vectors are the same size." },
    { "correct": "  for (size_t i = 0; i < a->size; i++) {", distractors: [{"text":"  for (size_t i = 0; i < SIMD_WIDTH; i++) {", reason:"This is a bug. The naive version must process *every* element in the vector, up to `a->size`."}], indent: 1, explanation: "Loop through each element from 0 to N-1." },
    { "correct": "    result->data[i] = a->data[i] + b->data[i];", distractors: [{"text":"    result->data[i] = a->data[i];", reason:"This would just copy vector `a` into the result, not perform the addition."}], indent: 2, explanation: "Perform one addition per loop iteration." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End loop." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End `vector_add_naive`." },
    { "correct": "// === Stage 4: Simulated SIMD Implementation ===", distractors: [{"text":"// === Stage 4: Naive Implementation ===", reason:"This stage implements the optimized, block-based approach that simulates a SIMD operation."}], indent: 0, explanation: "Implement the core logic using block-based processing to simulate SIMD." },
    { "correct": "void vector_add_simd(const FloatVector* a, const FloatVector* b, FloatVector* result) {", distractors: [{"text":"void vector_add_simd(const float* a, const float* b, float* result) {", reason:"Our API is designed to work with the `FloatVector` struct, which conveniently packages the data pointer and size together."}], indent: 0, explanation: "Begin `vector_add_simd`." },
    { "correct": "  if (a->size != b->size || a->size != result->size) return;", distractors: [{"text":"  // Assume sizes are equal", reason:"This is unsafe. A robust function must validate its inputs."}], indent: 1, explanation: "Perform size validation." },
    { "correct": "  size_t n = a->size;", distractors: [{"text":"  int n = a->size;", reason:"Using `size_t` is better practice as it matches the type of `a->size`."}], indent: 1, explanation: "Get the total size for convenience." },
    { "correct": "  size_t i = 0;", distractors: [{"text":"  size_t i;", reason:"It's critical to initialize the loop counter to 0 before using it."}], indent: 1, explanation: "Initialize the loop counter." },
    { "correct": "  // Process the bulk of the data in chunks of SIMD_WIDTH.", distractors: [{"text":"  // Process all data one by one.", reason:"This comment describes the naive approach. The point of this function is to process data in larger, SIMD-like chunks."}], indent: 1, explanation: "Comment on the main vectorized loop." },
    { "correct": "  for (; i + SIMD_WIDTH <= n; i += SIMD_WIDTH) {", distractors: [{"text":"  for (; i < n; i += SIMD_WIDTH) {", reason:"This is a subtle bug. If `n` is not a multiple of `SIMD_WIDTH`, this condition could cause the loop to read past the end of the array on its final iteration."}], indent: 1, explanation: "Loop as long as there is at least one full SIMD block remaining." },
    { "correct": "    // This block simulates a single SIMD instruction.", distractors: [{"text":"    // This is a standard for loop.", reason:"This is 'loop unrolling'. By performing multiple operations per iteration, we reduce loop overhead and better reflect how a real SIMD instruction would work."}], indent: 2, explanation: "Comment explaining the manual unrolling." },
    { "correct": "    result->data[i+0] = a->data[i+0] + b->data[i+0];", distractors: [{"text":"    result->data[i] = a->data[i] + b->data[i];", reason:"This would be correct, but it only processes the first element of the unrolled block."}], indent: 2, explanation: "Process the first element in the block." },
    { "correct": "    result->data[i+1] = a->data[i+1] + b->data[i+1];", distractors: [{"text":"    result->data[i] = a->data[i+1] + b->data[i+1];", reason:"This is a bug. The result should be stored at index `i+1`, not `i`."}], indent: 2, explanation: "Process the second element in the block." },
    { "correct": "    result->data[i+2] = a->data[i+2] + b->data[i+2];", distractors: [{"text":"    // More operations here...", reason:"The unrolling must match the `SIMD_WIDTH`. Since our width is 4, we need two more operations."}], indent: 2, explanation: "Process the third element in the block." },
    { "correct": "    result->data[i+3] = a->data[i+3] + b->data[i+3];", distractors: [{"text":"    i += 4;", reason:"The loop increment `i += SIMD_WIDTH` is part of the `for` statement's third clause, not inside the loop body."}], indent: 2, explanation: "Process the fourth element in the block." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End of the main SIMD loop." },
    { "correct": "  // Handle the remaining elements that didn't fit into a full SIMD block.", distractors: [{"text":"  // All elements are handled.", reason:"This is false. If the vector size is not a perfect multiple of the SIMD width, there will be a few 'leftover' elements that this second loop must handle."}], indent: 1, explanation: "Comment on the scalar cleanup loop." },
    { "correct": "  for (; i < n; i++) {", distractors: [{"text":"  for (i = 0; i < n % SIMD_WIDTH; i++) {", reason:"This is a bug. The main loop already advanced `i`. This 'cleanup' loop should continue from where `i` left off."}], indent: 1, explanation: "Loop through the remaining 0 to 3 elements." },
    { "correct": "    result->data[i] = a->data[i] + b->data[i];", distractors: [{"text":"    result->data[i] = 0;", reason:"This would incorrectly zero out the end of the result vector instead of calculating the sum."}], indent: 2, explanation: "Process the remaining elements one by one." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End of the cleanup loop." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End `vector_add_simd`." },
    { "correct": "// === Stage 5: Fused Multiply-Add (FMA) SIMD Implementation ===", distractors: [{"text":"// === Stage 5: Scalar FMA Implementation ===", reason:"This section implements the more complex FMA operation using the same optimized SIMD simulation technique."}], indent: 0, explanation: "Implement a more complex FMA operation, common in graphics and HPC." },
    { "correct": "void vector_fma_simd(const FloatVector* a, const FloatVector* b, const FloatVector* c, FloatVector* result) {", distractors: [{"text":"void vector_fma_naive(...)", reason:"This function demonstrates the SIMD pattern, not the naive one-by-one approach."}], indent: 0, explanation: "Begin `vector_fma_simd`." },
    { "correct": "  if (a->size != b->size || a->size != c->size || a->size != result->size) return;", distractors: [{"text":"  if (a->size != b->size) return;", reason:"This check is incomplete. All four vectors involved in the operation must have the same size."}], indent: 1, explanation: "Validate that all four vectors have the same size." },
    { "correct": "  size_t n = a->size;", distractors: [{"text":"  size_t n = 0;", reason:"This would be a bug. `n` must be set to the actual size of the vectors."}], indent: 1, explanation: "Get the size for convenience." },
    { "correct": "  size_t i = 0;", distractors: [{"text":"  size_t i;", reason:"The loop counter `i` must be initialized to 0."}], indent: 1, explanation: "Initialize the loop counter." },
    { "correct": "  // Main SIMD loop for FMA.", distractors: [{"text":"  // Scalar loop for FMA.", reason:"This comment is inaccurate. The following is the unrolled, SIMD-style loop."}], indent: 1, explanation: "Comment on the main FMA loop." },
    { "correct": "  for (; i + SIMD_WIDTH <= n; i += SIMD_WIDTH) {", distractors: [{"text":"  for (i = 0; i < n; i += SIMD_WIDTH) {", reason:"This is a bug. The condition `i < n` could allow the loop to run when there isn't a full block of 4 elements left, causing an out-of-bounds read."}], indent: 1, explanation: "Loop over full SIMD-width blocks." },
    { "correct": "    result->data[i+0] = a->data[i+0] * b->data[i+0] + c->data[i+0];", distractors: [{"text":"    result->data[i+0] = a->data[i+0] + b->data[i+0] * c->data[i+0];", reason:"This is a different operation (a+b*c). The Fused Multiply-Add is defined as a*b+c."}], indent: 2, explanation: "Perform FMA on the first element of the block." },
    { "correct": "    result->data[i+1] = a->data[i+1] * b->data[i+1] + c->data[i+1];", distractors: [{"text":"    result->data[i] = a->data[i+1] * b->data[i+1] + c->data[i+1];", reason:"This is a bug. The result must be stored at index `i+1`, not `i`."}], indent: 2, explanation: "Perform FMA on the second element." },
    { "correct": "    result->data[i+2] = a->data[i+2] * b->data[i+2] + c->data[i+2];", distractors: [{"text":"    result->data[i+2] = a->data[i+2] * b->data[i+2];", reason:"This is a bug. It's missing the final addition of the element from vector `c`."}], indent: 2, explanation: "Perform FMA on the third element." },
    { "correct": "    result->data[i+3] = a->data[i+3] * b->data[i+3] + c->data[i+3];", distractors: [{"text":"    result->data[i+4] = ...;", reason:"This would be an out-of-bounds access, as our SIMD width is 4, so valid offsets are 0, 1, 2, and 3."}], indent: 2, explanation: "Perform FMA on the fourth element." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End of the main FMA loop." },
    { "correct": "  // Scalar cleanup loop for the remainder.", distractors: [{"text":"  // All elements processed.", reason:"This is false. The remainder loop is essential for correctness when the vector size is not a multiple of the SIMD width."}], indent: 1, explanation: "Comment on the remainder handling for FMA." },
    { "correct": "  for (; i < n; i++) {", distractors: [{"text":"  for (i=0; i < n; i++) {", reason:"This is a bug. The loop must start from where the previous SIMD loop left off, not from 0 again."}], indent: 1, explanation: "Loop over the remaining elements." },
    { "correct": "    result->data[i] = a->data[i] * b->data[i] + c->data[i];", distractors: [{"text":"    result->data[i] = 0.0f;", reason:"This would incorrectly zero out the end of the result vector."}], indent: 2, explanation: "Perform FMA on the remaining elements one by one." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End of the FMA cleanup loop." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End `vector_fma_simd`." },
    { "correct": "// === Stage 6: Main Program for Demonstration ===", distractors: [{"text":"// === Stage 6: The SIMD Library ===", reason:"This is the main program that *uses* our vector functions to demonstrate they work, not the library itself."}], indent: 0, explanation: "Set up vectors and demonstrate that both naive and SIMD methods produce the same results." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid, and often preferred, way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start of main." },
    { "correct": "  srand(time(NULL)); // Seed the random number generator.", distractors: [{"text":"  srand(0);", reason:"Seeding with a constant like 0 would cause the program to produce the exact same sequence of 'random' numbers every time it runs."}], indent: 1, explanation: "Ensure we get different random numbers each time." },
    { "correct": "  printf(\"--- SIMD-like Vector Operations Demo (Vector Size: %d) ---\\n\", VECTOR_SIZE);", distractors: [{"text":"  printf(\"--- SIMD Demo ---\\n\");", reason:"This is less informative. Including the vector size provides important context for the test."}], indent: 1, explanation: "Demo title." },
    { "correct": "  // --- Vector Creation and Initialization ---", distractors: [{"text":"  // --- Run Arithmetic ---", reason:"We must first create and initialize the vectors before we can perform arithmetic on them."}], indent: 1, explanation: "Comment on the setup phase." },
    { "correct": "  FloatVector* vec_a = vector_create(VECTOR_SIZE);", distractors: [{"text":"  FloatVector vec_a = vector_create(VECTOR_SIZE);", reason:"This is a type mismatch. `vector_create` returns a pointer (`FloatVector*`), not a struct by value."}], indent: 1, explanation: "Create vector A." },
    { "correct": "  FloatVector* vec_b = vector_create(VECTOR_SIZE);", distractors: [{"text":"  FloatVector* vec_b = vector_create(100);", reason:"This is a bug. For vector arithmetic, all vectors must have the same size (`VECTOR_SIZE`)."}], indent: 1, explanation: "Create vector B." },
    { "correct": "  FloatVector* vec_c = vector_create(VECTOR_SIZE);", distractors: [{"text":"  FloatVector* vec_c = vec_a;", reason:"This would make `vec_c` and `vec_a` point to the same memory. We need a separate vector for the FMA operation."}], indent: 1, explanation: "Create vector C (for FMA)." },
    { "correct": "  FloatVector* result_naive = vector_create(VECTOR_SIZE);", distractors: [{"text":"  FloatVector* result_naive = NULL;", reason:"We need to allocate a vector to hold the result. A `NULL` pointer would cause a crash when passed to the add function."}], indent: 1, explanation: "Create a vector to store the naive result." },
    { "correct": "  FloatVector* result_simd = vector_create(VECTOR_SIZE);", distractors: [{"text":"  FloatVector* result_simd = result_naive;", reason:"We need two separate result vectors to verify that both the naive and SIMD functions produce the same output independently."}], indent: 1, explanation: "Create a vector to store the SIMD result." },
    { "correct": "  vector_fill_random(vec_a);", distractors: [{"text":"  vector_fill_random(&vec_a);", reason:"`vec_a` is already a pointer. Passing its address would be a `FloatVector**`, which is the wrong type for the function."}], indent: 1, explanation: "Fill vector A with random data." },
    { "correct": "  vector_fill_random(vec_b);", distractors: [{"text":"  // vec_b is left empty.", reason:"To test addition, both source vectors need to contain data."}], indent: 1, explanation: "Fill vector B with random data." },
    { "correct": "  vector_fill_random(vec_c);", distractors: [{"text":"  // No need to fill vec_c", reason:"`vec_c` is used as an input to the FMA function, so it must be filled with data."}], indent: 1, explanation: "Fill vector C with random data." },
    { "correct": "  vector_print(vec_a, \"A\");", distractors: [{"text":"  vector_print(*vec_a, \"A\");", reason:"This is a type mismatch. `vector_print` expects a pointer to a vector, not a vector struct passed by value."}], indent: 1, explanation: "Print the first few elements of A." },
    { "correct": "  vector_print(vec_b, \"B\");", distractors: [{"text":"  vector_print(vec_b, 'B');", reason:"The second argument must be a string literal (with double quotes), not a character literal (with single quotes)."}], indent: 1, explanation: "Print the first few elements of B." },
    { "correct": "  vector_print(vec_c, \"C\");", distractors: [{"text":"  vector_print(vec_c);", reason:"This would be a compiler error, as the `vector_print` function requires two arguments."}], indent: 1, explanation: "Print the first few elements of C." },
    { "correct": "  // --- Demonstrate Vector Addition ---", distractors: [{"text":"  // --- Demonstrate FMA ---", reason:"This comment is inaccurate. The following section tests the simple vector addition functions."}], indent: 1, explanation: "Comment on the addition demonstration." },
    { "correct": "  printf(\"\\n--- Testing Vector Addition ---\\n\");", distractors: [{"text":"  puts(\"--- Testing Vector Addition ---\");", reason:"`puts` is a valid and simpler alternative for printing this header."}], indent: 1, explanation: "Header for addition test." },
    { "correct": "  printf(\"Running naive version...\\n\");", distractors: [{"text":"  puts(\"Running naive version...\");", reason:"`puts` is an equally valid way to print this message."}], indent: 1, explanation: "Log naive execution." },
    { "correct": "  vector_add_naive(vec_a, vec_b, result_naive);", distractors: [{"text":"  vector_add_naive(vec_a, vec_b, result_simd);", reason:"We must use the separate `result_naive` vector to store the result of the naive calculation for a fair comparison."}], indent: 1, explanation: "Call the naive add function." },
    { "correct": "  printf(\"Running SIMD version...\\n\");", distractors: [{"text":"  puts(\"Running SIMD version...\");", reason:"`puts` is a valid alternative here."}], indent: 1, explanation: "Log SIMD execution." },
    { "correct": "  vector_add_simd(vec_a, vec_b, result_simd);", distractors: [{"text":"  vector_add_simd(vec_a, vec_b, vec_c);", reason:"`vec_c` contains random data. The result must be stored in the dedicated `result_simd` vector."}], indent: 1, explanation: "Call the SIMD add function." },
    { "correct": "  vector_print(result_naive, \"Result (Naive Add)\");", distractors: [{"text":"  vector_print(result_simd, \"Result (Naive Add)\");", reason:"This would print the SIMD result under the naive label, which would be confusing."}], indent: 1, explanation: "Print the naive result." },
    { "correct": "  vector_print(result_simd, \"Result (SIMD Add)\");", distractors: [{"text":"  // No need to print, assume they are the same.", reason:"You should never assume. The entire point of having a naive implementation is to print both results and verify they are identical, proving the optimized version is correct."}], indent: 1, explanation: "Print the SIMD result (should be identical)." },
    { "correct": "  // --- Demonstrate Fused Multiply-Add ---", distractors: [{"text":"  // --- Demonstrate Vector Subtraction ---", reason:"This section tests the FMA function (a*b+c), not subtraction."}], indent: 1, explanation: "Comment on the FMA demonstration." },
    { "correct": "  printf(\"\\n--- Testing Fused Multiply-Add (FMA) ---\\n\");", distractors: [{"text":"  puts(\"--- Testing FMA ---\");", reason:"`puts` would work, but the original is more descriptive."}], indent: 1, explanation: "Header for FMA test." },
    { "correct": "  printf(\"Running SIMD FMA version...\\n\");", distractors: [{"text":"  puts(\"Running SIMD FMA version...\");", reason:"This is a valid alternative."}], indent: 1, explanation: "Log SIMD FMA execution." },
    { "correct": "  vector_fma_simd(vec_a, vec_b, vec_c, result_simd);", distractors: [{"text":"  vector_add_simd(vec_a, vec_b, result_simd);", reason:"This would call the wrong function, performing addition instead of FMA."}], indent: 1, explanation: "Call the SIMD FMA function." },
    { "correct": "  vector_print(result_simd, \"Result (SIMD FMA)\");", distractors: [{"text":"  vector_print(vec_c, \"Result (SIMD FMA)\");", reason:"This would print one of the input vectors, not the result of the calculation."}], indent: 1, explanation: "Print the FMA result." },
    { "correct": "  // --- Cleanup ---", distractors: [{"text":"  // --- End Program ---", reason:"'Cleanup' is a more descriptive term for the memory deallocation phase that follows."}], indent: 1, explanation: "Comment on the cleanup phase." },
    { "correct": "  printf(\"\\nCleaning up all vectors...\\n\");", distractors: [{"text":"  puts(\"Cleaning up...\");", reason:"This is also valid, but less specific."}], indent: 1, explanation: "Log cleanup." },
    { "correct": "  vector_destroy(vec_a);", distractors: [{"text":"  free(vec_a);", reason:"This is a memory leak. `free(vec_a)` would only free the `FloatVector` struct, but not the `data` array inside it. You must use the custom `vector_destroy` function."}], indent: 1, explanation: "Destroy vector A." },
    { "correct": "  vector_destroy(vec_b);", distractors: [{"text":"  free(vec_b->data);", reason:"This is also a memory leak. It frees the data array but not the `FloatVector` struct itself."}], indent: 1, explanation: "Destroy vector B." },
    { "correct": "  vector_destroy(vec_c);", distractors: [{"text":"  // No need to free vec_c", reason:"This is a memory leak. Every vector created with `vector_create` must be destroyed."}], indent: 1, explanation: "Destroy vector C." },
    { "correct": "  vector_destroy(result_naive);", distractors: [{"text":"  // No need to free result_naive", reason:"This is a memory leak. The result vectors were also dynamically allocated and must be freed."}], indent: 1, explanation: "Destroy the naive result vector." },
    { "correct": "  vector_destroy(result_simd);", distractors: [{"text":"  vector_destroy(NULL);", reason:"While our destroy function can handle NULL safely, this would fail to free the memory associated with `result_simd`."}], indent: 1, explanation: "Destroy the SIMD result vector." },
    { "correct": "  printf(\"--- Demo Finished ---\\n\");", distractors: [{"text":"  puts(\"--- Demo Finished ---\");", reason:"`puts` is a valid alternative for printing this final message."}], indent: 1, explanation: "Final message." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 conventionally signals that an error occurred. The program should return 0 to indicate it ran successfully."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of main." }
]
},
// Level 98: Prep for Google
{
    "goal": "Implement a Trie data structure (prefix tree) to store a dictionary of words and then use it to find all words that start with a given prefix, simulating a search autocomplete feature.",
    "concepts": "Trie, prefix tree, recursion, tree traversal (DFS), dynamic memory allocation, string manipulation",
    "sequence": [
    { "correct": "// === Stage 1: Trie Data Structures and Constants ===", distractors: [{"text":"// === Stage 1: The Main Program ===", reason:"It's standard practice to define the data structures and constants first, as all subsequent logic will depend on them."}], indent: 0, explanation: "Define the structure for a trie node and constants for the alphabet size." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"The standard I/O function `printf` is declared in `<stdio.h>`."}], indent: 0, explanation: "For standard I/O." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <string.h>", reason:"`malloc` and `free` for memory management are prototyped in the standard library, `<stdlib.h>`."}], indent: 0, explanation: "For dynamic memory allocation." },
    { "correct": "#include <stdbool.h>", distractors: [{"text":"// No include needed", reason:"The `bool`, `true`, and `false` keywords are not built into C by default. They are defined as macros in the `<stdbool.h>` header as of the C99 standard."}], indent: 0, explanation: "For using the `bool` type." },
    { "correct": "#include <string.h>", distractors: [{"text":"#include <strings.h>", reason:"The standard C header for string functions like `strlen` and `strcpy` is `<string.h>`."}], indent: 0, explanation: "For string functions like `strlen`." },
    { "correct": "#define ALPHABET_SIZE 26", distractors: [{"text":"const int ALPHABET_SIZE = 26;", reason:"Using `#define` allows `ALPHABET_SIZE` to be used to declare the size of a static array inside our struct, which is not possible with a `const int` variable in C."}], indent: 0, explanation: "The number of possible characters (a-z) for our simple trie." },
    { "correct": "#define MAX_WORD_LENGTH 100", distractors: [{"text":"#define MAX_WORD_LENGTH 100;", reason:"Preprocessor macros should not end with a semicolon, as the semicolon becomes part of the text replacement and can cause syntax errors."}], indent: 0, explanation: "The maximum length of a word we can handle in our autocomplete buffer." },
    { "correct": "// A single node in the Trie data structure.", distractors: [{"text":"// A struct to hold a single word.", reason:"This comment is inaccurate. A single node represents a character in a path; a word is represented by a *sequence* of nodes."}], indent: 0, explanation: "Comment for the TrieNode struct." },
    { "correct": "typedef struct TrieNode {", distractors: [{"text":"struct TrieNode {", reason:"Without `typedef`, we would have to write `struct TrieNode*` every time, which is more verbose. `typedef` creates a convenient alias."}], indent: 0, explanation: "Start of TrieNode struct definition." },
    { "correct": "  struct TrieNode* children[ALPHABET_SIZE];", distractors: [{"text":"  TrieNode* children[ALPHABET_SIZE];", reason:"Because the `typedef` for `TrieNode` is not yet complete within the struct definition, you must use the `struct TrieNode` syntax for self-referential pointers."}], indent: 1, explanation: "An array of pointers to child nodes, one for each letter." },
    { "correct": "  bool isEndOfWord;", distractors: [{"text":"  int isEndOfWord;", reason:"Using an `int` as a boolean flag (0/1) is the traditional C way. Using `bool` from `<stdbool.h>` is more modern and explicitly conveys the intent."}], indent: 1, explanation: "A flag that is true if this node represents the end of a valid word." },
    { "correct": "} TrieNode;", distractors: [{"text":"};", reason:"When using `typedef` with a struct definition, the new type alias (`TrieNode`) must be provided before the final semicolon."}], indent: 0, explanation: "End of TrieNode typedef." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text":"// --- Function Implementations ---", reason:"These are just the forward declarations (prototypes). The function bodies (implementations) come later."}], indent: 0, explanation: "Forward declarations for our Trie functions." },
    { "correct": "TrieNode* trie_create_node();", distractors: [{"text":"void trie_create_node(TrieNode* node);", reason:"A 'constructor' function should handle the allocation itself and return a pointer to the newly created object."}], indent: 0, explanation: "Creates and initializes a single new Trie node." },
    { "correct": "void trie_insert(TrieNode* root, const char* word);", distractors: [{"text":"int trie_insert(TrieNode* root, const char* word);", reason:"An insert operation modifies the trie's state but doesn't typically calculate a value to return, so `void` is an appropriate return type."}], indent: 0, explanation: "Inserts a word into the Trie." },
    { "correct": "bool trie_search(TrieNode* root, const char* word);", distractors: [{"text":"TrieNode* trie_search(TrieNode* root, const char* word);", reason:"While returning the node is a valid design, returning a simple `bool` is often sufficient if the caller only needs to know if the word exists or not."}], indent: 0, explanation: "Searches for an exact word in the Trie." },
    { "correct": "void trie_autocomplete(TrieNode* root, const char* prefix);", distractors: [{"text":"char** trie_autocomplete(TrieNode* root, const char* prefix);", reason:"Returning an array of strings would be a valid, but much more complex, API that would require the caller to manage freeing the memory. Printing the results is simpler for this example."}], indent: 0, explanation: "Finds and prints all words with a given prefix." },
    { "correct": "static void autocomplete_recursive_helper(TrieNode* node, char* prefix, char* current_word_buffer);", distractors: [{"text":"void autocomplete_recursive_helper(...);", reason:"Marking this function as `static` makes it private to this source file. Since it's an internal helper function not meant for external use, this is good practice."}], indent: 0, explanation: "The recursive helper function for the autocomplete feature." },
    { "correct": "void trie_destroy(TrieNode* root);", distractors: [{"text":"void trie_destroy(TrieNode** root);", reason:"The function needs the pointer to the node to free it and its children. A pointer-to-a-pointer is not necessary for this recursive cleanup."}], indent: 0, explanation: "Frees all memory used by the Trie." },
    { "correct": "// === Stage 2: Trie Node Creation and Destruction ===", distractors: [{"text":"// === Stage 2: The Main Program ===", reason:"We must implement the core memory management functions first before we can use them to build a trie in `main`."}], indent: 0, explanation: "Implement the basic functions for managing node memory." },
    { "correct": "TrieNode* trie_create_node() {", distractors: [{"text":"TrieNode trie_create_node() {", reason:"The function must return a pointer (`TrieNode*`) to a dynamically allocated node, not the node struct itself by value."}], indent: 0, explanation: "Begin `trie_create_node` implementation." },
    { "correct": "  TrieNode* new_node = (TrieNode*)malloc(sizeof(TrieNode));", distractors: [{"text":"  TrieNode* new_node = (TrieNode*)malloc(sizeof(TrieNode*));", reason:"This is a critical bug. It allocates memory for a pointer, not the entire, much larger, TrieNode struct, which would lead to a buffer overflow."}], indent: 1, explanation: "Allocate memory for a new node." },
    { "correct": "  if (new_node) {", distractors: [{"text":"  if (new_node != NULL) {", reason:"This is an equally valid and often clearer way to check if the `malloc` call was successful."}], indent: 1, explanation: "Check if allocation was successful." },
    { "correct": "    new_node->isEndOfWord = false;", distractors: [{"text":"  new_node.isEndOfWord = false;", reason:"`new_node` is a pointer. The arrow operator `->` must be used to access members of a struct through a pointer."}], indent: 2, explanation: "A new node is not the end of a word by default." },
    { "correct": "    for (int i = 0; i < ALPHABET_SIZE; i++) {", distractors: [{"text":"    for (int i = 0; i <= ALPHABET_SIZE; i++) {", reason:"This is an off-by-one error. The loop would iterate 27 times, causing an out-of-bounds write on the `children` array."}], indent: 2, explanation: "Loop through the children array." },
    { "correct": "      new_node->children[i] = NULL;", distractors: [{"text":"      // No initialization needed", reason:"This is a critical bug. The children pointers would hold garbage addresses, and any attempt to traverse the trie would crash."}], indent: 3, explanation: "Initialize all child pointers to NULL." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 2, explanation: "End children initialization loop." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 1, explanation: "End successful allocation block." },
    { "correct": "  return new_node;", distractors: [{"text":"  return *new_node;", reason:"This is a type mismatch. The function must return a pointer (`TrieNode*`), not the struct itself."}], indent: 1, explanation: "Return the newly created and initialized node." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End `trie_create_node`." },
    { "correct": "void trie_destroy(TrieNode* root) {", distractors: [{"text":"void trie_destroy(const TrieNode* root) {", reason:"A destroy function frees memory, which is a 'modifying' action. The pointer should not be `const`."}], indent: 0, explanation: "Begin `trie_destroy` implementation." },
    { "correct": "  if (!root) return;", distractors: [{"text":"  // No base case needed", reason:"This is false. The recursive function must have a base case to stop the recursion. Here, the base case is when it reaches a NULL child pointer."}], indent: 1, explanation: "Base case for recursion: do nothing if the node is NULL." },
    { "correct": "  for (int i = 0; i < ALPHABET_SIZE; i++) {", distractors: [{"text":"  free(root);", reason:"This is a bug. You must recursively destroy all children *before* freeing the current node, otherwise you will leak all the memory for the subtrees."}], indent: 1, explanation: "Loop through all possible children." },
    { "correct": "    if (root->children[i]) {", distractors: [{"text":"    trie_destroy(root->children[i]);", reason:"This is unsafe. You must check if the child pointer is not NULL before making the recursive call."}], indent: 2, explanation: "If a child exists..." },
    { "correct": "      trie_destroy(root->children[i]);", distractors: [{"text":"      free(root->children[i]);", reason:"This is a bug. Simply freeing the child would not free *its* children. A recursive call to `trie_destroy` is required to clean up the entire subtree."}], indent: 3, explanation: "Recursively call destroy on that child." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 2, explanation: "End child check." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End child loop." },
    { "correct": "  free(root);", distractors: [{"text":"  // No need to free root", reason:"This is a memory leak. Every node allocated with `trie_create_node` (which uses `malloc`) must be freed."}], indent: 1, explanation: "After all children are destroyed, free the current node." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "End `trie_destroy`." },
    { "correct": "// === Stage 3: Core Trie Operations - Insertion and Search ===", distractors: [{"text":"// === Stage 3: Autocomplete ===", reason:"Before we can implement autocomplete, we need the fundamental `insert` and `search` operations."}], indent: 0, explanation: "Implement the functions to add words and search for them." },
    { "correct": "void trie_insert(TrieNode* root, const char* word) {", distractors: [{"text":"bool trie_insert(TrieNode* root, const char* word) {", reason:"The function definition must match the prototype. This function doesn't need to return a value, so `void` is appropriate."}], indent: 0, explanation: "Begin `trie_insert` implementation." },
    { "correct": "  TrieNode* current_node = root;", distractors: [{"text":"  TrieNode* current_node = trie_create_node();", reason:"This is a bug. The insertion must start from the existing `root` of the tree, not a new, detached node."}], indent: 1, explanation: "Start traversing from the root node." },
    { "correct": "  int len = strlen(word);", distractors: [{"text":"  size_t len = strlen(word);", reason:"Using `size_t` (the type returned by `strlen`) is more correct and portable than using `int`."}], indent: 1, explanation: "Get the length of the word to insert." },
    { "correct": "  for (int i = 0; i < len; i++) {", distractors: [{"text":"  while (*word) { ... word++; }", reason:"Using a `while` loop with a pointer is a valid alternative to a `for` loop with an index for iterating through a string."}], indent: 1, explanation: "Iterate through each character of the word." },
    { "correct": "    int index = word[i] - 'a';", distractors: [{"text":"    int index = word[i];", reason:"This is a bug. This would use the character's raw ASCII value (e.g., 97 for 'a') as the index, which is out of bounds for our `children` array (0-25)."}], indent: 2, explanation: "Calculate the character's index (0-25). Assumes lowercase 'a'-'z'." },
    { "correct": "    if (index < 0 || index >= ALPHABET_SIZE) continue; // Skip non-alphabetic chars", distractors: [{"text":"    // Assume all characters are valid", reason:"This is unsafe. Without validation, a character like 'A' or '-' would produce an out-of-bounds index, causing a crash."}], indent: 2, explanation: "Basic validation for character range." },
    { "correct": "    if (!current_node->children[index]) {", distractors: [{"text":"    if (current_node->children[index]) {", reason:"This logic is reversed. We should only create a new node if one *doesn't* already exist for the current character."}], indent: 2, explanation: "If the path for this character does not exist..." },
    { "correct": "      current_node->children[index] = trie_create_node();", distractors: [{"text":"      // Path doesn't exist, word cannot be inserted", reason:"This is a fundamental misunderstanding of a trie. If the path doesn't exist, the `insert` function's job is to *create* it."}], indent: 3, explanation: "Create a new node for it." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 2, explanation: "End node creation check." },
    { "correct": "    current_node = current_node->children[index];", distractors: [{"text":"    // No need to update current_node", reason:"This is a bug. We must advance the `current_node` pointer down the tree to follow the path for the word."}], indent: 2, explanation: "Move down to the next node in the path." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End of word character loop." },
    { "correct": "  // Mark the last node as the end of a word.", distractors: [{"text":"  // The word is now inserted.", reason:"This is incomplete. We must explicitly mark the final node to distinguish between a prefix (like 'car') and a complete word (like 'cart')."}], indent: 1, explanation: "Comment on marking the end of the word." },
    { "correct": "  current_node->isEndOfWord = true;", distractors: [{"text":"  current_node->isEndOfWord = 1;", reason:"Using `true` from `<stdbool.h>` is more expressive, but assigning `1` is also perfectly valid and common."}], indent: 1, explanation: "Set the flag on the final node." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to end a function block."}], indent: 0, explanation: "End `trie_insert`." },
    { "correct": "bool trie_search(TrieNode* root, const char* word) {", distractors: [{"text":"bool trie_search(const TrieNode* root, const char* word) {", reason:"The definition must match the prototype. Since search doesn't modify the trie, the `root` could have been declared `const`."}], indent: 0, explanation: "Begin `trie_search` implementation." },
    { "correct": "  TrieNode* current_node = root;", distractors: [{"text":"  TrieNode* current_node = NULL;", reason:"The search must start from the provided `root` of the trie."}], indent: 1, explanation: "Start traversal from the root." },
    { "correct": "  int len = strlen(word);", distractors: [{"text":"  // No length needed", reason:"Calculating the length once at the start is more efficient than calling it in the loop condition."}], indent: 1, explanation: "Get the length of the word to search for." },
    { "correct": "  for (int i = 0; i < len; i++) {", distractors: [{"text":"  for (int i = 0; i <= len; i++) {", reason:"This is a bug. This would read past the end of the `word` string, checking for the null terminator as if it were a character."}], indent: 1, explanation: "Iterate through each character." },
    { "correct": "    int index = word[i] - 'a';", distractors: [{"text":"    int index = word[i];", reason:"This would use the character's ASCII value as an index, causing an out-of-bounds access on the `children` array."}], indent: 2, explanation: "Calculate the character's index." },
    { "correct": "    if (index < 0 || index >= ALPHABET_SIZE || !current_node->children[index]) {", distractors: [{"text":"    if (!current_node->children[index]) {", reason:"This is incomplete. It doesn't guard against invalid characters (like uppercase letters or symbols) that would produce an invalid index."}], indent: 2, explanation: "If the char is invalid or the path doesn't exist..." },
    { "correct": "      return false; // The word is not in the trie.", distractors: [{"text":"      return NULL;", reason:"This is a type mismatch. The function is declared to return a `bool`, so it should return `true` or `false`."}], indent: 3, explanation: "Return false immediately." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 2, explanation: "End path check." },
    { "correct": "    current_node = current_node->children[index];", distractors: [{"text":"    current_node = current_node->children[word[i]];", reason:"This is a bug. You must use the calculated 0-25 `index`, not the raw ASCII value of the character."}], indent: 2, explanation: "Move down to the next node." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End character loop." },
    { "correct": "  // The word is found only if the final node exists and is marked as the end of a word.", distractors: [{"text":"  // If we reached here, the word was found.", reason:"This is incorrect. We could be at the end of a path for a valid *prefix* (like 'car') which is not itself a complete word in the dictionary."}], indent: 1, explanation: "Comment on the final condition." },
    { "correct": "  return (current_node != NULL && current_node->isEndOfWord);", distractors: [{"text":"  return current_node != NULL;", reason:"This is a bug. This would incorrectly return `true` for a prefix that is not a complete word (e.g., searching for 'appl' when 'apple' exists)."}], indent: 1, explanation: "Return true if the full path exists and is a valid word." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End `trie_search`." },
    { "correct": "// === Stage 4: Autocomplete Implementation ===", distractors: [{"text":"// === Stage 4: Trie Insertion ===", reason:"This stage implements the more complex autocomplete search, which builds upon the basic insert/search functions."}], indent: 0, explanation: "Implement the main autocomplete logic and its recursive helper." },
    { "correct": "static void autocomplete_recursive_helper(TrieNode* node, char* prefix, char* current_word_buffer) {", distractors: [{"text":"void autocomplete_recursive_helper(TrieNode* node, const char* prefix, ...)", reason:"The definition must match the prototype. `prefix` is only read, so it could be `const`, but the buffer is modified, so it must be `char*`."}], indent: 0, explanation: "Begin the recursive helper function." },
    { "correct": "  if (node->isEndOfWord) {", distractors: [{"text":"  // No need to check this here.", reason:"This is the base case for a successful find. If the current node marks the end of a word, we must print it."}], indent: 1, explanation: "Check if the current node represents a complete word." },
    { "correct": "    printf(\"  -> %s%s\\n\", prefix, current_word_buffer);", distractors: [{"text":"    printf(\"  -> %s\\n\", current_word_buffer);", reason:"This would only print the *suffix* found after the prefix, not the complete word."}], indent: 2, explanation: "If so, print the original prefix plus the suffix we've built." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End of word check." },
    { "correct": "  // Recursively explore all children of the current node.", distractors: [{"text":"  // Iteratively explore children.", reason:"This describes a different algorithm (Breadth-First Search). The recursive implementation here is a Depth-First Search (DFS)."}], indent: 1, explanation: "Comment on the recursive step (DFS)." },
    { "correct": "  for (int i = 0; i < ALPHABET_SIZE; i++) {", distractors: [{"text":"  if (node->children[i]) {", reason:"An `if` would only check the first child. A `for` loop is needed to explore all 26 possible child paths."}], indent: 1, explanation: "Iterate through all possible child characters." },
    { "correct": "    if (node->children[i]) {", distractors: [{"text":"    // No check needed", reason:"This is a bug. If we don't check for a NULL child, the recursive call would crash."}], indent: 2, explanation: "If a child node exists for this character..." },
    { "correct": "      int len = strlen(current_word_buffer);", distractors: [{"text":"      // len is not needed", reason:"`len` is crucial. It tells us where to append the new character and where to place the null terminator when we backtrack."}], indent: 3, explanation: "Get the length of the current suffix." },
    { "correct": "      current_word_buffer[len] = i + 'a';", distractors: [{"text":"      current_word_buffer[len] = i;", reason:"This would append a non-printable control character, not the correct letter."}], indent: 3, explanation: "Append the new character to the suffix buffer." },
    { "correct": "      current_word_buffer[len + 1] = '\\0';", distractors: [{"text":"      // No null terminator needed.", reason:"This is a bug. Without a null terminator, `printf` would read past the end of the buffer, printing garbage."}], indent: 3, explanation: "Null-terminate the updated suffix." },
    { "correct": "      autocomplete_recursive_helper(node->children[i], prefix, current_word_buffer);", distractors: [{"text":"      autocomplete_recursive_helper(node, prefix, current_word_buffer);", reason:"This would be a bug causing infinite recursion. The recursive call must be on the *child* node."}], indent: 3, explanation: "Make the recursive call on the child node." },
    { "correct": "      current_word_buffer[len] = '\\0';", distractors: [{"text":"      // No need to backtrack", reason:"This is a critical bug. Without backtracking (resetting the buffer), the buffer would grow incorrectly (e.g., 'ap' -> 'app' -> 'appl' -> 'applel' instead of 'apple')."}] , indent: 3, explanation: "Backtrack: remove the character we just added to explore other branches." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 2, explanation: "End of child check." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End of child loop." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End of `autocomplete_recursive_helper`." },
    { "correct": "void trie_autocomplete(TrieNode* root, const char* prefix) {", distractors: [{"text":"char** trie_autocomplete(TrieNode* root, const char* prefix) {", reason:"The definition must match the prototype. This function prints results directly."}], indent: 0, explanation: "Begin the main autocomplete function." },
    { "correct": "  printf(\"\\n--- Autocomplete results for prefix '%s' ---\\n\", prefix);", distractors: [{"text":"  printf(\"Autocomplete results:\\n\");", reason:"This is less informative. Echoing the prefix being searched for is better user feedback."}], indent: 1, explanation: "Print a header for the results." },
    { "correct": "  TrieNode* current_node = root;", distractors: [{"text":"  TrieNode* current_node = NULL;", reason:"The traversal must start from the provided `root` node."}], indent: 1, explanation: "Start traversal from the root." },
    { "correct": "  int len = strlen(prefix);", distractors: [{"text":"  // No len needed", reason:"Getting the length once is more efficient than calling `strlen` repeatedly in the loop condition."}], indent: 1, explanation: "Get the length of the prefix." },
    { "correct": "  // Traverse the trie to the node corresponding to the end of the prefix.", distractors: [{"text":"  // Search for the full prefix.", reason:"This is a good description of this phase of the algorithm."}], indent: 1, explanation: "Comment on the first phase: finding the prefix node." },
    { "correct": "  for (int i = 0; i < len; i++) {", distractors: [{"text":"  while (*prefix) { ... prefix++; }", reason:"Using a `while` loop with a moving pointer is an equally valid way to iterate through the prefix string."}], indent: 1, explanation: "Loop through each character of the prefix." },
    { "correct": "    int index = prefix[i] - 'a';", distractors: [{"text":"    int index = prefix[i];", reason:"This would use the character's raw ASCII value as the index, which would be out of bounds for the `children` array."}], indent: 2, explanation: "Calculate the character's index." },
    { "correct": "    if (index < 0 || index >= ALPHABET_SIZE || !current_node->children[index]) {", distractors: [{"text":"    if (!current_node->children[index]) {", reason:"This is less safe. It doesn't protect against invalid characters in the prefix (like uppercase letters) that would create an out-of-bounds index."}], indent: 2, explanation: "If the prefix itself doesn't exist in the trie..." },
    { "correct": "      printf(\"  -> No words found with this prefix.\\n\");", distractors: [{"text":"      puts(\"  -> No words found with this prefix.\");", reason:"`puts` is a valid and simpler way to print this message."}], indent: 3, explanation: "Print a message and exit." },
    { "correct": "      return;", distractors: [{"text":"      break;", reason:"`break` would exit the `for` loop, but the code would then incorrectly proceed to the recursive helper. `return` exits the function entirely."}], indent: 3, explanation: "Return from the function." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 2, explanation: "End of prefix path check." },
    { "correct": "    current_node = current_node->children[index];", distractors: [{"text":"    // No need to advance", reason:"This is a bug. You must advance the `current_node` pointer to follow the path of the prefix."}], indent: 2, explanation: "Move down to the next node in the prefix path." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End prefix traversal loop." },
    { "correct": "  // Now, from this node, find all descendant words.", distractors: [{"text":"  // The search is complete.", reason:"This is incorrect. We have only found the *end of the prefix*. Now we must start a new search (a DFS) from this node to find all words that follow."}], indent: 1, explanation: "Comment on the second phase: collecting words." },
    { "correct": "  char word_buffer[MAX_WORD_LENGTH];", distractors: [{"text":"  char* word_buffer = malloc(MAX_WORD_LENGTH);", reason:"For a temporary buffer used within a single function, a stack-allocated array is simpler and safer as it's automatically deallocated."}], indent: 1, explanation: "Create a buffer to build the word suffixes." },
    { "correct": "  word_buffer[0] = '\\0';", distractors: [{"text":"  memset(word_buffer, 0, MAX_WORD_LENGTH);", reason:"`memset` is also a perfectly valid way to initialize the buffer to all zeros, which includes the first null terminator."}], indent: 1, explanation: "Initialize the buffer as an empty string." },
    { "correct": "  char prefix_copy[MAX_WORD_LENGTH];", distractors: [{"text":"  // No copy needed", reason:"This is incorrect. The `prefix` parameter is `const`. The helper function needs a mutable buffer to pass to `printf`."}], indent: 1, explanation: "Create a mutable copy of the prefix." },
    { "correct": "  strcpy(prefix_copy, prefix);", distractors: [{"text":"  strncpy(prefix_copy, prefix, MAX_WORD_LENGTH - 1);", reason:"Using `strncpy` is a safer alternative to `strcpy` as it prevents buffer overflows if the prefix is too long."}], indent: 1, explanation: "Copy the prefix into the mutable buffer." },
    { "correct": "  autocomplete_recursive_helper(current_node, prefix_copy, word_buffer);", distractors: [{"text":"  autocomplete_recursive_helper(root, prefix_copy, word_buffer);", reason:"This is a bug. The recursive search must start from `current_node` (the end of the prefix), not from the `root` of the whole trie."}], indent: 1, explanation: "Call the recursive helper to start the search." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "End `trie_autocomplete`." },
    { "correct": "// === Stage 5: Main Program for Demonstration ===", distractors: [{"text":"// === Stage 5: The Trie Library ===", reason:"This is the main program that *uses* our Trie library to demonstrate its features."}], indent: 0, explanation: "Set up a dictionary and test the autocomplete functionality." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid and often preferred way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start of main." },
    { "correct": "  printf(\"--- Trie Autocomplete Demo ---\\n\");", distractors: [{"text":"  puts(\"--- Trie Autocomplete Demo ---\");", reason:"`puts` is a valid alternative that also prints a newline."}], indent: 1, explanation: "Demo title." },
    { "correct": "  TrieNode* root = trie_create_node();", distractors: [{"text":"  TrieNode root;", reason:"Our API is designed to work with pointers to dynamically allocated nodes. A stack variable would not work correctly with our functions."}], indent: 1, explanation: "Create the root of the Trie." },
    { "correct": "  // Insert a dictionary of words.", distractors: [{"text":"  // Search for words.", reason:"We must insert words into the trie before we can search for them."}], indent: 1, explanation: "Comment on populating the trie." },
    { "correct": "  const char* dictionary[] = {\"apple\", \"apply\", \"apricot\", \"ape\", \"application\", \"banana\", \"bandana\", \"band\", \"car\", \"cat\", \"cart\"};", distractors: [{"text":"  char* dictionary[] = {\"apple\", ...};", reason:"An array of string literals should be `const char*` because the string data itself is read-only."}], indent: 1, explanation: "Define an array of strings for our dictionary." },
    { "correct": "  int dict_size = sizeof(dictionary) / sizeof(dictionary[0]);", distractors: [{"text":"  int dict_size = 11;", reason:"Hardcoding the size is bad practice. If you change the dictionary, you might forget to update the count. The `sizeof` method is robust and calculates it automatically."}], indent: 1, explanation: "Calculate the number of words in the dictionary." },
    { "correct": "  printf(\"Inserting %d words into the Trie...\\n\", dict_size);", distractors: [{"text":"  printf(\"Inserting words...\\n\");", reason:"This is less informative. Printing the number of words is better for verification."}], indent: 1, explanation: "Log the insertion process." },
    { "correct": "  for (int i = 0; i < dict_size; i++) {", distractors: [{"text":"  int i=0; while(i < dict_size) { ... i++; }", reason:"A `while` loop is an equally valid way to structure this iteration."}], indent: 1, explanation: "Loop through the dictionary." },
    { "correct": "    trie_insert(root, dictionary[i]);", distractors: [{"text":"    trie_insert(&root, dictionary[i]);", reason:"`root` is already a pointer. Passing its address would be a `TrieNode**`, which is the wrong type for the function."}], indent: 2, explanation: "Insert each word into the trie." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End insertion loop." },
    { "correct": "  // --- Test Search Functionality ---", distractors: [{"text":"  // --- Test Autocomplete ---", reason:"This section tests the basic, exact-match `search` function first."}], indent: 1, explanation: "Comment on testing exact search." },
    { "correct": "  printf(\"\\nSearching for 'apple': %s\\n\", trie_search(root, \"apple\") ? \"Found\" : \"Not Found\");", distractors: [{"text":"  if (trie_search(root, \"apple\")) { printf(\"Found\\n\"); }", reason:"The ternary operator `? :` is a more compact way to write a simple if/else expression like this."}], indent: 1, explanation: "Search for a word that exists." },
    { "correct": "  printf(\"Searching for 'appl': %s\\n\", trie_search(root, \"appl\") ? \"Found\" : \"Not Found\");", distractors: [{"text":"  printf(\"Searching for 'appl': %s\\n\", trie_autocomplete(root, \"appl\") ? ...);", reason:"This is incorrect. We are testing the exact `search` function, which should return false for a prefix, not the `autocomplete` function."}], indent: 1, explanation: "Search for a prefix that is not a complete word." },
    { "correct": "  printf(\"Searching for 'banana': %s\\n\", trie_search(root, \"banana\") ? \"Found\" : \"Not Found\");", distractors: [{"text":"  printf(\"Searching for 'banana': %d\\n\", trie_search(root, \"banana\"));", reason:"The `%d` format specifier would print the boolean `true` as the integer `1`, which is less readable than printing the string \"Found\"."}], indent: 1, explanation: "Search for another existing word." },
    { "correct": "  printf(\"Searching for 'banned': %s\\n\", trie_search(root, \"banned\") ? \"Found\" : \"Not Found\");", distractors: [{"text":"  printf(\"Searching for 'banned': %s\\n\", \"Not Found\");", reason:"You must call the `trie_search` function to actually perform the search and get the result."}], indent: 1, explanation: "Search for a word that does not exist." },
    { "correct": "  // --- Test Autocomplete Functionality ---", distractors: [{"text":"  // --- Test Search ---", reason:"This section is specifically for testing the autocomplete feature."}], indent: 1, explanation: "Comment on testing the autocomplete feature." },
    { "correct": "  trie_autocomplete(root, \"ap\");", distractors: [{"text":"  trie_search(root, \"ap\");", reason:"`trie_search` would just return `false`. We need to call the `trie_autocomplete` function to get the list of suggestions."}], indent: 1, explanation: "Test autocomplete with prefix 'ap'." },
    { "correct": "  trie_autocomplete(root, \"band\");", distractors: [{"text":"  trie_autocomplete(root, \"bandana\");", reason:"While this would work, 'band' is a better test case because it is a prefix for multiple words."}], indent: 1, explanation: "Test autocomplete with prefix 'band'." },
    { "correct": "  trie_autocomplete(root, \"ca\");", distractors: [{"text":"  trie_autocomplete(root, \"car\");", reason:"'ca' is a better prefix test, as it should return 'car', 'cat', and 'cart'."}], indent: 1, explanation: "Test autocomplete with prefix 'ca'." },
    { "correct": "  trie_autocomplete(root, \"z\");", distractors: [{"text":"  trie_autocomplete(root, \"apple\");", reason:"It's important to test edge cases, such as a prefix that has no matches in the dictionary."}], indent: 1, explanation: "Test autocomplete with a prefix that has no matches." },
    { "correct": "  // --- Cleanup ---", distractors: [{"text":"  // --- End of program ---", reason:"'Cleanup' is a more descriptive term for the memory deallocation phase."}], indent: 1, explanation: "Comment on memory cleanup." },
    { "correct": "  printf(\"\\nDestroying the Trie...\\n\");", distractors: [{"text":"  puts(\"\\nDestroying the Trie...\");", reason:"`puts` adds its own newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Log the destruction." },
    { "correct": "  trie_destroy(root);", distractors: [{"text":"  free(root);", reason:"This is a massive memory leak. `free(root)` would only free the single root node, not the thousands of other nodes in the trie. The recursive `trie_destroy` function is mandatory."}], indent: 1, explanation: "Call the recursive destroy function to free all memory." },
    { "correct": "  printf(\"--- Demo Finished ---\\n\");", distractors: [{"text":"  puts(\"--- Demo Finished ---\");", reason:"`puts` is a valid alternative for printing this message."}], indent: 1, explanation: "Final message." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 conventionally signals an error. Since the demo completed successfully, it should return 0."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of main." }
]
},
// Level 99: Prep for Microsoft
{
    "goal": "Implement a simplified in-memory virtual file system (VFS) that supports creating directories and files, writing/reading file content, and listing directory contents.",
    "concepts": "Tree data structures, file system concepts (inodes, paths), recursion, string parsing, dynamic memory allocation, pointers",
    "sequence": [
    { "correct": "// === Stage 1: VFS Data Structures and Enums ===", distractors: [{"text":"// === Stage 1: The Main Program ===", reason:"Good software design starts with defining the core data structures first, as all subsequent logic will depend on them."}], indent: 0, explanation: "Define the fundamental structures for files, directories, and the file system itself." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"The standard I/O function `printf` is declared in `<stdio.h>`."}], indent: 0, explanation: "For standard input/output functions." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <string.h>", reason:"`malloc`, `free`, and `realloc` for memory management are prototyped in the standard library, `<stdlib.h>`."}], indent: 0, explanation: "For memory management (malloc, free, realloc)." },
    { "correct": "#include <string.h>", distractors: [{"text":"#include <strings.h>", reason:"The standard C header for string functions like `strcpy`, `strtok`, and `strdup` is `<string.h>`."}], indent: 0, explanation: "For string manipulation (strcpy, strtok, strdup)." },
    { "correct": "#include <stdbool.h>", distractors: [{"text":"// No include needed for bool", reason:"The `bool`, `true`, and `false` keywords are not built into C by default. They are defined as macros in the `<stdbool.h>` header."}], indent: 0, explanation: "For the boolean type." },
    { "correct": "#include <time.h>", distractors: [{"text":"#include <sys/time.h>", reason:"`<sys/time.h>` is for more advanced time functions like `gettimeofday`. The standard `time()` function is in `<time.h>`."}], indent: 0, explanation: "For managing file timestamps." },
    { "correct": "#define MAX_NAME_LEN 256", distractors: [{"text":"const int MAX_NAME_LEN = 256;", reason:"Using `#define` allows `MAX_NAME_LEN` to be used to declare the size of an array member inside our struct, which is not possible with a `const int` variable in older C standards."}], indent: 0, explanation: "Maximum length for a file or directory name." },
    { "correct": "// Enum to distinguish between file and directory nodes.", distractors: [{"text":"// An integer to distinguish node types.", reason:"An `enum` is more expressive and provides better type safety than using raw integers (e.g., 0 for file, 1 for directory)."}], indent: 0, explanation: "Comment for the NodeType enum." },
    { "correct": "typedef enum { NODE_FILE, NODE_DIRECTORY } NodeType;", distractors: [{"text":"#define NODE_FILE 0\n#define NODE_DIRECTORY 1", reason:"Using `#define` works, but an `enum` is generally preferred as it creates a distinct type (`NodeType`) for better code clarity and safety."}], indent: 0, explanation: "Defines the two types of nodes in our VFS." },
    { "correct": "// The core VFS node, acting like an 'inode'.", distractors: [{"text":"// The main VFS control struct.", reason:"This comment is inaccurate. This struct represents a single file or directory 'inode', not the entire file system."}], indent: 0, explanation: "Comment for the VFSNode struct." },
    { "correct": "typedef struct VFSNode {", distractors: [{"text":"struct VFSNode {", reason:"Without `typedef`, we would have to write `struct VFSNode*` every time we refer to a pointer of this type, which is more verbose."}], indent: 0, explanation: "Start of the VFSNode definition." },
    { "correct": "  char name[MAX_NAME_LEN];", distractors: [{"text":"  char* name;", reason:"Using `char*` would require an extra `malloc` for every single file/directory name. A fixed-size array is simpler for this design, though less flexible."}], indent: 1, explanation: "The name of this file or directory." },
    { "correct": "  NodeType type;", distractors: [{"text":"  int type;", reason:"Using the specific `NodeType` enum is clearer and provides better type safety than a generic `int`."}], indent: 1, explanation: "The type of this node." },
    { "correct": "  time_t creation_time;", distractors: [{"text":"  int creation_time;", reason:"`time_t` is the appropriate data type for storing time values returned by the `time()` function, as its actual representation (e.g., a 32-bit or 64-bit integer) can vary."}], indent: 1, explanation: "Timestamp for when the node was created." },
    { "correct": "  struct VFSNode* parent;", distractors: [{"text":"  // No parent pointer needed.", reason:"While not strictly needed for top-down traversal, a `parent` pointer is essential for implementing features like `cd ..` or resolving relative paths."}], indent: 1, explanation: "Pointer to the parent directory node." },
    { "correct": "  // Directory-specific members", distractors: [{"text":"  // File-specific members", reason:"This comment is inaccurate. `first_child` is relevant only for directories."}], indent: 1, explanation: "Comment for directory data." },
    { "correct": "  struct VFSNode* first_child;", distractors: [{"text":"  struct VFSNode* children[100];", reason:"A fixed-size array limits a directory to 100 children. The 'first child, next sibling' linked list approach is more flexible and allows an unlimited number of entries."}], indent: 1, explanation: "Pointer to the first child in a linked list of children." },
    { "correct": "  // File-specific members", distractors: [{"text":"  // Directory-specific members", reason:"This comment is inaccurate. `content` is relevant only for files."}], indent: 1, explanation: "Comment for file data." },
    { "correct": "  char* content;", distractors: [{"text":"  char content[4096];", reason:"A fixed-size buffer limits all files to 4KB. Using a `char*` allows each file to have a dynamically sized content buffer."}], indent: 1, explanation: "Pointer to the file's content buffer." },
    { "correct": "  size_t content_size;", distractors: [{"text":"  int content_size;", reason:"`size_t` is the correct and portable type for representing memory sizes."}], indent: 1, explanation: "The size of the content buffer." },
    { "correct": "  // Sibling pointer for the linked list", distractors: [{"text":"  // Child pointer", reason:"This pointer doesn't point to a child, but to a sibling (another node at the same level in the same directory)."}], indent: 1, explanation: "Comment for the sibling pointer." },
    { "correct": "  struct VFSNode* next_sibling;", distractors: [{"text":"  VFSNode next_sibling;", reason:"A struct cannot contain a full instance of itself, as this would require infinite memory. It must be a pointer."}], indent: 1, explanation: "Pointer to the next node in the same directory." },
    { "correct": "} VFSNode;", distractors: [{"text":"};", reason:"To complete the `typedef`, you must provide the new type alias (`VFSNode`) before the final semicolon."}], indent: 0, explanation: "End of VFSNode definition." },
    { "correct": "// Main VFS control structure.", distractors: [{"text":"// A struct for a directory.", reason:"This is the main struct for the *entire file system*, which contains the root directory."}], indent: 0, explanation: "Comment for the VFS struct." },
    { "correct": "typedef struct {", distractors: [{"text":"struct VFS {", reason:"Using `typedef` is a convenience that allows us to declare variables as `VFS* vfs;` instead of `struct VFS* vfs;`."}], indent: 0, explanation: "Start of VFS struct definition." },
    { "correct": "  VFSNode* root;", distractors: [{"text":"  VFSNode root;", reason:"The root must be a pointer to a dynamically allocated node. Storing the full node here would make the `VFS` struct very large and inflexible."}], indent: 1, explanation: "Pointer to the root directory ('/') of the file system." },
    { "correct": "} VFS;", distractors: [{"text":"} VFS", reason:"A `typedef` statement must end with a semicolon."}], indent: 0, explanation: "End of VFS struct definition." },
    { "correct": "// --- Function Prototypes ---", distractors: [{"text":"// --- Function Implementations ---", reason:"These are just forward declarations (prototypes). The function bodies (implementations) are defined later."}], indent: 0, explanation: "Forward declarations for our VFS API." },
    { "correct": "VFS* vfs_init();", distractors: [{"text":"void vfs_init(VFS* vfs);", reason:"A 'constructor' function typically handles its own allocation and returns a pointer to the new object, which is a clean API design."}], indent: 0, explanation: "Initializes the entire VFS." },
    { "correct": "void vfs_shutdown(VFS* vfs);", distractors: [{"text":"int vfs_shutdown(VFS* vfs);", reason:"A 'shutdown' or 'destroy' function's job is to clean up memory; it doesn't need to return a value, so `void` is appropriate."}], indent: 0, explanation: "Frees all memory used by the VFS." },
    { "correct": "VFSNode* vfs_get_node(VFS* vfs, const char* path);", distractors: [{"text":"bool vfs_get_node(VFS* vfs, const char* path);", reason:"Returning a boolean only tells you if the node exists. Returning a pointer (`VFSNode*`) is more useful as it allows the caller to interact with the found node."}], indent: 0, explanation: "Finds a node given its absolute path." },
    { "correct": "bool vfs_mkdir(VFS* vfs, const char* path);", distractors: [{"text":"void vfs_mkdir(VFS* vfs, const char* path);", reason:"Returning a `bool` is good API design, as it allows the function to signal to the caller whether the directory was created successfully or not."}], indent: 0, explanation: "Creates a new directory." },
    { "correct": "bool vfs_create_file(VFS* vfs, const char* path);", distractors: [{"text":"VFSNode* vfs_create_file(VFS* vfs, const char* path);", reason:"While returning the new node is a valid design, returning a simple `bool` for success/failure is often sufficient."}], indent: 0, explanation: "Creates a new empty file." },
    { "correct": "bool vfs_write(VFS* vfs, const char* path, const char* data);", distractors: [{"text":"void vfs_write(VFS* vfs, const char* path, const char* data);", reason:"Returning a `bool` allows the function to indicate if the write operation was successful."}], indent: 0, explanation: "Writes data to a file, overwriting existing content." },
    { "correct": "char* vfs_read(VFS* vfs, const char* path);", distractors: [{"text":"const char* vfs_read(VFS* vfs, const char* path);", reason:"Returning `const char*` would be safer to prevent modification of internal data. Returning `char*` is a design choice that implies the caller might want to modify the content (though that's not supported here)."}], indent: 0, explanation: "Reads the content of a file." },
    { "correct": "void vfs_ls(VFS* vfs, const char* path);", distractors: [{"text":"void vfs_ls(VFSNode* node);", reason:"The public API should work with user-friendly paths, not internal node pointers. The function can then use `vfs_get_node` internally."}], indent: 0, explanation: "Lists the contents of a directory." },
    { "correct": "static void vfs_free_node_recursive(VFSNode* node);", distractors: [{"text":"void vfs_free_node_recursive(VFSNode* node);", reason:"Marking this function as `static` makes it private to this source file. Since it's an internal helper for `vfs_shutdown`, it should not be part of the public API."}], indent: 0, explanation: "Internal helper to recursively free nodes." },
    { "correct": "// === Stage 2: Initialization and Shutdown Logic ===", distractors: [{"text":"// === Stage 2: The Main Program ===", reason:"First, we must implement the core setup/teardown functions before we can use them in a main program."}], indent: 0, explanation: "Implement the main setup and teardown functions for the VFS." },
    { "correct": "VFS* vfs_init() {", distractors: [{"text":"VFS vfs_init() {", reason:"The definition must match the prototype. The function must return a pointer (`VFS*`) to a dynamically allocated object."}], indent: 0, explanation: "Begin `vfs_init`." },
    { "correct": "  printf(\"Initializing Virtual File System...\\n\");", distractors: [{"text":"  puts(\"Initializing Virtual File System...\");", reason:"`puts` is a valid and simpler alternative for printing a fixed string followed by a newline."}], indent: 1, explanation: "Log the initialization event." },
    { "correct": "  VFS* vfs = malloc(sizeof(VFS));", distractors: [{"text":"  VFS* vfs = malloc(sizeof(vfs));", reason:"This is a bug. `sizeof(vfs)` would give the size of a pointer, not the size of the `VFS` struct it's supposed to point to."}], indent: 1, explanation: "Allocate the main VFS control struct." },
    { "correct": "  if (!vfs) return NULL;", distractors: [{"text":"  // Assume malloc succeeds", reason:"This is unsafe. `malloc` can fail if the system is out of memory. You must always check its return value."}], indent: 1, explanation: "Handle allocation failure." },
    { "correct": "  // Create the root directory node.", distractors: [{"text":"  // Root node is created later.", reason:"This is incorrect. A file system must have a root directory from the very beginning."}], indent: 1, explanation: "Comment on creating the root." },
    { "correct": "  vfs->root = malloc(sizeof(VFSNode));", distractors: [{"text":"  vfs.root = malloc(sizeof(VFSNode));", reason:"`vfs` is a pointer. You must use the arrow operator `->` to access the members of a struct through a pointer."}], indent: 1, explanation: "Allocate memory for the root node." },
    { "correct": "  if (!vfs->root) { free(vfs); return NULL; }", distractors: [{"text":"  if (!vfs->root) { return NULL; }", reason:"This is a memory leak. If the root node allocation fails, you must free the `VFS` struct itself before returning."}], indent: 1, explanation: "Handle root allocation failure." },
    { "correct": "  strcpy(vfs->root->name, \"/\");", distractors: [{"text":"  vfs->root->name = \"/\";", reason:"This is a bug. You cannot assign a string literal to a character array. You must copy the contents using `strcpy` or `strncpy`."}], indent: 1, explanation: "The root directory is named '/'." },
    { "correct": "  vfs->root->type = NODE_DIRECTORY;", distractors: [{"text":"  vfs->root->type = 1;", reason:"Using the named enumerator `NODE_DIRECTORY` is much clearer and less error-prone than using a 'magic number' like 1."}], indent: 1, explanation: "Set the node type to directory." },
    { "correct": "  vfs->root->creation_time = time(NULL);", distractors: [{"text":"  vfs->root->creation_time = 0;", reason:"Setting the timestamp to the current time using `time(NULL)` is more realistic."}], indent: 1, explanation: "Set the creation timestamp." },
    { "correct": "  vfs->root->parent = NULL; // Root has no parent", distractors: [{"text":"  vfs->root->parent = vfs->root;", reason:"This would be a bug. The root's parent is conceptually non-existent, so it should be `NULL`."}], indent: 1, explanation: "The parent of the root is NULL." },
    { "correct": "  vfs->root->first_child = NULL;", distractors: [{"text":"  // No need to initialize children", reason:"This is a critical bug. Pointers must be initialized to `NULL` so we know the list of children is empty."}], indent: 1, explanation: "Root starts with no children." },
    { "correct": "  vfs->root->content = NULL;", distractors: [{"text":"  vfs->root->content = \"\";", reason:"The content pointer for a directory should be `NULL`. An empty string is still a valid pointer to allocated memory."}], indent: 1, explanation: "Directories have no content buffer." },
    { "correct": "  vfs->root->content_size = 0;", distractors: [{"text":"  // content_size will be uninitialized", reason:"This is a bug. All members of a new struct should be explicitly initialized to a known, safe state."}], indent: 1, explanation: "Content size is zero for directories." },
    { "correct": "  vfs->root->next_sibling = NULL;", distractors: [{"text":"  // Siblings are not important", reason:"This is false. The `next_sibling` pointer is the crucial link that forms the linked list of children within a directory."}], indent: 1, explanation: "Root has no siblings." },
    { "correct": "  printf(\"VFS Initialized. Root directory '/' created.\\n\");", distractors: [{"text":"  puts(\"VFS Initialized.\");", reason:"This is okay, but the original message provides more specific confirmation."}], indent: 1, explanation: "Confirm initialization." },
    { "correct": "  return vfs;", distractors: [{"text":"  return vfs->root;", reason:"The API function must return a pointer to the main `VFS` control structure, not just its root node."}], indent: 1, explanation: "Return the new VFS instance." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End `vfs_init`." },
    { "correct": "void vfs_shutdown(VFS* vfs) {", distractors: [{"text":"void vfs_shutdown(const VFS* vfs) {", reason:"A shutdown function frees memory, which is a 'modifying' action, so the pointer should not be `const`."}], indent: 0, explanation: "Begin `vfs_shutdown`." },
    { "correct": "  if (!vfs) return;", distractors: [{"text":"  if (vfs == NULL) return;", reason:"This is an equally valid and often clearer way to check for a NULL pointer. Making shutdown functions safe to call on NULL is good practice."}], indent: 1, explanation: "Guard against NULL VFS pointer." },
    { "correct": "  printf(\"\\nShutting down VFS and freeing all memory...\\n\");", distractors: [{"text":"  free(vfs);", reason:"This is a massive memory leak. You must recursively free all the nodes inside the tree *before* freeing the main VFS struct."}], indent: 1, explanation: "Log the shutdown process." },
    { "correct": "  vfs_free_node_recursive(vfs->root);", distractors: [{"text":"  free(vfs->root);", reason:"This would only free the root node, leaking all of its descendants (the entire filesystem). A recursive free is required."}], indent: 1, explanation: "Start the recursive free from the root." },
    { "correct": "  free(vfs);", distractors: [{"text":"  // No need to free vfs", reason:"This is a memory leak. The main VFS struct was allocated with `malloc` and must be freed."}], indent: 1, explanation: "Free the main VFS control struct." },
    { "correct": "  printf(\"VFS Shutdown complete.\\n\");", distractors: [{"text":"  puts(\"VFS Shutdown complete.\");", reason:"`puts` is a valid and simpler alternative for printing this message."}], indent: 1, explanation: "Confirm shutdown." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "End `vfs_shutdown`." },
    { "correct": "static void vfs_free_node_recursive(VFSNode* node) {", distractors: [{"text":"void vfs_free_node_recursive(VFSNode* node) {", reason:"The `static` keyword makes this function private to this file. Since it's an internal helper, this is good encapsulation."}], indent: 0, explanation: "Begin recursive free helper." },
    { "correct": "  if (!node) return;", distractors: [{"text":"  // No base case needed.", reason:"This is a critical bug. All recursive functions must have a base case to stop the recursion. Here, the base case is a NULL node."}], indent: 1, explanation: "Base case: if node is NULL, do nothing." },
    { "correct": "  // Recursively free all children (if it's a directory)", distractors: [{"text":"  free(node);", reason:"This is a pre-order traversal bug. If you free the node first, you can't access its `first_child` to free the children, causing a huge memory leak."}], indent: 1, explanation: "Comment on freeing children." },
    { "correct": "  if (node->type == NODE_DIRECTORY) {", distractors: [{"text":"  if (node->first_child) {", reason:"Checking the node type is more explicit and correct. A file node might have garbage in its `first_child` member, so we should only check it for directories."}], indent: 1, explanation: "Check if the node is a directory." },
    { "correct": "    VFSNode* child = node->first_child;", distractors: [{"text":"    VFSNode* child = NULL;", reason:"The iterator must be initialized to the head of the children list (`node->first_child`)."}], indent: 2, explanation: "Get the first child." },
    { "correct": "    while (child) {", distractors: [{"text":"    if (child) {", reason:"An `if` would only process the first child. A `while` loop is necessary to traverse the entire linked list of siblings."}], indent: 2, explanation: "Iterate through the children list." },
    { "correct": "      VFSNode* next = child->next_sibling;", distractors: [{"text":"      vfs_free_node_recursive(child);", reason:"This is a use-after-free bug. You must save the pointer to the next sibling *before* you free the current child node."}], indent: 3, explanation: "Store the pointer to the next sibling before freeing the current one." },
    { "correct": "      vfs_free_node_recursive(child);", distractors: [{"text":"      free(child);", reason:"This is a bug. Just freeing the child node would leak its entire subtree. A recursive call is required."}], indent: 3, explanation: "Make the recursive call on the child." },
    { "correct": "      child = next;", distractors: [{"text":"      // No update needed", reason:"This is a bug. Forgetting to advance to the next sibling would cause an infinite loop."}], indent: 3, explanation: "Move to the next sibling." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 2, explanation: "End of child loop." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End directory check." },
    { "correct": "  // Free the node's own content (if it's a file)", distractors: [{"text":"  // Free content for all nodes", reason:"This is incorrect. Only nodes of type `NODE_FILE` have a `content` buffer that needs to be freed."}], indent: 1, explanation: "Comment on freeing file content." },
    { "correct": "  if (node->type == NODE_FILE) {", distractors: [{"text":"  if (node->content) {", reason:"Checking the node type is more robust and explicit than just checking if the content pointer is not NULL."}], indent: 1, explanation: "Check if the node is a file." },
    { "correct": "    free(node->content);", distractors: [{"text":"    // No free needed for content", reason:"This is a memory leak. The file's content was dynamically allocated and must be freed."}], indent: 2, explanation: "Free the file's content buffer." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End file check." },
    { "correct": "  // Finally, free the node struct itself", distractors: [{"text":"  // This is the first step", reason:"This is incorrect. This is post-order traversal; the node itself must be freed *last*, after all its descendants have been freed."}], indent: 1, explanation: "Comment on freeing the node." },
    { "correct": "  free(node);", distractors: [{"text":"  // No need to free node", reason:"This is a memory leak. Every node was allocated with `malloc` and must be freed."}], indent: 1, explanation: "Free the VFSNode." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End `vfs_free_node_recursive`." },
    { "correct": "// === Stage 3: Path Traversal and Node Creation ===", distractors: [{"text":"// === Stage 3: Cleanup Logic ===", reason:"This stage implements the core logic for navigating and modifying the tree, not cleaning it up."}], indent: 0, explanation: "Implement the core logic for navigating the VFS tree." },
    { "correct": "VFSNode* vfs_get_node(VFS* vfs, const char* path) {", distractors: [{"text":"bool vfs_get_node(VFS* vfs, const char* path) {", reason:"The definition must match the prototype. This function needs to return a pointer to the found node."}], indent: 0, explanation: "Begin `vfs_get_node`." },
    { "correct": "  if (strcmp(path, \"/\") == 0) return vfs->root;", distractors: [{"text":"  if (path == \"/\") return vfs->root;", reason:"This is a critical error. String content must be compared with `strcmp`, not the `==` operator."}], indent: 1, explanation: "Handle the special case for the root path." },
    { "correct": "  char path_copy[1024];", distractors: [{"text":"  // No copy needed", reason:"This is false. The `strtok` function modifies the string it parses, so we must work on a mutable copy, not the original `const char* path`."}], indent: 1, explanation: "Create a mutable copy of the path for tokenizing." },
    { "correct": "  strncpy(path_copy, path, sizeof(path_copy) - 1);", distractors: [{"text":"  strcpy(path_copy, path);", reason:"`strcpy` is unsafe and can cause a buffer overflow if the input path is too long. `strncpy` is a safer alternative."}], indent: 1, explanation: "Copy the path." },
    { "correct": "  path_copy[sizeof(path_copy)-1] = '\\0';", distractors: [{"text":"  // strncpy adds null terminator", reason:"This is a common myth. `strncpy` will *not* null-terminate if the source string is as long or longer than the size limit. Manual termination is crucial."}], indent: 1, explanation: "Ensure null termination." },
    { "correct": "  VFSNode* current_node = vfs->root;", distractors: [{"text":"  VFSNode* current_node = NULL;", reason:"Traversal must always begin from a known point, which is the `root` of the VFS."}], indent: 1, explanation: "Start traversal from the root." },
    { "correct": "  char* token = strtok(path_copy, \"/\");", distractors: [{"text":"  char* token = strtok(path, \"/\");", reason:"This would be a bug. `strtok` modifies its input, but `path` is a `const char*` and cannot be modified."}], indent: 1, explanation: "Get the first token (directory/file name) from the path." },
    { "correct": "  while (token != NULL) {", distractors: [{"text":"  while (token) {", reason:"This is a valid and common shorthand for checking if a pointer is not NULL."}], indent: 1, explanation: "Loop through all tokens in the path." },
    { "correct": "    VFSNode* child = current_node->first_child;", distractors: [{"text":"    VFSNode* child = current_node;", reason:"This is a logic error. We need to start the search with the first *child* of the current node."}], indent: 2, explanation: "Get the first child of the current directory." },
    { "correct": "    bool found = false;", distractors: [{"text":"    bool found = true;", reason:"The flag must be initialized to `false` at the start of searching each level of the directory."}], indent: 2, explanation: "Flag to indicate if we found the next node in the path." },
    { "correct": "    while (child) {", distractors: [{"text":"    if (child) {", reason:"An `if` would only check the first child. A `while` loop is needed to iterate through all siblings."}], indent: 2, explanation: "Iterate through the children to find a name match." },
    { "correct": "      if (strcmp(child->name, token) == 0) {", distractors: [{"text":"      if (child->name == token) {", reason:"This is a bug. String content must be compared with `strcmp`."}], indent: 3, explanation: "If a child's name matches the token..." },
    { "correct": "        current_node = child;", distractors: [{"text":"        // No update needed", reason:"This is a bug. We must update `current_node` to descend into the next level of the tree."}], indent: 4, explanation: "Move to that child node." },
    { "correct": "        found = true;", distractors: [{"text":"        found = 1;", reason:"Using `true` from `<stdbool.h>` is more expressive, but assigning `1` is also perfectly valid."}], indent: 4, explanation: "Set the found flag." },
    { "correct": "        break;", distractors: [{"text":"        // No break needed", reason:"`break` makes the search more efficient. Once we've found the matching child, there's no need to check its other siblings."}], indent: 4, explanation: "Break the inner while loop." },
    { "correct": "      }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 3, explanation: "End name comparison." },
    { "correct": "      child = child->next_sibling;", distractors: [{"text":"      child = child->first_child;", reason:"This is a bug. To traverse a directory's contents, you must follow the `next_sibling` pointers."}], indent: 3, explanation: "Move to the next sibling." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 2, explanation: "End child search loop." },
    { "correct": "    if (!found) return NULL; // Path component not found", distractors: [{"text":"    if (!found) continue;", reason:"This is a bug. If a component of the path is not found, the entire path is invalid, and we must stop and return `NULL`."}], indent: 2, explanation: "If any part of the path doesn't exist, return NULL." },
    { "correct": "    token = strtok(NULL, \"/\");", distractors: [{"text":"    token = strtok(path_copy, \"/\");", reason:"This would cause `strtok` to restart parsing from the beginning of the path, creating an infinite loop."}], indent: 2, explanation: "Get the next token in the path." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End token loop." },
    { "correct": "  return current_node;", distractors: [{"text":"  return vfs->root;", reason:"This would be a bug. The function must return the actual node found at the end of the traversal."}], indent: 1, explanation: "Return the final node found at the end of the path." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to end a function block."}], indent: 0, explanation: "End `vfs_get_node`." },
    { "correct": "// === Stage 4: Core VFS API Implementations ===", distractors: [{"text":"// === Stage 4: Initialization ===", reason:"This stage implements the main user-facing API functions for creating files and directories."}], indent: 0, explanation: "Implement the user-facing file system operations." },
    { "correct": "bool vfs_mkdir(VFS* vfs, const char* path) {", distractors: [{"text":"VFSNode* vfs_mkdir(...)", reason:"The definition must match the prototype. This function returns a `bool` to signal success or failure."}], indent: 0, explanation: "Begin `vfs_mkdir`." },
    { "correct": "  // Find parent directory and the new directory's name.", distractors: [{"text":"  // Find the directory.", reason:"This is incomplete. The logic needs to find the parent *and* extract the name for the new directory from the path."}], indent: 1, explanation: "Comment on path parsing." },
    { "correct": "  char path_copy[1024]; strncpy(path_copy, path, 1023);", distractors: [{"text":"  char* path_copy = strdup(path);", reason:"Using `strdup` also works, but requires a corresponding `free(path_copy)` at the end of the function to avoid a memory leak. A stack array is simpler here."}], indent: 1, explanation: "Make a copy of the path string." },
    { "correct": "  char* last_slash = strrchr(path_copy, '/');", distractors: [{"text":"  char* last_slash = strchr(path_copy, '/');", reason:"`strchr` finds the *first* occurrence of a character. `strrchr` correctly finds the *last* one, which is needed to separate a path from its final component."}], indent: 1, explanation: "Find the last slash to separate parent path from new directory name." },
    { "correct": "  if (!last_slash) return false; // Invalid path format", distractors: [{"text":"  // Assume path is valid", reason:"This is unsafe. A robust function must handle malformed input gracefully."}], indent: 1, explanation: "Handle invalid path." },
    { "correct": "  char* new_dir_name = last_slash + 1;", distractors: [{"text":"  char* new_dir_name = last_slash;", reason:"This would incorrectly include the `/` in the new directory's name."}], indent: 1, explanation: "The new directory name is what comes after the last slash." },
    { "correct": "  if (last_slash == path_copy) *(last_slash + 1) = '\\0'; else *last_slash = '\\0';", distractors: [{"text":"  *last_slash = '\\0';", reason:"This alone is not enough. It fails on paths like `/home`. The special check for when the slash is the first character is required."}], indent: 1, explanation: "Terminate the parent path string. Handle root case." },
    { "correct": "  const char* parent_path = (strlen(path_copy) == 0) ? \"/\" : path_copy;", distractors: [{"text":"  const char* parent_path = path_copy;", reason:"This would fail for a path like `/home`. After the previous step, `path_copy` would be empty, so we must special-case this to mean the root `\"/\"`."}], indent: 1, explanation: "Determine the parent path string." },
    { "correct": "  VFSNode* parent = vfs_get_node(vfs, parent_path);", distractors: [{"text":"  VFSNode* parent = vfs->root;", reason:"This is a bug. The new directory could be created in a subdirectory, so we must find the correct parent node using the parsed path."}], indent: 1, explanation: "Get the node for the parent directory." },
    { "correct": "  if (!parent || parent->type != NODE_DIRECTORY) return false;", distractors: [{"text":"  if (!parent) return false;", reason:"This is insufficient. We must also check that the parent is actually a directory; you can't create a subdirectory inside a file."}], indent: 1, explanation: "Check if parent exists and is a directory." },
    { "correct": "  // Create the new directory node", distractors: [{"text":"  // Find the directory node", reason:"We are creating a new one, not finding an existing one."}], indent: 1, explanation: "Comment on creating the new node." },
    { "correct": "  VFSNode* new_node = malloc(sizeof(VFSNode));", distractors: [{"text":"  VFSNode new_node;", reason:"This creates a temporary stack variable that will be invalid after the function returns. The node must be dynamically allocated."}], indent: 1, explanation: "Allocate memory for the new directory node." },
    { "correct": "  strcpy(new_node->name, new_dir_name);", distractors: [{"text":"  new_node->name = new_dir_name;", reason:"This is a bug. This would make the `name` pointer point into the temporary `path_copy` buffer. A copy of the string must be made."}], indent: 1, explanation: "Copy the name." },
    { "correct": "  new_node->type = NODE_DIRECTORY; new_node->creation_time = time(NULL);", distractors: [{"text":"  new_node->type = NODE_FILE;", reason:"This is a logic error. We are implementing `mkdir`, so the new node type must be a directory."}], indent: 1, explanation: "Set type and timestamp." },
    { "correct": "  new_node->parent = parent; new_node->first_child = NULL; new_node->content = NULL; new_node->content_size = 0;", distractors: [{"text":"  // Uninitialized members are OK", reason:"This is a bug. All pointers must be initialized to NULL and sizes to 0 to ensure the new node is in a clean, predictable state."}], indent: 1, explanation: "Initialize other fields." },
    { "correct": "  // Add new node to parent's children list", distractors: [{"text":"  // Add parent to new node's children list", reason:"This is backwards. The new node should be added to the parent's list."}], indent: 1, explanation: "Comment on linking the node." },
    { "correct": "  new_node->next_sibling = parent->first_child;", distractors: [{"text":"  parent->first_child = new_node;", reason:"This assignment must happen *after* linking the new node to the old first child. Doing it first would lose the rest of the children list."}], indent: 1, explanation: "New node points to the old first child." },
    { "correct": "  parent->first_child = new_node;", distractors: [{"text":"  new_node->next_sibling = NULL;", reason:"This is a bug if the parent directory is not empty. It would orphan all other children in that directory."}], indent: 1, explanation: "New node becomes the new first child." },
    { "correct": "  printf(\"Created directory: %s\\n\", path);", distractors: [{"text":"  puts(\"Created directory\");", reason:"This is less informative. Printing the full path of the created directory provides better user feedback."}], indent: 1, explanation: "Log the creation." },
    { "correct": "  return true;", distractors: [{"text":"  return 1;", reason:"Using the `bool` type `true` from `<stdbool.h>` is more expressive than returning the integer `1`."}], indent: 1, explanation: "Return success." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function definition."}], indent: 0, explanation: "End `vfs_mkdir`." },
    { "correct": "bool vfs_write(VFS* vfs, const char* path, const char* data) {", distractors: [{"text":"void vfs_write(...)", reason:"The definition must match the prototype. Returning a `bool` allows the function to signal success or failure."}], indent: 0, explanation: "Begin `vfs_write`." },
    { "correct": "  VFSNode* node = vfs_get_node(vfs, path);", distractors: [{"text":"  VFSNode* node = NULL;", reason:"We must first try to find an existing node at the given path."}], indent: 1, explanation: "Find the node for the given path." },
    { "correct": "  if (!node) { /* For simplicity, we create the file if it doesn't exist */", distractors: [{"text":"  if (!node) { return false; }", reason:"This is a valid design choice (refusing to create). The current implementation mimics `touch`-like behavior, which is also common."}], indent: 1, explanation: "If file doesn't exist, create it." },
    { "correct": "    char path_copy[1024]; strncpy(path_copy, path, 1023);", distractors: [{"text":"    char* path_copy = path;", reason:"This is a bug. `strrchr` can modify its argument if we write to the pointer it returns. We must work on a mutable copy."}], indent: 2, explanation: "Copy path to parse out parent." },
    { "correct": "    char* last_slash = strrchr(path_copy, '/');", distractors: [{"text":"    char* last_slash = strchr(path_copy, '/');", reason:"`strchr` finds the first slash. `strrchr` correctly finds the last slash to separate the parent path from the filename."}], indent: 2, explanation: "Find last slash." },
    { "correct": "    if(!last_slash) return false;", distractors: [{"text":"    // Assume path is valid", reason:"This is unsafe. The function must handle malformed paths gracefully."}], indent: 2, explanation: "Invalid path." },
    { "correct": "    char* new_file_name = last_slash + 1;", distractors: [{"text":"    char* new_file_name = last_slash - 1;", reason:"This pointer arithmetic is incorrect and would point to the wrong part of the string."}], indent: 2, explanation: "Get new file name." },
    { "correct": "    if (last_slash == path_copy) *(last_slash + 1) = '\\0'; else *last_slash = '\\0';", distractors: [{"text":"    *last_slash = '\\0';", reason:"This alone is buggy. It fails on paths like `/file.txt`. The special check for the slash being the first character is required."}], indent: 2, explanation: "Separate parent path." },
    { "correct": "    const char* parent_path = (strlen(path_copy) == 0) ? \"/\" : path_copy;", distractors: [{"text":"    const char* parent_path = path_copy;", reason:"This is buggy for root-level files. If the original path was `/file.txt`, `path_copy` becomes empty, and we must treat that as the root path `\"/\"`."}], indent: 2, explanation: "Determine parent path string." },
    { "correct": "    VFSNode* parent = vfs_get_node(vfs, parent_path);", distractors: [{"text":"    VFSNode* parent = vfs->root;", reason:"This is a bug. The file could be created in any subdirectory, so we must find the correct parent node."}], indent: 2, explanation: "Get parent node." },
    { "correct": "    if (!parent || parent->type != NODE_DIRECTORY) return false;", distractors: [{"text":"    if (!parent) return false;", reason:"This check is incomplete. You must also verify that the found parent is actually a directory."}], indent: 2, explanation: "Check parent validity." },
    { "correct": "    node = malloc(sizeof(VFSNode));", distractors: [{"text":"    node = vfs->root->first_child;", reason:"This is a bug. We need to allocate a completely new node for the file."}], indent: 2, explanation: "Allocate new file node." },
    { "correct": "    strcpy(node->name, new_file_name);", distractors: [{"text":"    node->name = new_file_name;", reason:"This is a bug. This copies a pointer to a temporary buffer. A permanent copy of the name must be made."}], indent: 2, explanation: "Set its name." },
    { "correct": "    node->type = NODE_FILE; node->creation_time = time(NULL); node->parent = parent;", distractors: [{"text":"    node->type = NODE_DIRECTORY;", reason:"This is a logic error. The function is creating a file, so the type must be `NODE_FILE`."}], indent: 2, explanation: "Set its properties." },
    { "correct": "    node->first_child = NULL; node->content=NULL; node->content_size=0;", distractors: [{"text":"    // Uninitialized members are ok", reason:"This is a bug. All pointers must be set to NULL and sizes to 0 to ensure the new node is in a clean state."}], indent: 2, explanation: "Initialize file-specific fields." },
    { "correct": "    node->next_sibling = parent->first_child;", distractors: [{"text":"    parent->first_child = node;", reason:"This assignment must come *after* linking. Doing it first would lose the rest of the directory's contents."}], indent: 2, explanation: "Link into parent's children list." },
    { "correct": "    parent->first_child = node;", distractors: [{"text":"    node->next_sibling = NULL;", reason:"This is a bug if the directory is not empty. It would orphan all other files/directories."}], indent: 2, explanation: "Update parent's first child." },
    { "correct": "    printf(\"Created file: %s\\n\", path);", distractors: [{"text":"    puts(\"Created file.\");", reason:"This is less informative. Printing the full path is better user feedback."}], indent: 2, explanation: "Log creation." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End of file creation block." },
    { "correct": "  if (node->type != NODE_FILE) return false; // Can't write to a directory", distractors: [{"text":"  // Assume it's a file", reason:"This is unsafe. The function must explicitly check the node type to prevent trying to write content to a directory."}], indent: 1, explanation: "Ensure we are writing to a file." },
    { "correct": "  free(node->content); // Free old content if any", distractors: [{"text":"  // No need to free old content", reason:"This is a memory leak. If we don't free the old content buffer before allocating a new one, the old memory is orphaned."}], indent: 1, explanation: "Free any pre-existing content." },
    { "correct": "  node->content_size = strlen(data) + 1;", distractors: [{"text":"  node->content_size = strlen(data);", reason:"`strlen` does not include the null terminator. We must add 1 to allocate space for it."}], indent: 1, explanation: "Calculate size of new data." },
    { "correct": "  node->content = malloc(node->content_size);", distractors: [{"text":"  node->content = data;", reason:"This is a bug. This just copies the pointer. We need to allocate a new buffer owned by the node and copy the content into it."}], indent: 1, explanation: "Allocate memory for the new content." },
    { "correct": "  strcpy(node->content, data);", distractors: [{"text":"  strncpy(node->content, data, node->content_size);", reason:"Since we allocated exactly the right size, `strcpy` is sufficient and slightly simpler here. `strncpy` is a good general-purpose safe alternative."}], indent: 1, explanation: "Copy the data into the node's content buffer." },
    { "correct": "  printf(\"Wrote %zu bytes to %s\\n\", node->content_size, path);", distractors: [{"text":"  printf(\"Wrote data to %s\\n\", path);", reason:"This is less useful. Including the number of bytes written is good for verification."}], indent: 1, explanation: "Log the write operation." },
    { "correct": "  return true;", distractors: [{"text":"  return 1;", reason:"Using `true` from `<stdbool.h>` is more expressive than the integer `1`."}], indent: 1, explanation: "Return success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End `vfs_write`." },
    { "correct": "char* vfs_read(VFS* vfs, const char* path) {", distractors: [{"text":"const char* vfs_read(...)", reason:"The definition must match the prototype. This function returns a mutable `char*`."}], indent: 0, explanation: "Begin `vfs_read`." },
    { "correct": "  VFSNode* node = vfs_get_node(vfs, path);", distractors: [{"text":"  VFSNode* node = NULL;", reason:"We must call `vfs_get_node` to actually find the node corresponding to the path."}], indent: 1, explanation: "Get the node for the path." },
    { "correct": "  if (!node || node->type != NODE_FILE) return NULL;", distractors: [{"text":"  if (!node) return NULL;", reason:"This is insufficient. We must also check that the found node is a file, not a directory."}], indent: 1, explanation: "Return NULL if path is not a valid file." },
    { "correct": "  printf(\"Read from %s\\n\", path);", distractors: [{"text":"  puts(\"Read from file.\");", reason:"This is less informative than printing the specific path being read."}], indent: 1, explanation: "Log the read operation." },
    { "correct": "  return node->content;", distractors: [{"text":"  return strdup(node->content);", reason:"This would return a *copy* of the content, which would force the caller to `free` it. The current API is simpler, returning a direct (non-owned) pointer."}], indent: 1, explanation: "Return a pointer to the content." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function definition."}], indent: 0, explanation: "End `vfs_read`." },
    { "correct": "void vfs_ls(VFS* vfs, const char* path) {", distractors: [{"text":"int vfs_ls(...)", reason:"The definition must match the prototype. This function prints directly and does not need to return a value."}], indent: 0, explanation: "Begin `vfs_ls`." },
    { "correct": "  VFSNode* dir_node = vfs_get_node(vfs, path);", distractors: [{"text":"  VFSNode* dir_node = vfs->root;", reason:"This would always list the root directory. We must call `vfs_get_node` to find the correct directory to list."}], indent: 1, explanation: "Get the node for the directory path." },
    { "correct": "  if (!dir_node || dir_node->type != NODE_DIRECTORY) {", distractors: [{"text":"  if (!dir_node) {", reason:"This is not enough. A node could exist at that path, but it might be a file, which cannot be listed."}], indent: 1, explanation: "Check if the path is a valid directory." },
    { "correct": "    printf(\"ls: cannot access '%s': Not a directory\\n\", path);", distractors: [{"text":"    printf(\"Error.\\n\");", reason:"Mimicking the error message style of the standard `ls` command is good practice and more informative."}], indent: 2, explanation: "Print an error if not a directory." },
    { "correct": "    return;", distractors: [{"text":"    // continue", reason:"We should exit the function if the path is invalid."}], indent: 2, explanation: "Exit the function." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End validity check." },
    { "correct": "  printf(\"Listing for %s:\\n\", path);", distractors: [{"text":"  printf(\"Listing:\\n\");", reason:"Including the path in the header makes the output unambiguous."}], indent: 1, explanation: "Print a header for the listing." },
    { "correct": "  VFSNode* child = dir_node->first_child;", distractors: [{"text":"  VFSNode* child = dir_node;", reason:"This is a bug. The iterator must start at the first *child* of the directory node."}], indent: 1, explanation: "Get the first child of the directory." },
    { "correct": "  while (child) {", distractors: [{"text":"  for (int i=0; i < MAX_USERS; i++) { ... }", reason:"This is incorrect. We must traverse the linked list of children using the `next_sibling` pointers, not iterate through a fixed-size array."}], indent: 1, explanation: "Loop through all children." },
    { "correct": "    printf(\"  %s%s\\n\", child->name, (child->type == NODE_DIRECTORY) ? \"/\" : \"\");", distractors: [{"text":"    printf(\"  %s\\n\", child->name);", reason:"This works, but appending a `/` for directories is a standard convention that makes the listing easier to read."}], indent: 2, explanation: "Print the child's name, adding a slash if it's a directory." },
    { "correct": "    child = child->next_sibling;", distractors: [{"text":"    child = child->first_child;", reason:"This is a bug. To iterate through a directory's contents, we must follow the `next_sibling` pointers."}], indent: 2, explanation: "Move to the next child." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End of child loop." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End `vfs_ls`." },
    { "correct": "// === Stage 5: Main Program for Demonstration ===", distractors: [{"text":"// === Stage 5: The VFS Library ===", reason:"This is the main program that *uses* our VFS library to demonstrate its features."}], indent: 0, explanation: "The main function to test the VFS API." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid, and often preferred, way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start of main." },
    { "correct": "  printf(\"--- Virtual File System Demo ---\\n\");", distractors: [{"text":"  puts(\"--- Virtual File System Demo ---\");", reason:"`puts` is a valid alternative that also prints a newline."}], indent: 1, explanation: "Demo title." },
    { "correct": "  VFS* my_vfs = vfs_init();", distractors: [{"text":"  vfs_init();", reason:"`vfs_init` returns a pointer to the new VFS instance. We must store this pointer in a variable to use it."}], indent: 1, explanation: "Initialize the VFS." },
    { "correct": "  // Create directory structure", distractors: [{"text":"  // Create files", reason:"It's logical to create the directory hierarchy first before placing files inside it."}], indent: 1, explanation: "Comment on creating directories." },
    { "correct": "  vfs_mkdir(my_vfs, \"/home\");", distractors: [{"text":"  vfs_mkdir(&my_vfs, \"/home\");", reason:"`my_vfs` is already a pointer. Passing its address would be a `VFS**`, which is the wrong type for the function."}], indent: 1, explanation: "Create /home." },
    { "correct": "  vfs_mkdir(my_vfs, \"/home/user\");", distractors: [{"text":"  vfs_mkdir(my_vfs, \"/home/user/profile\");", reason:"This would likely fail, as our simple `mkdir` doesn't create intermediate directories. The parent (`/home/user`) must exist first."}], indent: 1, explanation: "Create /home/user." },
    { "correct": "  vfs_mkdir(my_vfs, \"/etc\");", distractors: [{"text":"  vfs_create_file(my_vfs, \"/etc\");", reason:"This would create `/etc` as a file, which would then cause later attempts to write files inside it to fail."}], indent: 1, explanation: "Create /etc." },
    { "correct": "  // List root directory contents", distractors: [{"text":"  // List /home directory", reason:"This comment is inaccurate. The next line lists the root `\"/\"`."}], indent: 1, explanation: "Comment on listing root." },
    { "correct": "  vfs_ls(my_vfs, \"/\");", distractors: [{"text":"  vfs_ls(my_vfs->root);", reason:"Our public API is designed to work with paths, not internal node pointers."}], indent: 1, explanation: "List contents of /." },
    { "correct": "  // Create and write to files", distractors: [{"text":"  // Read from files", reason:"We must write to the files before we can read from them."}], indent: 1, explanation: "Comment on file operations." },
    { "correct": "  vfs_write(my_vfs, \"/home/user/profile.txt\", \"Name: Satya\\nCompany: Microsoft\");", distractors: [{"text":"  vfs_write(my_vfs, \"/home/user/profile.txt\");", reason:"The `vfs_write` function requires a third argument for the data to be written."}], indent: 1, explanation: "Write to the first file." },
    { "correct": "  vfs_write(my_vfs, \"/etc/config.conf\", \"TIMEOUT=30\");", distractors: [{"text":"  vfs_create_file(my_vfs, \"/etc/config.conf\"); vfs_write(...);", reason:"This is unnecessary. Our `vfs_write` implementation conveniently creates the file if it doesn't already exist."}], indent: 1, explanation: "Write to a second file." },
    { "correct": "  // List subdirectory contents", distractors: [{"text":"  // List root directory", reason:"This comment is inaccurate. The next line lists `/home/user`."}], indent: 1, explanation: "Comment on listing a subdirectory." },
    { "correct": "  vfs_ls(my_vfs, \"/home/user\");", distractors: [{"text":"  vfs_ls(my_vfs, \"/home\");", reason:"This would list the contents of `/home` (the `user` directory) instead of the contents of `/home/user`."}], indent: 1, explanation: "List the contents of /home/user." },
    { "correct": "  // Read from a file and print its content", distractors: [{"text":"  // Write to a file", reason:"The following lines demonstrate reading, not writing."}], indent: 1, explanation: "Comment on reading a file." },
    { "correct": "  char* content = vfs_read(my_vfs, \"/home/user/profile.txt\");", distractors: [{"text":"  const char* content = vfs_read(...);", reason:"Our `vfs_read` prototype returns a mutable `char*`, not a `const` one."}], indent: 1, explanation: "Read the profile file." },
    { "correct": "  if (content) { printf(\"\\nContent of /home/user/profile.txt:\\n%s\\n\", content); }", distractors: [{"text":"  printf(\"\\nContent:\\n%s\\n\", content);", reason:"This is unsafe. `vfs_read` can return `NULL` if the file doesn't exist. The `if (content)` check is required to prevent dereferencing a NULL pointer."}], indent: 1, explanation: "Print its content if read was successful." },
    { "correct": "  // Cleanup", distractors: [{"text":"  // End of program", reason:"'Cleanup' is a more descriptive term for the memory deallocation phase."}], indent: 1, explanation: "Comment on shutdown." },
    { "correct": "  vfs_shutdown(my_vfs);", distractors: [{"text":"  free(my_vfs);", reason:"This is a massive memory leak. `free` would only release the main `VFS` struct, not the tree of nodes and file contents inside it. The custom `vfs_shutdown` function is mandatory."}], indent: 1, explanation: "Free all memory used by the VFS." },
    { "correct": "  printf(\"--- Demo Finished ---\\n\");", distractors: [{"text":"  puts(\"--- Demo Finished ---\");", reason:"`puts` is a valid alternative for printing this message."}], indent: 1, explanation: "Final message." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 conventionally signals an error. Since the demo completed successfully, it should return 0."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of main." }
]
},
// Level 100: Prep for Apple
{
    "goal": "Implement a reference counting system for managing the lifecycle of different types of objects, preventing memory leaks by automatically freeing objects when they are no longer referenced.",
    "concepts": "Reference counting, automatic memory management (ARC), object-oriented C, structs, function pointers (vtables), polymorphism",
    "sequence": [
    { "correct": "// === Stage 1: Base Object and VTable Definitions ===", distractors: [{"text":"// === Stage 1: The Main Program ===", reason:"Good design requires defining the foundational data structures and types before writing the logic that uses them."}], indent: 0, explanation: "Define the core structures for all objects and their 'virtual tables'." },
    { "correct": "#include <stdio.h>", distractors: [{"text":"#include <stdlib.h>", reason:"The standard I/O function `printf` is declared in `<stdio.h>`."}], indent: 0, explanation: "For standard I/O." },
    { "correct": "#include <stdlib.h>", distractors: [{"text":"#include <string.h>", reason:"`malloc` and `free` for memory management are prototyped in the standard library, `<stdlib.h>`."}], indent: 0, explanation: "For memory management." },
    { "correct": "#include <string.h>", distractors: [{"text":"#include <strings.h>", reason:"The standard C header for `strdup` is `<string.h>`."}], indent: 0, explanation: "For string duplication." },
    { "correct": "#include <stdbool.h>", distractors: [{"text":"// No include needed", reason:"The `bool`, `true`, and `false` keywords are not built into C by default. They are defined as macros in the C99 standard header `<stdbool.h>`."}], indent: 0, explanation: "For using boolean types." },
    { "correct": "// The base struct for all reference-counted objects.", distractors: [{"text":"// A generic container for any data.", reason:"This struct is more specific; it's the required 'header' for all objects that will participate in our reference counting system."}], indent: 0, explanation: "Comment for BaseObject struct." },
    { "correct": "struct BaseObject;", distractors: [{"text":"struct BaseObject {};", reason:"This provides a full (but empty) definition. A forward declaration (`struct BaseObject;`) makes it an *incomplete type*, which is sufficient for declaring pointers to it."}], indent: 0, explanation: "Forward declaration of BaseObject." },
    { "correct": "// The 'virtual table' for polymorphic destruction.", distractors: [{"text":"// A struct for function pointers.", reason:"'Virtual table' or 'vtable' is the standard term for a struct of function pointers used to achieve polymorphic behavior in C."}], indent: 0, explanation: "Comment for the VTable struct." },
    { "correct": "typedef struct {", distractors: [{"text":"struct VTable {", reason:"Using `typedef` is a convenience that allows us to declare vtables as `VTable vt;` instead of `struct VTable vt;`."}], indent: 0, explanation: "Start VTable definition." },
    { "correct": "  void (*destroy)(struct BaseObject* obj);", distractors: [{"text":"  void* (*destroy)(struct BaseObject* obj);", reason:"A destructor's job is to clean up resources; it doesn't need to return a value, so `void` is the correct return type."}], indent: 1, explanation: "A function pointer to the type-specific destructor." },
    { "correct": "} VTable;", distractors: [{"text":"} VTable", reason:"A `typedef` statement must always end with a semicolon."}], indent: 0, explanation: "End VTable definition." },
    { "correct": "typedef struct BaseObject {", distractors: [{"text":"struct BaseObject {", reason:"Without `typedef`, we would have to write `struct BaseObject` every time, which is more verbose."}], indent: 0, explanation: "Start BaseObject definition." },
    { "correct": "  int ref_count;", distractors: [{"text":"  unsigned int ref_count;", reason:"Using `unsigned int` is arguably more correct since a reference count cannot be negative, but `int` is also commonly used."}], indent: 1, explanation: "The number of references to this object." },
    { "correct": "  const VTable* vtable;", distractors: [{"text":"  VTable vtable;", reason:"This would embed the entire vtable struct in every object, which is inefficient. A pointer to a single, shared, `static const` vtable is the correct pattern."}], indent: 1, explanation: "Pointer to the vtable for this object's type." },
    { "correct": "} BaseObject;", distractors: [{"text":"};", reason:"When using `typedef` with a struct definition, the new type alias (`BaseObject`) must be provided before the final semicolon."}], indent: 0, explanation: "End BaseObject definition." },
    { "correct": "// --- Core API Prototypes ---", distractors: [{"text":"// --- Implementation Details ---", reason:"This is the public API. It's what users of the library will call, hiding the implementation details."}], indent: 0, explanation: "Declare the retain/release API." },
    { "correct": "void object_retain(BaseObject* obj);", distractors: [{"text":"int object_retain(BaseObject* obj);", reason:"The retain operation modifies the object's state but doesn't need to return a value, so `void` is the appropriate return type."}], indent: 0, explanation: "Increments an object's reference count." },
    { "correct": "void object_release(BaseObject* obj);", distractors: [{"text":"void object_release(BaseObject obj);", reason:"The function needs to modify the object's `ref_count`, so it must accept a pointer to the object, not a copy."}], indent: 0, explanation: "Decrements an object's reference count and destroys it if the count reaches zero." },
    { "correct": "// === Stage 2: Retain and Release API Implementation ===", distractors: [{"text":"// === Stage 2: Concrete Object Implementation ===", reason:"Before implementing specific object types, we must first implement the core reference counting logic that applies to all of them."}], indent: 0, explanation: "Implement the core memory management functions." },
    { "correct": "void object_retain(BaseObject* obj) {", distractors: [{"text":"void object_retain(const BaseObject* obj) {", reason:"A retain operation modifies the object's `ref_count`, so the pointer cannot be `const`."}], indent: 0, explanation: "Begin `object_retain`." },
    { "correct": "  if (obj) {", distractors: [{"text":"  if (obj != NULL) {", reason:"This is an equally valid, and often clearer, way to check that the pointer is not NULL. It's good practice to make retain/release safely handle NULL."}], indent: 1, explanation: "Ensure the object pointer is not NULL." },
    { "correct": "    obj->ref_count++;", distractors: [{"text":"    obj->ref_count = obj->ref_count + 1;", reason:"This is also correct, but the `++` operator is the more common and concise C idiom for incrementing."}], indent: 2, explanation: "Increment the reference count." },
    { "correct": "    printf(\"[RC] Retain: obj at %p, new ref_count = %d\\n\", obj, obj->ref_count);", distractors: [{"text":"    printf(\"Retained object.\\n\");", reason:"This is less informative. Logging the address and new count is crucial for debugging reference counting issues."}], indent: 2, explanation: "Log the retain operation." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 1, explanation: "End NULL check." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End `object_retain`." },
    { "correct": "void object_release(BaseObject* obj) {", distractors: [{"text":"int object_release(BaseObject* obj) {", reason:"The definition must match the prototype. This function does not return a value."}], indent: 0, explanation: "Begin `object_release`." },
    { "correct": "  if (obj) {", distractors: [{"text":"  // No NULL check needed", reason:"This is unsafe. The C standard says freeing a NULL pointer is safe, but accessing `obj->ref_count` when `obj` is NULL would crash."}], indent: 1, explanation: "Ensure the object pointer is not NULL." },
    { "correct": "    obj->ref_count--;", distractors: [{"text":"    obj->ref_count -= 1;", reason:"This is an equally valid way to decrement the reference count."}], indent: 2, explanation: "Decrement the reference count." },
    { "correct": "    printf(\"[RC] Release: obj at %p, new ref_count = %d\\n\", obj, obj->ref_count);", distractors: [{"text":"    puts(\"Released object.\");", reason:"This is not useful for debugging. Logging the address and count helps trace the object's lifecycle."}], indent: 2, explanation: "Log the release operation." },
    { "correct": "    if (obj->ref_count == 0) {", distractors: [{"text":"    if (obj->ref_count <= 0) {", reason:"This is a potential bug. The count should be *exactly* 0. A negative ref_count indicates a serious error (an over-release), and trying to destroy it again could cause a crash."}], indent: 2, explanation: "Check if the reference count has dropped to zero." },
    { "correct": "      printf(\"[RC] Destroying obj at %p...\\n\", obj);", distractors: [{"text":"      free(obj);", reason:"This is a memory leak. You must call the object's specific destructor via the vtable to free its internal data *before* freeing the object itself."}], indent: 3, explanation: "Log the impending destruction." },
    { "correct": "      // Use the vtable to call the type-specific destructor", distractors: [{"text":"      // Call the string destructor directly.", reason:"This is not polymorphic. The `release` function doesn't know the object's concrete type. It *must* use the vtable to call the correct destructor."}], indent: 3, explanation: "Comment on using the vtable." },
    { "correct": "      obj->vtable->destroy(obj);", distractors: [{"text":"      free(obj); // Free the object first", reason:"This is a critical use-after-free bug. If you free `obj` first, you can no longer access `obj->vtable` to call the destructor."}], indent: 3, explanation: "Call the appropriate destructor via function pointer." },
    { "correct": "      free(obj);", distractors: [{"text":"      // No need to free obj", reason:"This is a memory leak. After destroying the object's internal data, the memory for the container struct itself must be freed."}], indent: 3, explanation: "Free the memory for the BaseObject itself." },
    { "correct": "    }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 2, explanation: "End zero-count check." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 1, explanation: "End NULL check." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close a function block."}], indent: 0, explanation: "End `object_release`." },
    { "correct": "// === Stage 3: Concrete Object Type - StringObject ===", distractors: [{"text":"// === Stage 3: The Base Object ===", reason:"The BaseObject was already defined. This stage defines a *concrete* type that 'inherits' from the base object."}], indent: 0, explanation: "Define and implement a reference-counted string object." },
    { "correct": "typedef struct {", distractors: [{"text":"struct StringObject {", reason:"Using `typedef` is a convention we've used throughout for cleaner syntax."}], indent: 0, explanation: "Start StringObject definition." },
    { "correct": "  BaseObject base;", distractors: [{"text":"  BaseObject* base;", reason:"This is a critical error. The base object must be the first *member*, not a pointer. This ensures the memory layout allows a `StringObject*` to be safely cast to a `BaseObject*`."}], indent: 1, explanation: "Must be the first member to allow casting." },
    { "correct": "  char* value;", distractors: [{"text":"  char value[100];", reason:"A fixed-size array is less flexible. Using `char*` and `strdup` allows the string to be any length."}], indent: 1, explanation: "The string data this object holds." },
    { "correct": "} StringObject;", distractors: [{"text":"};", reason:"This `typedef` requires the type alias `StringObject` before the final semicolon."}], indent: 0, explanation: "End StringObject definition." },
    { "correct": "// Function prototypes for StringObject", distractors: [{"text":"// Function implementations", reason:"These are just forward declarations for the functions specific to `StringObject`."}], indent: 0, explanation: "Forward declarations for string functions." },
    { "correct": "void string_destroy(BaseObject* obj);", distractors: [{"text":"void string_destroy(StringObject* obj);", reason:"To be compatible with the VTable, the destructor's signature must match `void (*destroy)(struct BaseObject* obj)` exactly."}], indent: 0, explanation: "Destructor for StringObject." },
    { "correct": "StringObject* string_create(const char* value);", distractors: [{"text":"BaseObject* string_create(const char* value);", reason:"It's better API design for a constructor to return a pointer to its specific type, even though it could be cast from a `BaseObject*`."}], indent: 0, explanation: "Constructor for StringObject." },
    { "correct": "static const VTable STRING_VTABLE = { .destroy = string_destroy };", distractors: [{"text":"VTable STRING_VTABLE = { &string_destroy };", reason:"Using designated initializers (`.destroy = ...`) is clearer. The `&` is optional for function pointers. `static const` is important to create a single, read-only instance of the vtable."}], indent: 0, explanation: "Define the vtable for StringObjects." },
    { "correct": "void string_destroy(BaseObject* obj) {", distractors: [{"text":"void string_destroy(StringObject* obj) {", reason:"The definition must match the prototype and the VTable's function pointer signature, which both use `BaseObject*`."}], indent: 0, explanation: "Begin `string_destroy`." },
    { "correct": "  StringObject* self = (StringObject*)obj;", distractors: [{"text":"  StringObject* self = obj;", reason:"This is a type mismatch. You must explicitly cast the generic `BaseObject*` back to the concrete `StringObject*` to access its specific members."}], indent: 1, explanation: "Cast the base object pointer back to a StringObject pointer." },
    { "correct": "  printf(\"  -> string_destroy: freeing value '%s'\\n\", self->value);", distractors: [{"text":"  printf(\"  -> string_destroy called.\\n\");", reason:"This is less useful for debugging. Logging the actual value being freed is better."}], indent: 1, explanation: "Log the specific destruction action." },
    { "correct": "  free(self->value);", distractors: [{"text":"  // No free needed", reason:"This is a memory leak. The `value` string was allocated by `strdup` (which uses `malloc`) and must be freed."}], indent: 1, explanation: "Free the character data." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function's closing brace."}], indent: 0, explanation: "End `string_destroy`." },
    { "correct": "StringObject* string_create(const char* value) {", distractors: [{"text":"StringObject* string_create(char* value) {", reason:"The definition should match the prototype. Using `const` is better as the function doesn't modify the input string."}], indent: 0, explanation: "Begin `string_create`." },
    { "correct": "  StringObject* obj = malloc(sizeof(StringObject));", distractors: [{"text":"  // No allocation needed", reason:"This is false. A new object must be dynamically allocated on the heap to persist after the function returns."}], indent: 1, explanation: "Allocate memory for the new StringObject." },
    { "correct": "  obj->base.ref_count = 1;", distractors: [{"text":"  obj->base.ref_count = 0;", reason:"This is a critical bug. A newly created object is returned to the caller, who now holds one reference. The count must start at 1."}], indent: 1, explanation: "Initialize reference count to 1 for the new reference." },
    { "correct": "  obj->base.vtable = &STRING_VTABLE;", distractors: [{"text":"  obj->base.vtable = NULL;", reason:"This is a bug. The vtable pointer must be set so that `object_release` can call the correct type-specific destructor."}], indent: 1, explanation: "Point the vtable to our string vtable." },
    { "correct": "  obj->value = strdup(value);", distractors: [{"text":"  obj->value = value;", reason:"This is a bug. It only copies the pointer, not the string content. `strdup` correctly allocates new memory for the string and copies the content into it."}], indent: 1, explanation: "Duplicate the provided string." },
    { "correct": "  printf(\"[RC] Create: StringObject at %p with value '%s', ref_count = 1\\n\", obj, obj->value);", distractors: [{"text":"  puts(\"Created string\");", reason:"This provides no useful debugging information. The detailed log is essential for tracing reference counts."}], indent: 1, explanation: "Log the creation event." },
    { "correct": "  return obj;", distractors: [{"text":"  return &obj;", reason:"`obj` is already a pointer. Returning its address would be a `StringObject**`, which is the wrong type."}], indent: 1, explanation: "Return the newly created object." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "End `string_create`." },
    { "correct": "// === Stage 4: Concrete Object Type - ListObject ===", distractors: [{"text":"// === Stage 4: StringObject ===", reason:"This stage defines a second, more complex concrete type: a list that can hold other reference-counted objects."}], indent: 0, explanation: "Define and implement a reference-counted list object that can hold other objects." },
    { "correct": "#define LIST_INITIAL_CAPACITY 4", distractors: [{"text":"#define LIST_INITIAL_CAPACITY 0", reason:"Starting with a capacity of 0 would force a `realloc` on the very first append, which is inefficient. Starting with a small capacity is better."}], indent: 0, explanation: "Initial capacity for our list." },
    { "correct": "typedef struct {", distractors: [{"text":"struct ListObject {", reason:"Using `typedef` provides a convenient alias."}], indent: 0, explanation: "Start ListObject definition." },
    { "correct": "  BaseObject base;", distractors: [{"text":"  BaseObject* base;", reason:"This is a critical error. The base object must be the first member, not a pointer, to allow for safe casting from `ListObject*` to `BaseObject*`."}], indent: 1, explanation: "Base object header." },
    { "correct": "  BaseObject** items;", distractors: [{"text":"  BaseObject* items[LIST_INITIAL_CAPACITY];", reason:"This creates a fixed-size list. To allow the list to grow, the `items` member must be a pointer (`BaseObject**`) that can be reallocated."}], indent: 1, explanation: "A dynamic array of pointers to other reference-counted objects." },
    { "correct": "  size_t size;", distractors: [{"text":"  int size;", reason:"`size_t` is the appropriate type for counts and sizes in C."}], indent: 1, explanation: "Current number of items in the list." },
    { "correct": "  size_t capacity;", distractors: [{"text":"  // No capacity needed", reason:"This is false. For a dynamic array, you must track both the current number of items (`size`) and the allocated capacity to know when to `realloc`."}], indent: 1, explanation: "Current allocated capacity of the items array." },
    { "correct": "} ListObject;", distractors: [{"text":"};", reason:"The `typedef` requires the alias name `ListObject` before the final semicolon."}], indent: 0, explanation: "End ListObject definition." },
    { "correct": "// Function prototypes for ListObject", distractors: [{"text":"// VTable for ListObject", reason:"This comment is inaccurate. These are function prototypes, not the vtable itself."}], indent: 0, explanation: "Forward declarations for list functions." },
    { "correct": "void list_destroy(BaseObject* obj);", distractors: [{"text":"void list_destroy(ListObject* obj);", reason:"To be compatible with the VTable, the destructor must have the signature `void (*destroy)(BaseObject*)`."}], indent: 0, explanation: "Destructor for ListObject." },
    { "correct": "ListObject* list_create();", distractors: [{"text":"void list_create(ListObject* list);", reason:"A 'constructor' function should handle its own allocation and return a pointer to the new object."}], indent: 0, explanation: "Constructor for ListObject." },
    { "correct": "void list_append(ListObject* list, BaseObject* item);", distractors: [{"text":"void list_append(ListObject* list, void* item);", reason:"While `void*` is generic, using `BaseObject*` is better here as it provides some type safety, ensuring only reference-counted objects can be added."}], indent: 0, explanation: "Appends an item to the list." },
    { "correct": "static const VTable LIST_VTABLE = { .destroy = list_destroy };", distractors: [{"text":"static const VTable LIST_VTABLE = { list_destroy };", reason:"Using designated initializers (`.destroy = ...`) is a clearer, more robust way to initialize structs."}], indent: 0, explanation: "Define the vtable for ListObjects." },
    { "correct": "void list_destroy(BaseObject* obj) {", distractors: [{"text":"void list_destroy(ListObject* self) {", reason:"The function signature must match the VTable, which expects a `BaseObject*`."}], indent: 0, explanation: "Begin `list_destroy`." },
    { "correct": "  ListObject* self = (ListObject*)obj;", distractors: [{"text":"  ListObject* self = obj;", reason:"This is a type mismatch. You must explicitly cast the generic `BaseObject*` to the concrete `ListObject*`."}], indent: 1, explanation: "Cast the base object pointer." },
    { "correct": "  printf(\"  -> list_destroy: releasing %zu items\\n\", self->size);", distractors: [{"text":"  puts(\"  -> list_destroy called.\");", reason:"This is less informative. Logging the number of items being released is useful for debugging."}], indent: 1, explanation: "Log the list destruction." },
    { "correct": "  // Release every object this list holds a reference to", distractors: [{"text":"  // Free every object in the list", reason:"'Release' is the more accurate term. The list is giving up its reference. The object is only freed if this is the *last* reference."}], indent: 1, explanation: "Comment on the crucial cascade release." },
    { "correct": "  for (size_t i = 0; i < self->size; i++) {", distractors: [{"text":"  free(self->items);", reason:"This is a massive memory leak. This would free the array of pointers, but not the objects that those pointers refer to."}], indent: 1, explanation: "Loop through all items in the list." },
    { "correct": "    object_release(self->items[i]);", distractors: [{"text":"    free(self->items[i]);", reason:"This is a bug. You must call `object_release` to correctly decrement the reference count. Calling `free` directly would bypass the reference counting system."}], indent: 2, explanation: "Release the list's reference to the item." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after a `for` loop."}], indent: 1, explanation: "End item loop." },
    { "correct": "  free(self->items);", distractors: [{"text":"  // No need to free items", reason:"This is a memory leak. The `items` array itself was dynamically allocated and must be freed."}], indent: 1, explanation: "Free the array of pointers itself." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used after a function definition."}], indent: 0, explanation: "End `list_destroy`." },
    { "correct": "ListObject* list_create() {", distractors: [{"text":"ListObject* list_create(size_t capacity) {", reason:"This is a valid alternative design that would allow the user to specify a starting capacity."}], indent: 0, explanation: "Begin `list_create`." },
    { "correct": "  ListObject* obj = malloc(sizeof(ListObject));", distractors: [{"text":"  ListObject* obj = malloc(sizeof(obj));", reason:"This is a bug. `sizeof(obj)` gives the size of a pointer, not the `ListObject` struct."}], indent: 1, explanation: "Allocate memory for the ListObject." },
    { "correct": "  obj->base.ref_count = 1;", distractors: [{"text":"  obj->base.ref_count = 0;", reason:"This is a bug. A new object must start with a reference count of 1 for the reference that is returned to the caller."}], indent: 1, explanation: "Initialize ref count to 1." },
    { "correct": "  obj->base.vtable = &LIST_VTABLE;", distractors: [{"text":"  obj->base.vtable = &STRING_VTABLE;", reason:"This is a critical bug. It would cause `object_release` to call the wrong destructor (`string_destroy`) when freeing a list."}], indent: 1, explanation: "Set the vtable pointer." },
    { "correct": "  obj->size = 0;", distractors: [{"text":"  // No need to init size", reason:"This is a bug. The size must be initialized to 0. A garbage value would cause the append logic to fail."}], indent: 1, explanation: "List starts empty." },
    { "correct": "  obj->capacity = LIST_INITIAL_CAPACITY;", distractors: [{"text":"  obj->capacity = 0;", reason:"This is inefficient. It would force a `realloc` on the very first item appended to the list."}], indent: 1, explanation: "Set initial capacity." },
    { "correct": "  obj->items = malloc(obj->capacity * sizeof(BaseObject*));", distractors: [{"text":"  obj->items = calloc(obj->capacity, sizeof(BaseObject*));", reason:"`calloc` also works and has the benefit of zero-initializing the memory, which sets all pointers to NULL."}], indent: 1, explanation: "Allocate the initial items array." },
    { "correct": "  printf(\"[RC] Create: ListObject at %p, ref_count = 1\\n\", obj);", distractors: [{"text":"  puts(\"Created list\");", reason:"This is not informative enough for debugging reference counting issues."}], indent: 1, explanation: "Log creation." },
    { "correct": "  return obj;", distractors: [{"text":"  return NULL;", reason:"The function must return the pointer to the newly created list object."}], indent: 1, explanation: "Return the new list." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses `}` to close function blocks."}], indent: 0, explanation: "End `list_create`." },
    { "correct": "void list_append(ListObject* list, BaseObject* item) {", distractors: [{"text":"void list_append(ListObject* list, const BaseObject* item) {", reason:"While the list doesn't modify the item, the `items` array is `BaseObject**`, so a `const` item would cause a type warning."}], indent: 0, explanation: "Begin `list_append`." },
    { "correct": "  if (list->size >= list->capacity) { /* Simple resize logic, not production-ready */", distractors: [{"text":"  if (list->size > list->capacity) {", reason:"This is an off-by-one error. The check must be `>=` to trigger a resize when `size` equals `capacity`."}], indent: 1, explanation: "Check if resize is needed." },
    { "correct": "    list->capacity *= 2;", distractors: [{"text":"    list->capacity++;", reason:"Incrementing by one is very inefficient. It would cause a `realloc` on every single append after the initial capacity is met. Doubling is a standard, efficient strategy."}], indent: 2, explanation: "Double the capacity." },
    { "correct": "    list->items = realloc(list->items, list->capacity * sizeof(BaseObject*));", distractors: [{"text":"    list->items = realloc(list->items, list->capacity * sizeof(BaseObject));", reason:"This is a bug. The array holds pointers, so the element size must be `sizeof(BaseObject*)`, not the size of the full struct."}], indent: 2, explanation: "Reallocate the items array." },
    { "correct": "  }", distractors: [{"text":"};", reason:"A semicolon is not used after an `if` block."}], indent: 1, explanation: "End resize block." },
    { "correct": "  // The list is taking ownership of a reference, so we must retain.", distractors: [{"text":"  // Just add the pointer to the list.", reason:"This is a critical bug. If the list doesn't 'retain' the object, its reference count won't be incremented. If the original owner releases it, the list will be left holding a dangling pointer."}], indent: 1, explanation: "Comment on the required retain call." },
    { "correct": "  object_retain(item);", distractors: [{"text":"  // No retain needed.", reason:"This is the central bug in reference counting. The list is a new 'owner' of the object, so it must increment the reference count via `retain`."}], indent: 1, explanation: "Increment the item's ref count because the list now points to it." },
    { "correct": "  list->items[list->size] = item;", distractors: [{"text":"  list->items[list->size + 1] = item;", reason:"This is an off-by-one error. The next available slot is at index `list->size`."}], indent: 1, explanation: "Add the item to the list." },
    { "correct": "  list->size++;", distractors: [{"text":"  // No need to increment size", reason:"This is a bug. Forgetting to increment the size would cause the next append to overwrite this one."}], indent: 1, explanation: "Increment the list size." },
    { "correct": "}", distractors: [{"text":"};", reason:"A semicolon is not used here."}], indent: 0, explanation: "End `list_append`." },
    { "correct": "// === Stage 5: Main Program for Demonstration ===", distractors: [{"text":"// === Stage 5: The Reference Counting Library ===", reason:"This is the main program that *uses* our reference counting objects to demonstrate how they work."}], indent: 0, explanation: "The main function to demonstrate the reference counting system." },
    { "correct": "int main() {", distractors: [{"text":"int main(void) {", reason:"This is an equally valid, and often preferred, way to define `main` when no command-line arguments are used."}], indent: 0, explanation: "Start of main." },
    { "correct": "  printf(\"--- Reference Counting Demo ---\\n\");", distractors: [{"text":"  puts(\"--- Reference Counting Demo ---\");", reason:"`puts` is a valid alternative that also prints a newline."}], indent: 1, explanation: "Demo title." },
    { "correct": "  // Create a list object. It is now owned by the 'my_list' variable.", distractors: [{"text":"  // Create a list object. Ref count is 0.", reason:"This is incorrect. A new object created by a 'create' function should always have a reference count of 1."}], indent: 1, explanation: "Comment on creating the list." },
    { "correct": "  ListObject* my_list = list_create();", distractors: [{"text":"  ListObject* my_list = NULL; list_create(my_list);", reason:"Our `create` function allocates the memory itself. The caller just needs to capture the returned pointer."}], indent: 1, explanation: "Create a list. ref_count=1." },
    { "correct": "  printf(\"\\n--- Populating List ---\\n\");", distractors: [{"text":"  puts(\"\\n--- Populating List ---\");", reason:"`puts` adds its own newline, so the initial `\\n` would create an unwanted blank line."}], indent: 1, explanation: "Header for population." },
    { "correct": "  // Create a string object. It is now owned by the 'str1' variable.", distractors: [{"text":"  // Create a string. It is owned by the list.", reason:"This is incorrect. At this point, only the `str1` pointer 'owns' a reference to the new object."}], indent: 1, explanation: "Comment on creating the first string." },
    { "correct": "  StringObject* str1 = string_create(\"Hello, Apple\");", distractors: [{"text":"  BaseObject* str1 = (BaseObject*)string_create(\"Hello, Apple\");", reason:"While this works, it's better to use the most specific type possible (`StringObject*`) for clarity and safety."}], indent: 1, explanation: "Create string 1. ref_count=1." },
    { "correct": "  // Add the string to the list. The list now also owns a reference.", distractors: [{"text":"  // Move the string to the list.", reason:"'Move' semantics are different. Here, we are creating a *shared* ownership, where both the local variable and the list have a reference."}], indent: 1, explanation: "Comment on appending." },
    { "correct": "  list_append(my_list, (BaseObject*)str1);", distractors: [{"text":"  list_append(my_list, str1);", reason:"This would be a compiler warning. `list_append` expects a `BaseObject*`, so we must explicitly cast our `StringObject*`."}], indent: 1, explanation: "Append str1. retain is called, str1->ref_count becomes 2." },
    { "correct": "  // We can release our original reference. The object will live on in the list.", distractors: [{"text":"  // We must not release our reference.", reason:"This is a key concept. Since the list has its own reference now, our local variable can (and should) release its reference to avoid a memory leak."}], indent: 1, explanation: "Comment on releasing local variable's reference." },
    { "correct": "  object_release((BaseObject*)str1);", distractors: [{"text":"  free(str1);", reason:"This is a bug. You must never call `free` directly on a reference-counted object. `object_release` must be used to correctly manage the reference count."}], indent: 1, explanation: "Release str1. ref_count drops to 1. It is not destroyed." },
    { "correct": "  // Append two more strings directly.", distractors: [{"text":"  // Create and forget two strings.", reason:"We are not forgetting them; we are immediately giving their reference to the list to manage."}], indent: 1, explanation: "Comment on creating and appending in one go." },
    { "correct": "  list_append(my_list, (BaseObject*)string_create(\"Cupertino\"));", distractors: [{"text":"  StringObject* str2 = string_create(\"Cupertino\"); list_append(my_list, (BaseObject*)str2);", reason:"This is also correct, but the original line shows how you can do it without a temporary local variable."}], indent: 1, explanation: "Create string 2 (ref_count=1), then append calls retain (ref_count=2)." },
    { "correct": "  list_append(my_list, (BaseObject*)string_create(\"Think Different\"));", distractors: [{"text":"  object_retain(list_append(my_list, ...));", reason:"This is incorrect. `list_append` doesn't return a value, and it already handles the retain internally."}], indent: 1, explanation: "Create string 3 (ref_count=1), then append calls retain (ref_count=2)." },
    { "correct": "  // We don't have local variables for the last two strings, but the list holds them.", distractors: [{"text":"  // The last two strings are now leaked.", reason:"This comment explains *why* the following manual release calls are needed to fix a subtle leak in the demo code."}], indent: 1, explanation: "Explanation for why we don't release the last two strings here." },
    { "correct": "  // Note: a better API would return the created object, which we would then release.", distractors: [{"text":"  // Note: This API is perfect.", reason:"The current API has a subtle ergonomic issue. The code `list_append(my_list, string_create(...))` leaks a reference. A better API might be `list_append_new_string(my_list, ...)`."}], indent: 1, explanation: "This shows a subtle memory leak in the demo code itself if not handled carefully." },
    { "correct": "  // For this demo, let's fix the above 'leaks' by releasing the temporary references.", distractors: [{"text":"  // The memory will be freed later.", reason:"This is incorrect. Without the following release calls, the reference count for these items would be 2, and they would never be destroyed."}], indent: 1, explanation: "Let's be explicit for the demo." },
    { "correct": "  object_release(my_list->items[1]);", distractors: [{"text":"  object_release(my_list->items[0]);", reason:"`items[0]` is the first string ('Hello, Apple'), whose local reference we already released. Releasing it again would be an error (a double-release)."}], indent: 1, explanation: "Release the 'Cupertino' reference created by string_create. Its ref_count is now 1 (held by list)." },
    { "correct": "  object_release(my_list->items[2]);", distractors: [{"text":"  free(my_list->items[2]);", reason:"You must always use `object_release`, never `free`, to correctly manage the reference count."}], indent: 1, explanation: "Release the 'Think Different' reference. Its ref_count is now 1." },
    { "correct": "  printf(\"\\n--- Triggering Cascade Release ---\\n\");", distractors: [{"text":"  puts(\"\\n--- Triggering Cascade Release ---\");", reason:"`puts` adds its own newline, so the initial `\\n` would cause an extra blank line."}], indent: 1, explanation: "Header for cascade test." },
    { "correct": "  // Now, we release our only reference to the list.", distractors: [{"text":"  // Now, we iterate and free the list.", reason:"This is incorrect. The core principle of reference counting is that you just 'release' your reference, and the system handles the destruction automatically if it was the last one."}], indent: 1, explanation: "Comment on the final release." },
    { "correct": "  // This should trigger the list's destruction, which in turn will release all its items.", distractors: [{"text":"  // This will free the list, but leak its items.", reason:"This is false. A correctly implemented `list_destroy` function will perform a cascade-release on all its items."}], indent: 1, explanation: "Explain the expected cascade." },
    { "correct": "  object_release((BaseObject*)my_list);", distractors: [{"text":"  list_destroy((BaseObject*)my_list);", reason:"This is a bug. You should never call a destructor directly. The `object_release` function handles this via the vtable when the reference count hits zero."}], indent: 1, explanation: "Release the list. Its ref_count drops to 0, and the cascade begins." },
    { "correct": "  printf(\"--- Demo Finished ---\\n\");", distractors: [{"text":"  puts(\"--- Demo Finished ---\");", reason:"`puts` is a valid alternative for printing this message."}], indent: 1, explanation: "Final message." },
    { "correct": "  return 0;", distractors: [{"text":"  return 1;", reason:"Returning 1 signals an error. Since the demo completed successfully, it should return 0."}], indent: 1, explanation: "Indicate success." },
    { "correct": "}", distractors: [{"text":"end;", reason:"C uses a closing brace `}` to end a function block."}], indent: 0, explanation: "End of main." }
]
}
]