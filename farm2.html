<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Chim Farms</title>
    <link rel="icon" href="data:,">
   <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet"/>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
      integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <script>
// Check if Babylon.js loads properly
window.addEventListener('load', () => {
  setTimeout(() => {
    if (typeof BABYLON === 'undefined') {
      console.error('Babylon.js failed to load from CDN');
      document.body.innerHTML = '<div style="color: white; text-align: center; padding: 50px;">Error: Failed to load 3D engine. Please refresh the page.</div>';
    }
  }, 2000);
});
</script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    
    <style>

        
/* Replace existing header styles with this */
.top-nav {
  background: rgba(255, 255, 255, 0.08) !important;
  backdrop-filter: blur(40px) saturate(180%) !important;
  -webkit-backdrop-filter: blur(40px) saturate(180%) !important;
  height: 60px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08) !important;
  position: fixed;         
  z-index: 50;              
}

/* Add to body */
body {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

      html {
        font-size: 100%;
        scroll-behavior: smooth;
      }
      body {
        font-family: 'Space Grotesk', sans-serif;
        background-color: #030712; /* gray-950 */
        overflow: hidden;
        position: relative;
        margin: 0;
        color: #E5E7EB;
      }

#game-container {
  height: 100vh !important;
  width: 100vw !important;
  position: relative;
}
      #game-container.pointer-locked {
        cursor: none; /* Hide cursor when locked */
      }
      canvas { display: block; }

      /* Hide game UI by default */
      #game-ui {
        display: none;
      }
      
      /* Hide message box by default */
      #message-box {
        display: none;
      }

      .star-button-container { position: relative; z-index: 50; }
      .star-button { /* Renamed from reserves-button for consistency, but ID is reserves-button */
        background-color: rgba(17, 24, 39, 0.7); backdrop-filter: blur(8px); border: 1px solid rgba(55, 65, 81, 0.6);
        transition: all 0.3s ease; padding: 0.5rem 1rem; border-radius: 9999px; display: flex; align-items: center; gap: 0.5rem;
        font-size: 0.875rem; color: #D1D5DB; cursor: pointer;
      }
      .star-button .fa-star { color: #FACC15; /* Tailwind yellow-400 */ margin-right: 0.25rem;}
      .star-button:hover { border-color: rgba(255, 255, 255, 0.7); background-color: rgba(17, 24, 39, 0.9); color: #ffffff; }
      .star-dropdown {
        position: absolute; top: calc(100% + 0.5rem); right: 0; background-color: rgba(31, 41, 55, 0.95); backdrop-filter: blur(12px);
        border: 1px solid rgba(75, 85, 99, 0.7); border-radius: 0.75rem; padding: 0.75rem; width: 340px; /* Slightly wider */
        z-index: 60; opacity: 0; visibility: hidden; transform: translateY(-10px) scale(0.98);
        transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s ease;
        display: flex; flex-direction: column; gap: 0.75rem; box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        max-height: 70vh; overflow-y: auto; /* Scrollable dropdown */
      }
      .star-dropdown.active { opacity: 1; visibility: visible; transform: translateY(0) scale(1); }
      .dropdown-item {
        display: flex; align-items: center; padding: 0.75rem; background-color: rgba(55, 65, 81, 0.6); border-radius: 0.5rem;
        transition: background-color 0.2s ease, transform 0.15s ease; cursor: pointer; border: 1px solid transparent;
      }
      .dropdown-item:hover { background-color: rgba(75, 85, 99, 0.8); transform: translateX(4px); border-color: rgba(107, 114, 128, 0.7); }
      .dropdown-item-icon {
        width: 40px; height: 40px; border-radius: 0.375rem; margin-right: 0.75rem;
        object-fit: cover; flex-shrink: 0; border: 1px solid rgba(75, 85, 99, 0.5);
        display: flex; align-items: center; justify-content: center; font-size: 1.5rem; /* For emoji/text placeholders */
      }
      .dropdown-item-content { flex-grow: 1; margin-right: 0.5rem; }
      .dropdown-item-title { color: #F3F4F6; font-weight: 500; font-size: 0.875rem; line-height: 1.2; margin-bottom: 2px; }
      .dropdown-item-desc { color: #9CA3AF; font-size: 0.75rem; line-height: 1.3; }
      .dropdown-item-price {
        background-color: #4B5563; color: #ffffff; font-size: 0.75rem; font-weight: 600; padding: 0.35rem 0.7rem; border-radius: 9999px;
        transition: all 0.2s ease; white-space: nowrap; border: none; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      .dropdown-item:hover .dropdown-item-price:not([disabled]) { background-color: #374151; transform: scale(1.05); }
      .dropdown-item-price[disabled] { background-color: #374151; color: #6b7280; cursor: not-allowed; opacity: 0.6; }
      .dropdown-item-price[disabled]:hover { background-color: #374151; transform: none; }

      @import "tailwindcss";
      @keyframes particleFade {
        0% { opacity: 0.7; transform: translate(0, 0) scale(1); }
        100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(0.5); }
      }
      
      .crosshair {
        position: fixed; top: 50%; left: 50%; width: 10px; height: 10px;
        border: 1px solid white; background-color: rgba(255,255,255,0.3);
        border-radius: 50%; transform: translate(-50%, -50%);
        pointer-events: none; z-index: 1000; display: none;
      }
      
      .payment-options-dropdown {
        position: absolute;
        background-color: rgba(31, 41, 55, 0.98);
        border: 1px solid rgba(75, 85, 99, 0.8);
        border-radius: 0.5rem;
        padding: 0.5rem;
        z-index: 70;
        width: 300px;
        box-shadow: 0 8px 16px rgba(0,0,0,0.4);
        display: none;
      }
      
      .payment-option {
        padding: 0.75rem;
        margin-bottom: 0.5rem;
        border-radius: 0.375rem;
        background-color: rgba(55, 65, 81, 0.7);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .payment-option:hover {
        background-color: rgba(75, 85, 99, 0.9);
        transform: translateX(4px);
      }
      
      .payment-option-label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      
      .third-party-warning {
        font-size: 0.7rem;
        color: #FCA5A5;
        padding: 0.25rem 0.5rem;
        background-color: rgba(153, 27, 27, 0.3);
        border-radius: 4px;
        margin-top: 0.25rem;
      }
      
      .shop-header-notice {
        color: #E5E7EB;
        font-size: 0.75rem;
        line-height: 1.3;
        padding: 0.75rem;
        background-color: rgba(79, 70, 229, 0.2);
        border: 1px solid rgba(79, 70, 229, 0.4);
        border-radius: 0.5rem;
        margin-bottom: 0.75rem;
      }
      
      .demo-badge {
        font-size: 0.65rem;
        padding: 0.15rem 0.4rem;
        background-color: rgba(245, 158, 11, 0.2);
        color: #FBBF24;
        border: 1px solid rgba(245, 158, 11, 0.4);
        border-radius: 9999px;
        margin-left: 0.5rem;
        vertical-align: middle;
      }
      
      .live-badge {
        font-size: 0.65rem;
        padding: 0.15rem 0.4rem;
        background-color: rgba(16, 185, 129, 0.2);
        color: #34D399;
        /* Removed border per requirement */
        border-radius: 9999px;
        margin-left: 0.5rem;
        vertical-align: middle;
        display: none;
      }
      
      .third-party-farms-section {
        display: none;
        margin-top: 0.5rem;
      }
      
      /* New aerial view styling */
      #aerial-view-container {
  position: fixed;
  top: 0;                 
  width: 100vw;
  height: 100vh;         
  z-index: 2;
  display: none;
  background-color: rgba(3, 7, 18, 0.9);
      }
      
      /* Mode selection popup */
      #mode-selection-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(31, 41, 55, 0.95);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(75, 85, 99, 0.7);
        border-radius: 0.75rem;
        padding: 1.5rem;
        width: 300px;
        z-index: 75;
        box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        display: none;
      }
      
      .mode-option {
        display: flex;
        align-items: center;
        padding: 1rem;
        margin-bottom: 1rem;
        background-color: rgba(55, 65, 81, 0.6);
        border-radius: 0.5rem;
        border: 1px solid transparent;
        transition: all 0.2s ease;
        cursor: pointer;
      }
      
      .mode-option:hover {
        background-color: rgba(75, 85, 99, 0.8);
        border-color: rgba(107, 114, 128, 0.7);
        transform: translateY(-2px);
      }
      
      .mode-icon {
        font-size: 1.5rem;
        margin-right: 1rem;
      }
      
      .mode-content h3 {
        font-weight: 600;
        font-size: 1.1rem;
        margin-bottom: 0.25rem;
      }
      
      .mode-content p {
        font-size: 0.8rem;
        color: #9CA3AF;
      }
      
      /* Prast Farms popup */
      #prast-farms-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(31, 41, 55, 0.95);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(75, 85, 99, 0.7);
        border-radius: 0.75rem;
        padding: 1.5rem;
        width: 450px;
        z-index: 80;
        box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        display: none;
      }
      
      .prast-farms-header {
        font-size: 1.5rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        text-align: center;
      }
      
      .prast-farms-subheader {
        font-size: 0.85rem;
        color: #9CA3AF;
        text-align: center;
        margin-bottom: 1.5rem;
      }
      
      /* Third party farms prompt */
      .third-party-prompt {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem;
        background-color: rgba(79, 70, 229, 0.2);
        border: 1px solid rgba(188, 187, 210, 0.4);
        border-radius: 0.5rem;
        margin-top: 0.5rem;
      }
      
      /* Search functionality */
      .search-container {
        display: flex;
        margin-bottom: 1rem;
        position: relative;
      }
      
      .search-input {
        flex-grow: 1;
        background-color: rgba(55, 65, 81, 0.6);
        border: 1px solid rgba(75, 85, 99, 0.5);
        border-radius: 0.5rem;
        padding: 0.5rem 1rem;
        color: #E5E7EB;
        font-size: 0.875rem;
      }
      
      .search-input:focus {
        outline: none;
        border-color: rgba(107, 114, 128, 0.8);
        background-color: rgba(55, 65, 81, 0.8);
      }
      
      .search-button {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: #9CA3AF;
        cursor: pointer;
        padding: 0.25rem;
      }
      
      .search-button:hover {
        color: #E5E7EB;
      }

      /* Farm Management Panel Styles */
      #farm-management {
        width: calc(100% - 32px) !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        right: auto !important;
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
      }
      
      #farm-management.hidden {
        transform: translateX(-50%) translateY(100%) !important;
        display: none;
      }
      
      @media (max-width: 640px) {
        #farm-management {
          width: calc(100% - 16px) !important;
        }
      }
      
      .animal-item {
        background-color: rgba(31, 41, 55, 0.8);
        border-radius: 0.75rem;
        padding: 1rem;
        min-width: 220px;
        flex-shrink: 0;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        border: 1px solid rgba(75, 85, 99, 0.4);
      }
      
      .animal-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        border-color: rgba(75, 85, 99, 0.6);
      }
      
      .animal-header {
        display: flex;
        align-items: center;
        margin-bottom: 0.75rem;
      }
      
      .animal-icon {
        width: 32px;
        height: 32px;
        border-radius: 0.375rem;
        background-color: rgba(55, 65, 81, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 0.75rem;
        font-size: 1.125rem;
      }
      
      .animal-name {
        font-weight: 600;
        font-size: 1.25rem;
        color: white;
        flex-grow: 1;
        cursor: text;
        padding: 2px 4px;
        border-radius: 4px;
      }
      
      .animal-name:hover {
        background-color: rgba(75, 85, 99, 0.6);
      }
      
      .animal-stat {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
        color: #e5e7eb;
      }
      
      .health-bar {
        width: 100%;
        height: 8px;
        background-color: rgba(239, 68, 68, 0.2);
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 1rem;
      }
      
      .health-bar-fill {
        height: 100%;
        background-color: rgb(34, 197, 94);
        border-radius: 4px;
      }
      
      .animal-actions {
        display: flex;
        gap: 0.5rem;
      }
      
      .animal-action-btn {
        flex: 1;
        padding: 0.5rem;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        text-align: center;
        color: white;
        border: none;
        cursor: pointer;
        transition: all 0.2s ease;
      }
    </style>
</head>
<script>
// Check if Babylon.js loaded correctly
if (typeof BABYLON === 'undefined') {
    console.error('Babylon.js failed to load from CDN');
    // Fallback to a different CDN
    document.write('<script src="https://cdn.babylonjs.com/babylon.js"><\/script>');
    document.write('<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"><\/script>');
    document.write('<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"><\/script>');
}
</script>
<body class="text-gray-100 min-h-screen flex flex-col">
  

  <nav class="top-nav fixed top-0 left-0 right-0 z-50 backdrop-blur-none">
    <div class="mx-auto h-full flex items-center justify-between px-4 sm:px-6">
      <div class="flex items-center gap-3">
        
        <span class="text-xl font-bold text-white group-hover:text-white transition-colors duration-200"> Chim Farms
          <span class="demo-badge" id="app-mode-badge">demo</span>
          <span class="live-badge" id="live-mode-badge">live</span>
        </span>
      </div>
      <div class="flex items-center gap-4">
        <a href="#" id="library-button" class="group flex items-center gap-2 bg-gray-800/60 hover:bg-gray-700/80 border border-gray-700 hover:border-gray-500 px-4 py-2 rounded-full transition-all duration-300 text-gray-300 hover:text-white text-sm">
          <span>Library</span> </a>
        <div class="star-button-container">
          <button id="reserves-button" class="star-button" aria-haspopup="true" aria-expanded="false">
  <i class="fas fa-star text-yellow-400"></i> <span id="reserves-amount">2000</span>
</button>
          <div id="farm-store-dropdown" class="star-dropdown" role="menu">
            <div class="search-container">
              <input type="text" class="search-input" placeholder="Search for farms or items...">
              <button class="search-button">
                <i class="fas fa-search"></i>
              </button>
            </div>
            
            
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="chicken" data-cost="500">
                <div class="dropdown-item-icon bg-yellow-700">🐔</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Chicken Farm</div>
                  <div class="dropdown-item-desc">80% annual return. Produces eggs.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-chicken-farm"></button>
              </div>
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="pig" data-cost="1000">
                <div class="dropdown-item-icon bg-pink-400">🐖</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Pig Farm</div>
                  <div class="dropdown-item-desc">100% annual return. Hardy animals.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-pig-farm"></button>
              </div>
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="cow" data-cost="2499">
                <div class="dropdown-item-icon bg-gray-400">🐄</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Cow Farm</div>
                  <div class="dropdown-item-desc">130% annual return. Milk and more.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-cow-farm"></button>
              </div>
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="goat" data-cost="749">
                <div class="dropdown-item-icon bg-stone-400">🐐</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Goat Farm</div>
                  <div class="dropdown-item-desc">60% annual return. Agile climbers.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-goat-farm"></button>
              </div>
             <div class="dropdown-item" role="menuitem" data-type="animal" data-id="fish" data-cost="99">
                <div class="dropdown-item-icon bg-sky-400">🐟</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Fish Pond</div>
                  <div class="dropdown-item-desc">60% annual return. Fresh catches.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-fish-farm"></button>
              </div>
              <hr class="border-gray-600 my-2">
              <div class="px-2 py-1 text-xs text-gray-400 uppercase">Plants (Max 1 Each)</div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="plantain" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-lime-600">🍌</div> <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Plantain Seeds</div>
                  <div class="dropdown-item-desc">~50% annual return. Versatile fruit.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-plantain"></button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="banana" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-yellow-500">🍌</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Banana Sapling</div>
                  <div class="dropdown-item-desc">~50% annual return. Sweet yield.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-banana"></button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="orange" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-orange-500">🍊</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Orange Tree Seedling</div>
                  <div class="dropdown-item-desc">~50% annual return. Juicy harvest.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-orange"></button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="sugarcane" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-green-700">🌿</div> <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Sugar Cane Stalk</div>
                  <div class="dropdown-item-desc">~50% annual return. Sweet raw material.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-sugarcane"></button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="coconut" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-yellow-800">🥥</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Coconut Seed</div>
                  <div class="dropdown-item-desc">~50% annual return. Tropical delight.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-coconut"></button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="papaya" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-orange-400">🥭</div> <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Papaya Seeds</div>
                  <div class="dropdown-item-desc">~50% annual return. Exotic fruit.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-papaya"></button>
              </div>
              <div class="dropdown-item" role="menuitem" data-type="plant" data-id="carrot" data-cost="50" data-max="1">
                <div class="dropdown-item-icon bg-orange-600">🥕</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Carrot Seeds</div>
                  <div class="dropdown-item-desc">~50% annual return. Root vegetable.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-carrot"></button>
              </div>
              <hr class="border-gray-600 my-2">
              <div class="px-2 py-1 text-xs text-gray-400 uppercase">Land & Partnerships</div>
              <div class="dropdown-item" role="menuitem" data-type="land" data-id="expansion" data-cost="2000">
                <div class="dropdown-item-icon bg-emerald-800">🏞️</div>
                <div class="dropdown-item-content">
                  <div class="dropdown-item-title">Land Expansion</div>
                  <div class="dropdown-item-desc">Expand your land by 100%. More room for farms.</div>
                </div>
                <button class="dropdown-item-price" data-action="get-land-expansion"></button>
              </div>
              
              <div class="third-party-prompt">
                <div>
                  <span class="font-semibold">Want to purchase from third party farms?</span>
                  <p class="text-xs text-gray-400">Explore more farming options globally</p>
                </div>
                <button class="dropdown-item-price" data-action="show-third-party-farms">View</button>
              </div>
              
              <div class="third-party-farms-section" id="third-party-farms">
                <div class="px-2 py-1 text-xs text-amber-300">THIRD PARTY FARMS</div>
                
                <div class="search-container">
                  <input type="text" class="search-input" placeholder="Find a farm...">
                  <button class="search-button">
                    <i class="fas fa-search"></i>
                  </button>
                </div>
                
                <div class="dropdown-item" role="menuitem" data-type="third-party" data-id="sunshine-acres" data-cost="1500" data-return="85">
                  <div class="dropdown-item-icon bg-yellow-600">🌞</div>
                  <div class="dropdown-item-content">
                    <div class="dropdown-item-title">Sunshine Acres</div>
                    <div class="dropdown-item-desc">85% annual return. Organic methods.</div>
                    <div class="third-party-warning">Requires auditing fee</div>
                  </div>
                  <button class="dropdown-item-price" data-action="get-third-party-farm"></button>
                </div>
                
                <div class="dropdown-item" role="menuitem" data-type="third-party" data-id="azure-fields" data-cost="3500" data-return="120">
                  <div class="dropdown-item-icon bg-blue-400">🌾</div>
                  <div class="dropdown-item-content">
                    <div class="dropdown-item-title">Azure Fields</div>
                    <div class="dropdown-item-desc">120% annual return. Scale operations.</div>
                    <div class="third-party-warning">Requires auditing fee</div>
                  </div>
                  <button class="dropdown-item-price" data-action="get-third-party-farm"></button>
                </div>
                
                <div class="dropdown-item" role="menuitem" data-type="third-party" data-id="emerald-valleys" data-cost="7500" data-return="150">
                  <div class="dropdown-item-icon bg-emerald-500">🏞️</div>
                  <div class="dropdown-item-content">
                    <div class="dropdown-item-title">Emerald Valleys</div>
                    <div class="dropdown-item-desc">150% annual return. Premium operation.</div>
                    <div class="third-party-warning">Requires auditing fee</div>
                  </div>
                  <button class="dropdown-item-price" data-action="get-third-party-farm"></button>
                </div>
                
                <div class="dropdown-item" role="menuitem" data-type="third-party" data-id="mountain-vista" data-cost="5000" data-return="135">
                  <div class="dropdown-item-icon bg-indigo-500">⛰️</div>
                  <div class="dropdown-item-content">
                    <div class="dropdown-item-title">Mountain Vista</div>
                    <div class="dropdown-item-desc">135% annual return. Highland specialty crops.</div>
                    <div class="third-party-warning">Requires auditing fee</div>
                  </div>
                  <button class="dropdown-item-price" data-action="get-third-party-farm"></button>
                </div>
                
                <div class="dropdown-item" role="menuitem" data-type="third-party" data-id="coastal-breeze" data-cost="4200" data-return="125">
                  <div class="dropdown-item-icon bg-cyan-400">🌊</div>
                  <div class="dropdown-item-content">
                    <div class="dropdown-item-title">Coastal Breeze</div>
                    <div class="dropdown-item-desc">125% annual return. Seaside agriculture.</div>
                    <div class="third-party-warning">Requires auditing fee</div>
                  </div>
                  <button class="dropdown-item-price" data-action="get-third-party-farm"></button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </nav>

  <div id="game-container">
  </div>
  
  <div id="aerial-view-container">
    </div>
  
  <div class="crosshair" id="crosshair"></div>


  
<div id="management-popup" class="payment-options-dropdown">
  <div class="px-2 py-1 mb-2 text-xs text-gray-300 text-center font-semibold">MANAGE FARM</div>
  <div class="payment-option" data-action="buy-more">
    <div class="payment-option-label">
      <i class="fas fa-plus text-green-400"></i>
      <span>Buy Another</span>
    </div>
    <span class="payment-price" id="buy-more-price">500</span>
  </div>
  <div class="payment-option" data-action="sell-item">
    <div class="payment-option-label">
      <i class="fas fa-minus text-red-400"></i>
      <span>Sell Farm</span>
    </div>
    <span class="payment-price" id="sell-price">250</span>
  </div>
</div>

  <div id="mode-selection-popup">
    <h2 class="text-xl font-bold mb-4 text-center">Select Mode</h2>

    <div id="library-mode-notice" class="text-xs text-gray-300 mb-4 px-1 text-center" style="line-height: 1.4;">
        Live mode partners you with real farms; You'll be charged upon approval.
    </div>
    <div class="mode-option" data-mode="demo">
        <div class="mode-icon">
            <i class="fas fa-star text-yellow-400"></i>
        </div>
        <div class="mode-content">
            <h3>Demo Mode</h3>
            <p>Try out the experience with your reserves.</p>
        </div>
    </div>

    <div class="mode-option" data-mode="live">
        <div class="mode-icon">
            <i class="fas fa-dollar-sign text-green-400"></i>
        </div>
        <div class="mode-content">
            <h3>Live Mode</h3>
            <p> Real investments with fixed audited returns.</p>
        </div>
    </div>
</div>
  
  <div id="prast-farms-popup">
    <div class="prast-farms-header">Prast Farms</div>
    <div class="prast-farms-subheader">
       Live mode partners you with real farms; You'll be charged upon approval.
    </div>
    
    <div class="prast-farms-content">
      </div>
    
    <div class="mt-4 flex justify-end">
      <button class="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-md mr-2" id="prast-farms-close">Close</button>
      <button class="bg-indigo-600 hover:bg-indigo-500 text-white px-4 py-2 rounded-md" id="prast-farms-continue">Continue</button>
    </div>
  </div>

<!-- Farm Management Panel -->
<div id="farm-management" class="fixed bottom-0 left-1/2 transform -translate-x-1/2 z-50 hidden flex-col w-[calc(100%-32px)] rounded-t-xl overflow-hidden shadow-2xl border border-gray-700 border-b-0">
  <div class="w-full bg-gray-800/90 backdrop-blur-xl p-3 flex justify-between items-center">
    <h3 id="farm-management-title" class="text-lg font-semibold text-white">Managing Chicken Farm</h3>
    <div class="flex items-center gap-3">
      <button id="buy-animals" class="px-5 py-2 bg-green-700 hover:bg-green-600 rounded-md text-white text-sm md:text-lg transition-colors">Buy</button>
      <button id="sell-all-animals" class="px-5 py-2 bg-red-700 hover:bg-red-600 rounded-md text-white text-sm md:text-lg transition-colors">Sell All</button>
      <button id="exit-management" class="ml-2 w-8 h-8 flex items-center justify-center bg-gray-700 hover:bg-gray-600 rounded-full transition-colors">
        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </div>
  </div>
  
  <div class="w-full bg-gray-900/80 backdrop-blur-xl p-3 overflow-x-auto">
    <div id="animals-list" class="flex gap-3 pb-1">
    </div>
  </div>
</div>

<div id="buy-animals-popup" class="fixed inset-0 z-60 hidden items-center justify-center">
  <div class="bg-gray-900 p-4 rounded-lg border border-gray-700 w-80">
    <h3 class="text-center text-lg font-bold mb-3">Buy Animals</h3>
    <div class="flex items-center justify-between mb-4">
      <span>Quantity:</span>
      <div class="flex items-center">
        <button id="decrease-qty" class="px-2 py-1 bg-gray-700 rounded-l-md">-</button>
        <input id="animal-qty" type="number" value="1" min="1" class="w-16 px-2 py-1 text-center bg-gray-800 border-0">
        <button id="increase-qty" class="px-2 py-1 bg-gray-700 rounded-r-md">+</button>
      </div>
    </div>
    <div class="flex justify-between">
      <button id="cancel-buy" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded-md">Cancel</button>
      <button id="confirm-buy" class="px-3 py-1 bg-green-700 hover:bg-green-600 rounded-md">Confirm</button>
    </div>
  </div>
</div>

  <script>
 
document.addEventListener('DOMContentLoaded', () => {
  // MOVE ALL VARIABLE DECLARATIONS TO THE TOP FIRST
  const gameContainer = document.getElementById('game-container');
  const aerialViewContainer = document.getElementById('aerial-view-container');
  const reservesButton = document.getElementById('reserves-button');
  const reservesAmountSpan = document.getElementById('reserves-amount');
  const farmStoreDropdown = document.getElementById('farm-store-dropdown');
  const libraryButton = document.getElementById('library-button');
  const messageBox = document.getElementById('message-box');
  const crosshair = document.getElementById('crosshair');
  const paymentOptions = document.getElementById('payment-options');
  const appModeBadge = document.getElementById('app-mode-badge');
  const liveModeBadge = document.getElementById('live-mode-badge');
  const thirdPartyFarmsSection = document.getElementById('third-party-farms');
  const modeSelectionPopup = document.getElementById('mode-selection-popup');
  const prastFarmsPopup = document.getElementById('prast-farms-popup');

function initBabylonJS(gameContainer) {
const canvas = document.createElement('canvas');
canvas.style.width = '100%';
canvas.style.height = '100%';
canvas.style.display = 'block';
canvas.style.position = 'absolute';
canvas.style.top = '0';
canvas.style.left = '0';
gameContainer.appendChild(canvas);

// Add this after: gameContainer.appendChild(canvas);
canvas.style.width = '100%';
canvas.style.height = '100%';
canvas.style.display = 'block';

// Let the CSS handle the sizing automatically

console.log("Canvas created:", canvas);
console.log("Canvas dimensions:", canvas.width, canvas.height);

        engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color3(0.0117, 0.0275, 0.0706); // #030712
        scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;
        scene.fogColor = initialFogColor;
        scene.fogStart = 20;
        scene.fogEnd = worldSize * 0.7;

        camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0, playerHeight, 0), scene);
camera.setTarget(BABYLON.Vector3.Zero());
camera.minZ = 0.1;
camera.maxZ = 1000;

player = new BABYLON.TransformNode("player", scene);
player.position = new BABYLON.Vector3(0, playerHeight / 2, 5);
camera.parent = player;

// ADD THIS LINE:
scene.activeCamera = camera;

        // Enable shadows
        const directionalLight = new BABYLON.DirectionalLight("directionalLight", new BABYLON.Vector3(-50, -80, -30), scene);
        directionalLight.intensity = 1.0;
        directionalLight.position = new BABYLON.Vector3(50, 80, 30);
        
        const shadowGenerator = new BABYLON.ShadowGenerator(4096, directionalLight);
        shadowGenerator.useExponentialShadowMap = true;

        const ambientLight = new BABYLON.HemisphericLight("ambientLight", new BABYLON.Vector3(0, 1, 0), scene);
        ambientLight.intensity = 0.7;

        // Create ground with grass texture
        const groundTexture = createGrassTexture(512, 512);
        const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
        groundMaterial.diffuseTexture = groundTexture;
        groundMaterial.roughness = 0.8;

        ground = BABYLON.MeshBuilder.CreateDisc("ground", {radius: worldSize/2, tessellation: 64}, scene);
        ground.rotation.x = -Math.PI / 2;
        ground.material = groundMaterial;
        ground.receiveShadows = true;
        worldObjects.push(ground);

        // Add ocean and boat
        createOceanAndBoat();

        createEnvironmentFeatures();
        setupControls();
        animate();
        window.addEventListener('resize', onWindowResize, false);
        updateReservesDisplay();
      }

  // NOW DEFINE THE BABYLON.JS LOADING FUNCTION
  function waitForBabylon() {
    if (typeof BABYLON !== 'undefined') {
      console.log('Babylon.js loaded successfully');
      initBabylonJS(gameContainer);
      updateReservesDisplay();
    } else {
      console.log('Waiting for Babylon.js...');
      setTimeout(waitForBabylon, 100);
    }
  }

  // START THE LOADING PROCESS
  waitForBabylon();

function isPositionAvailable(position, radius) {
  for (const space of occupiedSpaces) {
    const distance = BABYLON.Vector3.Distance(position, space.position);
    if (distance < (radius + space.radius)) {
      return false; 
    }
  }
  return true;
}

function markPositionOccupied(position, radius) {
  occupiedSpaces.push({
    position: position.clone(),
    radius: radius
  });
}

const animalLifespans = {
    chicken: 1825,  // 5 years
    pig: 4380,      // 12 years
    cow: 5475,      // 15 years 
    goat: 4380,     // 12 years
    fish: 5475      // 15 years
  };

  const plantLifespans = {
    plantain: 5475,   // 15 years
    banana: 1460,     // 4 years
    orange: 18250,    // 50 years
    sugarcane: 1825,  // 5 years
    coconut: 25550,   // 70 years
    papaya: 1825,     // 5 years 
    carrot: 365       // 1 year
  };

  function calculateAgePercent(type, daysOld) {
    const maxLifespan = animalLifespans[type] || plantLifespans[type] || 1825; // Default to 5 years
    return Math.min(Math.round((daysOld / maxLifespan) * 100), 100); // Cap at 100%
  }
      
      let playerReserves = 2000;
      let isLiveMode = false;
      let currentPaymentItem = null;
      let isAerialView = false;
      let aerialViewCamera, aerialViewEngine, aerialViewScene; // For aerial view

      
      
      // Track if we need to update portfolio value
      let lastPortfolioUpdate = Date.now();
      
      // Define returns for each farm type as a base value plus the annual return
      const farmReturns = {
        chicken: 0.80,  // 80% annual return
        pig: 1.00,      // 100% annual return
        cow: 1.30,      // 130% annual return
        goat: 0.60,     // 60% annual return
        fish: 0.60,     // 60% annual return
        plantain: 0.50,  // 50% annual return
        banana: 0.50,    // 50% annual return
        orange: 0.50,    // 50% annual return
        sugarcane: 0.50, // 50% annual return
        coconut: 0.50,   // 50% annual return
        papaya: 0.50,    // 50% annual return
        carrot: 0.50     // 50% annual return
      };

// Animal tracking data structure
const animalData = {
  chicken: [],
  pig: [],
  cow: [],
  goat: [],
  fish: []
};

// Function to generate a random animal name
function generateAnimalName(type) {
  const prefixes = ["Happy", "Fluffy", "Speedy", "Sunny", "Lucky"];
  const chickenNames = ["Cluck", "Peck", "Wing", "Feather", "Egg"];
  const pigNames = ["Oink", "Snout", "Curly", "Mud", "Trotter"];
  const cowNames = ["Moo", "Spot", "Milk", "Bell", "Daisy"];
  const goatNames = ["Billy", "Gruff", "Mountain", "Beard", "Hopper"];
  const fishNames = ["Bubbles", "Fin", "Splash", "Gill", "Scale"];
  
  const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
  let suffix;
  
  switch(type) {
    case 'chicken': suffix = chickenNames[Math.floor(Math.random() * chickenNames.length)]; break;
    case 'pig': suffix = pigNames[Math.floor(Math.random() * pigNames.length)]; break;
    case 'cow': suffix = cowNames[Math.floor(Math.random() * cowNames.length)]; break;
    case 'goat': suffix = goatNames[Math.floor(Math.random() * goatNames.length)]; break;
    case 'fish': suffix = fishNames[Math.floor(Math.random() * fishNames.length)]; break;
    default: suffix = "Animal";
  }
  
  return `${prefix} ${suffix}`;
}

// Function to create a new animal data object
function createAnimalData(type) {
  return {
    id: Date.now().toString(36) + Math.random().toString(36).substring(2, 5),
    name: generateAnimalName(type),
    age: 0, // Days
    stage: "Baby",
    health: 100,
    lastFed: new Date(),
    created: new Date(), // This is crucial for age calculation
    mesh: null // Will store reference to 3D mesh
  };
}

      // Track farm purchase dates and investment amounts
      let farmValues = {
        demo: {}, // Will track values for demo mode farms
        live: {}  // Will track values for live mode farms
      };

      // Separate inventory for each mode
      let demoInventory = {
        chicken: 0, pig: 0, cow: 0, goat: 0, fish: 0,
        plantain: 0, banana: 0, orange: 0, sugarcane: 0, coconut: 0, papaya: 0, carrot: 0,
        expansion: 0, // Land expansion
      };
      
      let liveInventory = {
        chicken: 0, pig: 0, cow: 0, goat: 0, fish: 0,
        plantain: 0, banana: 0, orange: 0, sugarcane: 0, coconut: 0, papaya: 0, carrot: 0,
        expansion: 0, // Land expansion
      };
      
      // Use the appropriate inventory based on the current mode
      let purchasedItems = demoInventory;

      let scene, camera, engine, player, ground;
      let playerVelocity = new BABYLON.Vector3();
      let playerOnGround = false;
      const playerHeight = 1.8; // Player's eye height
      const playerCapsuleRadius = 0.4; // For potential future capsule collision
      const playerSpeed = 8.0;
      const playerJumpForce = 7.0;
      const gravity = -20.0;
      let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
      let worldObjects = []; // For farms, plants, trees, stream for potential interaction/collision
      let chickenAIMeshes = []; // Store chickens that need AI updates
      
      // Land size configuration
      let worldSize = 100; // Reduced to 1/3 of original (was 300)
      let landExpansionMultiplier = 1.0; // Will increase with land purchases

      // Weather variables
      let isRaining = false;
      let rainParticles, rainParticleSystem;
      let lightningActive = false;
      let lightningTimeout, nextLightningStrikeTimeout;
      let clouds = [];
      const initialFogColor = new BABYLON.Color3(0.0117, 0.0275, 0.0706); // #030712
      const rainFogColor = new BABYLON.Color3(0.102, 0.125, 0.173); // #1A202C

      


      
     function initAerialView() {
        const canvas = document.createElement('canvas');
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.display = 'block';
        
        // Clear the container first
        while (aerialViewContainer.firstChild) {
          aerialViewContainer.removeChild(aerialViewContainer.firstChild);
        }
        
        aerialViewContainer.appendChild(canvas);
        
        aerialViewEngine = new BABYLON.Engine(canvas, true);
        aerialViewScene = scene; // Use the same scene
        aerialViewCamera = new BABYLON.ArcRotateCamera("aerialCamera", 0, 0.5, 50, BABYLON.Vector3.Zero(), scene);
        aerialViewCamera.setTarget(BABYLON.Vector3.Zero());
        
        // Set camera controls
        aerialViewCamera.attachControls(canvas);
        aerialViewCamera.lowerRadiusLimit = 20;
        aerialViewCamera.upperRadiusLimit = 150;
        aerialViewCamera.lowerBetaLimit = 0.1;
        aerialViewCamera.upperBetaLimit = Math.PI / 2.2;
        
        // Start aerial view animation
        animateAerialView();
      }
      
      function animateAerialView() {
        if (!isAerialView) return;
        
        aerialViewEngine.runRenderLoop(() => {
          if (aerialViewScene) {
            aerialViewScene.render();
          }
        });
      }
      
      function toggleAerialView() {
        // Always activate aerial view on library button click, don't toggle
        isAerialView = true;
        
        // Hide game view, show aerial view
        gameContainer.style.display = 'none';
        aerialViewContainer.style.display = 'block';
        
        // Initialize aerial view if not already done
        if (!aerialViewEngine) {
          initAerialView();
        }
        
        // Position mode selection UI in top right instead of center
        modeSelectionPopup.style.display = 'block';
        modeSelectionPopup.style.position = 'absolute';
        modeSelectionPopup.style.top = '80px';
        modeSelectionPopup.style.right = '20px';
        modeSelectionPopup.style.left = 'auto';
        modeSelectionPopup.style.transform = 'none';
      }
      
      function exitAerialView() {
        isAerialView = false;
        gameContainer.style.display = 'block';
        aerialViewContainer.style.display = 'none';
        
        if (aerialViewEngine) {
          aerialViewEngine.stopRenderLoop();
        }
        
        // Hide popups
        modeSelectionPopup.style.display = 'none';
        prastFarmsPopup.style.display = 'none';
      }
      
      function createGrassTexture(width, height) {
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const context = canvas.getContext('2d');

          // Base green color
          context.fillStyle = `rgb(${Math.floor(30 + Math.random()*10)}, ${Math.floor(100 + Math.random()*30)}, ${Math.floor(30 + Math.random()*10)})`;
          context.fillRect(0, 0, width, height);

          // Add some variations
          for (let i = 0; i < 20000; i++) { // More speckles for detail
              const x = Math.random() * width;
              const y = Math.random() * height;
              const r = Math.floor(20 + Math.random() * 20); // Darker greens
              const g = Math.floor(90 + Math.random() * 40);
              const b = Math.floor(20 + Math.random() * 20);
              const alpha = Math.random() * 0.5 + 0.3; // Vary opacity
              context.fillStyle = `rgba(${r},${g},${b},${alpha})`;
              context.fillRect(x, y, Math.random()*2+1, Math.random()*2+1); // Vary speckle size
          }
          const texture = new BABYLON.Texture("data:" + canvas.toDataURL(), scene);
          texture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
          texture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
          texture.uScale = 20;
          texture.vScale = 20;
          return texture;
      }


      function createEnvironmentFeatures() {
  // Trees - fewer than before due to smaller land
  for (let i = 0; i < 40; i++) { // Try to place more trees, but respect spacing
    const tree = createTree();
    
    // Try up to 10 positions for each tree
    let placed = false;
    for (let attempt = 0; attempt < 10; attempt++) {
      const radius = 3; // Tree radius for placement purposes
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * (worldSize/2 - radius); // Ensure trees stay within island
      
      const posX = Math.cos(angle) * distance;
      const posZ = Math.sin(angle) * distance;
      
      // Check if this position works
      const position = new BABYLON.Vector3(posX, 0, posZ);
      if (isPositionAvailable(position, radius)) {
        tree.position.copyFrom(position);
        // Avoid placing trees too close to initial spawn
        if (position.length() > 15) {
          worldObjects.push(tree);
          markPositionOccupied(position, radius);
          placed = true;
          break;
        }
      }
    }
    
    // If we couldn't place the tree after 10 attempts, dispose it
    if (!placed) {
      tree.dispose();
    }
  }

  // Clouds - fewer
  for (let i = 0; i < 8; i++) {
    const cloud = createCloud();
    cloud.position = new BABYLON.Vector3(
      (Math.random() - 0.5) * worldSize * 1.5,
      Math.random() * 20 + 40, // Cloud height
      (Math.random() - 0.5) * worldSize * 1.5
    );
    clouds.push(cloud);
  }
}
      

      function createTree() {
        const treeGroup = new BABYLON.TransformNode("tree", scene);
        
        // Trunk
        const trunkHeight = Math.random() * 4 + 4; // Vary height
        const trunkRadius = Math.random() * 0.2 + 0.3;
        const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk", {
          height: trunkHeight, 
          diameterTop: trunkRadius * 0.7 * 2, 
          diameterBottom: trunkRadius * 2, 
          tessellation: 8
        }, scene);
        const trunkMaterial = new BABYLON.StandardMaterial("trunkMaterial", scene);
        trunkMaterial.diffuseColor = new BABYLON.Color3(0.396, 0.263, 0.129); // Brown
        trunk.material = trunkMaterial;
        trunk.receiveShadows = true;
        trunk.position.y = trunkHeight / 2;
        trunk.parent = treeGroup;

        // Leaves (multiple spheres for a fuller look)
        const leavesMaterial = new BABYLON.StandardMaterial("leavesMaterial", scene);
        leavesMaterial.diffuseColor = new BABYLON.Color3(0.133, 0.545, 0.133); // ForestGreen
        const numLeafBlobs = Math.floor(Math.random() * 3) + 3;
        for(let i=0; i < numLeafBlobs; i++) {
            const leafRadius = Math.random() * 1.5 + 1.5;
            const leaves = BABYLON.MeshBuilder.CreateSphere("leaves", {diameter: leafRadius * 2, segments: 6}, scene);
            leaves.material = leavesMaterial;
            leaves.receiveShadows = true;
            leaves.position = new BABYLON.Vector3(
                (Math.random() - 0.5) * leafRadius * 0.5, // Slight horizontal offset
                trunkHeight + (Math.random() - 0.3) * leafRadius * 0.6, // Overlap with trunk and each other
                (Math.random() - 0.5) * leafRadius * 0.5  // Slight depth offset
            );
            leaves.parent = treeGroup;
        }

        treeGroup.metadata = {
          collisionRadius: 2, // Fixed size that's large enough for all trees
          itemType: 'environment',
          itemId: 'tree',
          isCollidable: true // Explicit flag to check
        };

        return treeGroup;
      }

      // FIXED Ocean creation function
      function createOceanAndBoat() {
        // 1. Create the ocean as a large disc with a hole (donut shape)
        const oceanOuterRadius = worldSize * 1.5; // Ocean extends beyond the island
        const oceanInnerRadius = worldSize / 2;   // Inner circle matches island edge
        
        // Create ocean using a simple approach - large outer disc
        const ocean = BABYLON.MeshBuilder.CreateDisc("ocean", {
          radius: oceanOuterRadius,
          tessellation: 64
        }, scene);
        
        const oceanMaterial = new BABYLON.StandardMaterial("oceanMaterial", scene);
        oceanMaterial.diffuseColor = new BABYLON.Color3(0, 0.467, 0.745); // Ocean blue
        oceanMaterial.alpha = 0.8;
        oceanMaterial.roughness = 0.1;
        
        ocean.material = oceanMaterial;
        ocean.rotation.x = -Math.PI / 2; // Lay flat
        ocean.position.y = -0.1; // Slightly below ground level
        ocean.receiveShadows = true;
        
        // 2. Create a simple wooden dock
        const dockGroup = new BABYLON.TransformNode("dock", scene);
        
        // Base dock planks
        const dockMaterial = new BABYLON.StandardMaterial("dockMaterial", scene);
        dockMaterial.diffuseColor = new BABYLON.Color3(0.545, 0.271, 0.075); // Brown wood
        
        const dock = BABYLON.MeshBuilder.CreateBox("dockPlank", {width: 1.5, height: 0.2, depth: 6}, scene);
        dock.material = dockMaterial;
        dock.position.y = 0.1; // Slightly above water
        dock.receiveShadows = true;
        dock.parent = dockGroup;
        
        // Add dock posts
        for (let i = 0; i < 3; i++) {
          const post = BABYLON.MeshBuilder.CreateCylinder("post", {height: 1.2, diameter: 0.3, tessellation: 8}, scene);
          post.material = dockMaterial;
          post.position = new BABYLON.Vector3(0, -0.5, -2 + (i * 2)); // Space posts along the dock
          post.parent = dockGroup;
        }
        
        // 3. Create a simple boat
        const boatGroup = new BABYLON.TransformNode("boat", scene);
        
        // Boat hull
        const hullMaterial = new BABYLON.StandardMaterial("hullMaterial", scene);
        hullMaterial.diffuseColor = new BABYLON.Color3(0.545, 0.271, 0.075); // Wood color
        
        const hull = BABYLON.MeshBuilder.CreateBox("hull", {width: 2, height: 0.8, depth: 4}, scene);
        hull.material = hullMaterial;
        hull.position.y = 0.4; // Half height
        hull.parent = boatGroup;
        
        // Boat bottom
        const bottomMaterial = new BABYLON.StandardMaterial("bottomMaterial", scene);
        bottomMaterial.diffuseColor = new BABYLON.Color3(0.396, 0.263, 0.129); // Darker wood
        
        const bottom = BABYLON.MeshBuilder.CreateBox("bottom", {width: 1.6, height: 0.4, depth: 4}, scene);
        bottom.material = bottomMaterial;
        bottom.position.y = 0; // At water level
        bottom.parent = boatGroup;
        
        // Add a simple mast
        const mastMaterial = new BABYLON.StandardMaterial("mastMaterial", scene);
        mastMaterial.diffuseColor = new BABYLON.Color3(0.545, 0.271, 0.075);
        
        const mast = BABYLON.MeshBuilder.CreateCylinder("mast", {height: 3, diameter: 0.2, tessellation: 8}, scene);
        mast.material = mastMaterial;
        mast.position = new BABYLON.Vector3(0, 2, -0.5); // Positioned toward back of boat
        mast.parent = boatGroup;
        
        // Add a simple sail
        const sailMaterial = new BABYLON.StandardMaterial("sailMaterial", scene);
        sailMaterial.diffuseColor = new BABYLON.Color3(1, 0.98, 0.98); // Off-white
        sailMaterial.backFaceCulling = false;
        
        const sail = BABYLON.MeshBuilder.CreatePlane("sail", {width: 1.5, height: 2}, scene);
        sail.material = sailMaterial;
        sail.position = new BABYLON.Vector3(0.8, 2, -0.5); // Offset from mast
        sail.rotation.y = Math.PI / 2; // Rotate to face properly
        sail.parent = boatGroup;
        
        // Position the boat and dock at the edge of the island
        const angle = Math.PI / 4; // Position at northeast
        const distance = oceanInnerRadius - 1; // Just inside the island edge
        
        const posX = Math.cos(angle) * distance;
        const posZ = Math.sin(angle) * distance;
        
        // Position dock first
        dockGroup.position = new BABYLON.Vector3(posX * 0.9, 0, posZ * 0.9); // Slightly inward from boat
        dockGroup.lookAt(new BABYLON.Vector3(0, 0, 0)); // Point toward island center
        dockGroup.rotate(BABYLON.Axis.Y, Math.PI); // Rotate to point outward
        
        // Position boat at the end of the dock
        boatGroup.position = new BABYLON.Vector3(posX * 1.1, 0, posZ * 1.1); // Slightly outward from dock
        boatGroup.lookAt(new BABYLON.Vector3(0, 0, 0)); // Face toward island center
        boatGroup.rotate(BABYLON.Axis.Y, Math.PI); // Rotate to face outward
        
        // 4. Add gentle ocean movement animation
        let oceanTime = 0;
        scene.registerBeforeRender(() => {
          oceanTime += 0.01;
          // Subtle wave height adjustment
          ocean.position.y = -0.1 + Math.sin(oceanTime) * 0.05;
          
          // Gentle boat rocking
          boatGroup.rotation.z = Math.sin(oceanTime * 0.5) * 0.03;
          boatGroup.position.y = Math.sin(oceanTime) * 0.1;
        });
        
        return { ocean, dockGroup, boatGroup };
      }

      function createCloud() {
        const cloudGroup = new BABYLON.TransformNode("cloud", scene);
        const baseMaterial = new BABYLON.StandardMaterial("cloudMaterial", scene);
        baseMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
        baseMaterial.alpha = 0.85;

        const numBlobs = Math.floor(Math.random() * 4) + 3; // 3 to 6 blobs per cloud
        for (let i = 0; i < numBlobs; i++) {
            const blobSize = Math.random() * 8 + 5; // Size of each blob
            const blobMesh = BABYLON.MeshBuilder.CreateSphere("cloudBlob", {diameter: blobSize, segments: 5}, scene);
            blobMesh.material = baseMaterial;
            blobMesh.position = new BABYLON.Vector3(
                (Math.random() - 0.5) * blobSize * 1.5, // Overlap them
                (Math.random() - 0.5) * blobSize * 0.5,
                (Math.random() - 0.5) * blobSize * 1.0
            );
            blobMesh.parent = cloudGroup;
        }
        cloudGroup.scaling.y = Math.random() * 0.3 + 0.6; // Make some clouds flatter
        return cloudGroup;
      }


      function onWindowResize() {
        if (engine) {
          engine.resize();
        }
        
        if (aerialViewEngine) {
          aerialViewEngine.resize();
        }
      }

      function animate() {
        engine.runRenderLoop(() => {
          const deltaTime = engine.getDeltaTime() / 1000; // Convert to seconds

          if (document.pointerLockElement === document.body || gameContainer.classList.contains('pointer-locked')) {
              updatePlayer(deltaTime);
          }
          
          // Animate clouds
          clouds.forEach(cloud => {
              cloud.position.x += deltaTime * (Math.random()*1+0.5); // Vary speed slightly
              if (cloud.position.x > worldSize) { // Reset cloud position if it goes too far
                  cloud.position.x = -worldSize;
                  cloud.position.z = (Math.random() - 0.5) * worldSize; // New Z position
              }
          });
          
          // Chicken AI
          chickenAIMeshes.forEach(chickenData => {
            chickenData.timer -= deltaTime;
            if (chickenData.timer <= 0) {
              // New random direction within pen
              const penSize = chickenData.penSize - 0.5; // keep inside fence
              
              // Try multiple positions to avoid obstacles
              let validPositionFound = false;
              for (let attempt = 0; attempt < 5; attempt++) {
                const randomX = (Math.random() - 0.5) * penSize;
                const randomZ = (Math.random() - 0.5) * penSize;
                const potentialTarget = new BABYLON.Vector3(randomX, chickenData.mesh.position.y, randomZ)
                  .add(chickenData.penCenter);
                
                // Check if path is clear (simplified - just check endpoint)
                let pathClear = true;
                
                // Only check collision with objects inside this pen
                const penObjects = worldObjects.filter(obj => {
                  if (!obj.metadata || !obj.metadata.collisionRadius) return false;
                  
                  // Check if object is within the pen
                  const distToPen = BABYLON.Vector3.Distance(obj.position, chickenData.penCenter);
                  return distToPen < chickenData.penSize;
                });
                
                for (const obj of penObjects) {
                  if (obj === chickenData.mesh) continue; // Skip self
                  
                  const objRadius = obj.metadata.collisionRadius || 0.5;
                  const dist = BABYLON.Vector3.Distance(potentialTarget, obj.position);
                  
                  if (dist < objRadius + 0.2) { // 0.2 is chicken radius
                    pathClear = false;
                    break;
                  }
                }
                
                if (pathClear) {
                  chickenData.targetPosition = potentialTarget;
                  validPositionFound = true;
                  break;
                }
              }
              
              // If no valid position found, just stay in place
              if (!validPositionFound) {
                chickenData.targetPosition = chickenData.mesh.position.clone();
              }
              
              chickenData.timer = Math.random() * 3 + 2; // Next change in 2-5 seconds
            }
            
            // Move towards target with collision avoidance
            const direction = chickenData.targetPosition.subtract(chickenData.mesh.position);
            
            if (direction.lengthSquared() > 0.01) {
              direction.normalize();
              
              // Check for collisions before moving
              const newPosition = chickenData.mesh.position.clone();
              newPosition.addInPlace(direction.scale(deltaTime * 0.5));
              
              let canMove = true;
              // Check against pen boundary
              const distToCenter = BABYLON.Vector3.Distance(newPosition, chickenData.penCenter);
              if (distToCenter > chickenData.penSize / 2 - 0.2) {
                canMove = false;
              }
              
              // Check against other objects in pen
              if (canMove) {
                for (const obj of worldObjects) {
                  if (obj === chickenData.mesh) continue; // Skip self
                  if (!obj.metadata || !obj.metadata.collisionRadius) continue;
                  
                  const objRadius = obj.metadata.collisionRadius || 0.5;
                  const dist = BABYLON.Vector3.Distance(newPosition, obj.position);
                  
                  if (dist < objRadius + 0.2) { // 0.2 is chicken radius
                    canMove = false;
                    break;
                  }
                }
              }
              
              if (canMove) {
                chickenData.mesh.position.copyFrom(newPosition);
              } else {
                // Pick a new random direction if blocked
                chickenData.timer = 0;
              }
              
              // Make chicken look in direction of movement
              chickenData.mesh.lookAt(chickenData.targetPosition);
            }
          });

          if (isRaining) updateRain(deltaTime);
          
          // Periodically update portfolio value in live mode (every 2.5 seconds)
          if (isLiveMode && Date.now() - lastPortfolioUpdate > 2500) {
              updateReservesDisplay();
          }

          // Update animals periodically
          if (!window.lastAnimalUpdate || Date.now() - window.lastAnimalUpdate > 60000) {
              updateAnimals();
              window.lastAnimalUpdate = Date.now();
            }

          scene.render();
        });
      }

      function setupControls() {
        scene.actionManager = new BABYLON.ActionManager(scene);
        
        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);

        document.addEventListener('pointerlockchange', () => {
          if (document.pointerLockElement === document.body) {
            crosshair.style.display = 'block';
            gameContainer.classList.add('pointer-locked');
          } else {
            crosshair.style.display = 'none';
            gameContainer.classList.remove('pointer-locked');
            moveForward = false; moveBackward = false; moveLeft = false; moveRight = false;
          }
        }, false);
      }

      function onMouseMove(event) {
        if (document.pointerLockElement === document.body) {
          const movementX = event.movementX || 0;
          const movementY = event.movementY || 0;
          player.rotation.y -= movementX * 0.002;
          camera.rotation.x -= movementY * 0.002;
          camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }
      }

      function onKeyDown(event) {
        // Changed from L key to Enter key as per requirement
        if (event.code === 'Enter') { 
            if (document.pointerLockElement === document.body) {
                document.exitPointerLock();
            } else {
                document.body.requestPointerLock().catch(err => {
                    if (!gameContainer.classList.contains('interacted')) {
                         showGameMessage("Click the game screen to enable mouse lock.", "info", 5000);
                    }
                });
            }
        }
        if (event.code === 'KeyP') { // Dev key to toggle weather
            toggleWeather();
        }
        if (event.code === 'Delete') { // Added Delete key to exit pointer lock
            if (document.pointerLockElement === document.body) {
                document.exitPointerLock();
            }
        }

        if (document.pointerLockElement !== document.body && !['Enter', 'KeyP', 'Escape', 'Delete'].includes(event.code)) return;

        switch (event.code) {
          case 'KeyW': case 'ArrowUp': moveForward = true; break;
          case 'KeyS': case 'ArrowDown': moveBackward = true; break;
          case 'KeyA': case 'ArrowLeft': moveRight = true; break; // FIXED: Left and right were swapped
          case 'KeyD': case 'ArrowRight': moveLeft = true; break; // FIXED: Left and right were swapped
          case 'Space': if (playerOnGround) playerVelocity.y = playerJumpForce; break;
          case 'Escape':
            if (document.pointerLockElement === document.body) document.exitPointerLock();
            if (farmStoreDropdown.classList.contains('active')) {
                farmStoreDropdown.classList.remove('active');
                reservesButton.setAttribute('aria-expanded', 'false');
            }
            if (paymentOptions && paymentOptions.style.display === 'block') {
                paymentOptions.style.display = 'none';
                currentPaymentItem = null;
            }
            if (isAerialView) {
                 exitAerialView();
            }
            if (modeSelectionPopup.style.display === 'block') {
                modeSelectionPopup.style.display = 'none';
            }
            if (prastFarmsPopup.style.display === 'block') {
                prastFarmsPopup.style.display = 'none';
            }
            break;
        }
      }

        // Add a click listener to gameContainer to mark it as interacted
        if (gameContainer) {
            gameContainer.addEventListener('click', () => {
                gameContainer.classList.add('interacted');
                if (document.pointerLockElement !== document.body && !gameContainer.classList.contains('pointer-locked')) {
                    document.body.requestPointerLock().catch(err => {
                        // console.warn("Pointer lock failed on click.", err);
                    });
                }
            }, { once: false });
        }

      function onKeyUp(event) {
        switch (event.code) {
          case 'KeyW': case 'ArrowUp': moveForward = false; break;
          case 'KeyS': case 'ArrowDown': moveBackward = false; break;
          case 'KeyA': case 'ArrowLeft': moveRight = false; break; // FIXED: Left and right were swapped
          case 'KeyD': case 'ArrowRight': moveLeft = false; break; // FIXED: Left and right were swapped
        }
      }

      function updatePlayer(deltaTime) {
        const moveSpeed = playerSpeed * deltaTime;
        const moveDirection = new BABYLON.Vector3();
        
        // Get camera direction for forward/backward movement
        const forward = camera.getDirection(BABYLON.Axis.Z).normalize();
        forward.y = 0; // Don't move up/down when walking
        forward.normalize();
        
        const right = camera.getDirection(BABYLON.Axis.X).normalize();
        right.y = 0;
        right.normalize();

        if (moveForward) moveDirection.addInPlace(forward);
        if (moveBackward) moveDirection.subtractInPlace(forward);
        if (moveLeft) moveDirection.subtractInPlace(right);
        if (moveRight) moveDirection.addInPlace(right);
        
        moveDirection.normalize();

        // Calculate potential new position
        const potentialPosition = player.position.clone()
          .addInPlace(moveDirection.scale(moveSpeed));

        // Check if new position would be inside the circular world boundary
        const playerWorldLimit = (worldSize / 2) * landExpansionMultiplier;
        const playerDistFromCenter = Math.sqrt(
          potentialPosition.x * potentialPosition.x + 
          potentialPosition.z * potentialPosition.z
        );

        let canMove = playerDistFromCenter <= playerWorldLimit;

        // Check collision with world objects
        if (canMove) {
          const playerRadius = 0.5; // Player collision radius
          
          for (const obj of worldObjects) {
            // Skip ground or objects without collision data
            if (obj === ground || !obj.metadata || !obj.metadata.collisionRadius) continue;
            
            const objRadius = obj.metadata.collisionRadius || 1;
            const collisionDist = BABYLON.Vector3.Distance(
                new BABYLON.Vector3(potentialPosition.x, 0, potentialPosition.z),
                new BABYLON.Vector3(obj.position.x, 0, obj.position.z)
                );
            
            if (collisionDist < playerRadius + objRadius) {
              // Allow jumping over short obstacles
              const isJumping = playerVelocity.y > 0 || player.position.y > playerHeight;
              const canJumpOver = obj.metadata.itemType === 'plant' || 
                                  (obj.metadata.itemId === 'tree' && isJumping);
              
              if (isJumping && canJumpOver) {
                // Can jump over this obstacle
                canMove = true;
              } else {
                canMove = false;
              }
              
              if (!canMove) break;
            }
          }
        }
        
        // Apply movement if valid
        if (canMove) {
          player.position.copyFrom(potentialPosition);
        }

        // Handle vertical movement (jumping/falling)
        playerVelocity.y += gravity * deltaTime;
        player.position.y += playerVelocity.y * deltaTime;

        if (player.position.y < playerHeight / 2) {
          player.position.y = playerHeight / 2;
          playerVelocity.y = 0;
          playerOnGround = true;
        } else {
          playerOnGround = false;
        }
        
        // Calculate circular world boundary based on land expansion
        const worldRadius = (worldSize / 2) * landExpansionMultiplier;
        const distanceFromCenter = Math.sqrt(player.position.x * player.position.x + player.position.z * player.position.z);
        if (distanceFromCenter > worldRadius) {
          // If player is beyond the boundary, move them back to the edge
          const angle = Math.atan2(player.position.z, player.position.x);
          player.position.x = Math.cos(angle) * worldRadius;
          player.position.z = Math.sin(angle) * worldRadius;
        }
      }

      // Calculate portfolio value based on investments and their returns
      function calculatePortfolioValue() {
        if (!isLiveMode) return playerReserves; // Return stars in demo mode
        
        let totalValue = 0;
        const modeKey = isLiveMode ? 'live' : 'demo';
        const currentInventory = isLiveMode ? liveInventory : demoInventory;
        
        // Calculate value for all farm items
        for (const [itemId, quantity] of Object.entries(currentInventory)) {
          if (quantity > 0 && itemId !== 'expansion') { // Skip land expansion from value calculation
            const itemCost = getItemCost(itemId);
            const annualReturn = farmReturns[itemId] || 0;
            
            // For each item purchased
            for (let i = 0; i < quantity; i++) {
              // get purchase date or use a default (30 days ago for demo)
              const purchaseInfo = farmValues[modeKey][itemId]?.[i] || { 
                cost: itemCost,
                date: new Date(Date.now() - (30 * 24 * 60 * 60 * 1000)) // Default to 30 days ago
              };
              
              // Calculate days since purchase
              const daysSincePurchase = (new Date() - new Date(purchaseInfo.date)) / (1000 * 60 * 60 * 24);
              const yearFraction = daysSincePurchase / 365; // Fraction of a year
              
              // Calculate current value: original cost + (original cost * annual return * time)
              const currentValue = purchaseInfo.cost * (1 + (annualReturn * yearFraction));
              totalValue += currentValue;
            }
          }
        }
        
        // Add any third-party farms
        if (farmValues[modeKey].thirdParty) {
          for (const [farmId, farmInfo] of Object.entries(farmValues[modeKey].thirdParty)) {
            const annualReturn = farmInfo.return / 100; // Convert percentage to decimal
            const daysSincePurchase = (new Date() - new Date(farmInfo.date)) / (1000 * 60 * 60 * 24);
            const yearFraction = daysSincePurchase / 365;
            
            const currentValue = farmInfo.cost * (1 + (annualReturn * yearFraction));
            totalValue += currentValue;
          }
        }
        
        // Convert cents to dollars
        return totalValue / 100;
      }
      
      // Helper function to get item cost
      function getItemCost(itemId) {
        const itemElement = document.querySelector(`.dropdown-item[data-id="${itemId}"]`);
        return itemElement ? parseInt(itemElement.dataset.cost || 0) : 0;
      }

      // Update reserves display to show dollar value in live mode
      function updateReservesDisplay() {
        if (reservesAmountSpan) {
          if (isLiveMode) {
            // Calculate total portfolio value in live mode
            let totalValue = calculatePortfolioValue();
            
            // Update button appearance for live mode
            const icon = reservesButton.querySelector('i');
            if (icon) {
              icon.className = 'fas fa-dollar-sign text-green-400';
            }
            
            reservesAmountSpan.textContent = `${Math.round(totalValue)}`;
          } else {
            // Update button appearance for demo mode
            const icon = reservesButton.querySelector('i');
            if (icon) {
              icon.className = 'fas fa-star text-yellow-400';
            }
            
            reservesAmountSpan.textContent = playerReserves;
          }
        }
        
        // Update store items display
        farmStoreDropdown.querySelectorAll('.dropdown-item').forEach(item => {
          const cost = parseInt(item.dataset.cost);
          const itemId = item.dataset.id;
          const itemType = item.dataset.type;
          const maxPurchases = item.dataset.max ? parseInt(item.dataset.max) : Infinity;
          const button = item.querySelector('.dropdown-item-price');

          // Skip items that are in the Manage section
          if (item.closest('#manage-farms-section')) return;

          if (button) {
            const currentInventory = isLiveMode ? liveInventory : demoInventory;
            
            // Special case for third-party button
            if (button.dataset.action === 'show-third-party-farms') {
              button.textContent = "View";
              return;
            }

            // Check if already owned
            if (currentInventory[itemId] && currentInventory[itemId] > 0) {
              button.textContent = "Manage";
            } else {
              // Not owned, show price
              if (isLiveMode) {
                button.textContent = `$${(cost / 100).toFixed(2)}`;
              } else {
                button.innerHTML = `<i class="fas fa-star text-yellow-400"></i> ${cost}`;
              }
            }
          }
        });
      }

// Add event listeners for the management popup actions
document.querySelectorAll('#management-popup .payment-option').forEach(option => {
  option.addEventListener('click', (event) => {
    const popup = document.getElementById('management-popup');
    const action = option.dataset.action;
    const itemId = popup.dataset.itemId;
    const itemType = popup.dataset.itemType;
    const cost = parseInt(popup.dataset.itemCost || '0');
    
    if (action === 'buy-more') {
      // Use the existing purchase flow
      currentPaymentItem = {
        itemType: itemType,
        itemId: itemId,
        cost: cost
      };
      
      // Show payment options similar to regular farms
      const paymentOptions = document.getElementById('payment-options');
      if (paymentOptions) {
        paymentOptions.style.display = 'block';
        paymentOptions.style.top = popup.style.top;
        paymentOptions.style.left = popup.style.left;
        
        // Update payment options display
        document.getElementById('stars-price').textContent = cost;
        document.getElementById('dollar-price').textContent = `$${(cost / 100).toFixed(2)}`;
      }
    } 
    else if (action === 'sell-item') {
      // Handle selling logic
      if (isLiveMode) {
        if (liveInventory[itemId] > 0) {
          liveInventory[itemId]--;
          playerReserves += Math.floor(cost / 2); // Half price for selling
        }
      } else {
        if (demoInventory[itemId] > 0) {
          demoInventory[itemId]--;
          playerReserves += Math.floor(cost / 2); // Half price for selling
        }
      }
      
      // Update UI
      updateReservesDisplay();
      showGameMessage(`Sold ${itemId.charAt(0).toUpperCase() + itemId.slice(1)} farm`, 'success');
    }
    
    // Hide popup
    popup.style.display = 'none';
  });
});
      
  function setAppMode(isLive) {
  isLiveMode = isLive;
  appModeBadge.style.display = isLive ? 'none' : 'inline';
  liveModeBadge.style.display = isLive ? 'inline' : 'none';
  
  // Update icon
  const icon = reservesButton.querySelector('i');
  if (isLive) {
    icon.classList.remove('fa-star', 'text-yellow-400');
    icon.classList.add('fa-dollar-sign', 'text-green-400');
  } else {
    icon.classList.remove('fa-dollar-sign', 'text-green-400');
    icon.classList.add('fa-star', 'text-yellow-400');
  }
  
  purchasedItems = isLive ? liveInventory : demoInventory;

  // Control visibility of third-party elements
  const thirdPartyPrompt = document.querySelector('.third-party-prompt');
  const thirdPartyFarmsSection = document.getElementById('third-party-farms');
  
  if (isLive) { // Live Mode
    if (thirdPartyPrompt) thirdPartyPrompt.style.display = 'flex';
  } else { // Demo Mode
    if (thirdPartyPrompt) thirdPartyPrompt.style.display = 'none';
    if (thirdPartyFarmsSection) thirdPartyFarmsSection.style.display = 'none';
    
    // Also hide any third-party items within dropdown
    document.querySelectorAll('.dropdown-item[data-type="third-party"]').forEach(item => {
      item.style.display = 'none';
    });
  }
  
  updateReservesDisplay();
}
      
      function expandLand() {
        const currentExpansionLevel = isLiveMode ? liveInventory.expansion : demoInventory.expansion;
        if (currentExpansionLevel >= 3) {
          showGameMessage("You've reached the maximum land expansion!", 'info');
          return false;
        }
        
        if (isLiveMode) {
          liveInventory.expansion++;
        } else {
          demoInventory.expansion++;
        }
        
        landExpansionMultiplier = 1.0 + (isLiveMode ? liveInventory.expansion : demoInventory.expansion) * 0.33;

        // Update fog for new size
        scene.fogStart = 20 * landExpansionMultiplier;
        scene.fogEnd = worldSize * 0.7 * landExpansionMultiplier;
        
        // Update ground size
        if (ground) {
          ground.dispose();
          scene.removeMesh(ground);
        }

        const groundTexture = createGrassTexture(512, 512);
        const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
        groundMaterial.diffuseTexture = groundTexture;
        groundMaterial.roughness = 0.8;

        ground = BABYLON.MeshBuilder.CreateDisc("ground", {radius: (worldSize/2) * landExpansionMultiplier, tessellation: 64}, scene);
        ground.rotation.x = -Math.PI / 2;
        ground.material = groundMaterial;
        ground.receiveShadows = true;
        
        showGameMessage(`Land expanded! New radius: ${Math.floor((worldSize/2) * landExpansionMultiplier)}`, 'success');
        return true;
      }

      function showGameMessage(message, type = 'info', timeout = 3000) {
        if (!messageBox) return;
        // Modified to handle hidden message box - don't show messages at all
      }

      function showFarmManagement(animalType) {
        const managementUI = document.getElementById('farm-management');
        if (!managementUI) return;
        
        const title = document.getElementById('farm-management-title');
        
        // Update title
        if (title) {
          title.textContent = `Managing ${animalType.charAt(0).toUpperCase() + animalType.slice(1)} Farm`;
        }
        
        // Position camera near the animals
        const farm = worldObjects.find(obj => obj.metadata && 
          obj.metadata.itemType === 'animal' && 
          obj.metadata.itemId === animalType);
        
        if (farm) {
          // Position and rotate player to face the farm
          const farmPos = farm.position.clone();
          player.position = new BABYLON.Vector3(farmPos.x - 5, playerHeight / 2, farmPos.z - 5);
          player.rotation.y = Math.atan2(player.position.x - farmPos.x, player.position.z - farmPos.z);
        }
        
        // Populate animals list
        populateAnimalsList(animalType);
        
        // Make popup appear with animation
        managementUI.classList.remove('hidden');
        // Ensure flex display is applied after the hidden class is removed
        setTimeout(() => {
          managementUI.style.display = 'flex';
          managementUI.style.flexDirection = 'column';
        }, 10);
      }

      function hideFarmManagement() {
        const managementUI = document.getElementById('farm-management');
        if (!managementUI) return;
        
        managementUI.classList.add('hidden');
        // Hide after animation completes
        setTimeout(() => {
          managementUI.style.display = 'none';
        }, 300); // Match transition duration
      }

      // Updated function to populate animals in a horizontal layout
      function populateAnimalsList(animalType) {
        const animalsList = document.getElementById('animals-list');
        if (!animalsList) return;
        
        animalsList.innerHTML = ''; // Clear existing items
        
        // Animal type to emoji mapping
        const animalIcons = {
          'chicken': '🐔',
          'pig': '🐖',
          'cow': '🐄',
          'goat': '🐐',
          'fish': '🐟'
        };
        
         // Create animal items
        animalData[animalType].forEach(animal => {
          // Calculate age percentage
          const agePercent = calculateAgePercent(animalType, animal.age);
          
          const animalItem = document.createElement('div');
          animalItem.className = 'animal-item';
          animalItem.dataset.id = animal.id;
          
          animalItem.innerHTML = `
            <div class="animal-header">
              <div class="animal-icon">${animalIcons[animalType] || '🐾'}</div>
              <div class="animal-name" contenteditable="true">${animal.name}</div>
            </div>
            <div class="animal-stat">
              <span>Age:</span>
              <span>${animal.age} days (${agePercent}%)</span>
            </div>
            <div class="health-bar">
              <div class="health-bar-fill" style="width: ${animal.health}%"></div>
            </div>
            <div class="animal-actions">
              <button class="animal-action-btn bg-blue-700 hover:bg-blue-600" data-action="feed">Feed</button>
              <button class="animal-action-btn bg-green-700 hover:bg-green-600" data-action="heal">Heal</button>
              <button class="animal-action-btn bg-red-700 hover:bg-red-600" data-action="sell">Sell</button>
            </div>
          `;
          
          animalsList.appendChild(animalItem);
        });
        
        // Add event listeners for animal actions
        document.querySelectorAll('.animal-action-btn').forEach(btn => {
          btn.addEventListener('click', handleAnimalAction);
        });
        
        // Add event listeners for editable names
        document.querySelectorAll('.animal-name').forEach(nameElem => {
          nameElem.addEventListener('blur', function() {
            const animalId = this.closest('.animal-item').dataset.id;
            const newName = this.textContent;
            updateAnimalName(animalType, animalId, newName);
          });
        });
      }

      // Function to handle animal actions (feed, heal, sell)
      function handleAnimalAction(event) {
        const action = event.target.dataset.action;
        const animalItem = event.target.closest('.animal-item');
        const animalId = animalItem.dataset.id;
        const animalType = document.getElementById('farm-management-title')?.textContent.split(' ')[1]?.toLowerCase();
        
        if (!animalType) return;
        
        switch(action) {
          case 'feed':
            feedAnimal(animalType, animalId);
            break;
          case 'heal':
            healAnimal(animalType, animalId);
            break;
          case 'sell':
            sellAnimal(animalType, animalId);
            break;
        }
        
        // Update the display
        populateAnimalsList(animalType);
      }

      // Function implementations for animal actions
      function feedAnimal(animalType, animalId) {
        const animal = animalData[animalType].find(a => a.id === animalId);
        if (animal) {
          animal.health = Math.min(100, animal.health + 10);
          animal.lastFed = new Date();
        }
      }

      function healAnimal(animalType, animalId) {
        const animal = animalData[animalType].find(a => a.id === animalId);
        if (animal) {
          animal.health = 100;
        }
      }

      function sellAnimal(animalType, animalId) {
        const index = animalData[animalType].findIndex(a => a.id === animalId);
        if (index !== -1) {
          const animal = animalData[animalType][index];
          // Remove from array
          animalData[animalType].splice(index, 1);
          // Add stars based on animal type and age
          const baseValue = getItemCost(animalType) / 2;
          const ageBonus = animal.age * 0.05 * baseValue; // 5% per day age bonus
          playerReserves += Math.floor(baseValue + ageBonus);
          updateReservesDisplay();
        }
      }

      function updateAnimalName(animalType, animalId, newName) {
        const animal = animalData[animalType].find(a => a.id === animalId);
        if (animal) {
          animal.name = newName;
        }
      }

      // Fix the age calculation in the updateAnimals function
      function updateAnimals() {
        const now = new Date();
        
        // Update all animal types
        Object.keys(animalData).forEach(animalType => {
          animalData[animalType].forEach(animal => {
            // Calculate time since last update
            const lastFedHours = (now - new Date(animal.lastFed)) / (1000 * 60 * 60);
            
            // Update health (decrease if not fed recently)
            if (lastFedHours > 24) {
              animal.health = Math.max(0, animal.health - Math.floor(lastFedHours / 24));
            }
            
            // Fix age calculation
            if (animal.created) {
              const daysSinceCreation = Math.floor((now - new Date(animal.created)) / (1000 * 60 * 60 * 24));
              animal.age = daysSinceCreation;
            } else {
              // For legacy animals that might not have a created date
              animal.created = now;
              animal.age = 0;
            }
            
            // Stage is still calculated (for internal logic) but not displayed
            if (animal.age < 3) animal.stage = "Baby";
            else if (animal.age < 10) animal.stage = "Young";
            else if (animal.age < 30) animal.stage = "Adult";
            else animal.stage = "Senior";
          });
        });
        
        // Update UI if farm management is open
        const managementUI = document.getElementById('farm-management');
        if (managementUI && getComputedStyle(managementUI).display !== 'none') {
          const animalType = document.getElementById('farm-management-title')?.textContent.split(' ')[1]?.toLowerCase();
          if (animalType) {
            populateAnimalsList(animalType);
          }
        }
      }

      function addPurchasedItemToWorld(itemType, itemId, count) {
        // Special handling for land expansion and third-party farms (unchanged)
        if (itemType === 'land' && itemId === 'expansion') {
          return;
        }
        if (itemType === 'third-party') {
          console.log(`Partnership established with ${itemId.replace(/-/g, ' ')}. No 3D model.`);
          return;
        }

        let itemGroup;
        if (itemType === 'animal') {
          itemGroup = createAnimalFarmStructure(itemId, count);
        } else if (itemType === 'plant') {
          itemGroup = createPlantPlot(itemId, count);
        } else {
          console.error("Unknown item type:", itemType);
          return;
        }

        if (itemType === 'animal') {
          // Create initial animal
          const animal = createAnimalData(itemId);
          animalData[itemId].push(animal);
        }

        // Determine appropriate size for collision
        const itemRadius = itemType === 'animal' ? 6 : 4; // Animal farms are larger
        
        // Try to find a valid position
        let placed = false;
        let posX, posZ;
        
        for (let attempt = 0; attempt < 20; attempt++) {
          const angle = Math.random() * Math.PI * 2;
          // Place within 80% of island radius to leave some margin at the edge
          const distance = Math.random() * (worldSize/2 * 0.8);
          
          posX = Math.cos(angle) * distance;
          posZ = Math.sin(angle) * distance;
          
          const position = new BABYLON.Vector3(posX, 0, posZ);
          if (isPositionAvailable(position, itemRadius)) {
            placed = true;
            itemGroup.position = new BABYLON.Vector3(posX, 0, posZ);
            markPositionOccupied(position, itemRadius);
            break;
          }
        }
        
        // If we couldn't find a valid position, place at a fixed position at the center
        if (!placed) {
          console.warn("Couldn't find space for new item, placing near center");
          // Place in spiral pattern around center
          const spiralCount = worldObjects.filter(obj => 
            obj.metadata && (obj.metadata.itemType === 'animal' || obj.metadata.itemType === 'plant')
          ).length;
          
          const spiralAngle = spiralCount * 0.5; // Increment angle for each item
          const spiralRadius = 5 + spiralCount * 0.5; // Increase radius for each item
          
          posX = Math.cos(spiralAngle) * spiralRadius;
          posZ = Math.sin(spiralAngle) * spiralRadius;
          
          itemGroup.position = new BABYLON.Vector3(posX, 0, posZ);
          markPositionOccupied(new BABYLON.Vector3(posX, 0, posZ), itemRadius);
        }
        
        itemGroup.name = `${itemId}_${itemType}_${count}`;
        itemGroup.metadata = { 
          itemType: itemType, 
          itemId: itemId, 
          instanceCount: count,
          collisionRadius: itemRadius // Store radius for collision detection
        };
        worldObjects.push(itemGroup);
      }

      function createAnimalFarmStructure(animalId, count) {
        const farmGroup = new BABYLON.TransformNode(`${animalId}Farm`, scene);
        let baseColor, structureColor, animalColor;
        const fenceHeight = 1.2, fencePostRadius = 0.1, fencePlankHeight = 0.15;
        const farmSize = (animalId === 'cow' || animalId === 'goat') ? 10 : 8; // Larger for bigger animals
        const structureSize = {x: animalId === 'cow' ? 5 : 4, y: 2.5, z: animalId === 'cow' ? 4 : 3};

        // Minecraft-style blocky animals
        switch(animalId) {
            case 'chicken':
                baseColor = new BABYLON.Color3(0.824, 0.706, 0.549); structureColor = new BABYLON.Color3(0.545, 0.271, 0.075); animalColor = new BABYLON.Color3(1, 1, 0.878);
                break;
            case 'pig':
                baseColor = new BABYLON.Color3(1, 0.753, 0.796); structureColor = new BABYLON.Color3(0.627, 0.322, 0.176); animalColor = new BABYLON.Color3(1, 0.627, 0.478);
                break;
            case 'cow':
                baseColor = new BABYLON.Color3(0.737, 0.690, 0.631); structureColor = new BABYLON.Color3(0.478, 0.439, 0.380); animalColor = new BABYLON.Color3(1, 1, 1);
                break;
            case 'goat':
                baseColor = new BABYLON.Color3(0.753, 0.753, 0.753); structureColor = new BABYLON.Color3(0.314, 0.314, 0.314); animalColor = new BABYLON.Color3(0.878, 0.878, 0.878);
                break;
            case 'fish': // Fish pond, no land structure like others
                return createFishPond(animalId, count); // Special handling
            default:
                baseColor = new BABYLON.Color3(0.8, 0.8, 0.8); structureColor = new BABYLON.Color3(0.333, 0.333, 0.333); animalColor = new BABYLON.Color3(0.6, 0.6, 0.6);
        }

        const structureMaterial = new BABYLON.StandardMaterial(`${animalId}StructureMaterial`, scene);
        structureMaterial.diffuseColor = baseColor;
        
        const mainStructureMesh = BABYLON.MeshBuilder.CreateBox(`${animalId}Structure`, structureSize, scene);
        mainStructureMesh.material = structureMaterial;
        mainStructureMesh.receiveShadows = true;
        mainStructureMesh.position.y = structureSize.y / 2;
        mainStructureMesh.parent = farmGroup;

        const roofMaterial = new BABYLON.StandardMaterial(`${animalId}RoofMaterial`, scene);
        roofMaterial.diffuseColor = structureColor;
        
        const roofMesh = BABYLON.MeshBuilder.CreateBox(`${animalId}Roof`, {
          width: structureSize.x * 1.1, 
          height: 0.3, 
          depth: structureSize.z * 1.1
        }, scene);
        roofMesh.material = roofMaterial;
        roofMesh.position.y = structureSize.y + 0.15;
        roofMesh.parent = farmGroup;

        // Fence
        const fenceMaterial = new BABYLON.StandardMaterial(`${animalId}FenceMaterial`, scene);
        fenceMaterial.diffuseColor = new BABYLON.Color3(0.545, 0.271, 0.075); // Brown color for fence

        // Create posts at corners
        const postPositions = [
            new BABYLON.Vector3(-farmSize / 2, fenceHeight / 2, -farmSize / 2),
            new BABYLON.Vector3(farmSize / 2, fenceHeight / 2, -farmSize / 2),
            new BABYLON.Vector3(-farmSize / 2, fenceHeight / 2, farmSize / 2),
            new BABYLON.Vector3(farmSize / 2, fenceHeight / 2, farmSize / 2)
        ];
        postPositions.forEach((pos, index) => {
            const post = BABYLON.MeshBuilder.CreateCylinder(`${animalId}Post${index}`, {
              height: fenceHeight, 
              diameter: fencePostRadius * 2, 
              tessellation: 8
            }, scene);
            post.material = fenceMaterial;
            post.position.copyFrom(pos);
            post.parent = farmGroup;
        });

        // Create planks (2 levels)
        [0.3 * fenceHeight, 0.7 * fenceHeight].forEach((plankLevelY, levelIndex) => {
            // Front and back planks
            const plankFront = BABYLON.MeshBuilder.CreateBox(`${animalId}PlankFront${levelIndex}`, {
              width: farmSize, 
              height: fencePlankHeight, 
              depth: 0.1
            }, scene);
            plankFront.material = fenceMaterial;
            plankFront.position = new BABYLON.Vector3(0, plankLevelY, farmSize / 2);
            plankFront.parent = farmGroup;

            const plankBack = BABYLON.MeshBuilder.CreateBox(`${animalId}PlankBack${levelIndex}`, {
              width: farmSize, 
              height: fencePlankHeight, 
              depth: 0.1
            }, scene);
            plankBack.material = fenceMaterial;
            plankBack.position = new BABYLON.Vector3(0, plankLevelY, -farmSize / 2);
            plankBack.parent = farmGroup;
            
            // Left and right planks
            const plankLeft = BABYLON.MeshBuilder.CreateBox(`${animalId}PlankLeft${levelIndex}`, {
              width: 0.1, 
              height: fencePlankHeight, 
              depth: farmSize
            }, scene);
            plankLeft.material = fenceMaterial;
            plankLeft.position = new BABYLON.Vector3(-farmSize / 2, plankLevelY, 0);
            plankLeft.parent = farmGroup;

            const plankRight = BABYLON.MeshBuilder.CreateBox(`${animalId}PlankRight${levelIndex}`, {
              width: 0.1, 
              height: fencePlankHeight, 
              depth: farmSize
            }, scene);
            plankRight.material = fenceMaterial;
            plankRight.position = new BABYLON.Vector3(farmSize / 2, plankLevelY, 0);
            plankRight.parent = farmGroup;
        });

        // Add blocky animals
        const animalMaterial = new BABYLON.StandardMaterial(`${animalId}AnimalMaterial`, scene);
        animalMaterial.diffuseColor = animalColor;
        
        const numAnimals = 1; // Just create one animal initially
        const penCenterForAI = new BABYLON.Vector3(0,0,0); // Relative to farmGroup origin
        
        for (let i = 0; i < numAnimals; i++) {
            const animal = new BABYLON.TransformNode(`${animalId}Animal${i}`, scene);
            
            let bodySize;
            switch(animalId) {
                case 'chicken': bodySize = {width: 0.4, height: 0.5, depth: 0.3}; break;
                case 'pig': bodySize = {width: 0.8, height: 0.5, depth: 0.4}; break;
                case 'cow': bodySize = {width: 1.5, height: 1.0, depth: 0.7}; break;
                case 'goat': bodySize = {width: 1.0, height: 0.8, depth: 0.5}; break;
                default: bodySize = {width: 0.5, height: 0.5, depth: 0.5};
            }
            
            const body = BABYLON.MeshBuilder.CreateBox(`${animalId}Body${i}`, bodySize, scene);
            body.material = animalMaterial;
            body.parent = animal;

            // Simple legs for larger animals
            if (animalId === 'pig' || animalId === 'cow' || animalId === 'goat') {
                const legSize = {width: 0.2, height: 0.4, depth: 0.2};
                const legPositions = [
                    {x: bodySize.width/2 * 0.7, z: bodySize.depth/2 * 0.7},
                    {x: -bodySize.width/2 * 0.7, z: bodySize.depth/2 * 0.7},
                    {x: bodySize.width/2 * 0.7, z: -bodySize.depth/2 * 0.7},
                    {x: -bodySize.width/2 * 0.7, z: -bodySize.depth/2 * 0.7},
                ];
                legPositions.forEach((pos, legIndex) => {
                    const leg = BABYLON.MeshBuilder.CreateBox(`${animalId}Leg${i}${legIndex}`, legSize, scene);
                    leg.material = animalMaterial;
                    // Position legs underneath the body
                    leg.position = new BABYLON.Vector3(pos.x, -bodySize.height/2 - legSize.height/2 + 0.1, pos.z);
                    leg.parent = animal;
                });
                body.position.y = legSize.height / 2 + 0.1; // Lift body to accommodate legs
            } else { // Chickens
                 body.position.y = bodySize.height / 2; // Chickens on ground
            }

            animal.position = new BABYLON.Vector3(
                (Math.random() - 0.5) * (farmSize - structureSize.x - 1), // Try to place outside structure
                0, // Y will be set by body/leg logic, animal group itself is at ground level
                (Math.random() - 0.5) * (farmSize - structureSize.z - 1)
            );
             // Ensure animals are somewhat clear of the main structure
            const clearance = 1.0; // Min distance from structure edge
            if (animal.position.x > -structureSize.x/2 - clearance && animal.position.x < structureSize.x/2 + clearance &&
                animal.position.z > -structureSize.z/2 - clearance && animal.position.z < structureSize.z/2 + clearance) {
                // If too close, try to push it away from structure center
                const pushDirectionX = (animal.position.x > 0 ? 1 : -1);
                const pushDirectionZ = (animal.position.z > 0 ? 1 : -1);
                animal.position.x = pushDirectionX * (structureSize.x/2 + clearance + Math.random()*0.5);
                animal.position.z = pushDirectionZ * (structureSize.z/2 + clearance + Math.random()*0.5);
            }
            // Clamp animal position to be within the fence
            const halfFarmSize = farmSize / 2 - (bodySize.width || 0.5); // Minus half animal width for buffer
            animal.position.x = Math.max(-halfFarmSize, Math.min(halfFarmSize, animal.position.x));
            animal.position.z = Math.max(-halfFarmSize, Math.min(halfFarmSize, animal.position.z));

            animal.parent = farmGroup;

            if (animalId === 'chicken') { // Only chickens get AI for now
                chickenAIMeshes.push({
                    mesh: animal,
                    timer: Math.random() * 5,
                    targetPosition: animal.position.clone(), // Start at current pos within farmGroup
                    penSize: farmSize, // The size of the fenced area
                    penCenter: farmGroup.position.clone().add(penCenterForAI) // Initial pen center, will be updated once farmGroup is placed
                });
            }
        }
        return farmGroup;
      }

      function createFishPond(itemId, count) {
        const pondGroup = new BABYLON.TransformNode("fishPond", scene);
        const pondRadius = 4;
        const pondDepth = 1.5;

        // Water
        const water = BABYLON.MeshBuilder.CreateCylinder("water", {
          height: pondDepth, 
          diameter: pondRadius * 2, 
          tessellation: 16
        }, scene);
        const waterMat = new BABYLON.StandardMaterial("waterMaterial", scene);
        waterMat.diffuseColor = new BABYLON.Color3(0.275, 0.510, 0.706);
        waterMat.alpha = 0.6;
        waterMat.roughness = 0.2;
        water.material = waterMat;
        water.position.y = -pondDepth/2 + 0.1; // Slightly recessed so top is just below ground
        water.receiveShadows = true; // Water can receive shadows
        water.parent = pondGroup;

        // Border
        const border = BABYLON.MeshBuilder.CreateTorus("border", {
          diameter: pondRadius * 2, 
          thickness: 0.3, 
          tessellation: 24
        }, scene);
        const borderMat = new BABYLON.StandardMaterial("borderMaterial", scene);
        borderMat.diffuseColor = new BABYLON.Color3(0.667, 0.667, 0.667);
        borderMat.roughness = 0.7;
        border.material = borderMat;
        border.rotation.x = Math.PI/2;
        border.position.y = 0.05; // Top of border slightly above ground
        border.receiveShadows = true;
        border.parent = pondGroup;

        // Fish (simple blocky fish)
        const fishMat = new BABYLON.StandardMaterial("fishMaterial", scene);
        fishMat.diffuseColor = new BABYLON.Color3(1, 0.549, 0); // Orange
        
        for(let i=0; i<5; i++) {
            const fish = BABYLON.MeshBuilder.CreateBox(`fish${i}`, {width: 0.5, height: 0.2, depth: 0.15}, scene);
            fish.material = fishMat;
            fish.position = new BABYLON.Vector3(
                (Math.random() - 0.5) * pondRadius * 1.5, // Spread within pond radius
                water.position.y + (pondDepth/2) - (Math.random() * (pondDepth * 0.8)) - 0.1, // Within water depth, slightly below surface
                (Math.random() - 0.5) * pondRadius * 1.5
            );
            fish.rotation.y = Math.random() * Math.PI * 2;
            fish.parent = pondGroup;
        }
        return pondGroup;
      }

      function createPlantPlot(plantId, count) {
        const plotGroup = new BABYLON.TransformNode(`${plantId}Plot`, scene);
        let plantColor1 = new BABYLON.Color3(0.133, 0.545, 0.133), plantColor2 = new BABYLON.Color3(0, 0.392, 0); // Default greens
        let scale = 1.0;

        switch(plantId) {
            case 'plantain': case 'banana':
                plantColor1 = new BABYLON.Color3(0.561, 0.737, 0.561); plantColor2 = new BABYLON.Color3(0.235, 0.702, 0.443); scale = 1.2;
                
                const stalk = BABYLON.MeshBuilder.CreateCylinder(`${plantId}Stalk`, {
                  height: 1.5, 
                  diameterTop: 0.2, 
                  diameterBottom: 0.4, 
                  tessellation: 6
                }, scene);
                const stalkMat = new BABYLON.StandardMaterial(`${plantId}StalkMaterial`, scene);
                stalkMat.diffuseColor = plantColor1;
                stalk.material = stalkMat;
                stalk.position.y = 0.75;
                stalk.parent = plotGroup;
                
                const leafyTop = BABYLON.MeshBuilder.CreateSphere(`${plantId}Leaves`, {diameter: 1.2, segments: 5}, scene);
                const leafMat = new BABYLON.StandardMaterial(`${plantId}LeafMaterial`, scene);
                leafMat.diffuseColor = plantColor2;
                leafyTop.material = leafMat;
                leafyTop.position.y = 1.5;
                leafyTop.parent = plotGroup;
                break;
                
            case 'orange': case 'coconut': case 'papaya':
                plantColor1 = new BABYLON.Color3(0.545, 0.271, 0.075); plantColor2 = new BABYLON.Color3(0.180, 0.545, 0.341); scale = 1.1;
                
                const trunk = BABYLON.MeshBuilder.CreateCylinder(`${plantId}Trunk`, {
                  height: 1.2, 
                  diameterTop: 0.3, 
                  diameterBottom: 0.5, 
                  tessellation: 6
                }, scene);
                const trunkMat = new BABYLON.StandardMaterial(`${plantId}TrunkMaterial`, scene);
                trunkMat.diffuseColor = plantColor1;
                trunk.material = trunkMat;
                trunk.position.y = 0.6;
                trunk.parent = plotGroup;
                
                const foliage = BABYLON.MeshBuilder.CreateSphere(`${plantId}Foliage`, {diameter: 1.6, segments: 6}, scene);
                const foliageMat = new BABYLON.StandardMaterial(`${plantId}FoliageMaterial`, scene);
                foliageMat.diffuseColor = plantColor2;
                foliage.material = foliageMat;
                foliage.position.y = 1.5;
                foliage.parent = plotGroup;
                
                // Add fruit
                let fruitColor, fruitCount = 0;
                if (plantId === 'orange') {
                    fruitColor = new BABYLON.Color3(1, 0.549, 0); // Orange
                    fruitCount = 3;
                } else if (plantId === 'coconut') {
                    fruitColor = new BABYLON.Color3(0.545, 0.271, 0.075); // Brownish
                    fruitCount = 2;
                } else if (plantId === 'papaya') {
                    fruitColor = new BABYLON.Color3(1, 0.843, 0); // Yellow-Orange
                    fruitCount = 2;
                }
                
                if (fruitCount > 0) {
                    const fruitMat = new BABYLON.StandardMaterial(`${plantId}FruitMaterial`, scene);
                    fruitMat.diffuseColor = fruitColor;
                    
                    for(let f=0; f<fruitCount; f++) {
                        const fruit = BABYLON.MeshBuilder.CreateSphere(`${plantId}Fruit${f}`, {diameter: plantId === 'coconut' ? 0.4 : 0.36}, scene);
                        fruit.material = fruitMat;
                        // Position fruits within the foliage sphere
                        fruit.position = new BABYLON.Vector3(
                            (Math.random()-0.5) * 0.64, 
                            1.5 + (Math.random()-0.5) * 0.4, 
                            (Math.random()-0.5) * 0.64
                        );
                        fruit.parent = plotGroup;
                    }
                }
                break;
                
            case 'sugarcane':
                plantColor1 = new BABYLON.Color3(0.565, 0.933, 0.565); // Light green
                scale = 1.0;
                for(let i=0; i<3; i++) { // Bundle of 3 stalks
                    const stalkHeight = 1.5 + Math.random() * 0.5;
                    const stalk = BABYLON.MeshBuilder.CreateCylinder(`${plantId}Stalk${i}`, {
                      height: stalkHeight, 
                      diameter: 0.1, 
                      tessellation: 6
                    }, scene);
                    const stalkMat = new BABYLON.StandardMaterial(`${plantId}StalkMaterial${i}`, scene);
                    stalkMat.diffuseColor = plantColor1;
                    stalk.material = stalkMat;
                    stalk.position = new BABYLON.Vector3(
                        (Math.random()-0.5)*0.3, 
                        stalkHeight/2, // Base on ground
                        (Math.random()-0.5)*0.3
                    );
                    stalk.rotation = new BABYLON.Vector3( // Slight random tilt
                        (Math.random()-0.5)*0.1, 0, (Math.random()-0.5)*0.1
                    );
                    stalk.parent = plotGroup;
                }
                break;
                
            case 'carrot':
                scale = 0.8;
                // Create soil patch
                const soil = BABYLON.MeshBuilder.CreateCylinder(`${plantId}Soil`, {
                  height: 0.15, 
                  diameter: 1.6, 
                  tessellation: 8
                }, scene);
                const soilMat = new BABYLON.StandardMaterial(`${plantId}SoilMaterial`, scene);
                soilMat.diffuseColor = new BABYLON.Color3(0.361, 0.251, 0.200); // Darker brown
                soil.material = soilMat;
                soil.position.y = -0.075; // Center it on ground
                soil.receiveShadows = true;
                soil.parent = plotGroup;
                
                // Add multiple small carrot tops
                const leafClumpMat = new BABYLON.StandardMaterial(`${plantId}LeafMaterial`, scene);
                leafClumpMat.diffuseColor = new BABYLON.Color3(0.196, 0.804, 0.196); // Bright green
                
                for(let i=0; i<5; i++) {
                    const leafClump = BABYLON.MeshBuilder.CreateSphere(`${plantId}Leaves${i}`, {diameter: 0.3, segments: 4}, scene);
                    leafClump.material = leafClumpMat;
                    
                    // Position carrots randomly within the soil patch circle
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * (0.8 - 0.15); // Within soil radius, minus leaf radius
                    leafClump.position = new BABYLON.Vector3(
                        Math.cos(angle) * radius,
                        0.1, // Tops just above soil line
                        Math.sin(angle) * radius
                    );
                    leafClump.parent = plotGroup;
                    
                    // Add a small carrot cone sticking out (optional, mostly buried)
                    if (Math.random() > 0.5) { // Some carrots might show a bit
                        const carrotTop = BABYLON.MeshBuilder.CreateCylinder(`${plantId}CarrotTop${i}`, {
                          height: 0.1, 
                          diameterTop: 0, 
                          diameterBottom: 0.1, 
                          tessellation: 4
                        }, scene);
                        const carrotTopMat = new BABYLON.StandardMaterial(`${plantId}CarrotTopMaterial${i}`, scene);
                        carrotTopMat.diffuseColor = new BABYLON.Color3(1, 0.549, 0); // Orange
                        carrotTop.material = carrotTopMat;
                        carrotTop.position.copyFrom(leafClump.position);
                        carrotTop.position.y = 0.02; // Tip slightly visible
                        carrotTop.parent = plotGroup;
                    }
                }
                break;
                
            default:
                const defaultPlant = BABYLON.MeshBuilder.CreateBox(`${plantId}Default`, {width: 0.3, height: 0.8, depth: 0.3}, scene);
                const defaultMat = new BABYLON.StandardMaterial(`${plantId}DefaultMaterial`, scene);
                defaultMat.diffuseColor = plantColor1;
                defaultPlant.material = defaultMat;
                defaultPlant.position.y = 0.4;
                defaultPlant.parent = plotGroup;
                break;
        }

        plotGroup.scaling = new BABYLON.Vector3(scale, scale, scale);
        return plotGroup;
      }

      // Event handlers and UI setup
      if (reservesButton && farmStoreDropdown) {
        reservesButton.addEventListener('click', (event) => {
          event.stopPropagation();
          if (document.pointerLockElement === document.body) document.exitPointerLock();
          const isActive = farmStoreDropdown.classList.toggle('active');
          reservesButton.setAttribute('aria-expanded', isActive);
          if (isActive) {
            updateReservesDisplay();
          }
        });
        
        reservesAmountSpan.addEventListener('click', function(event) {
          event.stopPropagation();
          reservesButton.click();
        });

        // Wrap pointer lock request in user gesture handler
document.addEventListener('click', () => {
  document.body.requestPointerLock().catch(err => {
    console.log('Error requesting pointer lock:', err);
  });
});
        
        // Handle third party farms view button
        const thirdPartyViewButton = document.querySelector('[data-action="show-third-party-farms"]');
        if (thirdPartyViewButton) {
          thirdPartyViewButton.addEventListener('click', (e) => {
              e.stopPropagation();
              thirdPartyFarmsSection.style.display = thirdPartyFarmsSection.style.display === 'block' ? 'none' : 'block';
          });
        }

        // Main store dropdown handlers
        farmStoreDropdown.querySelectorAll('.dropdown-item').forEach(item => {
          const itemId = item.dataset.id;
          const itemType = item.dataset.type;
          const cost = parseInt(item.dataset.cost || '0');
          const purchaseButton = item.querySelector('.dropdown-item-price');

          if (purchaseButton) {
              purchaseButton.addEventListener('click', (event) => {
                  event.stopPropagation();
                  
                  // Special cases for special actions
                  if (purchaseButton.dataset.action === 'show-third-party-farms') {
                      thirdPartyFarmsSection.style.display = thirdPartyFarmsSection.style.display === 'block' ? 'none' : 'block';
                      return;
                  }

                  // Handle "Manage" button clicks
                  if (purchaseButton.textContent === "Manage") {
                      farmStoreDropdown.classList.remove('active');
                      showFarmManagement(itemId);
                      return;
                  }
                  
                  // Land expansion direct purchase (using Stars)
                  if (itemType === 'land' && itemId === 'expansion') {
                      if (playerReserves >= cost) {
                        if (expandLand()) {
                            playerReserves -= cost;
                            updateReservesDisplay();
                        }
                      } else {
                          showGameMessage("Not enough stars for land expansion!", 'error');
                      }
                      return;
                  }
                  
                  // REGULAR PURCHASE FLOW
                  if (isLiveMode) {
                      // Live mode purchase
                      liveInventory[itemId] = (liveInventory[itemId] || 0) + 1;
                      
                      // Store purchase info
                      farmValues.live[itemId] = farmValues.live[itemId] || [];
                      farmValues.live[itemId].push({
                        cost: cost,
                        date: new Date()
                      });
                      
                      updateReservesDisplay();
                      addPurchasedItemToWorld(itemType, itemId, liveInventory[itemId]);
                      showGameMessage(`${itemId.charAt(0).toUpperCase() + itemId.slice(1)} ${itemType === 'plant' ? 'seeds' : 'Farm'} partnership initiated (LIVE)!`, 'success');
                  } else {
                      // Demo mode purchase
                      if (playerReserves >= cost) {
                        playerReserves -= cost;
                        demoInventory[itemId] = (demoInventory[itemId] || 0) + 1;
                        
                        // Store purchase info
                        farmValues.demo[itemId] = farmValues.demo[itemId] || [];
                        farmValues.demo[itemId].push({
                          cost: cost,
                          date: new Date()
                        });
                        
                        updateReservesDisplay();
                        addPurchasedItemToWorld(itemType, itemId, demoInventory[itemId]);
                        showGameMessage(`${itemId.charAt(0).toUpperCase() + itemId.slice(1)} ${itemType === 'plant' ? 'seeds' : 'Farm'} purchased with Stars!`, 'success');
                      } else {
                        showGameMessage("Not enough stars!", 'error');
                      }
                  }
            });
          }
        });
      }
      
      // Library button with aerial view functionality
      if (libraryButton) {
        libraryButton.addEventListener('click', (e) => {
          e.preventDefault();
          if (document.pointerLockElement === document.body) document.exitPointerLock();
          
          // Toggle aerial view
          toggleAerialView();
        });
      }
      
      // Setup mode selection popup
      document.querySelectorAll('.mode-option').forEach(option => {
        option.addEventListener('click', () => {
            const mode = option.dataset.mode; 
            
            if (mode === 'demo') {
                setAppMode(false); 
            } else if (mode === 'live') {
                setAppMode(true); 
            }
            
            // Make sure aerial view is properly closed
            isAerialView = false;
            if (gameContainer) gameContainer.style.display = 'block';
            if (aerialViewContainer) aerialViewContainer.style.display = 'none';

            // Hide all popups
            if (modeSelectionPopup) modeSelectionPopup.style.display = 'none';
            if (prastFarmsPopup) prastFarmsPopup.style.display = 'none';

            updateReservesDisplay();
        });
      });
      
      // Setup Prast Farms popup buttons
      const prastFarmsCloseButton = document.getElementById('prast-farms-close');
      if (prastFarmsCloseButton) {
        prastFarmsCloseButton.addEventListener('click', () => {
            prastFarmsPopup.style.display = 'none';
        });
      }
      
      const prastFarmsContinueButton = document.getElementById('prast-farms-continue');
      if (prastFarmsContinueButton) {
        prastFarmsContinueButton.addEventListener('click', () => {
            if (!isLiveMode) {
                setAppMode(true);
                showGameMessage("Switched to LIVE mode! You can now partner with farms.", 'success');
            }
            prastFarmsPopup.style.display = 'none';
        });
      }

      // Add farm management event listeners
      const buyAnimalsBtn = document.getElementById('buy-animals');
      const sellAllAnimalsBtn = document.getElementById('sell-all-animals');
      const exitManagementBtn = document.getElementById('exit-management');
      
      if (buyAnimalsBtn) {
        buyAnimalsBtn.addEventListener('click', function() {
          const animalType = document.getElementById('farm-management-title')?.textContent.split(' ')[1]?.toLowerCase();
          if (animalType) {
            const buyPopup = document.getElementById('buy-animals-popup');
            if (buyPopup) {
              buyPopup.dataset.animalType = animalType;
              buyPopup.classList.remove('hidden');
              buyPopup.classList.add('flex');
            }
          }
        });
      }

      if (sellAllAnimalsBtn) {
        sellAllAnimalsBtn.addEventListener('click', function() {
          const animalType = document.getElementById('farm-management-title')?.textContent.split(' ')[1]?.toLowerCase();
          if (animalType && animalData[animalType]) {
            const animals = animalData[animalType];
            let totalValue = 0;
            
            animals.forEach(animal => {
              const baseValue = getItemCost(animalType) / 2;
              const ageBonus = animal.age * 0.05 * baseValue;
              totalValue += Math.floor(baseValue + ageBonus);
            });
            
            if (animals.length > 0 && confirm(`Sell all ${animals.length} animals for ${totalValue} stars?`)) {
              playerReserves += totalValue;
              animalData[animalType] = [];
              updateReservesDisplay();
              populateAnimalsList(animalType);
            }
          }
        });
      }

      if (exitManagementBtn) {
        exitManagementBtn.addEventListener('click', function() {
          const managementUI = document.getElementById('farm-management');
          if (managementUI) {
            managementUI.style.display = 'none';
            managementUI.classList.add('hidden');
          }
        });
      }

      // Buy animals popup handlers
      const decreaseQtyBtn = document.getElementById('decrease-qty');
      const increaseQtyBtn = document.getElementById('increase-qty');
      const cancelBuyBtn = document.getElementById('cancel-buy');
      const confirmBuyBtn = document.getElementById('confirm-buy');
      
      if (decreaseQtyBtn) {
        decreaseQtyBtn.addEventListener('click', function() {
          const qtyInput = document.getElementById('animal-qty');
          if (qtyInput) {
            qtyInput.value = Math.max(1, parseInt(qtyInput.value) - 1);
          }
        });
      }

      if (increaseQtyBtn) {
        increaseQtyBtn.addEventListener('click', function() {
          const qtyInput = document.getElementById('animal-qty');
          if (qtyInput) {
            qtyInput.value = parseInt(qtyInput.value) + 1;
          }
        });
      }

      if (cancelBuyBtn) {
        cancelBuyBtn.addEventListener('click', function() {
          const buyPopup = document.getElementById('buy-animals-popup');
          if (buyPopup) {
            buyPopup.classList.add('hidden');
          }
        });
      }

      if (confirmBuyBtn) {
        confirmBuyBtn.addEventListener('click', function() {
          const popup = document.getElementById('buy-animals-popup');
          const animalType = popup?.dataset.animalType;
          const qtyInput = document.getElementById('animal-qty');
          
          if (animalType && qtyInput) {
            const quantity = parseInt(qtyInput.value);
            const cost = getItemCost(animalType) * quantity;
            
            if (playerReserves >= cost) {
              playerReserves -= cost;
              
              for (let i = 0; i < quantity; i++) {
                animalData[animalType].push(createAnimalData(animalType));
              }
              
              updateReservesDisplay();
              populateAnimalsList(animalType);
              popup.classList.add('hidden');
            } else {
              alert("Not enough stars!");
            }
          }
        });
      }

      // Add search functionality to the main store dropdown
      const mainStoreSearchInput = farmStoreDropdown.querySelector('.search-input');
      if (mainStoreSearchInput) {
          mainStoreSearchInput.addEventListener('input', (e) => {
              const searchTerm = e.target.value.toLowerCase();
              
              farmStoreDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                  if (item.classList.contains('third-party-prompt') || item.textContent.toUpperCase() === 'THIRD PARTY FARMS' || item.querySelector('.shop-header-notice') || item.matches('hr') || item.classList.contains('px-2')) {
                      return;
                  }
                  const title = item.querySelector('.dropdown-item-title')?.textContent.toLowerCase() || '';
                  const desc = item.querySelector('.dropdown-item-desc')?.textContent.toLowerCase() || '';
                  item.style.display = (title.includes(searchTerm) || desc.includes(searchTerm)) ? 'flex' : 'none';
              });
          });
      }

      // Add search functionality to the third-party farms section
      const thirdPartySearchInput = thirdPartyFarmsSection.querySelector('.search-input');
      if (thirdPartySearchInput) {
          thirdPartySearchInput.addEventListener('input', (e) => {
              const searchTerm = e.target.value.toLowerCase();
              thirdPartyFarmsSection.querySelectorAll('.dropdown-item').forEach(item => {
                  const title = item.querySelector('.dropdown-item-title')?.textContent.toLowerCase() || '';
                  const desc = item.querySelector('.dropdown-item-desc')?.textContent.toLowerCase() || '';
                  item.style.display = (title.includes(searchTerm) || desc.includes(searchTerm)) ? 'flex' : 'none';
              });
          });
      }

      // Weather functions (simplified)
      function toggleWeather() {
        isRaining = !isRaining;
        if (isRaining) {
          // Simple rain effect could be added here
          scene.fogColor = rainFogColor;
        } else {
          scene.fogColor = initialFogColor;
        }
      }

      function updateRain(deltaTime) {
        // Rain update logic would go here
      }

      initBabylonJS();

      // Add this after initBabylonJS(); call for debugging
console.log("Game container:", gameContainer);
console.log("Canvas elements:", gameContainer.querySelectorAll('canvas'));
console.log("Engine:", engine);
console.log("Scene:", scene);
console.log("Camera:", camera);
      updateReservesDisplay();
    });
  </script>

</body>
</html>